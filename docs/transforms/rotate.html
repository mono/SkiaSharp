<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>The Rotate Transform | SkiaSharp </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="The Rotate Transform | SkiaSharp ">
      
      <meta name="description" content="This article explores the effects and animations possible with the SkiaSharp rotate transform, and demonstrates this with sample code.">
      <link rel="icon" href="../../images/logo.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../TOC.html">
      <meta name="docfx:tocrel" content="../TOC.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/transforms/rotate.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="the-rotate-transform">The Rotate Transform</h1>

<p><em>Explore the effects and animations possible with the SkiaSharp rotate transform</em></p>
<p>With the rotate transform, SkiaSharp graphics objects break free of the constraint of alignment with the horizontal and vertical axes:</p>
<p><img src="rotate-images/rotateexample.png" alt="Text rotated around a center"></p>
<p>For rotating a graphical object around the point (0, 0), SkiaSharp supports both a <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.rotatedegrees#skiasharp-skcanvas-rotatedegrees(system-single)"><code>RotateDegrees</code></a> method and a <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.rotateradians#skiasharp-skcanvas-rotateradians(system-single)"><code>RotateRadians</code></a> method:</p>
<pre><code class="lang-csharp">public void RotateDegrees (Single degrees)

public Void RotateRadians (Single radians)
</code></pre>
<p>A circle of 360 degrees is the same as 2π radians, so it's easy to convert between the two units. Use whichever is convenient. All the trigonometric functions in the .NET <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.math"><code>Math</code></a> class use units of radians.</p>
<p>Rotation is clockwise for increasing angles. (Although rotation on the Cartesian coordinate system is counter-clockwise by convention, clockwise rotation is consistent with Y coordinates increasing going down as in SkiaSharp.) Negative angles and angles greater than 360 degrees are allowed.</p>
<p>The transform formulas for rotation are more complex than those for translate and scale. For an angle of α, the transform formulas are:</p>
<p>x' = x•cos(α) – y•sin(α)</p>
<p>y` = x•sin(α) + y•cos(α)</p>
<p>The <strong>Basic Rotate</strong> page demonstrates the <code>RotateDegrees</code> method. The <a href="https://github.com/mono/SkiaSharp/blob/docs/samples/Demos/Demos/SkiaSharpFormsDemos/Transforms/BasicRotatePage.xaml.cs"><strong>BasicRotate.xaml.cs</strong></a> file displays some text with its baseline centered on the page and rotates it based on a <code>Slider</code> with a range of –360 to 360. Here's the relevant part of the <code>PaintSurface</code> handler:</p>
<pre><code class="lang-csharp">using (SKPaint textPaint = new SKPaint
{
    Style = SKPaintStyle.Fill,
    Color = SKColors.Blue
})
using (SKFont font = new SKFont
{
    Size = 100
})
{
    canvas.RotateDegrees((float)rotateSlider.Value);
    canvas.DrawText(Title, info.Width / 2, info.Height / 2, SKTextAlign.Center, font, textPaint);
}
</code></pre>
<p>Because rotation is centered around the upper-left corner of the canvas, for most angles set in this program, the text is rotated off the screen:</p>
<p><a href="rotate-images/basicrotate-large.png#lightbox" title="Triple screenshot of the Basic Rotate page"><img src="rotate-images/basicrotate-small.png" alt="Triple screenshot of the Basic Rotate page"></a></p>
<p>Very often you'll want to rotate something centered around a specified pivot point using these versions of the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.rotatedegrees#skiasharp-skcanvas-rotatedegrees(system-single-system-single-system-single)"><code>RotateDegrees</code></a> and <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.rotateradians#skiasharp-skcanvas-rotateradians(system-single-system-single-system-single)"><code>RotateRadians</code></a> methods:</p>
<pre><code class="lang-csharp">public void RotateDegrees (Single degrees, Single px, Single py)

public void RotateRadians (Single radians, Single px, Single py)
</code></pre>
<p>The <strong>Centered Rotate</strong> page is just like the <strong>Basic Rotate</strong> except that the expanded version of the <code>RotateDegrees</code> is used to set the center of rotation to the same point used to position the text:</p>
<pre><code class="lang-csharp">using (SKPaint textPaint = new SKPaint
{
    Style = SKPaintStyle.Fill,
    Color = SKColors.Blue
})
using (SKFont font = new SKFont
{
    Size = 100
})
{
    canvas.RotateDegrees((float)rotateSlider.Value, info.Width / 2, info.Height / 2);
    canvas.DrawText(Title, info.Width / 2, info.Height / 2, SKTextAlign.Center, font, textPaint);
}
</code></pre>
<p>Now the text rotates around the point used to position the text, which is the horizontal center of the text's baseline:</p>
<p><a href="rotate-images/centeredrotate-large.png#lightbox" title="Triple screenshot of the Centered Rotate page"><img src="rotate-images/centeredrotate-small.png" alt="Triple screenshot of the Centered Rotate page"></a></p>
<p>As with the centered version of the <code>Scale</code> method, the centered version of the <code>RotateDegrees</code> call is a shortcut. Here's the method:</p>
<pre><code class="lang-csharp">RotateDegrees (degrees, px, py);
</code></pre>
<p>That call is equivalent to the following:</p>
<pre><code class="lang-csharp">canvas.Translate(px, py);
canvas.RotateDegrees(degrees);
canvas.Translate(-px, -py);
</code></pre>
<p>You'll discover that you can sometimes combine <code>Translate</code> calls with <code>Rotate</code> calls. For example, here are the <code>RotateDegrees</code> and <code>DrawText</code> calls in the <strong>Centered Rotate</strong> page;</p>
<pre><code class="lang-csharp">canvas.RotateDegrees((float)rotateSlider.Value, info.Width / 2, info.Height / 2);
canvas.DrawText(Title, info.Width / 2, info.Height / 2, SKTextAlign.Center, font, textPaint);
</code></pre>
<p>The <code>RotateDegrees</code> call is equivalent to two <code>Translate</code> calls and a non-centered <code>RotateDegrees</code>:</p>
<pre><code class="lang-csharp">canvas.Translate(info.Width / 2, info.Height / 2);
canvas.RotateDegrees((float)rotateSlider.Value);
canvas.Translate(-info.Width / 2, -info.Height / 2);
canvas.DrawText(Title, info.Width / 2, info.Height / 2, SKTextAlign.Center, font, textPaint);
</code></pre>
<p>The <code>DrawText</code> call to display text at a particular location is equivalent to a <code>Translate</code> call for that location followed by <code>DrawText</code> at the point (0, 0):</p>
<pre><code class="lang-csharp">canvas.Translate(info.Width / 2, info.Height / 2);
canvas.RotateDegrees((float)rotateSlider.Value);
canvas.Translate(-info.Width / 2, -info.Height / 2);
canvas.Translate(info.Width / 2, info.Height / 2);
canvas.DrawText(Title, 0, 0, SKTextAlign.Center, font, textPaint);
</code></pre>
<p>The two consecutive <code>Translate</code> calls cancel each other out:</p>
<pre><code class="lang-csharp">canvas.Translate(info.Width / 2, info.Height / 2);
canvas.RotateDegrees((float)rotateSlider.Value);
canvas.DrawText(Title, 0, 0, SKTextAlign.Center, font, textPaint);
</code></pre>
<p>Conceptually, the two transforms are applied in the order opposite to how they appear in the code. The <code>DrawText</code> call displays the text in the upper-left corner of the canvas. The <code>RotateDegrees</code> call rotates that text relative to the upper-left corner. Then the <code>Translate</code> call moves the text to the center of the canvas.</p>
<p>There are usually several ways to combine rotation and translation. The <strong>Rotated Text</strong> page creates the following display:</p>
<p><a href="rotate-images/rotatedtext-large.png#lightbox" title="Triple screenshot of the Rotated Text page"><img src="rotate-images/rotatedtext-small.png" alt="Triple screenshot of the Rotated Text page"></a></p>
<p>Here's the <code>PaintSurface</code> handler of the <a href="https://github.com/mono/SkiaSharp/blob/docs/samples/Demos/Demos/SkiaSharpFormsDemos/Transforms/RotatedTextPage.cs"><code>RotatedTextPage</code></a> class:</p>
<pre><code class="lang-csharp">static readonly string text = &quot;    ROTATE&quot;;
...
void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    SKImageInfo info = args.Info;
    SKSurface surface = args.Surface;
    SKCanvas canvas = surface.Canvas;

    canvas.Clear();

    using (SKPaint textPaint = new SKPaint
    {
        Color = SKColors.Black
    })
    using (SKFont font = new SKFont
    {
        Size = 72
    })
    {
        float xCenter = info.Width / 2;
        float yCenter = info.Height / 2;

        SKRect textBounds = new SKRect();
        font.MeasureText(text, out textBounds);
        float yText = yCenter - textBounds.Height / 2 - textBounds.Top;

        for (int degrees = 0; degrees &lt; 360; degrees += 30)
        {
            canvas.Save();
            canvas.RotateDegrees(degrees, xCenter, yCenter);
            canvas.DrawText(text, xCenter, yText, SKTextAlign.Center, font, textPaint);
            canvas.Restore();
        }
    }
}

</code></pre>
<p>The <code>xCenter</code> and <code>yCenter</code> values indicate the center of the canvas. The <code>yText</code> value is a little offset from that. This value is the Y coordinate necessary to position the text so that it is truly vertically centered on the page. The <code>for</code> loop then sets a rotation based on the center of the canvas. The rotation is in increments of 30 degrees. The text is drawn using the <code>yText</code> value. The number of blanks before the word &quot;ROTATE&quot; in the <code>text</code> value was determined empirically to make the connection between these 12 text strings appear to be a dodecagon.</p>
<p>One way to simplify this code is to increment the rotation angle by 30 degrees each time through the loop after the <code>DrawText</code> call. This eliminates the need for calls to <code>Save</code> and <code>Restore</code>. Notice that the <code>degrees</code> variable is no longer used within the body of the <code>for</code> block:</p>
<pre><code class="lang-csharp">for (int degrees = 0; degrees &lt; 360; degrees += 30)
{
    canvas.DrawText(text, xCenter, yText, SKTextAlign.Center, font, textPaint);
    canvas.RotateDegrees(30, xCenter, yCenter);
}

</code></pre>
<p>It's also possible to use the simple form of <code>RotateDegrees</code> by prefacing the loop with a call to <code>Translate</code> to move everything to the center of the canvas:</p>
<pre><code class="lang-csharp">float yText = -textBounds.Height / 2 - textBounds.Top;

canvas.Translate(xCenter, yCenter);

for (int degrees = 0; degrees &lt; 360; degrees += 30)
{
    canvas.DrawText(text, 0, yText, SKTextAlign.Center, font, textPaint);
    canvas.RotateDegrees(30);
}
</code></pre>
<p>The modified <code>yText</code> calculation no longer incorporates <code>yCenter</code>. Now the <code>DrawText</code> call centers the text vertically at the top of the canvas.</p>
<p>Because the transforms are conceptually applied opposite to how they appear in code, it's often possible to begin with more global transforms, followed by more local transforms. This is often the easiest way to combine rotation and translation.</p>
<p>For example, suppose you want to draw a graphical object that rotates around its center much like a planet rotating on its axis. But you also want this object to revolve around the center of the screen much like a planet revolving around the sun.</p>
<p>You can do this by positioning the object in the upper-left corner of the canvas, and then using an animation to rotate it around that corner. Next, translate the object horizontally like an orbital radius. Now apply a second animated rotation, also around the origin. This makes the object revolve around the corner. Now translate to the center of the canvas.</p>
<p>Here's the <code>PaintSurface</code> handler that contains these transform calls in reverse order:</p>
<pre><code class="lang-csharp">float revolveDegrees, rotateDegrees;
...
void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    SKImageInfo info = args.Info;
    SKSurface surface = args.Surface;
    SKCanvas canvas = surface.Canvas;

    canvas.Clear();

    using (SKPaint fillPaint = new SKPaint
    {
        Style = SKPaintStyle.Fill,
        Color = SKColors.Red
    })
    {
        // Translate to center of canvas
        canvas.Translate(info.Width / 2, info.Height / 2);

        // Rotate around center of canvas
        canvas.RotateDegrees(revolveDegrees);

        // Translate horizontally
        float radius = Math.Min(info.Width, info.Height) / 3;
        canvas.Translate(radius, 0);

        // Rotate around center of object
        canvas.RotateDegrees(rotateDegrees);

        // Draw a square
        canvas.DrawRect(new SKRect(-50, -50, 50, 50), fillPaint);
    }
}
</code></pre>
<p>The <code>revolveDegrees</code> and <code>rotateDegrees</code> fields are animated. This program uses a different animation technique based on the .NET MAUI <a class="xref" href="https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.animation"><code>Animation</code></a> class. The <code>OnAppearing</code> override creates two <code>Animation</code> objects with callback methods and then calls <code>Commit</code> on them for an animation duration:</p>
<pre><code class="lang-csharp">protected override void OnAppearing()
{
    base.OnAppearing();

    new Animation((value) =&gt; revolveDegrees = 360 * (float)value).
        Commit(this, &quot;revolveAnimation&quot;, length: 10000, repeat: () =&gt; true);

    new Animation((value) =&gt;
    {
        rotateDegrees = 360 * (float)value;
        canvasView.InvalidateSurface();
    }).Commit(this, &quot;rotateAnimation&quot;, length: 1000, repeat: () =&gt; true);
}
</code></pre>
<p>The first <code>Animation</code> object animates <code>revolveDegrees</code> from 0 degrees to 360 degrees over 10 seconds. The second one animates <code>rotateDegrees</code> from 0 degrees to 360 degrees every 1 second and also invalidates the surface to generate another call to the <code>PaintSurface</code> handler. The <code>OnDisappearing</code> override cancels these two animations:</p>
<pre><code class="lang-csharp">protected override void OnDisappearing()
{
    base.OnDisappearing();
    this.AbortAnimation(&quot;revolveAnimation&quot;);
    this.AbortAnimation(&quot;rotateAnimation&quot;);
}
</code></pre>
<p>The <strong>Ugly Analog Clock</strong> program (so called because a more attractive analog clock will be described in a later article) uses rotation to draw the minute and hour marks of the clock and to rotate the hands. The program draws the clock using an arbitrary coordinate system based on a circle that is centered at the point (0, 0) with a radius of 100. It uses translation and scaling to expand and center that circle on the page.</p>
<p>The <code>Translate</code> and <code>Scale</code> calls apply globally to the clock, so those are the first ones to be called following the initialization of the <code>SKPaint</code> objects:</p>
<pre><code class="lang-csharp">void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    SKImageInfo info = args.Info;
    SKSurface surface = args.Surface;
    SKCanvas canvas = surface.Canvas;

    canvas.Clear();

    using (SKPaint strokePaint = new SKPaint())
    using (SKPaint fillPaint = new SKPaint())
    {
        strokePaint.Style = SKPaintStyle.Stroke;
        strokePaint.Color = SKColors.Black;
        strokePaint.StrokeCap = SKStrokeCap.Round;

        fillPaint.Style = SKPaintStyle.Fill;
        fillPaint.Color = SKColors.Gray;

        // Transform for 100-radius circle centered at origin
        canvas.Translate(info.Width / 2f, info.Height / 2f);
        canvas.Scale(Math.Min(info.Width / 200f, info.Height / 200f));
        ...
    }
}
</code></pre>
<p>There are 60 marks of two different sizes that must be drawn in a circle around the clock. The <code>DrawCircle</code> call draws that circle at the point (0, –90), which relative to the center of the clock corresponds to 12:00. The <code>RotateDegrees</code> call increments the rotation angle by 6 degrees after every tick mark. The <code>angle</code> variable is used solely to determine if a large circle or a small circle is drawn:</p>
<pre><code class="lang-csharp">void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    ...
        // Hour and minute marks
        for (int angle = 0; angle &lt; 360; angle += 6)
        {
            canvas.DrawCircle(0, -90, angle % 30 == 0 ? 4 : 2, fillPaint);
            canvas.RotateDegrees(6);
        }
    ...
    }
}
</code></pre>
<p>Finally, the <code>PaintSurface</code> handler obtains the current time and calculates rotation degrees for the hour, minute, and second hands. Each hand is drawn in the 12:00 position so that the rotation angle is relative to that:</p>
<pre><code class="lang-csharp">void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    ...
        DateTime dateTime = DateTime.Now;

        // Hour hand
        strokePaint.StrokeWidth = 20;
        canvas.Save();
        canvas.RotateDegrees(30 * dateTime.Hour + dateTime.Minute / 2f);
        canvas.DrawLine(0, 0, 0, -50, strokePaint);
        canvas.Restore();

        // Minute hand
        strokePaint.StrokeWidth = 10;
        canvas.Save();
        canvas.RotateDegrees(6 * dateTime.Minute + dateTime.Second / 10f);
        canvas.DrawLine(0, 0, 0, -70, strokePaint);
        canvas.Restore();

        // Second hand
        strokePaint.StrokeWidth = 2;
        canvas.Save();
        canvas.RotateDegrees(6 * dateTime.Second);
        canvas.DrawLine(0, 10, 0, -80, strokePaint);
        canvas.Restore();
    }
}
</code></pre>
<p>The clock is certainly functional although the hands are rather crude:</p>
<p><a href="rotate-images/uglyanalogclock-large.png#lightbox" title="Triple screenshot of the Ugly Analog page"><img src="rotate-images/uglyanalogclock-small.png" alt="Triple screenshot of the Ugly Analog Clock Text page"></a></p>
<p>For a more attractive clock, see the article <a href="../curves/path-data.html"><strong>SVG Path Data in SkiaSharp</strong></a>.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="/dotnet/api/skiasharp">SkiaSharp APIs</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/transforms/rotate.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
