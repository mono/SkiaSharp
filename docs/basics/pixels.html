<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Pixels and Device-Independent Units | SkiaSharp </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Pixels and Device-Independent Units | SkiaSharp ">
      
      <meta name="description" content="This article explores the differences between SkiaSharp coordinates and .NET MAUI coordinates, and demonstrates this with sample code.">
      <link rel="icon" href="../../images/logo.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../TOC.html">
      <meta name="docfx:tocrel" content="../TOC.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/basics/pixels.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="pixels-and-device-independent-units">Pixels and Device-Independent Units</h1>

<p><em>Explore the differences between SkiaSharp coordinates and .NET MAUI coordinates</em></p>
<p>This article explores the differences in the coordinate system used in SkiaSharp and .NET MAUI. You can obtain information to convert between the two coordinate systems and also draw graphics that fill a particular area:</p>
<p><img src="pixels-images/screenfillexample.png" alt="An oval that fills the screen"></p>
<p>If you've been programming in .NET MAUI for a while, you might have a feel for .NET MAUI coordinates and sizes. The circles drawn in the two previous articles might seem a little small to you.</p>
<p>Those circles <em>are</em> small in comparison with .NET MAUI sizes. By default, SkiaSharp draws in units of pixels while .NET MAUI bases coordinates and sizes on a device-independent unit established by the underlying platform.</p>
<p>The page in the sample program entitled <strong>Surface Size</strong> uses SkiaSharp text output to show the size of the display surface from three different sources:</p>
<ul>
<li>The normal .NET MAUI <a class="xref" href="https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.visualelement.width#microsoft-maui-controls-visualelement-width"><code>Width</code></a> and <a class="xref" href="https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.visualelement.height#microsoft-maui-controls-visualelement-height"><code>Height</code></a> properties of the <code>SKCanvasView</code> object.</li>
<li>The <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.views.maui.controls.skcanvasview.canvassize#skiasharp-views-maui-controls-skcanvasview-canvassize"><code>CanvasSize</code></a> property of the <code>SKCanvasView</code> object.</li>
<li>The <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skimageinfo.size#skiasharp-skimageinfo-size"><code>Size</code></a> property of the <code>SKImageInfo</code> value, which is consistent with the <code>Width</code> and <code>Height</code> properties used in the two previous pages.</li>
</ul>
<p>The <a href="https://github.com/mono/SkiaSharp/blob/docs/samples/DocsSamplesApp/DocsSamplesApp/Basics/SurfaceSizePage.cs"><code>SurfaceSizePage</code></a> class shows how to display these values. The constructor saves the <code>SKCanvasView</code> object as a field, so it can be accessed in the <code>PaintSurface</code> event handler:</p>
<pre><code class="lang-csharp">SKCanvasView canvasView;

public SurfaceSizePage()
{
    Title = &quot;Surface Size&quot;;

    canvasView = new SKCanvasView();
    canvasView.PaintSurface += OnCanvasViewPaintSurface;
    Content = canvasView;
}
</code></pre>
<p><code>SKCanvas</code> includes several <code>DrawText</code> methods. The main method for drawing text uses both <code>SKFont</code> for text metrics and <code>SKPaint</code> for styling:</p>
<pre><code class="lang-csharp">public void DrawText (String text, Single x, Single y, SKTextAlign textAlign, SKFont font, SKPaint paint)
</code></pre>
<p>You specify the text string, the X and Y coordinates where the text is to begin, the text alignment, an <code>SKFont</code> object for font attributes, and an <code>SKPaint</code> object for color and styling. The X coordinate specifies where the text is positioned based on the alignment, and the Y coordinate specifies the position of the <em>baseline</em> of the text. If you've ever written by hand on lined paper, the baseline is the line on which characters sit, and below which descenders (such as those on the letters g, p, q, and y) descend.</p>
<p>The <code>SKPaint</code> class allows you to specify the color of the text, while <code>SKFont</code> controls the font family and text size. By default, the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skfont.size#skiasharp-skfont-size"><code>Size</code></a> property has a value of 12, which results in tiny text on high-resolution devices such as phones. In anything but the simplest applications, you'll also need some information on the size of the text you're displaying. The <code>SKFont</code> class defines a <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skfont.metrics#skiasharp-skfont-metrics"><code>Metrics</code></a> property and several <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skfont.measuretext#skiasharp-skfont-measuretext(system-string-skiasharp-skpaint)"><code>MeasureText</code></a> methods, but for less fancy needs, the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skfont.spacing#skiasharp-skfont-spacing"><code>Spacing</code></a> property provides a recommended value for spacing successive lines of text.</p>
<p>The following <code>PaintSurface</code> handler creates an <code>SKFont</code> object with a <code>Size</code> of 40 pixels, which is the desired vertical height of the text from the top of ascenders to the bottom of descenders. The <code>Spacing</code> value that the <code>SKFont</code> object returns is a little larger than that, about 47 pixels.</p>
<pre><code class="lang-csharp">void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    SKImageInfo info = args.Info;
    SKSurface surface = args.Surface;
    SKCanvas canvas = surface.Canvas;

    canvas.Clear();

    SKPaint paint = new SKPaint
    {
        Color = SKColors.Black
    };

    SKFont font = new SKFont
    {
        Size = 40
    };

    float fontSpacing = font.Spacing;
    float x = 20;               // left margin
    float y = fontSpacing;      // first baseline
    float indent = 100;

    canvas.DrawText(&quot;SKCanvasView Height and Width:&quot;, x, y, SKTextAlign.Left, font, paint);
    y += fontSpacing;
    canvas.DrawText(String.Format(&quot;{0:F2} x {1:F2}&quot;,
                                  canvasView.Width, canvasView.Height),
                    x + indent, y, SKTextAlign.Left, font, paint);
    y += fontSpacing * 2;
    canvas.DrawText(&quot;SKCanvasView CanvasSize:&quot;, x, y, SKTextAlign.Left, font, paint);
    y += fontSpacing;
    canvas.DrawText(canvasView.CanvasSize.ToString(), x + indent, y, SKTextAlign.Left, font, paint);
    y += fontSpacing * 2;
    canvas.DrawText(&quot;SKImageInfo Size:&quot;, x, y, SKTextAlign.Left, font, paint);
    y += fontSpacing;
    canvas.DrawText(info.Size.ToString(), x + indent, y, SKTextAlign.Left, font, paint);
}
</code></pre>
<p>The method begins the first line of text with an X coordinate of 20 (for a little margin at the left) and a Y coordinate of <code>fontSpacing</code>, which is a little more than what's necessary to display the full height of the first line of text at the top of the display surface. After each call to <code>DrawText</code>, the Y coordinate is increased by one or two increments of <code>fontSpacing</code>.</p>
<p>Here's the program running:</p>
<p><a href="pixels-images/surfacesize-large.png#lightbox" title="Triple screenshot of the Surface Size  page"><img src="pixels-images/surfacesize-small.png" alt="Screenshots show the Surface Size app running on two mobile devices."></a></p>
<p>As you can see, the <code>CanvasSize</code> property of the <code>SKCanvasView</code> and the <code>Size</code> property of the <code>SKImageInfo</code> value are consistent in reporting the pixel dimensions. The <code>Height</code> and <code>Width</code> properties of the <code>SKCanvasView</code> are .NET MAUI properties, and report the size of the view in the device-independent units defined by the platform.</p>
<p>The iOS seven simulator on the left has two pixels per device-independent unit, and the Android Nexus 5 in the center has three pixels per unit. That's why the simple circle shown earlier has different sizes on different platforms.</p>
<p>If you'd prefer to work entirely in device-independent units, you can do so by setting the <code>IgnorePixelScaling</code> property of the <code>SKCanvasView</code> to <code>true</code>. However, you might not like the results. SkiaSharp renders the graphics on a smaller device surface, with a pixel size equal to the size of the view in device-independent units. (For example, SkiaSharp would use a display surface of 360 x 512 pixels on the Nexus 5.) It then scales up that image in size, resulting in noticeable bitmap jaggies.</p>
<p>To maintain the same image resolution, a better solution is to write your own simple functions to convert between the two coordinate systems.</p>
<p>In addition to the <code>DrawCircle</code> method, <code>SKCanvas</code> also defines two <code>DrawOval</code> methods that draw an ellipse. An ellipse is defined by two radii rather than a single radius. These are known as the <em>major radius</em> and the <em>minor radius</em>. The <code>DrawOval</code> method draws an ellipse with the two radii parallel to the X and Y axes. (If you need to draw an ellipse with axes that are not parallel to the X and Y axes, you can use a rotation transform as discussed in the article <a href="../transforms/rotate.html"><strong>The Rotate Transform</strong></a> or a graphics path as discussed in the article <a href="../curves/arcs.html"><strong>Three Ways to Draw an Arc</strong></a>). This overload of the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.drawoval#skiasharp-skcanvas-drawoval(system-single-system-single-system-single-system-single-skiasharp-skpaint)"><code>DrawOval</code></a> method names the two radii parameters <code>rx</code> and <code>ry</code> to indicate that they are parallel to the X and Y axes:</p>
<pre><code class="lang-csharp">public void DrawOval (Single cx, Single cy, Single rx, Single ry, SKPaint paint)
</code></pre>
<p>Is it possible to draw an ellipse that fills the display surface? The <strong>Ellipse Fill</strong> page demonstrates how. The <code>PaintSurface</code> event handler in the <a href="https://github.com/mono/SkiaSharp/blob/docs/samples/DocsSamplesApp/DocsSamplesApp/Basics/EllipseFillPage.xaml.cs"><strong>EllipseFillPage.xaml.cs</strong></a> class subtracts half the stroke width from the <code>xRadius</code> and <code>yRadius</code> values to fit the whole ellipse and its outline within the display surface:</p>
<pre><code class="lang-csharp">void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
{
    SKImageInfo info = args.Info;
    SKSurface surface = args.Surface;
    SKCanvas canvas = surface.Canvas;

    canvas.Clear();

    float strokeWidth = 50;
    float xRadius = (info.Width - strokeWidth) / 2;
    float yRadius = (info.Height - strokeWidth) / 2;

    SKPaint paint = new SKPaint
    {
        Style = SKPaintStyle.Stroke,
        Color = SKColors.Blue,
        StrokeWidth = strokeWidth
    };
    canvas.DrawOval(info.Width / 2, info.Height / 2, xRadius, yRadius, paint);
}
</code></pre>
<p>Here it is running:</p>
<p><a href="pixels-images/ellipsefill-large.png#lightbox" title="Triple screenshot of the Surface Size  page"><img src="pixels-images/ellipsefill-small.png" alt="Screenshots show the Ellipse Fill app running on two mobile devices."></a></p>
<p>The other <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.drawoval#skiasharp-skcanvas-drawoval(skiasharp-skrect-skiasharp-skpaint)"><code>DrawOval</code></a> method has an <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skrect"><code>SKRect</code></a> argument, which is a rectangle defined in terms of the X and Y coordinates of its upper-left corner and lower-right corner. The oval fills that rectangle, which suggests that it might be possible to use it in the <strong>Ellipse Fill</strong> page like this:</p>
<pre><code class="lang-csharp">SKRect rect = new SKRect(0, 0, info.Width, info.Height);
canvas.DrawOval(rect, paint);
</code></pre>
<p>However, that truncates all the edges of the outline of the ellipse on the four sides. You need to adjust all the <code>SKRect</code> constructor arguments based on the <code>strokeWidth</code> to make this work right:</p>
<pre><code class="lang-csharp">SKRect rect = new SKRect(strokeWidth / 2,
                         strokeWidth / 2,
                         info.Width - strokeWidth / 2,
                         info.Height - strokeWidth / 2);
canvas.DrawOval(rect, paint);
</code></pre>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="/dotnet/api/skiasharp">SkiaSharp APIs</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/basics/pixels.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
