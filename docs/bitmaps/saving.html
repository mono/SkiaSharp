<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Saving SkiaSharp bitmaps to files | SkiaSharp </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Saving SkiaSharp bitmaps to files | SkiaSharp ">
      
      <meta name="description" content="Explore the various file formats supported by SkiaSharp for saving bitmaps in the user&#39;s photo library in .NET MAUI applications.">
      <link rel="icon" href="../../images/logo.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../TOC.html">
      <meta name="docfx:tocrel" content="../TOC.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/bitmaps/saving.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="saving-skiasharp-bitmaps-to-files">Saving SkiaSharp bitmaps to files</h1>

<p>After a SkiaSharp application has created or modified a bitmap, the application might want to save the bitmap to the user's photo library:</p>
<p><img src="saving-images/SavingSample.png" alt="Saving Bitmaps" title="Saving Bitmaps"></p>
<p>This task encompasses two steps:</p>
<ul>
<li>Converting the SkiaSharp bitmap to data in a particular file format, such as JPEG or PNG.</li>
<li>Saving the result to the photo library using platform-specific code.</li>
</ul>
<h2 id="file-formats-and-codecs">File formats and codecs</h2>
<p>Most of today's popular bitmap file formats use compression to reduce storage space. The two broad categories of compression techniques are called <em>lossy</em> and <em>lossless</em>. These terms indicate whether or not the compression algorithm results in the loss of data.</p>
<p>The most popular lossy format was developed by the Joint Photographic Experts Group and is called JPEG. The JPEG compression algorithm analyzes the image using a mathematical tool called the <em>discrete cosine transform</em>, and attempts to remove data that is not crucial to preserving the image's visual fidelity. The degree of compression can be controlled with a setting generally referred to as <em>quality</em>. Higher quality settings result in larger files.</p>
<p>In contrast, a lossless compression algorithm analyzes the image for repetition and patterns of pixels that can be encoded in a way that reduces the data but does not result in the loss of any information. The original bitmap data can be restored entirely from the compressed file. The primary lossless compressed file format in use today is Portable Network Graphics (PNG).</p>
<p>Generally, JPEG is used for photographs, while PNG is used for images that have been manually or algorithmically generated. Any lossless compression algorithm that reduces the size of some files must necessarily increase the size of others. Fortunately, this increase in size generally only occurs for data that contains a lot of random (or seemingly random) information.</p>
<p>The compression algorithms are complex enough to warrant two terms that describe the compression and decompression processes:</p>
<ul>
<li><em>decode</em> — read a bitmap file format and decompress it</li>
<li><em>encode</em> — compress the bitmap and write to a bitmap file format</li>
</ul>
<p>The <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skbitmap"><code>SKBitmap</code></a> class contains several methods named <code>Decode</code> that create an <code>SKBitmap</code> from a compressed source. All that's required is to supply a filename, stream, or array of bytes. The decoder can determine the file format and hand it off to the proper internal decoding function.</p>
<p>In addition, the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcodec"><code>SKCodec</code></a> class has two methods named <code>Create</code> that can create an <code>SKCodec</code> object from a compressed source and allow an application to get more involved in the decoding process. (The <code>SKCodec</code> class is shown in the article <a href="animating.html#gif-animation"><strong>Animating SkiaSharp Bitmaps</strong></a> in connection with decoding an animated GIF file.)</p>
<p>When encoding a bitmap, more information is required: The encoder must know the particular file format the application wants to use (JPEG or PNG or something else). If a lossy format is desired, the encode must also know the desired level of quality.</p>
<p>The <code>SKBitmap</code> class defines one <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skbitmap.encode#skiasharp-skbitmap-encode(skiasharp-skwstream-skiasharp-skencodedimageformat-system-int32)"><code>Encode</code></a> method with the following syntax:</p>
<pre><code class="lang-csharp">public Boolean Encode (SKWStream dst, SKEncodedImageFormat format, Int32 quality)
</code></pre>
<p>This method is described in more detail shortly. The encoded bitmap is written to a writable stream. (The 'W' in <code>SKWStream</code> stands for &quot;writable&quot;.) The second and third arguments specify the file format and (for lossy formats) the desired quality ranging from 0 to 100.</p>
<p>In addition, the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skimage"><code>SKImage</code></a> and <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skpixmap"><code>SKPixmap</code></a> classes also define <code>Encode</code> methods that are somewhat more versatile, and which you might prefer. You can easily create an <code>SKImage</code> object from an <code>SKBitmap</code> object using the static <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skimage.frombitmap#skiasharp-skimage-frombitmap(skiasharp-skbitmap)"><code>SKImage.FromBitmap</code></a> method. You can obtain an <code>SKPixmap</code> object from an <code>SKBitmap</code> object using the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skbitmap.peekpixels#skiasharp-skbitmap-peekpixels"><code>PeekPixels</code></a> method.</p>
<p>One of the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skimage.encode#skiasharp-skimage-encode"><code>Encode</code></a> methods defined by <code>SKImage</code> has no parameters and automatically saves to a PNG format. That parameterless method is very easy to use.</p>
<h2 id="saving-bitmap-files-with-community-toolkit">Saving bitmap files with Community Toolkit</h2>
<p>When you encode an <code>SKBitmap</code> object into a particular file format, generally you'll be left with a stream object of some sort, or an array of data. Some of the <code>Encode</code> methods (including the one with no parameters defined by <code>SKImage</code>) return an <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skdata"><code>SKData</code></a> object, which can be converted to an array of bytes using the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skdata.toarray#skiasharp-skdata-toarray"><code>ToArray</code></a> method. This data must then be saved to a file.</p>
<p>Saving to a file in application local storage is quite easy because you can use standard <code>System.IO</code> classes and methods for this task. This technique is demonstrated in the article <a href="animating.html#bitmap-animation"><strong>Animating SkiaSharp Bitmaps</strong></a> in connection with animating a series of bitmaps of the Mandelbrot set.</p>
<p>If you want to let the user save a file to a location of their choice, .NET MAUI provides a cross-platform solution through the <a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/essentials/file-saver">Community Toolkit FileSaver</a>. This eliminates the need for platform-specific code.</p>
<h3 id="setting-up-the-community-toolkit">Setting up the Community Toolkit</h3>
<p>First, add the Community Toolkit NuGet package to your project:</p>
<pre><code class="lang-xml">&lt;PackageReference Include=&quot;CommunityToolkit.Maui&quot; Version=&quot;13.0.0&quot; /&gt;
</code></pre>
<p>Then register it in your <code>MauiProgram.cs</code>:</p>
<pre><code class="lang-csharp">using CommunityToolkit.Maui;

public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp&lt;App&gt;()
        .UseMauiCommunityToolkit()
        // ... other configuration
    return builder.Build();
}
</code></pre>
<h3 id="using-filesaver-to-save-images">Using FileSaver to save images</h3>
<p>The <code>FileSaver</code> opens a native file picker dialog that lets the user choose where to save the file. Here's how to save an encoded bitmap:</p>
<pre><code class="lang-csharp">using CommunityToolkit.Maui.Storage;

// Encode the bitmap
using SKImage image = SKImage.FromBitmap(bitmap);
SKData data = image.Encode(SKEncodedImageFormat.Png, 100);

// Save using FileSaver (opens a file picker dialog)
using var stream = new MemoryStream(data.ToArray());
var result = await FileSaver.Default.SaveAsync(&quot;MyImage.png&quot;, stream, CancellationToken.None);

if (result.IsSuccessful)
{
    // File was saved to: result.FilePath
}
else
{
    // Handle the error: result.Exception
}
</code></pre>
<p>This approach offers several advantages over the old platform-specific approach:</p>
<ul>
<li><strong>Cross-platform</strong>: Works on Android, iOS, macOS, and Windows with no platform-specific code</li>
<li><strong>User control</strong>: The user chooses where to save the file</li>
<li><strong>Testable</strong>: The <code>IFileSaver</code> interface can be mocked for unit testing</li>
</ul>
<h2 id="exploring-the-image-formats">Exploring the image formats</h2>
<p>Here's the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skbitmap.encode#skiasharp-skbitmap-encode(skiasharp-skwstream-skiasharp-skencodedimageformat-system-int32)"><code>Encode</code></a> method of <code>SKImage</code> again:</p>
<pre><code class="lang-csharp">public Boolean Encode (SKWStream dst, SKEncodedImageFormat format, Int32 quality)
</code></pre>
<p><a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skencodedimageformat"><code>SKEncodedImageFormat</code></a> is an enumeration with members that refer to eleven bitmap file formats, some of which are rather obscure:</p>
<ul>
<li><code>Astc</code> — Adaptive Scalable Texture Compression</li>
<li><code>Bmp</code> — Windows Bitmap</li>
<li><code>Dng</code> — Adobe Digital Negative</li>
<li><code>Gif</code> — Graphics Interchange Format</li>
<li><code>Ico</code> — Windows icon images</li>
<li><code>Jpeg</code> — Joint Photographic Experts Group</li>
<li><code>Ktx</code> — Khronos texture format for OpenGL</li>
<li><code>Pkm</code> — Custom format for GrafX2</li>
<li><code>Png</code> — Portable Network Graphics</li>
<li><code>Wbmp</code> — Wireless Application Protocol Bitmap Format (1 bit per pixel)</li>
<li><code>Webp</code> — Google WebP format</li>
</ul>
<p>As you'll see shortly, only three of these file formats (<code>Jpeg</code>, <code>Png</code>, and <code>Webp</code>) are actually supported by SkiaSharp.</p>
<p>To save an <code>SKBitmap</code> object named <code>bitmap</code> to a user-selected location, you need a member of the <code>SKEncodedImageFormat</code> enumeration named <code>imageFormat</code> and (for lossy formats) an integer <code>quality</code> variable. You can use the following code to encode the bitmap and let the user choose where to save it:</p>
<pre><code class="lang-csharp">using CommunityToolkit.Maui.Storage;

using (MemoryStream memStream = new MemoryStream())
using (SKManagedWStream wstream = new SKManagedWStream(memStream))
{
    bitmap.Encode(wstream, imageFormat, quality);
    byte[] data = memStream.ToArray();

    // Check the data array for content!
    if (data != null &amp;&amp; data.Length &gt; 0)
    {
        using var stream = new MemoryStream(data);
        var result = await FileSaver.Default.SaveAsync(filename, stream, CancellationToken.None);
        
        if (!result.IsSuccessful)
        {
            // Handle the error
        }
    }
}
</code></pre>
<p>The <code>SKManagedWStream</code> class derives from <code>SKWStream</code> (which stands for &quot;writable stream&quot;). The <code>Encode</code> method writes the encoded bitmap file into that stream.</p>
<p>The <strong>Save File Formats</strong> page in the sample application uses similar code to allow you to experiment with saving a bitmap in the various formats.</p>
<p>The XAML file contains an <code>SKCanvasView</code> that displays a bitmap, while the rest of the page contains everything the application needs to call the <code>Encode</code> method of <code>SKBitmap</code>. It has a <code>Picker</code> for a member of the <code>SKEncodedImageFormat</code> enumeration, a <code>Slider</code> for the quality argument for lossy bitmap formats, an <code>Entry</code> view for a filename, and a <code>Button</code> for saving the file.</p>
<pre><code class="lang-xaml">&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             xmlns:skia=&quot;clr-namespace:SkiaSharp;assembly=SkiaSharp&quot;
             xmlns:skiaforms=&quot;clr-namespace:SkiaSharp.Views.Maui.Controls;assembly=SkiaSharp.Views.Maui.Controls&quot;
             x:Class=&quot;DocsSamplesApp.Bitmaps.SaveFileFormatsPage&quot;
             Title=&quot;Save File Formats&quot;&gt;

    &lt;Grid RowDefinitions=&quot;*,Auto,Auto,Auto,Auto,Auto,Auto&quot; Margin=&quot;10&quot;&gt;
        &lt;skiaforms:SKCanvasView x:Name=&quot;canvasView&quot;
                                PaintSurface=&quot;OnCanvasViewPaintSurface&quot; /&gt;

        &lt;Picker Grid.Row=&quot;1&quot;
                x:Name=&quot;formatPicker&quot;
                Title=&quot;image format&quot;
                SelectedIndexChanged=&quot;OnFormatPickerChanged&quot;&gt;
            &lt;Picker.ItemsSource&gt;
                &lt;x:Array Type=&quot;{x:Type skia:SKEncodedImageFormat}&quot;&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Astc&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Bmp&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Dng&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Gif&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Ico&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Jpeg&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Ktx&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Pkm&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Png&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Wbmp&quot; /&gt;
                    &lt;x:Static Member=&quot;skia:SKEncodedImageFormat.Webp&quot; /&gt;
                &lt;/x:Array&gt;
            &lt;/Picker.ItemsSource&gt;
        &lt;/Picker&gt;

        &lt;Slider Grid.Row=&quot;2&quot;
                x:Name=&quot;qualitySlider&quot;
                Maximum=&quot;100&quot;
                Value=&quot;50&quot; /&gt;

        &lt;Label Grid.Row=&quot;3&quot;
               Text=&quot;{Binding Source={x:Reference qualitySlider},
                              Path=Value,
                              StringFormat='Quality = {0:F0}'}&quot;
               HorizontalTextAlignment=&quot;Center&quot; /&gt;

        &lt;Grid Grid.Row=&quot;4&quot; ColumnDefinitions=&quot;Auto,*&quot;&gt;
            &lt;Label Text=&quot;File Name: &quot;
                   VerticalOptions=&quot;Center&quot; /&gt;

            &lt;Entry Grid.Column=&quot;1&quot;
                   x:Name=&quot;fileNameEntry&quot;
                   Text=&quot;Sample.xxx&quot; /&gt;
        &lt;/Grid&gt;

        &lt;Button Grid.Row=&quot;5&quot;
                Text=&quot;Save&quot; 
                Clicked=&quot;OnButtonClicked&quot;&gt;
            &lt;Button.Triggers&gt;
                &lt;DataTrigger TargetType=&quot;Button&quot;
                             Binding=&quot;{Binding Source={x:Reference formatPicker},
                                               Path=SelectedIndex}&quot;
                             Value=&quot;-1&quot;&gt;
                    &lt;Setter Property=&quot;IsEnabled&quot; Value=&quot;False&quot; /&gt;
                &lt;/DataTrigger&gt;

                &lt;DataTrigger TargetType=&quot;Button&quot;
                             Binding=&quot;{Binding Source={x:Reference fileNameEntry},
                                               Path=Text.Length}&quot;
                             Value=&quot;0&quot;&gt;
                    &lt;Setter Property=&quot;IsEnabled&quot; Value=&quot;False&quot; /&gt;
                &lt;/DataTrigger&gt;
            &lt;/Button.Triggers&gt;
        &lt;/Button&gt;

        &lt;Label Grid.Row=&quot;6&quot;
               x:Name=&quot;statusLabel&quot;
               Text=&quot;OK&quot;
               Margin=&quot;10, 0&quot; /&gt;
    &lt;/Grid&gt;
&lt;/ContentPage&gt;
</code></pre>
<p>The code-behind file loads a bitmap resource and uses the <code>SKCanvasView</code> to display it. That bitmap never changes. The <code>SelectedIndexChanged</code> handler for the <code>Picker</code> modifies the filename with an extension that is the same as the enumeration member:</p>
<pre><code class="lang-csharp">using CommunityToolkit.Maui.Storage;

public partial class SaveFileFormatsPage : ContentPage
{
    SKBitmap? bitmap;

    public SaveFileFormatsPage ()
    {
        InitializeComponent ();
        _ = LoadBitmapAsync();
    }

    async Task LoadBitmapAsync()
    {
        using Stream stream = await FileSystem.OpenAppPackageFileAsync(&quot;MonkeyFace.png&quot;);
        bitmap = SKBitmap.Decode(stream);
        canvasView.InvalidateSurface();
    }

    void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
    {
        if (bitmap is null)
            return;
        args.Surface.Canvas.DrawBitmap(bitmap, args.Info.Rect, BitmapStretch.Uniform);
    }

    void OnFormatPickerChanged(object? sender, EventArgs args)
    {
        if (formatPicker.SelectedIndex != -1)
        {
            SKEncodedImageFormat imageFormat = (SKEncodedImageFormat)formatPicker.SelectedItem;
            fileNameEntry.Text = Path.ChangeExtension(fileNameEntry.Text, imageFormat.ToString());
            statusLabel.Text = &quot;OK&quot;;
        }
    }

    async void OnButtonClicked(object? sender, EventArgs args)
    {
        if (bitmap is null)
            return;
        SKEncodedImageFormat imageFormat = (SKEncodedImageFormat)formatPicker.SelectedItem;
        int quality = (int)qualitySlider.Value;

        using (MemoryStream memStream = new MemoryStream())
        using (SKManagedWStream wstream = new SKManagedWStream(memStream))
        {
            bitmap.Encode(wstream, imageFormat, quality);
            byte[] data = memStream.ToArray();

            if (data == null)
            {
                statusLabel.Text = &quot;Encode returned null&quot;;
            }
            else if (data.Length == 0)
            {
                statusLabel.Text = &quot;Encode returned empty array&quot;;
            }
            else
            {
                using var stream = new MemoryStream(data);
                var result = await FileSaver.Default.SaveAsync(fileNameEntry.Text, stream, CancellationToken.None);

                if (!result.IsSuccessful)
                {
                    statusLabel.Text = &quot;Save failed: &quot; + result.Exception?.Message;
                }
                else
                {
                    statusLabel.Text = &quot;Success! Saved to: &quot; + result.FilePath;
                }
            }
        }
    }
}
</code></pre>
<p>The <code>Clicked</code> handler for the <code>Button</code> does all the real work. It obtains two arguments for <code>Encode</code> from the <code>Picker</code> and <code>Slider</code>, and then uses the code shown earlier to create an <code>SKManagedWStream</code> for the <code>Encode</code> method. The <code>FileSaver</code> from the Community Toolkit opens a native file picker dialog so the user can choose where to save the file.</p>
<p>Most of this method is devoted to handling problems or errors. If <code>Encode</code> creates an empty array, it means that the particular file format isn't supported. If the <code>FileSaverResult.IsSuccessful</code> property is <code>false</code>, then the file wasn't successfully saved.</p>
<p>Here is the program running:</p>
<p><a href="saving-images/SaveFileFormats-Large.png#lightbox"><img src="saving-images/SaveFileFormats.png" alt="Save File Formats" title="Save File Formats"></a></p>
<p>That screenshot shows the only three formats that are supported on these platforms:</p>
<ul>
<li>JPEG</li>
<li>PNG</li>
<li>WebP</li>
</ul>
<p>For all the other formats, the <code>Encode</code> method writes nothing into the stream and the resultant byte array is empty.</p>
<p>The bitmap that the <strong>Save File Formats</strong> page saves is 600-pixels square. With 4 bytes per pixel, that's a total of 1,440,000 bytes in memory. The following table shows the file size for various combinations of file format and quality:</p>
<table>
<thead>
<tr>
<th>Format</th>
<th style="text-align: right;">Quality</th>
<th style="text-align: right;">Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>PNG</td>
<td style="text-align: right;">N/A</td>
<td style="text-align: right;">492K</td>
</tr>
<tr>
<td>JPEG</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">2.95K</td>
</tr>
<tr>
<td></td>
<td style="text-align: right;">50</td>
<td style="text-align: right;">22.1K</td>
</tr>
<tr>
<td></td>
<td style="text-align: right;">100</td>
<td style="text-align: right;">206K</td>
</tr>
<tr>
<td>WebP</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">2.71K</td>
</tr>
<tr>
<td></td>
<td style="text-align: right;">50</td>
<td style="text-align: right;">11.9K</td>
</tr>
<tr>
<td></td>
<td style="text-align: right;">100</td>
<td style="text-align: right;">101K</td>
</tr>
</tbody>
</table>
<p>You can experiment with various quality settings and examine the results.</p>
<h2 id="saving-finger-paint-art">Saving finger-paint art</h2>
<p>One common use of a bitmap is in drawing programs, where it functions as something called a <em>shadow bitmap</em>. All the drawing is retained on the bitmap, which is then displayed by the program. The bitmap also comes in handy for saving the drawing.</p>
<p>The <a href="../paths/finger-paint.html"><strong>Finger Painting in SkiaSharp</strong></a> article demonstrated how to use touch tracking to implement a primitive finger-painting program. The program supported only one color and only one stroke width, but it retained the entire drawing in a collection of <code>SKPath</code> objects.</p>
<p>The <strong>Finger Paint with Save</strong> page in the sample also retains the entire drawing in a collection of <code>SKPath</code> objects, but it also renders the drawing on a bitmap, which it can save to your photo library.</p>
<p>Much of this program is similar to the original <strong>Finger Paint</strong> program. One enhancement is that the XAML file now instantiates buttons labeled <strong>Clear</strong> and <strong>Save</strong>:</p>
<pre><code class="lang-xaml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             xmlns:skia=&quot;clr-namespace:SkiaSharp.Views.Maui.Controls;assembly=SkiaSharp.Views.Maui.Controls&quot;
             x:Class=&quot;SkiaSharpFormsDemos.Bitmaps.FingerPaintSavePage&quot;
             Title=&quot;Finger Paint Save&quot;&gt;

    &lt;StackLayout&gt;
        &lt;Grid BackgroundColor=&quot;White&quot;
              VerticalOptions=&quot;FillAndExpand&quot;&gt;
            &lt;skia:SKCanvasView x:Name=&quot;canvasView&quot;
                               PaintSurface=&quot;OnCanvasViewPaintSurface&quot;
                               EnableTouchEvents=&quot;True&quot;
                               Touch=&quot;OnTouch&quot; /&gt;
        &lt;/Grid&gt;

        &lt;Grid&gt;
            &lt;Grid.ColumnDefinitions&gt;
                &lt;ColumnDefinition Width=&quot;*&quot; /&gt;
                &lt;ColumnDefinition Width=&quot;*&quot; /&gt;
            &lt;/Grid.ColumnDefinitions&gt;
        &lt;/Grid&gt;

        &lt;Button Text=&quot;Clear&quot;
                Grid.Row=&quot;0&quot;
                Margin=&quot;50, 5&quot;
                Clicked=&quot;OnClearButtonClicked&quot; /&gt;

        &lt;Button Text=&quot;Save&quot;
                Grid.Row=&quot;1&quot;
                Margin=&quot;50, 5&quot;
                Clicked=&quot;OnSaveButtonClicked&quot; /&gt;

    &lt;/StackLayout&gt;
&lt;/ContentPage&gt;
</code></pre>
<p>The code-behind file maintains a field of type <code>SKBitmap</code> named <code>saveBitmap</code>. This bitmap is created or recreated in the <code>PaintSurface</code> handler whenever the size of the display surface changes. If the bitmap needs to be recreated, the contents of the existing bitmap are copied to the new bitmap so that everything is retained no matter how the display surface changes in size:</p>
<pre><code class="lang-csharp">public partial class FingerPaintSavePage : ContentPage
{
    ···
    SKBitmap saveBitmap;

    public FingerPaintSavePage ()
    {
        InitializeComponent ();
    }

    void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
    {
        SKImageInfo info = args.Info;
        SKSurface surface = args.Surface;
        SKCanvas canvas = surface.Canvas;

        // Create bitmap the size of the display surface
        if (saveBitmap == null)
        {
            saveBitmap = new SKBitmap(info.Width, info.Height);
        }
        // Or create new bitmap for a new size of display surface
        else if (saveBitmap.Width &lt; info.Width || saveBitmap.Height &lt; info.Height)
        {
            SKBitmap newBitmap = new SKBitmap(Math.Max(saveBitmap.Width, info.Width),
                                              Math.Max(saveBitmap.Height, info.Height));

            using (SKCanvas newCanvas = new SKCanvas(newBitmap))
            {
                newCanvas.Clear();
                newCanvas.DrawBitmap(saveBitmap, 0, 0);
            }

            saveBitmap = newBitmap;
        }

        // Render the bitmap
        canvas.Clear();
        canvas.DrawBitmap(saveBitmap, 0, 0);
    }
    ···
}
</code></pre>
<p>The drawing done by the <code>PaintSurface</code> handler occurs at the very end, and consists solely of rendering the bitmap.</p>
<p>The touch processing is similar to the earlier program. The program maintains two collections, <code>inProgressPaths</code> and <code>completedPaths</code>, that contain everything the user has drawn since the last time the display was cleared. For each touch event, the <code>OnTouch</code> handler calls <code>UpdateBitmap</code>:</p>
<pre><code class="lang-csharp">public partial class FingerPaintSavePage : ContentPage
{
    Dictionary&lt;long, SKPath&gt; inProgressPaths = new Dictionary&lt;long, SKPath&gt;();
    List&lt;SKPath&gt; completedPaths = new List&lt;SKPath&gt;();

    SKPaint paint = new SKPaint
    {
        Style = SKPaintStyle.Stroke,
        Color = SKColors.Blue,
        StrokeWidth = 10,
        StrokeCap = SKStrokeCap.Round,
        StrokeJoin = SKStrokeJoin.Round
    };
    ···
    void OnTouch(object? sender, SKTouchEventArgs e)
    {
        switch (e.ActionType)
        {
            case SKTouchAction.Pressed:
                if (!inProgressPaths.ContainsKey(e.Id))
                {
                    SKPath path = new SKPath();
                    path.MoveTo(e.Location);
                    inProgressPaths.Add(e.Id, path);
                    UpdateBitmap();
                }
                break;

            case SKTouchAction.Moved:
                if (inProgressPaths.ContainsKey(e.Id))
                {
                    SKPath path = inProgressPaths[e.Id];
                    path.LineTo(e.Location);
                    UpdateBitmap();
                }
                break;

            case SKTouchAction.Released:
                if (inProgressPaths.ContainsKey(e.Id))
                {
                    completedPaths.Add(inProgressPaths[e.Id]);
                    inProgressPaths.Remove(e.Id);
                    UpdateBitmap();
                }
                break;

            case SKTouchAction.Cancelled:
                if (inProgressPaths.ContainsKey(e.Id))
                {
                    inProgressPaths.Remove(e.Id);
                    UpdateBitmap();
                }
                break;
        }

        e.Handled = true;
    }

    void UpdateBitmap()
    {
        using (SKCanvas saveBitmapCanvas = new SKCanvas(saveBitmap))
        {
            saveBitmapCanvas.Clear();

            foreach (SKPath path in completedPaths)
            {
                saveBitmapCanvas.DrawPath(path, paint);
            }

            foreach (SKPath path in inProgressPaths.Values)
            {
                saveBitmapCanvas.DrawPath(path, paint);
            }
        }

        canvasView.InvalidateSurface();
    }
    ···
}
</code></pre>
<p>The <code>UpdateBitmap</code> method redraws <code>saveBitmap</code> by creating a new <code>SKCanvas</code>, clearing it, and then rendering all the paths on the bitmap. It concludes by invalidating <code>canvasView</code> so that the bitmap can be drawn on the display.</p>
<p>Here are the handlers for the two buttons. The <strong>Clear</strong> button clears both path collections, updates <code>saveBitmap</code> (which results in clearing the bitmap), and invalidates the <code>SKCanvasView</code>:</p>
<pre><code class="lang-csharp">public partial class FingerPaintSavePage : ContentPage
{
    ···
    void OnClearButtonClicked(object? sender, EventArgs args)
    {
        completedPaths.Clear();
        inProgressPaths.Clear();
        UpdateBitmap();
        canvasView.InvalidateSurface();
    }

    async void OnSaveButtonClicked(object? sender, EventArgs args)
    {
        using (SKImage image = SKImage.FromBitmap(saveBitmap))
        {
            SKData data = image.Encode();
            DateTime dt = DateTime.Now;
            string filename = String.Format(&quot;FingerPaint-{0:D4}{1:D2}{2:D2}-{3:D2}{4:D2}{5:D2}{6:D3}.png&quot;,
                                            dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond);

            using var stream = new MemoryStream(data.ToArray());
            var result = await FileSaver.Default.SaveAsync(filename, stream, CancellationToken.None);

            if (!result.IsSuccessful)
            {
                await DisplayAlertAsync(&quot;FingerPaint&quot;, &quot;Artwork could not be saved. Sorry!&quot;, &quot;OK&quot;);
            }
        }
    }
}
</code></pre>
<p>The <strong>Save</strong> button handler uses the simplified <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skimage.encode#skiasharp-skimage-encode"><code>Encode</code></a> method from <code>SKImage</code>. This method encodes using the PNG format. The <code>SKImage</code> object is created based on <code>saveBitmap</code>, and the <code>SKData</code> object contains the encoded PNG file.</p>
<p>The <code>ToArray</code> method of <code>SKData</code> obtains an array of bytes. This data is passed to the <code>FileSaver</code> from the Community Toolkit, which opens a native file picker dialog so the user can choose where to save their artwork.</p>
<p>Here's the program in action:</p>
<p><a href="saving-images/FingerPaintSave-Large.png#lightbox"><img src="saving-images/FingerPaintSave.png" alt="Finger Paint Save" title="Finger Paint Save"></a></p>
<p>A very similar technique is used in the sample. This is also a finger-painting program except that the user paints on a spinning disk that then reproduces the designs on its other four quadrants. The color of the finger paint changes as the disk is spinning:</p>
<p><a href="saving-images/SpinPaint-Large.png#lightbox"><img src="saving-images/SpinPaint.png" alt="Spin Paint" title="Spin Paint"></a></p>
<p>The <strong>Save</strong> button of <code>SpinPaint</code> class is similar to <strong>Finger Paint</strong> in that it uses the Community Toolkit's <code>FileSaver</code> to let the user choose where to save their artwork.</p>
<h2 id="related-links">Related links</h2>
<ul>
<li><a href="/dotnet/api/skiasharp">SkiaSharp APIs</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/bitmaps/saving.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
