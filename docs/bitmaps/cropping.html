<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Cropping SkiaSharp bitmaps | SkiaSharp </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Cropping SkiaSharp bitmaps | SkiaSharp ">
      
      <meta name="description" content="Learn how to use SkiaSharp to design a user interface for interactively desribing a cropping rectangle in .NET MAUI applications.">
      <link rel="icon" href="../../images/logo.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../TOC.html">
      <meta name="docfx:tocrel" content="../TOC.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/bitmaps/cropping.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="cropping-skiasharp-bitmaps">Cropping SkiaSharp bitmaps</h1>

<p>The <a href="drawing.html"><strong>Creating and Drawing SkiaSharp Bitmaps</strong></a> article described how an <code>SKBitmap</code> object can be passed to an <code>SKCanvas</code> constructor. Any drawing method called on that canvas causes graphics to be rendered on the bitmap. These drawing methods include <code>DrawBitmap</code>, which means that this technique allows transferring part or all of one bitmap to another bitmap, perhaps with transforms applied.</p>
<p>You can use that technique for cropping a bitmap by calling the <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.skcanvas.drawbitmap#skiasharp-skcanvas-drawbitmap(skiasharp-skbitmap-skiasharp-skrect-skiasharp-skrect-skiasharp-skpaint)"><code>DrawBitmap</code></a> method with source and destination rectangles:</p>
<pre><code class="lang-csharp">canvas.DrawBitmap(bitmap, sourceRect, destRect);
</code></pre>
<p>However, applications that implement cropping often provide an interface for the user to interactively select the cropping rectangle:</p>
<p><img src="cropping-images/CroppingSample.png" alt="Cropping Sample" title="Cropping Sample"></p>
<p>This article focuses on that interface.</p>
<h2 id="encapsulating-the-cropping-rectangle">Encapsulating the cropping rectangle</h2>
<p>It's helpful to isolate some of the cropping logic in a class named <code>CroppingRectangle</code>. The constructor parameters include a maximum rectangle, which is generally the size of the bitmap being cropped, and an optional aspect ratio. The constructor first defines an initial cropping rectangle, which it makes public in the <code>Rect</code> property of type <code>SKRect</code>. This initial cropping rectangle is 80% of the width and height of the bitmap rectangle, but it is then adjusted if an aspect ratio is specified:</p>
<pre><code class="lang-csharp">class CroppingRectangle
{
    ···
    SKRect maxRect;             // generally the size of the bitmap
    float? aspectRatio;

    public CroppingRectangle(SKRect maxRect, float? aspectRatio = null)
    {
        this.maxRect = maxRect;
        this.aspectRatio = aspectRatio;

        // Set initial cropping rectangle
        Rect = new SKRect(0.9f * maxRect.Left + 0.1f * maxRect.Right,
                          0.9f * maxRect.Top + 0.1f * maxRect.Bottom,
                          0.1f * maxRect.Left + 0.9f * maxRect.Right,
                          0.1f * maxRect.Top + 0.9f * maxRect.Bottom);

        // Adjust for aspect ratio
        if (aspectRatio.HasValue)
        {
            SKRect rect = Rect;
            float aspect = aspectRatio.Value;

            if (rect.Width &gt; aspect * rect.Height)
            {
                float width = aspect * rect.Height;
                rect.Left = (maxRect.Width - width) / 2;
                rect.Right = rect.Left + width;
            }
            else
            {
                float height = rect.Width / aspect;
                rect.Top = (maxRect.Height - height) / 2;
                rect.Bottom = rect.Top + height;
            }

            Rect = rect;
        }
    }

    public SKRect Rect { set; get; }
    ···
}
</code></pre>
<p>One useful piece of information that <code>CroppingRectangle</code> also makes available is an array of <code>SKPoint</code> values corresponding to the four corners of the cropping rectangle in the order upper-left, upper-right, lower-right, and lower-left:</p>
<pre><code class="lang-csharp">class CroppingRectangle
{
    ···
    public SKPoint[] Corners
    {
        get
        {
            return new SKPoint[]
            {
                new SKPoint(Rect.Left, Rect.Top),
                new SKPoint(Rect.Right, Rect.Top),
                new SKPoint(Rect.Right, Rect.Bottom),
                new SKPoint(Rect.Left, Rect.Bottom)
            };
        }
    }
    ···
}
</code></pre>
<p>This array is used in the following method, which is called <code>HitTest</code>. The <code>SKPoint</code> parameter is a point corresponding to a finger touch or a mouse click. The method returns an index (0, 1, 2, or 3) corresponding to the corner that the finger or mouse pointer touched, within a distance given by the <code>radius</code> parameter:</p>
<pre><code class="lang-csharp">class CroppingRectangle
{
    ···
    public int HitTest(SKPoint point, float radius)
    {
        SKPoint[] corners = Corners;

        for (int index = 0; index &lt; corners.Length; index++)
        {
            SKPoint diff = point - corners[index];

            if ((float)Math.Sqrt(diff.X * diff.X + diff.Y * diff.Y) &lt; radius)
            {
                return index;
            }
        }

        return -1;
    }
    ···
}
</code></pre>
<p>If the touch or mouse point was not within <code>radius</code> units of any corner, the method returns –1.</p>
<p>The final method in <code>CroppingRectangle</code> is called <code>MoveCorner</code>, which is called in response to touch or mouse movement. The two parameters indicate the index of the corner being moved, and the new location of that corner. The first half of the method adjusts the cropping rectangle based on the new location of the corner, but always within the bounds of <code>maxRect</code>, which is the size of the bitmap. This logic also takes account of the <code>MINIMUM</code> field to avoid collapsing the cropping rectangle into nothing:</p>
<pre><code class="lang-csharp">class CroppingRectangle
{
    const float MINIMUM = 10;   // pixels width or height
    ···
    public void MoveCorner(int index, SKPoint point)
    {
        SKRect rect = Rect;

        switch (index)
        {
            case 0: // upper-left
                rect.Left = Math.Min(Math.Max(point.X, maxRect.Left), rect.Right - MINIMUM);
                rect.Top = Math.Min(Math.Max(point.Y, maxRect.Top), rect.Bottom - MINIMUM);
                break;

            case 1: // upper-right
                rect.Right = Math.Max(Math.Min(point.X, maxRect.Right), rect.Left + MINIMUM);
                rect.Top = Math.Min(Math.Max(point.Y, maxRect.Top), rect.Bottom - MINIMUM);
                break;

            case 2: // lower-right
                rect.Right = Math.Max(Math.Min(point.X, maxRect.Right), rect.Left + MINIMUM);
                rect.Bottom = Math.Max(Math.Min(point.Y, maxRect.Bottom), rect.Top + MINIMUM);
                break;

            case 3: // lower-left
                rect.Left = Math.Min(Math.Max(point.X, maxRect.Left), rect.Right - MINIMUM);
                rect.Bottom = Math.Max(Math.Min(point.Y, maxRect.Bottom), rect.Top + MINIMUM);
                break;
        }

        // Adjust for aspect ratio
        if (aspectRatio.HasValue)
        {
            float aspect = aspectRatio.Value;

            if (rect.Width &gt; aspect * rect.Height)
            {
                float width = aspect * rect.Height;

                switch (index)
                {
                    case 0:
                    case 3: rect.Left = rect.Right - width; break;
                    case 1:
                    case 2: rect.Right = rect.Left + width; break;
                }
            }
            else
            {
                float height = rect.Width / aspect;

                switch (index)
                {
                    case 0:
                    case 1: rect.Top = rect.Bottom - height; break;
                    case 2:
                    case 3: rect.Bottom = rect.Top + height; break;
                }
            }
        }

        Rect = rect;
    }
}
</code></pre>
<p>The second half of the method adjusts for the optional aspect ratio.</p>
<p>Keep in mind that everything in this class is in units of pixels.</p>
<h2 id="a-canvas-view-just-for-cropping">A canvas view just for cropping</h2>
<p>The <code>CroppingRectangle</code> class you've just seen is used by the <code>PhotoCropperCanvasView</code> class, which derives from <code>SKCanvasView</code>. This class is responsible for displaying the bitmap and the cropping rectangle, as well as handling touch or mouse events for changing the cropping rectangle.</p>
<p>The <code>PhotoCropperCanvasView</code> constructor requires a bitmap. An aspect ratio is optional. The constructor instantiates an object of type <code>CroppingRectangle</code> based on this bitmap and aspect ratio and saves it as a field:</p>
<pre><code class="lang-csharp">class PhotoCropperCanvasView : SKCanvasView
{
    ···
    SKBitmap bitmap;
    CroppingRectangle croppingRect;
    ···
    public PhotoCropperCanvasView(SKBitmap bitmap, float? aspectRatio = null)
    {
        this.bitmap = bitmap;

        SKRect bitmapRect = new SKRect(0, 0, bitmap.Width, bitmap.Height);
        croppingRect = new CroppingRectangle(bitmapRect, aspectRatio);
        ···
    }
    ···
}
</code></pre>
<p>Because this class derives from <code>SKCanvasView</code>, it doesn't need to install a handler for the <code>PaintSurface</code> event. It can instead override its <code>OnPaintSurface</code> method. The method displays the bitmap and uses a couple of <code>SKPaint</code> objects saved as fields to draw the current cropping rectangle:</p>
<pre><code class="lang-csharp">class PhotoCropperCanvasView : SKCanvasView
{
    const int CORNER = 50;      // pixel length of cropper corner
    ···
    SKBitmap bitmap;
    CroppingRectangle croppingRect;
    SKMatrix inverseBitmapMatrix;
    ···
    // Drawing objects
    SKPaint cornerStroke = new SKPaint
    {
        Style = SKPaintStyle.Stroke,
        Color = SKColors.White,
        StrokeWidth = 10
    };

    SKPaint edgeStroke = new SKPaint
    {
        Style = SKPaintStyle.Stroke,
        Color = SKColors.White,
        StrokeWidth = 2
    };
    ···
    protected override void OnPaintSurface(SKPaintSurfaceEventArgs args)
    {
        base.OnPaintSurface(args);

        SKImageInfo info = args.Info;
        SKSurface surface = args.Surface;
        SKCanvas canvas = surface.Canvas;

        canvas.Clear(SKColors.Gray);

        // Calculate rectangle for displaying bitmap
        float scale = Math.Min((float)info.Width / bitmap.Width, (float)info.Height / bitmap.Height);
        float x = (info.Width - scale * bitmap.Width) / 2;
        float y = (info.Height - scale * bitmap.Height) / 2;
        SKRect bitmapRect = new SKRect(x, y, x + scale * bitmap.Width, y + scale * bitmap.Height);
        canvas.DrawBitmap(bitmap, bitmapRect);

        // Calculate a matrix transform for displaying the cropping rectangle
        SKMatrix bitmapScaleMatrix = SKMatrix.Identity;
        bitmapScaleMatrix.SetScaleTranslate(scale, scale, x, y);

        // Display rectangle
        SKRect scaledCropRect = bitmapScaleMatrix.MapRect(croppingRect.Rect);
        canvas.DrawRect(scaledCropRect, edgeStroke);

        // Display heavier corners
        using (SKPath path = new SKPath())
        {
            path.MoveTo(scaledCropRect.Left, scaledCropRect.Top + CORNER);
            path.LineTo(scaledCropRect.Left, scaledCropRect.Top);
            path.LineTo(scaledCropRect.Left + CORNER, scaledCropRect.Top);

            path.MoveTo(scaledCropRect.Right - CORNER, scaledCropRect.Top);
            path.LineTo(scaledCropRect.Right, scaledCropRect.Top);
            path.LineTo(scaledCropRect.Right, scaledCropRect.Top + CORNER);

            path.MoveTo(scaledCropRect.Right, scaledCropRect.Bottom - CORNER);
            path.LineTo(scaledCropRect.Right, scaledCropRect.Bottom);
            path.LineTo(scaledCropRect.Right - CORNER, scaledCropRect.Bottom);

            path.MoveTo(scaledCropRect.Left + CORNER, scaledCropRect.Bottom);
            path.LineTo(scaledCropRect.Left, scaledCropRect.Bottom);
            path.LineTo(scaledCropRect.Left, scaledCropRect.Bottom - CORNER);

            canvas.DrawPath(path, cornerStroke);
        }

        // Invert the transform for touch tracking
        bitmapScaleMatrix.TryInvert(out inverseBitmapMatrix);
    }
    ···
}
</code></pre>
<p>The code in the <code>CroppingRectangle</code> class bases the cropping rectangle on the pixel size of the bitmap. However, the display of the bitmap by the <code>PhotoCropperCanvasView</code> class is scaled based on the size of the display area. The <code>bitmapScaleMatrix</code> calculated in the <code>OnPaintSurface</code> override maps from the bitmap pixels to the size and position of the bitmap as it is displayed. This matrix is then used to transform the cropping rectangle so that it can be displayed relative to the bitmap.</p>
<p>The last line of the <code>OnPaintSurface</code> override takes the inverse of the <code>bitmapScaleMatrix</code> and saves it as the <code>inverseBitmapMatrix</code> field. This is used for touch processing.</p>
<p>The <code>SKCanvasView</code> has built-in touch support. Touch events are enabled in the constructor by setting <code>EnableTouchEvents</code> to <code>true</code> and attaching a handler to the <code>Touch</code> event:</p>
<pre><code class="lang-csharp">class PhotoCropperCanvasView : SKCanvasView
{
    ···
    const int RADIUS = 100;     // pixel radius of touch hit-test
    ···
    CroppingRectangle croppingRect;
    SKMatrix inverseBitmapMatrix;

    // Touch tracking
    struct TouchPoint
    {
        public int CornerIndex { set; get; }
        public SKPoint Offset { set; get; }
    }

    Dictionary&lt;long, TouchPoint&gt; touchPoints = new Dictionary&lt;long, TouchPoint&gt;();
    ···
    public PhotoCropperCanvasView(SKBitmap bitmap, float? aspectRatio = null)
    {
        ···
        EnableTouchEvents = true;
        Touch += OnTouch;
    }
    ···
    void OnTouch(object? sender, SKTouchEventArgs e)
    {
        SKPoint bitmapLocation = inverseBitmapMatrix.MapPoint(e.Location);

        switch (e.ActionType)
        {
            case SKTouchAction.Pressed:
                // Convert radius to bitmap/cropping scale
                float radius = inverseBitmapMatrix.ScaleX * RADIUS;

                // Find corner that the finger is touching
                int cornerIndex = croppingRect.HitTest(bitmapLocation, radius);

                if (cornerIndex != -1 &amp;&amp; !touchPoints.ContainsKey(e.Id))
                {
                    TouchPoint touchPoint = new TouchPoint
                    {
                        CornerIndex = cornerIndex,
                        Offset = bitmapLocation - croppingRect.Corners[cornerIndex]
                    };

                    touchPoints.Add(e.Id, touchPoint);
                }
                break;

            case SKTouchAction.Moved:
                if (touchPoints.ContainsKey(e.Id))
                {
                    TouchPoint touchPoint = touchPoints[e.Id];
                    croppingRect.MoveCorner(touchPoint.CornerIndex,
                                            bitmapLocation - touchPoint.Offset);
                    InvalidateSurface();
                }
                break;

            case SKTouchAction.Released:
            case SKTouchAction.Cancelled:
                if (touchPoints.ContainsKey(e.Id))
                {
                    touchPoints.Remove(e.Id);
                }
                break;
        }

        e.Handled = true;
    }
}
</code></pre>
<p>The <code>Touch</code> event handler receives <code>SKTouchEventArgs</code> where <code>e.Location</code> is already in pixel coordinates. The location is converted to <code>CroppingRectangle</code> units using <code>inverseBitmapMatrix</code>. Setting <code>e.Handled = true</code> at the end of the handler ensures the view continues to receive touch events.</p>
<p>For <code>Pressed</code> events, the <code>TouchAction</code> handler calls the <code>HitTest</code> method of <code>CroppingRectangle</code>. If this returns an index other than –1, then one of the corners of the cropping rectangle is being manipulated. That index and an offset of the actual touch point from the corner is stored in a <code>TouchPoint</code> object and added to the <code>touchPoints</code> dictionary.</p>
<p>For the <code>Moved</code> event, the <code>MoveCorner</code> method of <code>CroppingRectangle</code> is called to move the corner, with possible adjustments for the aspect ratio.</p>
<p>At any time, a program using <code>PhotoCropperCanvasView</code> can access the <code>CroppedBitmap</code> property. This property uses the <code>Rect</code> property of the <code>CroppingRectangle</code> to create a new bitmap of the cropped size. The version of <code>DrawBitmap</code> with destination and source rectangles then extracts a subset of the original bitmap:</p>
<pre><code class="lang-csharp">class PhotoCropperCanvasView : SKCanvasView
{
    ···
    SKBitmap bitmap;
    CroppingRectangle croppingRect;
    ···
    public SKBitmap CroppedBitmap
    {
        get
        {
            SKRect cropRect = croppingRect.Rect;
            SKBitmap croppedBitmap = new SKBitmap((int)cropRect.Width,
                                                  (int)cropRect.Height);
            SKRect dest = new SKRect(0, 0, cropRect.Width, cropRect.Height);
            SKRect source = new SKRect(cropRect.Left, cropRect.Top,
                                       cropRect.Right, cropRect.Bottom);

            using (SKCanvas canvas = new SKCanvas(croppedBitmap))
            {
                canvas.DrawBitmap(bitmap, source, dest);
            }

            return croppedBitmap;
        }
    }
    ···
}
</code></pre>
<h2 id="hosting-the-photo-cropper-canvas-view">Hosting the photo cropper canvas view</h2>
<p>With those two classes handling the cropping logic, the <strong>Photo Cropping</strong> page in the sample application has very little work to do. The XAML file instantiates a <code>Grid</code> to host the <code>PhotoCropperCanvasView</code> and a <strong>Done</strong> button:</p>
<pre><code class="lang-xaml">&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;SkiaSharpFormsDemos.Bitmaps.PhotoCroppingPage&quot;
             Title=&quot;Photo Cropping&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=&quot;*&quot; /&gt;
            &lt;RowDefinition Height=&quot;Auto&quot; /&gt;
        &lt;/Grid.RowDefinitions&gt;

        &lt;Grid x:Name=&quot;canvasViewHost&quot;
              Grid.Row=&quot;0&quot;
              BackgroundColor=&quot;Gray&quot;
              Padding=&quot;5&quot; /&gt;

        &lt;Button Text=&quot;Done&quot;
                Grid.Row=&quot;1&quot;
                HorizontalOptions=&quot;Center&quot;
                Margin=&quot;5&quot;
                Clicked=&quot;OnDoneButtonClicked&quot; /&gt;
    &lt;/Grid&gt;
&lt;/ContentPage&gt;
</code></pre>
<p>The <code>PhotoCropperCanvasView</code> cannot be instantiated in the XAML file because it requires a parameter of type <code>SKBitmap</code>.</p>
<p>Instead, the <code>PhotoCropperCanvasView</code> is instantiated in the constructor of the code-behind file using one of the resource bitmaps:</p>
<pre><code class="lang-csharp">public partial class PhotoCroppingPage : ContentPage
{
    PhotoCropperCanvasView photoCropper;
    SKBitmap croppedBitmap;

    public PhotoCroppingPage ()
    {
        InitializeComponent ();

        SKBitmap bitmap = BitmapExtensions.LoadBitmap(&quot;MountainClimbers.jpg&quot;);

        photoCropper = new PhotoCropperCanvasView(bitmap);
        canvasViewHost.Children.Add(photoCropper);
    }

    void OnDoneButtonClicked(object? sender, EventArgs args)
    {
        croppedBitmap = photoCropper.CroppedBitmap;

        SKCanvasView canvasView = new SKCanvasView();
        canvasView.PaintSurface += OnCanvasViewPaintSurface;
        Content = canvasView;
    }

    void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
    {
        SKImageInfo info = args.Info;
        SKSurface surface = args.Surface;
        SKCanvas canvas = surface.Canvas;

        canvas.Clear();
        canvas.DrawBitmap(croppedBitmap, info.Rect, BitmapStretch.Uniform);
    }
}
</code></pre>
<p>The user can then manipulate the cropping rectangle:</p>
<p><a href="cropping-images/PhotoCropping1-Large.png#lightbox"><img src="cropping-images/PhotoCropping1.png" alt="Photo Cropper 1" title="Photo Cropper 1"></a></p>
<p>When a good cropping rectangle has been defined, click the <strong>Done</strong> button. The <code>Clicked</code> handler obtains the cropped bitmap from the <code>CroppedBitmap</code> property of <code>PhotoCropperCanvasView</code>, and replaces all the content of the page with a new <code>SKCanvasView</code> object that displays this cropped bitmap:</p>
<p><a href="cropping-images/PhotoCropping2-Large.png#lightbox"><img src="cropping-images/PhotoCropping2.png" alt="Photo Cropper 2" title="Photo Cropper 2"></a></p>
<p>Try setting the second argument of <code>PhotoCropperCanvasView</code> to 1.78f (for example):</p>
<pre><code class="lang-csharp">photoCropper = new PhotoCropperCanvasView(bitmap, 1.78f);
</code></pre>
<p>You'll see the cropping rectangle restricted to a 16-to-9 aspect ratio characteristic of high-definition television.</p>
<h2 id="dividing-a-bitmap-into-tiles">Dividing a bitmap into tiles</h2>
<p>A .NET MAUI version of the famous 14-15 puzzle can be implemented using SkiaSharp. The puzzle becomes more fun (and often more challenging) when it is based on an image from your own photo library.</p>
<p>This version of the 14-15 puzzle is part of the sample application, and consists of a series of pages titled <strong>Photo Puzzle</strong>.</p>
<p>The <strong>PhotoPuzzlePage1.xaml</strong> file consists of a <code>Button</code>:</p>
<pre><code class="lang-xaml">&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;SkiaSharpFormsDemos.Bitmaps.PhotoPuzzlePage1&quot;
             Title=&quot;Photo Puzzle&quot;&gt;

    &lt;Button Text=&quot;Pick a photo from your library&quot;
            VerticalOptions=&quot;CenterAndExpand&quot;
            HorizontalOptions=&quot;CenterAndExpand&quot;
            Clicked=&quot;OnPickButtonClicked&quot;/&gt;

&lt;/ContentPage&gt;
</code></pre>
<p>The code-behind file implements a <code>Clicked</code> handler that uses MAUI's <code>MediaPicker</code> to let the user pick a photo from the photo library:</p>
<pre><code class="lang-csharp">using Microsoft.Maui.Media;

public partial class PhotoPuzzlePage1 : ContentPage
{
    public PhotoPuzzlePage1 ()
    {
        InitializeComponent ();
    }

    async void OnPickButtonClicked(object? sender, EventArgs args)
    {
        var results = await MediaPicker.Default.PickPhotosAsync(new MediaPickerOptions
        {
            SelectionLimit = 1,
            Title = &quot;Select a photo for the puzzle&quot;
        });
        
        var photo = results.FirstOrDefault();
        if (photo != null)
        {
            using Stream stream = await photo.OpenReadAsync();
            SKBitmap bitmap = SKBitmap.Decode(stream);
            await Navigation.PushAsync(new PhotoPuzzlePage2(bitmap));
        }
    }
}
</code></pre>
<p>The method then navigates to <code>PhotoPuzzlePage2</code>, passing to the constuctor the selected bitmap.</p>
<p>It's possible that the photo selected from the library is not oriented as it appeared in the photo library, but is rotated or upside-down. (This is particularly a problem with iOS devices.) For that reason, <code>PhotoPuzzlePage2</code> allows you to rotate the image to a desired orientation. The XAML file contains three buttons labeled <strong>90° Right</strong> (meaning clockwise), <strong>90° Left</strong> (counterclockwise), and <strong>Done</strong>.</p>
<p>The code-behind file implements the bitmap-rotation logic shown in the article <strong><a href="drawing.html#rotating-bitmaps">Creating and Drawing on SkiaSharp Bitmaps</a></strong>. The user can rotate the image 90 degrees clockwise or counter-clockwise any number of times:</p>
<pre><code class="lang-csharp">public partial class PhotoPuzzlePage2 : ContentPage
{
    SKBitmap bitmap;

    public PhotoPuzzlePage2 (SKBitmap bitmap)
    {
        this.bitmap = bitmap;

        InitializeComponent ();
    }

    void OnCanvasViewPaintSurface(object? sender, SKPaintSurfaceEventArgs args)
    {
        SKImageInfo info = args.Info;
        SKSurface surface = args.Surface;
        SKCanvas canvas = surface.Canvas;

        canvas.Clear();
        canvas.DrawBitmap(bitmap, info.Rect, BitmapStretch.Uniform);
    }

    void OnRotateRightButtonClicked(object? sender, EventArgs args)
    {
        SKBitmap rotatedBitmap = new SKBitmap(bitmap.Height, bitmap.Width);

        using (SKCanvas canvas = new SKCanvas(rotatedBitmap))
        {
            canvas.Clear();
            canvas.Translate(bitmap.Height, 0);
            canvas.RotateDegrees(90);
            canvas.DrawBitmap(bitmap, new SKPoint());
        }

        bitmap = rotatedBitmap;
        canvasView.InvalidateSurface();
    }

    void OnRotateLeftButtonClicked(object? sender, EventArgs args)
    {
        SKBitmap rotatedBitmap = new SKBitmap(bitmap.Height, bitmap.Width);

        using (SKCanvas canvas = new SKCanvas(rotatedBitmap))
        {
            canvas.Clear();
            canvas.Translate(0, bitmap.Width);
            canvas.RotateDegrees(-90);
            canvas.DrawBitmap(bitmap, new SKPoint());
        }

        bitmap = rotatedBitmap;
        canvasView.InvalidateSurface();
    }

    async void OnDoneButtonClicked(object? sender, EventArgs args)
    {
        await Navigation.PushAsync(new PhotoPuzzlePage3(bitmap));
    }
}
</code></pre>
<p>When the user clicks the <strong>Done</strong> button, the <code>Clicked</code> handler navigates to <code>PhotoPuzzlePage3</code>, passing the final rotated bitmap in the page's constructor.</p>
<p><code>PhotoPuzzlePage3</code> allows the photo to be cropped. The program requires a square bitmap to divide into a 4-by-4 grid of tiles.</p>
<p>The <strong>PhotoPuzzlePage3.xaml</strong> file contains a <code>Label</code>, a <code>Grid</code> to host the <code>PhotoCropperCanvasView</code>, and another <strong>Done</strong> button:</p>
<pre><code class="lang-xaml">&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;SkiaSharpFormsDemos.Bitmaps.PhotoPuzzlePage3&quot;
             Title=&quot;Photo Puzzle&quot;&gt;
    &lt;Grid&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height=&quot;Auto&quot; /&gt;
            &lt;RowDefinition Height=&quot;*&quot; /&gt;
            &lt;RowDefinition Height=&quot;Auto&quot; /&gt;
        &lt;/Grid.RowDefinitions&gt;

        &lt;Label Text=&quot;Crop the photo to a square&quot;
               Grid.Row=&quot;0&quot;
               FontSize=&quot;Large&quot;
               HorizontalTextAlignment=&quot;Center&quot;
               Margin=&quot;5&quot; /&gt;

        &lt;Grid x:Name=&quot;canvasViewHost&quot;
              Grid.Row=&quot;1&quot;
              BackgroundColor=&quot;Gray&quot;
              Padding=&quot;5&quot; /&gt;

        &lt;Button Text=&quot;Done&quot;
                Grid.Row=&quot;2&quot;
                HorizontalOptions=&quot;Center&quot;
                Margin=&quot;5&quot;
                Clicked=&quot;OnDoneButtonClicked&quot; /&gt;
    &lt;/Grid&gt;
&lt;/ContentPage&gt;
</code></pre>
<p>The code-behind file instantiates the <code>PhotoCropperCanvasView</code> with the bitmap passed to its constructor. Notice that a 1 is passed as the second argument to <code>PhotoCropperCanvasView</code>. This aspect ratio of 1 forces the cropping rectangle to be a square:</p>
<pre><code class="lang-csharp">public partial class PhotoPuzzlePage3 : ContentPage
{
    PhotoCropperCanvasView photoCropper;

    public PhotoPuzzlePage3(SKBitmap bitmap)
    {
        InitializeComponent ();

        photoCropper = new PhotoCropperCanvasView(bitmap, 1f);
        canvasViewHost.Children.Add(photoCropper);
    }

    async void OnDoneButtonClicked(object? sender, EventArgs args)
    {
        SKBitmap croppedBitmap = photoCropper.CroppedBitmap;
        int width = croppedBitmap.Width / 4;
        int height = croppedBitmap.Height / 4;

        ImageSource[] imgSources = new ImageSource[15];

        for (int row = 0; row &lt; 4; row++)
        {
            for (int col = 0; col &lt; 4; col++)
            {
                // Skip the last one!
                if (row == 3 &amp;&amp; col == 3)
                    break;

                // Create a bitmap 1/4 the width and height of the original
                SKBitmap bitmap = new SKBitmap(width, height);
                SKRect dest = new SKRect(0, 0, width, height);
                SKRect source = new SKRect(col * width, row * height, (col + 1) * width, (row + 1) * height);

                // Copy 1/16 of the original into that bitmap
                using (SKCanvas canvas = new SKCanvas(bitmap))
                {
                    canvas.DrawBitmap(croppedBitmap, source, dest);
                }

                imgSources[4 * row + col] = (SKBitmapImageSource)bitmap;
            }
        }

        await Navigation.PushAsync(new PhotoPuzzlePage4(imgSources));
    }
}
</code></pre>
<p>The <strong>Done</strong> button handler obtains the width and height of the cropped bitmap (these two values should be the same) and then divides it into 15 separate bitmaps, each of which is 1/4 the width and height of the original. (The last of the possible 16 bitmaps is not created.) The <code>DrawBitmap</code> method with source and destination rectangle allows a bitmap to be created based on subset of a larger bitmap.</p>
<h2 id="converting-to-net-maui-bitmaps">Converting to .NET MAUI bitmaps</h2>
<p>In the <code>OnDoneButtonClicked</code> method, the array created for the 15 bitmaps is of type <a class="xref" href="https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.imagesource"><code>ImageSource</code></a>:</p>
<pre><code class="lang-csharp">ImageSource[] imgSources = new ImageSource[15];
</code></pre>
<p><code>ImageSource</code> is the .NET MAUI base type that encapsulates a bitmap. Fortunately, SkiaSharp allows converting from SkiaSharp bitmaps to .NET MAUI bitmaps. The <strong>SkiaSharp.Views.Maui.Controls</strong> assembly defines an <a class="xref" href="https://learn.microsoft.com/dotnet/api/skiasharp.views.maui.controls.skbitmapimagesource"><code>SKBitmapImageSource</code></a> class that derives from <code>ImageSource</code> but can be created based on a SkiaSharp <code>SKBitmap</code> object. <code>SKBitmapImageSource</code> even defines conversions between <code>SKBitmapImageSource</code> and <code>SKBitmap</code>, and that's how <code>SKBitmap</code> objects are stored in an array as .NET MAUI bitmaps:</p>
<pre><code class="lang-csharp">imgSources[4 * row + col] = (SKBitmapImageSource)bitmap;
</code></pre>
<p>This array of bitmaps is passed as a constructor to <code>PhotoPuzzlePage4</code>. That page is entirely .NET MAUI and doesn't use any SkiaSharp. It implements the classic 14-15 puzzle game, so it won't be described here, but it displays your selected photo divided into 15 square tiles:</p>
<p><a href="cropping-images/PhotoPuzzle1-Large.png#lightbox"><img src="cropping-images/PhotoPuzzle1.png" alt="Photo Puzzle 1" title="Photo Puzzle 1"></a></p>
<p>Pressing the <strong>Randomize</strong> button mixes up all the tiles:</p>
<p><a href="cropping-images/PhotoPuzzle2-Large.png#lightbox"><img src="cropping-images/PhotoPuzzle2.png" alt="Photo Puzzle 2" title="Photo Puzzle 2"></a></p>
<p>Now you can put them back in the correct order. Any tiles in the same row or column as the blank square can be tapped to move them into the blank square.</p>
<h2 id="related-links">Related links</h2>
<ul>
<li><a href="/dotnet/api/skiasharp">SkiaSharp APIs</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/mono/SkiaSharp/blob/docs/docs/docs/bitmaps/cropping.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
