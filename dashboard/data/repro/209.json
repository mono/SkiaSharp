{
  "meta": {
    "schemaVersion": "1.0",
    "number": 209,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-12T17:15:00Z"
  },
  "conclusion": "not-reproduced",
  "notes": "Attempted to reproduce concurrent SKBitmap.Decode AccessViolationException on macOS ARM64 with .NET 8. Ran 3 stress tests (byte array decode, stream decode, SKCodec path) with 100 threads x 200 iterations each (60,000 concurrent decodes per version) across SkiaSharp 2.88.9, 3.119.2, and main (source). All 180,000\u002B decodes completed with zero errors. The original issue was reported on Windows IIS with .NET Framework 4.x in 2016, and subsequent reports span .NET Core through .NET 7 on Windows. The bug may be platform-specific (Windows), specific to older Skia native library versions, or related to .NET Framework GC/marshaling behavior that differs from modern .NET on macOS.",
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "description": "Create standalone console project with SkiaSharp 2.88.9",
      "layer": "setup",
      "command": "dotnet new console -n Repro --framework net8.0 \u0026\u0026 cd Repro \u0026\u0026 dotnet add package SkiaSharp --version 2.88.9",
      "exitCode": 0,
      "output": "Restore succeeded. PackageReference for package \u0027SkiaSharp\u0027 version \u00272.88.9\u0027 added.",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Console project targeting net8.0 with SkiaSharp 2.88.9",
          "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp\u0022 Version=\u00222.88.9\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E"
        },
        {
          "filename": "Program.cs",
          "description": "Concurrent SKBitmap.Decode stress test with 100 threads x 200 iterations across byte array, stream, and SKCodec decode paths with 3 different image sizes",
          "content": "using System;\nusing System.Collections.Concurrent;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing SkiaSharp;\n\nConsole.WriteLine($\u0022SkiaSharp Version: {typeof(SKBitmap).Assembly.GetName().Version}\u0022);\nConsole.WriteLine($\u0022OS: {RuntimeInformation.OSDescription}\u0022);\nConsole.WriteLine($\u0022Arch: {RuntimeInformation.ProcessArchitecture}\u0022);\nConsole.WriteLine($\u0022Runtime: {RuntimeInformation.FrameworkDescription}\u0022);\n\nbyte[] CreateTestPng(int size, SKColor bg)\n{\n    using var bmp = new SKBitmap(size, size);\n    using var canvas = new SKCanvas(bmp);\n    canvas.Clear(bg);\n    using var paint = new SKPaint { Color = SKColors.White, IsAntialias = true };\n    canvas.DrawCircle(size / 2f, size / 2f, size / 3f, paint);\n    using var image = SKImage.FromBitmap(bmp);\n    using var data = image.Encode(SKEncodedImageFormat.Png, 100);\n    return data.ToArray();\n}\n\nvar pngSmall = CreateTestPng(100, SKColors.Blue);\nvar pngMedium = CreateTestPng(500, SKColors.Green);\nvar pngLarge = CreateTestPng(1000, SKColors.Red);\nvar images = new[] { pngSmall, pngMedium, pngLarge };\n\nconst int numThreads = 100;\nconst int numIterationsPerThread = 200;\nvar errors = new ConcurrentBag\u003Cstring\u003E();\nvar totalDecoded = 0;\nvar barrier = new Barrier(numThreads);\n\n// Test 1: byte array decode\nvar tasks = new Task[numThreads];\nfor (int i = 0; i \u003C numThreads; i\u002B\u002B)\n{\n    int threadId = i;\n    tasks[i] = Task.Run(() =\u003E\n    {\n        var localBytes = (byte[])images[threadId % 3].Clone();\n        barrier.SignalAndWait();\n        for (int j = 0; j \u003C numIterationsPerThread; j\u002B\u002B)\n        {\n            using var bitmap = SKBitmap.Decode(localBytes);\n            if (bitmap == null)\n                errors.Add($\u0022T{threadId}/i{j}: Decode returned null\u0022);\n            else\n                Interlocked.Increment(ref totalDecoded);\n        }\n    });\n}\nTask.WaitAll(tasks);\n\n// Test 2: stream decode\nvar errors2 = new ConcurrentBag\u003Cstring\u003E();\nvar totalDecoded2 = 0;\nvar barrier2 = new Barrier(numThreads);\nvar tasks2 = new Task[numThreads];\nfor (int i = 0; i \u003C numThreads; i\u002B\u002B)\n{\n    int threadId = i;\n    tasks2[i] = Task.Run(() =\u003E\n    {\n        var localBytes = (byte[])images[threadId % 3].Clone();\n        barrier2.SignalAndWait();\n        for (int j = 0; j \u003C numIterationsPerThread; j\u002B\u002B)\n        {\n            using var ms = new MemoryStream(localBytes);\n            using var skStream = new SKManagedStream(ms);\n            using var bitmap = SKBitmap.Decode(skStream);\n            if (bitmap == null)\n                errors2.Add($\u0022T{threadId}/i{j}: null\u0022);\n            else\n                Interlocked.Increment(ref totalDecoded2);\n        }\n    });\n}\nTask.WaitAll(tasks2);\n\n// Test 3: SKCodec path\nvar errors3 = new ConcurrentBag\u003Cstring\u003E();\nvar totalDecoded3 = 0;\nvar barrier3 = new Barrier(numThreads);\nvar tasks3 = new Task[numThreads];\nfor (int i = 0; i \u003C numThreads; i\u002B\u002B)\n{\n    int threadId = i;\n    tasks3[i] = Task.Run(() =\u003E\n    {\n        var localBytes = (byte[])images[threadId % 3].Clone();\n        barrier3.SignalAndWait();\n        for (int j = 0; j \u003C numIterationsPerThread; j\u002B\u002B)\n        {\n            using var data = SKData.CreateCopy(localBytes);\n            using var codec = SKCodec.Create(data);\n            if (codec == null) { errors3.Add($\u0022null codec\u0022); continue; }\n            var info = codec.Info;\n            using var bitmap = new SKBitmap(info.Width, info.Height, info.ColorType, info.AlphaType);\n            var result = codec.GetPixels(bitmap.Info, bitmap.GetPixels());\n            if (result != SKCodecResult.Success)\n                errors3.Add($\u0022GetPixels: {result}\u0022);\n            else\n                Interlocked.Increment(ref totalDecoded3);\n        }\n    });\n}\nTask.WaitAll(tasks3);\n\nvar allErrors = errors.Count \u002B errors2.Count \u002B errors3.Count;\nConsole.WriteLine($\u0022Total errors: {allErrors}\u0022);\nif (allErrors \u003E 0) Environment.Exit(1);\nelse { Console.WriteLine(\u0022No errors\u0022); Environment.Exit(0); }"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 2,
      "description": "Run concurrent decode stress test with SkiaSharp 2.88.9 \u2014 100 threads x 200 iterations x 3 test patterns (byte array, stream, SKCodec)",
      "layer": "csharp",
      "command": "cd /tmp/repro-209/Repro \u0026\u0026 dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp Version: 2.88.0.0\nOS: Darwin 25.2.0\nArch: Arm64\nRuntime: .NET 8.0.23\nTest images: 1379, 9272, 18424 bytes\n\nTest 1: 100 threads x 200 iterations (byte array decode)...\n  Decoded: 20000, Errors: 0\n\nTest 2: 100 threads x 200 iterations (stream decode)...\n  Decoded: 20000, Errors: 0\n\nTest 3: 100 threads x 200 iterations (SKCodec path)...\n  Decoded: 20000, Errors: 0\n\n=== SUMMARY ===\nTotal errors: 0\nNo errors detected - concurrent decode appears stable on this platform/version",
      "result": "success"
    },
    {
      "stepNumber": 3,
      "description": "Update to SkiaSharp 3.119.2 (latest stable) and re-run concurrent decode stress test",
      "layer": "csharp",
      "command": "dotnet add package SkiaSharp \u0026\u0026 dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp Version: 3.119.0.0\nOS: Darwin 25.2.0\nArch: Arm64\nRuntime: .NET 8.0.23\nTest images: 1380, 9270, 18418 bytes\n\nTest 1: 100 threads x 200 iterations (byte array decode)...\n  Decoded: 20000, Errors: 0\n\nTest 2: 100 threads x 200 iterations (stream decode)...\n  Decoded: 20000, Errors: 0\n\nTest 3: 100 threads x 200 iterations (SKCodec path)...\n  Decoded: 20000, Errors: 0\n\n=== SUMMARY ===\nTotal errors: 0\nNo errors detected - concurrent decode appears stable on this platform/version",
      "result": "success"
    },
    {
      "stepNumber": 4,
      "description": "Build SkiaSharp test project from main branch source and run concurrent decode test via xUnit (100 threads x 200 iterations with baboon.jpg test image)",
      "layer": "csharp",
      "command": "dotnet build tests/SkiaSharp.Tests.Console/SkiaSharp.Tests.Console.csproj \u0026\u0026 dotnet test tests/SkiaSharp.Tests.Console/SkiaSharp.Tests.Console.csproj --no-build --filter FullyQualifiedName~ConcurrentDecodeDoesNotCrash",
      "exitCode": 0,
      "output": "Build succeeded. 0 Error(s)\nPassed SkiaSharp.Tests.SKBitmapTest.ConcurrentDecodeDoesNotCrash [1 m 7 s]\nTest Run Successful. Total tests: 1, Passed: 1",
      "result": "success"
    }
  ],
  "environment": {
    "os": "macOS 26.2",
    "arch": "arm64",
    "dotnetVersion": "8.0.417",
    "skiaSharpVersion": "2.88.9",
    "dockerUsed": false
  },
  "inputs": {
    "triageFile": "ai-triage/209.json"
  },
  "assessment": "likely-bug",
  "reproductionTime": "~15 minutes",
  "versionResults": [
    {
      "version": "2.88.9",
      "source": "nuget",
      "result": "not-reproduced",
      "notes": "60,000 concurrent decodes (100 threads x 200 iterations x 3 tests) with zero errors on macOS ARM64"
    },
    {
      "version": "3.119.2",
      "source": "nuget",
      "result": "not-reproduced",
      "notes": "60,000 concurrent decodes with zero errors on macOS ARM64"
    },
    {
      "version": "main (source)",
      "source": "source",
      "result": "not-reproduced",
      "notes": "20,000 concurrent decodes (100 threads x 200 iterations) via xUnit test with zero errors, completed in 67 seconds"
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net8.0",
    "packages": [
      {
        "name": "SkiaSharp",
        "version": "2.88.9"
      }
    ]
  },
  "blockers": [
    "Original issue reported on Windows IIS with .NET Framework 4.x \u2014 current environment is macOS ARM64 with .NET 8, which may have different threading/GC/native interop behavior",
    "AccessViolationException terminates the .NET process and cannot be caught \u2014 if a subtle race condition exists, it may require many more iterations or specific timing conditions to trigger on macOS",
    "Multiple reporters confirmed the crash on Windows (.NET Framework 4.x, .NET Core 2.x, .NET 5, .NET 7) but none on macOS \u2014 this may be a Windows-specific native code issue"
  ]
}