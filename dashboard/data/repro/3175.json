{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3175,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-12T17:55:00Z"
  },
  "conclusion": "reproduced",
  "notes": "Reproduced: SKManagedStream.OnReadManagedStream performs a single stream.Read() call without looping. When a stream returns fewer bytes than requested (valid per .NET Stream contract), Skia treats the short read as EOF and stops decoding. A 13MB PNG decoded through a ChunkedStream (max 2048 bytes per read) produces a 2000x2000 bitmap with zero pixel data \u2014 all rows are blank. With chunk sizes \u003E= 4096 (matching Skia\u0027s internal read request size), decoding works because no short reads occur. This affects any .NET stream that returns partial reads: Azure Blob Storage, network streams, buffered streams crossing buffer boundaries. The reporter\u0027s scenario (Azure Blob with 4MB default chunk size) triggers when Skia\u0027s 4096-byte read request crosses a chunk boundary in the Azure buffer, causing a partial return. Duplicate of #1962. Bug exists on 3.116.0, 3.119.2, and main.",
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "description": "Create console project and add SkiaSharp 3.116.0",
      "layer": "setup",
      "command": "dotnet new console -n Repro --framework net8.0 \u0026\u0026 cd Repro \u0026\u0026 dotnet add package SkiaSharp --version 3.116.0",
      "exitCode": 0,
      "output": "The template \u0022Console App\u0022 was created successfully.\nPackageReference for package \u0027SkiaSharp\u0027 version \u00273.116.0\u0027 added.",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Console project targeting net8.0 with SkiaSharp 3.116.0",
          "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp\u0022 Version=\u00223.116.0\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 2,
      "description": "Write reproduction code with instrumented ChunkedStream that limits Read() to a max chunk size, simulating Azure Blob stream behavior. Generates a 13MB PNG with random pixels, then decodes through ChunkedStream with various chunk sizes.",
      "layer": "csharp",
      "filesCreated": [
        {
          "filename": "Program.cs",
          "description": "Reproduction code: creates a large PNG, decodes through ChunkedStream wrapper that limits bytes per Read() call to simulate Azure Blob chunked delivery",
          "content": "using SkiaSharp;\nusing System;\nusing System.IO;\nusing System.Collections.Generic;\n\nConsole.WriteLine($\u0022SkiaSharp version: {typeof(SKBitmap).Assembly.GetName().Version}\u0022);\nConsole.WriteLine();\n\nconst int width = 2000;\nconst int height = 2000;\nbyte[] pngBytes;\n\nusing (var bmp = new SKBitmap(width, height, SKColorType.Rgba8888, SKAlphaType.Premul))\n{\n    var rng = new Random(42);\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n            bmp.SetPixel(x, y, new SKColor((byte)rng.Next(256), (byte)rng.Next(256), (byte)rng.Next(256)));\n    \n    using var image = SKImage.FromBitmap(bmp);\n    using var data = image.Encode(SKEncodedImageFormat.Png, 100);\n    pngBytes = data.ToArray();\n}\n\nConsole.WriteLine($\u0022PNG: {pngBytes.Length} bytes ({pngBytes.Length / 1024.0 / 1024.0:F2} MB)\u0022);\nConsole.WriteLine();\n\nforeach (var chunkSize in new[] { 2048, 4096, 4 * 1024 * 1024 })\n{\n    var reads = new List\u003C(int requested, int returned)\u003E();\n    using var inner = new MemoryStream(pngBytes);\n    using var chunked = new InstrumentedChunkedStream(inner, chunkSize, reads);\n    using var bitmap = SKBitmap.Decode(chunked);\n    \n    int shortReads = 0;\n    foreach (var (req, ret) in reads)\n        if (ret \u003C req \u0026\u0026 ret \u003E 0) shortReads\u002B\u002B;\n    \n    int lastRow = bitmap == null ? -1 : FindLastRow(bitmap, width, height);\n    bool ok = lastRow == height - 1;\n    \n    Console.WriteLine($\u0022[chunk={chunkSize,10}] reads={reads.Count}, short_reads={shortReads}, lastRow={lastRow}/{height - 1} {(ok ? \u0022OK\u0022 : \u0022TRUNCATED\u0022)}\u0022);\n}\n\nstatic int FindLastRow(SKBitmap bmp, int w, int h)\n{\n    for (int y = h - 1; y \u003E= 0; y--)\n        if (bmp.GetPixel(w / 2, y).Alpha \u003E 0) return y;\n    return -1;\n}\n\nclass InstrumentedChunkedStream : Stream\n{\n    private readonly Stream _inner;\n    private readonly int _chunkSize;\n    private readonly List\u003C(int requested, int returned)\u003E _reads;\n\n    public InstrumentedChunkedStream(Stream inner, int chunkSize, List\u003C(int, int)\u003E reads)\n    {\n        _inner = inner;\n        _chunkSize = chunkSize;\n        _reads = reads;\n    }\n\n    public override bool CanRead =\u003E true;\n    public override bool CanSeek =\u003E true;\n    public override bool CanWrite =\u003E false;\n    public override long Length =\u003E _inner.Length;\n    public override long Position { get =\u003E _inner.Position; set =\u003E _inner.Position = value; }\n\n    public override int Read(byte[] buffer, int offset, int count)\n    {\n        int toRead = Math.Min(count, _chunkSize);\n        int ret = _inner.Read(buffer, offset, toRead);\n        _reads.Add((count, ret));\n        return ret;\n    }\n\n    public override long Seek(long offset, SeekOrigin origin) =\u003E _inner.Seek(offset, origin);\n    public override void SetLength(long value) =\u003E _inner.SetLength(value);\n    public override void Write(byte[] buffer, int offset, int count) =\u003E throw new NotSupportedException();\n    public override void Flush() =\u003E _inner.Flush();\n}"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 3,
      "description": "Run reproduction with SkiaSharp 3.116.0 (reporter\u0027s version). ChunkedStream with 2048-byte limit causes Skia to stop after one short read \u2014 image is completely blank despite correct dimensions.",
      "layer": "csharp",
      "command": "dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.116.0.0\n\nPNG: 13840553 bytes (13.20 MB)\n\n[chunk=      2048] reads=8, short_reads=1, lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads=6758, short_reads=0, lastRow=1999/1999 OK\n[chunk=   4194304] reads=6758, short_reads=0, lastRow=1999/1999 OK",
      "result": "wrong-output"
    },
    {
      "stepNumber": 4,
      "description": "Update to SkiaSharp 3.119.2 (latest stable) and rerun. Same truncation behavior \u2014 bug not fixed.",
      "layer": "csharp",
      "command": "dotnet add package SkiaSharp --version 3.119.2 \u0026\u0026 dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.119.0.0\n\nPNG: 13840553 bytes (13.20 MB)\n\n[chunk=      2048] reads=8, short_reads=1, lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads=6758, short_reads=0, lastRow=1999/1999 OK\n[chunk=   4194304] reads=6758, short_reads=0, lastRow=1999/1999 OK",
      "result": "wrong-output"
    },
    {
      "stepNumber": 5,
      "description": "Test on main (source) by adding a temporary xUnit test to SKManagedStreamTest.cs. Created a 500x500 PNG with random pixels, decoded through ChunkedStream (2048 limit), compared bottom pixel. Test fails: expected #ff2fc4c8, got #00000000.",
      "layer": "csharp",
      "command": "dotnet test tests/SkiaSharp.Tests.Console/SkiaSharp.Tests.Console.csproj --filter \u0022FullyQualifiedName~DecodeFromChunkedStreamReadsAllData\u0022 --no-restore",
      "exitCode": 1,
      "output": "Failed SkiaSharp.Tests.SKManagedStreamTest.DecodeFromChunkedStreamReadsAllData [43 s]\nError Message:\n Assert.Equal() Failure\nExpected: #ff2fc4c8\nActual:   #00000000\nFailed! - Failed: 1, Passed: 0, Skipped: 0, Total: 1",
      "result": "failure"
    }
  ],
  "environment": {
    "os": "macOS 26.2",
    "arch": "arm64",
    "dotnetVersion": "8.0.417",
    "skiaSharpVersion": "3.116.0",
    "dockerUsed": false
  },
  "inputs": {
    "triageFile": "ai-triage/3175.json"
  },
  "assessment": "likely-bug",
  "reproductionTime": "~12 minutes",
  "versionResults": [
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "notes": "ChunkedStream with 2048-byte limit: 8 reads total, short read on request #8 (requested 4096, got 2048), Skia stops. Image 2000x2000 but all pixels blank."
    },
    {
      "version": "3.119.2",
      "source": "nuget",
      "result": "reproduced",
      "notes": "Identical behavior to 3.116.0. Same 8 reads, same short read, same blank image."
    },
    {
      "version": "main (source)",
      "source": "source",
      "result": "reproduced",
      "notes": "Test DecodeFromChunkedStreamReadsAllData failed: expected bottom pixel #ff2fc4c8, got #00000000. Bug still present on main."
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net8.0",
    "packages": [
      {
        "name": "SkiaSharp",
        "version": "3.116.0"
      }
    ]
  },
  "errorMessages": {
    "primaryError": "SKBitmap.Decode produces blank image when underlying stream returns partial reads (fewer bytes than requested). Skia\u0027s PNG codec makes 4096-byte read requests; a single short read causes Skia to treat the stream as ended, producing a bitmap with correct dimensions but zero pixel data."
  }
}