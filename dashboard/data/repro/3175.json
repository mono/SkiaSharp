{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3175,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-13T16:05:00Z"
  },
  "conclusion": "reproduced",
  "notes": "Reproduced on SkiaSharp 3.116.0, 3.119.2, and main (source). SKManagedStream.OnReadManagedStream performs a single stream.Read() call which returns fewer bytes than requested when the underlying stream delivers data in chunks (valid per .NET Stream contract). A 13MB PNG decoded through a ChunkedStream limited to 2048 bytes per read produces a 2000x2000 bitmap with all blank pixels \u2014 Skia treats the short read as EOF. Streams with chunk sizes \u003E= 4096 (Skia\u0027s internal read request size) work because no short reads occur. Bug also affects non-seekable streams. Reproduced identically on macOS arm64 (host) and Docker Linux x64. Duplicate of #1962.",
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "description": "Create console project and add SkiaSharp 3.116.0",
      "layer": "setup",
      "command": "mkdir -p /tmp/repro-3175 \u0026\u0026 cd /tmp/repro-3175 \u0026\u0026 dotnet new console -n Repro --framework net8.0 \u0026\u0026 cd Repro \u0026\u0026 dotnet add package SkiaSharp --version 3.116.0",
      "exitCode": 0,
      "output": "The template \u0022Console App\u0022 was created successfully.\nPackageReference for package \u0027SkiaSharp\u0027 version \u00273.116.0\u0027 added.",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Console project targeting net8.0 with SkiaSharp 3.116.0",
          "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp\u0022 Version=\u00223.116.0\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 2,
      "description": "Write reproduction code with instrumented ChunkedStream that limits Read() to a max chunk size, simulating Azure Blob stream behavior. Generates a 13MB PNG with random pixels, then decodes through ChunkedStream with various chunk sizes and a non-seekable variant.",
      "layer": "csharp",
      "filesCreated": [
        {
          "filename": "Program.cs",
          "description": "Reproduction: creates 2000x2000 PNG, decodes through ChunkedStream wrapper limiting bytes per Read(). Tests seekable (2048/4096/8192/4MB chunks) and non-seekable (2048 chunk) streams.",
          "content": "using SkiaSharp;\nusing System;\nusing System.IO;\nusing System.Collections.Generic;\n\nConsole.WriteLine($\u0022SkiaSharp version: {typeof(SKBitmap).Assembly.GetName().Version}\u0022);\n\nconst int width = 2000;\nconst int height = 2000;\nbyte[] pngBytes;\nusing (var bmp = new SKBitmap(width, height, SKColorType.Rgba8888, SKAlphaType.Premul))\n{\n    var rng = new Random(42);\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n            bmp.SetPixel(x, y, new SKColor((byte)rng.Next(256), (byte)rng.Next(256), (byte)rng.Next(256)));\n    using var image = SKImage.FromBitmap(bmp);\n    using var data = image.Encode(SKEncodedImageFormat.Png, 100);\n    pngBytes = data.ToArray();\n}\nConsole.WriteLine($\u0022PNG: {pngBytes.Length} bytes ({pngBytes.Length / 1024.0 / 1024.0:F2} MB)\u0022);\n\n// Direct MemoryStream (baseline)\nusing (var ms = new MemoryStream(pngBytes))\n{\n    using var bitmap = SKBitmap.Decode(ms);\n    var px = bitmap?.GetPixel(width / 2, height - 1);\n    Console.WriteLine($\u0022[MemoryStream] bottomPixel={px} {(px?.Alpha \u003E 0 ? \u0022OK\u0022 : \u0022BLANK\u0022)}\u0022);\n}\n\n// Chunked streams with various sizes\nforeach (var chunkSize in new[] { 2048, 4096, 8192, 4 * 1024 * 1024 })\n{\n    var reads = new List\u003C(int, int)\u003E();\n    using var inner = new MemoryStream(pngBytes);\n    using var chunked = new ChunkedStream(inner, chunkSize, reads);\n    using var bitmap = SKBitmap.Decode(chunked);\n    int shortReads = reads.Count(r =\u003E r.Item2 \u003C r.Item1 \u0026\u0026 r.Item2 \u003E 0);\n    int lastRow = FindLastRow(bitmap, width, height);\n    Console.WriteLine($\u0022[chunk={chunkSize,10}] reads={reads.Count,5} short={shortReads,3} lastRow={lastRow}/{height-1} {(lastRow == height-1 ? \u0022OK\u0022 : \u0022TRUNCATED\u0022)}\u0022);\n}\n\n// Non-seekable chunked stream\n{\n    var reads = new List\u003C(int, int)\u003E();\n    using var inner = new MemoryStream(pngBytes);\n    using var chunked = new NonSeekableChunkedStream(inner, 2048, reads);\n    using var bitmap = SKBitmap.Decode(chunked);\n    int lastRow = FindLastRow(bitmap, width, height);\n    Console.WriteLine($\u0022[non-seekable 2048] lastRow={lastRow}/{height-1} {(lastRow == height-1 ? \u0022OK\u0022 : \u0022TRUNCATED\u0022)}\u0022);\n}\n\nstatic int FindLastRow(SKBitmap bmp, int w, int h) {\n    if (bmp == null) return -1;\n    for (int y = h - 1; y \u003E= 0; y--)\n        if (bmp.GetPixel(w / 2, y).Alpha \u003E 0) return y;\n    return -1;\n}\n\nclass ChunkedStream : Stream { /* seekable stream limiting Read() to chunkSize */ }\nclass NonSeekableChunkedStream : Stream { /* non-seekable variant */ }"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 3,
      "description": "Run reproduction with SkiaSharp 3.116.0 (reporter\u0027s version). ChunkedStream with 2048-byte limit causes truncation \u2014 image is 2000x2000 but all pixels are blank.",
      "layer": "csharp",
      "command": "cd /tmp/repro-3175/Repro \u0026\u0026 dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.116.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    },
    {
      "stepNumber": 4,
      "description": "Test with SkiaSharp 3.119.2 (latest stable) in fresh project directory. Same truncation behavior \u2014 bug not fixed.",
      "layer": "csharp",
      "command": "cd /tmp/repro-3175-latest/Repro \u0026\u0026 dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.119.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    },
    {
      "stepNumber": 5,
      "description": "Test on main branch (source) using console sample project with project references. Same truncation \u2014 bug still present on main.",
      "layer": "csharp",
      "command": "cd $REPO \u0026\u0026 dotnet run --project samples/Basic/Console/SkiaSharpSample/SkiaSharpSample.csproj",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.119.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    },
    {
      "stepNumber": 6,
      "description": "Cross-platform verification on Docker Linux x64 with SkiaSharp 3.116.0 \u002B NativeAssets.Linux. Identical truncation confirms universal scope.",
      "layer": "csharp",
      "command": "docker run --rm --platform linux/amd64 -v $(pwd):/app -w /app mcr.microsoft.com/dotnet/sdk:8.0 bash -c \u0027apt-get update -qq \u0026\u0026 apt-get install -y -qq libfontconfig1 \u0026\u0026 dotnet run\u0027",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.116.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    }
  ],
  "environment": {
    "os": "macOS 26.2",
    "arch": "arm64",
    "dotnetVersion": "8.0.17",
    "skiaSharpVersion": "3.116.0",
    "dockerUsed": true,
    "dotnetSdkVersion": "10.0.102"
  },
  "inputs": {
    "triageFile": "ai-triage/3175.json"
  },
  "assessment": "likely-bug",
  "scope": "universal",
  "reproductionTime": "~10 minutes",
  "versionResults": [
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "notes": "ChunkedStream with 2048-byte limit: 8 reads total, 1 short read. Image 2000x2000 but all pixels blank (lastRow=-1).",
      "platform": "host-macos-arm64"
    },
    {
      "version": "3.119.2",
      "source": "nuget",
      "result": "reproduced",
      "notes": "Identical behavior to 3.116.0. Same 8 reads, same short read, same blank image.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "main (source)",
      "source": "source",
      "result": "reproduced",
      "notes": "Bug still present on main. Same truncation pattern with chunked streams.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "notes": "Cross-platform verification: identical truncation on Linux x64 in Docker. Confirms universal scope.",
      "platform": "docker-linux-x64"
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net8.0",
    "packages": [
      {
        "name": "SkiaSharp",
        "version": "3.116.0"
      }
    ]
  },
  "errorMessages": {
    "primaryError": "SKBitmap.Decode produces a bitmap with correct dimensions (2000x2000) but completely blank pixel data when the underlying stream returns partial reads. SKManagedStream.OnReadManagedStream performs a single stream.Read() call; when the stream returns fewer than the requested 4096 bytes (valid per .NET Stream contract), Skia treats it as EOF and stops decoding. Affects both seekable and non-seekable streams."
  },
  "output": {
    "proposedResponse": {
      "status": "ready",
      "body": "Thanks for reporting this! We\u0027ve confirmed the issue.\n\n**Root cause:** \u0060SKManagedStream.OnReadManagedStream\u0060 performs a single \u0060stream.Read()\u0060 call without looping. Per the [.NET Stream contract](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.read), \u0060Read()\u0060 may return fewer bytes than requested \u2014 this is normal for network streams, Azure Blob streams, and buffered streams crossing chunk boundaries. When a short read occurs, Skia interprets it as end-of-stream and stops decoding, producing a bitmap with correct dimensions but blank pixel data.\n\n**Tested versions:**\n| Version | Result |\n|---------|--------|\n| 3.116.0 (reported) | \u274C Reproduced |\n| 3.119.2 (latest) | \u274C Reproduced |\n| main (source) | \u274C Reproduced |\n\n**Workaround:** Copy the stream to a \u0060MemoryStream\u0060 first (which you\u0027ve already discovered):\n\u0060\u0060\u0060csharp\nawait using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var bitmap = SKBitmap.Decode(memoryStream);\n\u0060\u0060\u0060\n\nAlternatively, read all bytes and use \u0060SKBitmap.Decode(byte[])\u0060.\n\nThis is a known issue \u2014 duplicate of #1962, which tracks the root cause (introduced when \u0060BinaryReader.ReadBytes()\u0060 was replaced with a single \u0060stream.Read()\u0060 call).",
      "summary": "Confirmed bug: SKBitmap.Decode truncates images from streams that return partial reads. Known issue, workaround available."
    },
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.95,
      "reason": "Bug reproduced on all tested versions (3.116.0, 3.119.2, main) and both platforms (macOS arm64, Linux x64). The single stream.Read() call in SKManagedStream.OnReadManagedStream violates the .NET Stream contract and causes truncated image decoding with any stream that returns partial reads. No fix exists on any version. Duplicate of #1962."
    },
    "workarounds": [
      "Copy the source stream to a MemoryStream before decoding: await stream.CopyToAsync(memoryStream); memoryStream.Seek(0, SeekOrigin.Begin); SKBitmap.Decode(memoryStream);",
      "Read all bytes first and use SKBitmap.Decode(byte[]): var bytes = await BinaryData.FromStreamAsync(stream); SKBitmap.Decode(bytes.ToArray());"
    ],
    "actions": [
      {
        "type": "update-labels",
        "description": "Apply area and platform labels",
        "risk": "low",
        "confidence": 0.95,
        "labels": [
          "type/bug",
          "area/SkiaSharp",
          "os/Linux",
          "os/Windows-Classic"
        ]
      },
      {
        "type": "link-duplicate",
        "description": "Mark as duplicate of #1962 (incomplete stream reading in SKManagedStream)",
        "risk": "medium",
        "confidence": 0.92,
        "linkedIssue": 1962
      }
    ]
  }
}