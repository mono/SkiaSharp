{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3472,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-13T16:40:00Z"
  },
  "conclusion": "reproduced",
  "notes": "Reproduced with 100% reliability. HarfBuzzSharp.Blob.FromStream() uses a fixed{} block to pin a managed byte[] temporarily, but the Blob outlives the fixed block. After FromStream returns, the byte[] from ms.ToArray() has no managed root (the release delegate captures ms, not data). GC collects/moves the array, leaving the native blob holding a dangling pointer. On macOS arm64, this manifests as silent data corruption (65,294/65,536 bytes corrupted). On Linux x64, it causes an AccessViolationException crash. Reproduced on HarfBuzzSharp 7.3.0.3 (reporter), 8.3.1.3 (latest), and main branch source. The reporter\u0027s suggested fix using Marshal.AllocCoTaskMem is the correct approach.",
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "description": "Create console project and add HarfBuzzSharp package",
      "layer": "setup",
      "command": "mkdir -p /tmp/repro-3472 \u0026\u0026 cd /tmp/repro-3472 \u0026\u0026 dotnet new console -n Repro --framework net10.0 \u0026\u0026 cd Repro \u0026\u0026 dotnet add package HarfBuzzSharp --version 7.3.0.3",
      "exitCode": 0,
      "output": "The template \u0022Console App\u0022 was created successfully.\nlog  : Restored /tmp/repro-3472/Repro/Repro.csproj (in 97 ms).",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Console project referencing HarfBuzzSharp 7.3.0.3",
          "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet10.0\u003C/TargetFramework\u003E\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022HarfBuzzSharp\u0022 Version=\u00227.3.0.3\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E"
        },
        {
          "filename": "Program.cs",
          "description": "GC stress test that creates a Blob from a stream with known data, forces aggressive GC to collect the unrooted byte array, then verifies data integrity via Blob.AsSpan().",
          "content": "using System;\nusing System.IO;\nusing System.Runtime;\nusing System.Runtime.InteropServices;\nusing HarfBuzzSharp;\n\nConsole.WriteLine($\u0022HarfBuzzSharp Blob.FromStream GC Safety Test\u0022);\nConsole.WriteLine($\u0022Runtime: {RuntimeInformation.FrameworkDescription}\u0022);\nConsole.WriteLine($\u0022OS: {RuntimeInformation.OSDescription}\u0022);\nConsole.WriteLine($\u0022Arch: {RuntimeInformation.ProcessArchitecture}\u0022);\nConsole.WriteLine();\n\nconst int dataSize = 64 * 1024;\nbyte[] originalData = new byte[dataSize];\nvar rng = new Random(42);\nrng.NextBytes(originalData);\nbyte[] expectedData = (byte[])originalData.Clone();\n\nConsole.WriteLine($\u0022Creating Blob from {dataSize} byte stream...\u0022);\nvar blob = Blob.FromStream(new MemoryStream(originalData));\nConsole.WriteLine($\u0022Blob created, Length={blob.Length}\u0022);\noriginalData = null!;\n\nConsole.WriteLine(\u0022Applying aggressive GC pressure...\u0022);\nint corruptions = 0;\nint checks = 0;\n\nfor (int round = 0; round \u003C 20; round\u002B\u002B)\n{\n    var pressure = new byte[100][];\n    for (int i = 0; i \u003C pressure.Length; i\u002B\u002B)\n        pressure[i] = new byte[dataSize \u002B round * 1024];\n    \n    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;\n    GC.Collect(GC.MaxGeneration, GCCollectionMode.Aggressive, blocking: true, compacting: true);\n    GC.WaitForPendingFinalizers();\n    GC.Collect(GC.MaxGeneration, GCCollectionMode.Aggressive, blocking: true, compacting: true);\n    \n    for (int i = 0; i \u003C pressure.Length; i\u002B\u002B)\n        Array.Fill(pressure[i], (byte)(0xAA \u002B round));\n    \n    var span = blob.AsSpan();\n    checks\u002B\u002B;\n    int roundCorruptions = 0;\n    for (int i = 0; i \u003C span.Length \u0026\u0026 i \u003C expectedData.Length; i\u002B\u002B)\n    {\n        if (span[i] != expectedData[i])\n        {\n            roundCorruptions\u002B\u002B;\n            if (corruptions \u002B roundCorruptions \u003C= 10)\n                Console.WriteLine($\u0022  CORRUPTION at offset {i}: expected 0x{expectedData[i]:X2}, got 0x{span[i]:X2} (round {round})\u0022);\n        }\n    }\n    if (roundCorruptions \u003E 0)\n    {\n        corruptions \u002B= roundCorruptions;\n        Console.WriteLine($\u0022  Round {round}: {roundCorruptions} corrupted bytes\u0022);\n    }\n    pressure = null;\n}\n\nConsole.WriteLine();\nif (corruptions \u003E 0)\n{\n    Console.WriteLine($\u0022FAILURE: {corruptions} byte corruptions detected across {checks} checks\u0022);\n    Console.WriteLine(\u0022The internal byte array created by Blob.FromStream was moved/collected by GC.\u0022);\n    blob.Dispose();\n    return 1;\n}\nelse\n{\n    Console.WriteLine($\u0022No corruption detected in {checks} checks.\u0022);\n    blob.Dispose();\n    return 0;\n}"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 2,
      "description": "Build the reproduction project",
      "layer": "csharp",
      "command": "cd /tmp/repro-3472/Repro \u0026\u0026 dotnet build",
      "exitCode": 0,
      "output": "Build succeeded.\n    0 Warning(s)\n    0 Error(s)",
      "result": "success"
    },
    {
      "stepNumber": 3,
      "description": "Run the GC stress test on macOS arm64 with HarfBuzzSharp 7.3.0.3 (reporter version)",
      "layer": "csharp",
      "command": "cd /tmp/repro-3472/Repro \u0026\u0026 dotnet run",
      "exitCode": 1,
      "output": "HarfBuzzSharp Blob.FromStream GC Safety Test\nRuntime: .NET 10.0.2\nOS: macOS 26.2.0\nArch: Arm64\n\nCreating Blob from 65536 byte stream...\nBlob created, Length=65536\nApplying aggressive GC pressure...\n  CORRUPTION at offset 0: expected 0x3E, got 0xAA (round 0)\n  CORRUPTION at offset 1: expected 0x17, got 0xAA (round 0)\n  [...8 more corruption lines...]\n  Round 0: 65294 corrupted bytes\n  Round 1-19: 65294 corrupted bytes each\n\nFAILURE: 1305880 byte corruptions detected across 20 checks\nThe internal byte array created by Blob.FromStream was moved/collected by GC.",
      "result": "failure"
    },
    {
      "stepNumber": 4,
      "description": "Test with latest HarfBuzzSharp 8.3.1.3 on macOS arm64",
      "layer": "csharp",
      "command": "cd /tmp/repro-3472-latest/Repro \u0026\u0026 dotnet run",
      "exitCode": 1,
      "output": "HarfBuzzSharp Blob.FromStream GC Safety Test\nRuntime: .NET 10.0.2\nOS: macOS 26.2.0\nArch: Arm64\n\nCreating Blob from 65536 byte stream...\nBlob created, Length=65536\nApplying aggressive GC pressure...\nFAILURE: 1305879 byte corruptions detected across 20 checks",
      "result": "failure"
    },
    {
      "stepNumber": 5,
      "description": "Test against main branch source built from repository",
      "layer": "csharp",
      "command": "dotnet run --project samples/Basic/Console/SkiaSharpSample/SkiaSharpSample.csproj",
      "exitCode": 1,
      "output": "Runtime: .NET 8.0.23\nBlob created, Length=65536\n  CORRUPTION at offset 0: expected 0x3E, got 0xAA (round 0)\nFAILURE: 1305880 byte corruptions detected across 20 checks",
      "result": "failure"
    },
    {
      "stepNumber": 6,
      "description": "Cross-platform test on Docker Linux x64 with HarfBuzzSharp 7.3.0.3",
      "layer": "csharp",
      "command": "docker run --rm --platform linux/amd64 mcr.microsoft.com/dotnet/sdk:10.0 bash -c \u0027...\u0027",
      "exitCode": 1,
      "output": "Runtime: .NET 10.0.3\nOS: Ubuntu 24.04.4 LTS\nArch: X64\nBlob created, Length=65536\nFatal error.\nSystem.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\n   at Program.\u003CMain\u003E$(System.String[])",
      "result": "failure"
    }
  ],
  "environment": {
    "os": "macOS 26.2",
    "arch": "arm64",
    "dotnetVersion": "10.0.2",
    "skiaSharpVersion": "N/A (HarfBuzzSharp 7.3.0.3)",
    "dockerUsed": true,
    "dotnetSdkVersion": "10.0.102"
  },
  "assessment": "likely-bug",
  "scope": "universal",
  "reproductionTime": "~15 minutes",
  "versionResults": [
    {
      "version": "7.3.0.3",
      "source": "nuget",
      "result": "reproduced",
      "notes": "65,294/65,536 bytes corrupted after aggressive GC. Data overwritten by subsequent allocations.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "8.3.1.3",
      "source": "nuget",
      "result": "reproduced",
      "notes": "65,294/65,536 bytes corrupted. Same behavior as 7.3.0.3.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "main (source)",
      "source": "source",
      "result": "reproduced",
      "notes": "Same corruption pattern. Bug exists in current main branch source.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "7.3.0.3",
      "source": "nuget",
      "result": "reproduced",
      "notes": "AccessViolationException crash on Linux. More severe than macOS silent corruption.",
      "platform": "docker-linux-x64"
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net10.0",
    "packages": [
      {
        "name": "HarfBuzzSharp",
        "version": "7.3.0.3"
      }
    ]
  },
  "errorMessages": {
    "primaryError": "Data corruption: 65,294/65,536 bytes overwritten after GC collects unrooted byte array in Blob.FromStream. On Linux: AccessViolationException crash.",
    "stackTrace": "System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\n   at Program.\u003CMain\u003E$(System.String[])",
    "additionalErrors": [
      "macOS: Silent data corruption (99.6% of bytes corrupted with 0xAA from subsequent allocations)",
      "Linux: Hard crash with AccessViolationException on Blob.AsSpan() after GC"
    ]
  },
  "output": {
    "proposedResponse": {
      "status": "ready",
      "body": "Thanks for reporting this! We\u0027ve confirmed the issue.\n\n\u0060Blob.FromStream()\u0060 uses a \u0060fixed\u0060 block to temporarily pin a managed \u0060byte[]\u0060, but the \u0060Blob\u0060 outlives the \u0060fixed\u0060 scope. After the method returns, the internal \u0060byte[]\u0060 (from \u0060ms.ToArray()\u0060) has no managed root \u2014 the release delegate captures \u0060ms\u0060 but not \u0060data\u0060. The GC can collect or relocate the array at any time, leaving the native blob with a dangling pointer.\n\n**Tested versions:**\n\n| Version | Platform | Result |\n|---------|----------|--------|\n| HarfBuzzSharp 7.3.0.3 | macOS arm64 | \u274C Data corruption (99.6% bytes) |\n| HarfBuzzSharp 8.3.1.3 | macOS arm64 | \u274C Data corruption |\n| main (source) | macOS arm64 | \u274C Data corruption |\n| HarfBuzzSharp 7.3.0.3 | Linux x64 (Docker) | \u274C AccessViolationException crash |\n\nThe corruption is deterministic under GC pressure \u2014 the managed array gets collected and its memory reused by other allocations.\n\n**Workarounds:**\n- Use \u0060Blob.FromFile()\u0060 when font data is available as a file\n- Construct \u0060Blob\u0060 directly with \u0060Marshal.AllocCoTaskMem\u0060 for unmanaged memory\n\nYour suggested fix using \u0060Marshal.AllocCoTaskMem\u0060 \u002B \u0060UnmanagedMemoryStream\u0060 is the right approach.",
      "summary": "Confirmed GC safety bug in Blob.FromStream \u2014 data corruption and crashes reproduced on all versions."
    },
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.95,
      "reason": "Bug reproduced on all tested versions including latest release (8.3.1.3) and main branch source. The fix is straightforward (use unmanaged memory allocation instead of fixed block) as the reporter suggests, but requires code review and testing."
    },
    "workarounds": [
      "Use Blob.FromFile() instead of Blob.FromStream() when the font data is available as a file",
      "Use the Blob constructor directly with unmanaged memory: allocate via Marshal.AllocCoTaskMem, copy data, and pass a release delegate that calls Marshal.FreeCoTaskMem"
    ],
    "actions": [
      {
        "type": "update-labels",
        "description": "Add area/HarfBuzzSharp label since the bug is in HarfBuzzSharp.Blob, not SkiaSharp",
        "risk": "low",
        "confidence": 0.95,
        "labels": [
          "area/HarfBuzzSharp"
        ]
      }
    ]
  }
}