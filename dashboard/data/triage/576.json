{
  "meta": {
    "schemaVersion": "2.1",
    "number": 576,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2025-07-24T12:00:00Z",
    "currentLabels": [
      "type/bug",
      "area/SkiaSharp",
      "backend/OpenGL"
    ],
    "state": "open"
  },
  "summary": "User reports GPU memory leaks with SKSurface.Snapshot() on Intel HD Graphics \u2014 resolved as user error (not disposing SKImage before overwriting reference)",
  "classification": {
    "type": {
      "value": "type/question",
      "confidence": 0.85
    },
    "area": {
      "value": "area/SkiaSharp",
      "confidence": 0.95
    },
    "backends": [
      {
        "value": "backend/OpenGL",
        "confidence": 0.85
      }
    ]
  },
  "evidence": {
    "reproEvidence": {
      "screenshots": [
        {
          "url": "https://user-images.githubusercontent.com/41022806/42469527-fdefdc92-8385-11e8-96d5-cfa8b693ae34.png",
          "context": "Visual Studio memory usage showing 30-40MB step-ups",
          "source": "description"
        }
      ],
      "stepsToReproduce": [
        "Create a GPU-backed SKSurface using GRContext with OpenGL (Intel HD Graphics 520)",
        "Call surface.Snapshot() in a loop and store result in an array/dictionary",
        "Overwrite previous SKImage reference without calling Dispose() first",
        "Observe 30-40MB memory step-ups per iteration until crash"
      ],
      "codeSnippets": [
        {
          "code": "var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\nsurface.Dispose();\n_skiaMain.DisplayPlaneRecompose[plane] = false;",
          "language": "csharp",
          "context": "Code that leaks GPU memory \u2014 Snapshot() creates new SKImage each iteration without disposing the previous DisplayImages[plane] reference"
        }
      ],
      "environmentDetails": "Intel HD Graphics 520, Visual Studio, Windows (implied from VS usage)"
    },
    "versionAnalysis": {
      "reason": "No specific SkiaSharp version mentioned. Issue is from 2018 and relates to fundamental GPU resource management patterns that are unchanged.",
      "currentRelevance": "likely"
    }
  },
  "analysis": {
    "summary": "Reporter observed GPU memory leaks when repeatedly calling SKSurface.Snapshot() in a render loop. The root cause, confirmed by the reporter in comment 2, was overwriting the stored SKImage reference without disposing the previous one. Since SKImage is ISKReferenceCounted and GPU-backed, the finalizer alone cannot reliably reclaim GPU memory in a timely manner. This is expected behavior requiring explicit disposal, not a SkiaSharp bug.",
    "keySignals": [
      {
        "text": "Every time I run through this section of code visual studios shows 30-40MB step ups in memory usage until eventually it crashes",
        "source": "body",
        "interpretation": "Each Snapshot() creates a new GPU-backed SKImage (~30MB). Without disposing the old one, GPU memory grows unbounded."
      },
      {
        "text": "_skiaMain.DisplayImages[plane] = surface.Snapshot();",
        "source": "body",
        "interpretation": "Overwrites the previous SKImage reference without Dispose() \u2014 the GPU texture backing the old SKImage is leaked."
      },
      {
        "text": "The issue actually was appearing based on the snapshot() because when I would overwrite the SkImage without disposing first then the ref was getting lost",
        "source": "comment 2",
        "interpretation": "Reporter confirmed root cause is user error \u2014 not disposing SKImage before overwriting the reference."
      },
      {
        "text": "when it was getting lost in the GPU memory GC.Collect was not cleaning up the lost reference",
        "source": "comment 2",
        "interpretation": "GC finalizer cannot reliably release GPU resources on Intel integrated graphics. Explicit Dispose() is required."
      }
    ],
    "fieldRationales": [
      {
        "field": "type",
        "chosen": "type/question",
        "expandedReason": "Reporter initially believed this was a SkiaSharp bug, but comment 2 confirms the root cause is user error \u2014 not disposing SKImage before overwriting the reference. The maintainer\u0027s guidance resolved the issue. This is a usage/understanding question about GPU resource management, not broken behavior in SkiaSharp.",
        "alternatives": [
          {
            "value": "type/bug",
            "whyRejected": "Reporter confirmed in comment 2 that the leak was caused by their own code not disposing SKImage. SkiaSharp\u0027s Snapshot() API works as designed \u2014 it returns a new reference-counted image that the caller must dispose."
          }
        ]
      },
      {
        "field": "area",
        "chosen": "area/SkiaSharp",
        "expandedReason": "The issue involves core SkiaSharp types SKSurface and SKImage, not view-layer components."
      },
      {
        "field": "backends",
        "chosen": "backend/OpenGL",
        "expandedReason": "The issue is specific to GPU-backed surfaces created with a GRContext (OpenGL). The commented-out line in the code shows the user tried CPU surfaces without the leak, confirming the GPU-specific nature."
      },
      {
        "field": "versionAnalysis.currentRelevance",
        "chosen": "likely",
        "expandedReason": "The underlying pattern \u2014 needing to explicitly dispose GPU-backed SKImage objects \u2014 remains true in current SkiaSharp. This is fundamental to how reference-counted GPU resources work."
      },
      {
        "field": "actionability.suggestedAction",
        "chosen": "close-with-docs",
        "expandedReason": "The reporter confirmed the solution in comment 2. The maintainer provided correct diagnosis. The issue is resolved \u2014 the user needed to dispose SKImage before overwriting references. Can be closed as answered."
      }
    ],
    "uncertainties": [
      "Whether the issue was specific to Intel HD Graphics 520 or affects all GPU backends equally (likely all, since the root cause is missing Dispose())"
    ],
    "assumptions": [
      "Assumed Windows platform based on Visual Studio usage and Intel HD Graphics reference"
    ],
    "resolution": {
      "hypothesis": "The user was creating GPU-backed SKImage objects via Snapshot() in a loop and overwriting the stored reference without disposing the previous SKImage. GPU texture memory is not reclaimed by the GC finalizer in a timely manner, requiring explicit Dispose() calls.",
      "proposals": [
        {
          "title": "Dispose previous SKImage before overwriting",
          "description": "Dispose the existing SKImage in DisplayImages[plane] before assigning the new Snapshot() result. This is the correct pattern for managing GPU-backed resources.",
          "confidence": 0.95,
          "effort": "low",
          "category": "workaround",
          "codeSnippet": "var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n\n// Dispose old image before overwriting\n_skiaMain.DisplayImages[plane]?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\n\nsurface.Dispose();",
          "validated": "untested"
        },
        {
          "title": "Use using statement with temporary variable",
          "description": "Swap with a temporary variable and dispose old reference using a using pattern for safety.",
          "confidence": 0.9,
          "effort": "low",
          "category": "alternative",
          "codeSnippet": "using var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n\nvar newImage = surface.Snapshot();\nvar oldImage = _skiaMain.DisplayImages[plane];\n_skiaMain.DisplayImages[plane] = newImage;\noldImage?.Dispose();",
          "validated": "untested"
        }
      ],
      "recommendedProposal": "Dispose previous SKImage before overwriting",
      "recommendedReason": "Simplest fix \u2014 one line addition. Directly addresses the confirmed root cause."
    },
    "codeInvestigation": [
      {
        "file": "binding/SkiaSharp/SKSurface.cs",
        "lines": "274-275",
        "relevance": "Snapshot() creates a new SKImage via sk_surface_new_image_snapshot. Each call returns a new reference-counted object \u2014 caller is responsible for disposal."
      },
      {
        "file": "binding/SkiaSharp/SKImage.cs",
        "lines": "16-24",
        "relevance": "SKImage implements ISKReferenceCounted and has a finalizer via SKNativeObject. However, GPU-backed images hold texture references that need timely release via explicit Dispose()."
      },
      {
        "file": "binding/SkiaSharp/SKObject.cs",
        "lines": "94-98",
        "relevance": "DisposeNative() calls SafeUnRef() for ISKReferenceCounted objects. The finalizer (~SKNativeObject) at line 229 eventually calls this, but GC scheduling is non-deterministic \u2014 GPU resources may not be freed promptly."
      }
    ]
  },
  "output": {
    "actionability": {
      "suggestedAction": "close-with-docs",
      "confidence": 0.88,
      "reason": "Reporter confirmed the root cause and solution in comment 2. Maintainer provided correct diagnosis. The issue is fully resolved as a usage question."
    },
    "actions": [
      {
        "id": "labels-1",
        "type": "update-labels",
        "risk": "low",
        "description": "Reclassify from type/bug to type/question \u2014 reporter confirmed user error",
        "reason": "Issue was filed as bug but reporter confirmed in comment 2 that the leak was caused by not disposing SKImage before overwriting reference. This is a usage question, not a SkiaSharp defect.",
        "confidence": 0.85,
        "payload": {
          "labelsToAdd": [
            "type/question"
          ],
          "labelsToRemove": [
            "type/bug"
          ]
        }
      },
      {
        "id": "comment-1",
        "type": "add-comment",
        "risk": "high",
        "description": "Post closing comment summarizing the resolution",
        "reason": "Issue has been idle since 2018 with the resolution confirmed. A closing comment documents the solution for future searchers.",
        "confidence": 0.85,
        "dependsOn": "labels-1",
        "payload": {
          "commentType": "close-message",
          "draftBody": "Thanks for following up with the root cause.\n\nFor anyone landing here: GPU-backed \u0060SKImage\u0060 objects returned by \u0060SKSurface.Snapshot()\u0060 hold texture references that must be explicitly disposed. If you overwrite a stored \u0060SKImage\u0060 reference without calling \u0060Dispose()\u0060 first, the GPU memory won\u0027t be reclaimed promptly (the GC finalizer is non-deterministic for GPU resources).\n\n\u0060\u0060\u0060csharp\n// Dispose the old image before overwriting\n_skiaMain.DisplayImages[plane]?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\n\u0060\u0060\u0060\n\nClosing as resolved \u2014 the reporter confirmed this was the fix.",
          "requiresHumanEdit": true,
          "finalBody": null,
          "dedupeToken": "triage-576-comment-1"
        }
      },
      {
        "id": "close-1",
        "type": "close-issue",
        "risk": "medium",
        "description": "Close as resolved \u2014 reporter confirmed the fix",
        "reason": "Reporter confirmed in comment 2 that disposing SKImage before overwriting resolved the memory leak. Issue has been idle since July 2018.",
        "confidence": 0.85,
        "dependsOn": "comment-1",
        "payload": {
          "reason": "completed",
          "comment": null
        }
      }
    ]
  },
  "url": "https://github.com/mono/SkiaSharp/issues/576"
}