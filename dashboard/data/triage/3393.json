{
  "meta": {
    "schemaVersion": "2.0",
    "number": 3393,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-08T15:00:00Z",
    "currentLabels": [
      "type/bug",
      "os/Android",
      "area/SkiaSharp",
      "tenet/reliability"
    ],
    "state": "open"
  },
  "summary": "All P/Invoke wrapper methods lack GC.KeepAlive calls, allowing premature collection of managed objects while native code is using their handles",
  "classification": {
    "type": {
      "value": "type/bug",
      "confidence": 0.95
    },
    "area": {
      "value": "area/SkiaSharp",
      "confidence": 0.95
    },
    "tenets": [
      {
        "value": "tenet/reliability",
        "confidence": 0.95
      }
    ],
    "partner": {
      "value": "partner/unoplatform",
      "confidence": 0.75
    }
  },
  "evidence": {
    "bugSignals": {
      "hasCrash": true,
      "hasStackTrace": false,
      "reproQuality": "partial",
      "severity": "high",
      "severityReason": "Race condition between GC and native code can cause use-after-free crashes on any platform. Non-deterministic and hard to diagnose. Affects all P/Invoke wrappers across the entire binding surface.",
      "hasWorkaround": true,
      "workaroundSummary": "Callers can manually add GC.KeepAlive() after SkiaSharp API calls, but this is fragile and shifts the burden to every consumer.",
      "targetFrameworks": [
        "net8.0-android"
      ]
    },
    "reproEvidence": {
      "repoLinks": [
        {
          "url": "https://github.com/unoplatform/uno/pull/21660",
          "description": "Uno Platform PR demonstrating the GC race with SkiaSharp canvas.DrawPicture"
        },
        {
          "url": "https://github.com/dotnet/java-interop/issues/719",
          "description": "Related .NET java-interop issue showing same GC.KeepAlive problem"
        }
      ],
      "relatedIssues": [
        3393
      ],
      "codeSnippets": [
        {
          "code": "var canvas = \u2026\nvar picture = \u2026\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point.",
          "language": "csharp",
          "context": "Demonstration of the GC race: after extracting picture.Handle, nothing keeps picture alive during the native call"
        },
        {
          "code": "public void DrawPicture (SKPicture picture, SKPaint paint = null)\n{\n\tif (picture == null)\n\t\tthrow new ArgumentNullException (nameof (picture));\n\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n\tGC.KeepAlive (picture);\n\tGC.KeepAlive (paint);\n}",
          "language": "csharp",
          "context": "Proposed fix: add GC.KeepAlive for all reference type parameters after the P/Invoke call"
        }
      ],
      "environmentDetails": "SkiaSharp 3.116.0, VS Code macOS, Android and all platforms affected"
    },
    "versionAnalysis": {
      "reason": "This is a latent bug present since the inception of the P/Invoke wrappers. It has never been systematically addressed \u2014 only a handful of methods (SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) have GC.KeepAlive calls.",
      "mentionedVersions": [
        "3.116.0"
      ],
      "currentRelevance": "likely"
    },
    "regression": {
      "isRegression": false,
      "confidence": 0.95,
      "reason": "This has always been the case. The GC race exists in every version of SkiaSharp \u2014 it was never systematically protected."
    }
  },
  "analysis": {
    "summary": "Well-documented GC race condition bug. When a managed SkiaSharp object\u0027s Handle is passed to a P/Invoke method, the .NET GC can collect the managed object (and run its finalizer, freeing native memory) before the native call completes. The reporter provides authoritative Microsoft documentation, a concrete Uno Platform reproduction, and a clear fix pattern.",
    "keySignals": [
      {
        "text": "[BUG] P/Invokes should protect parameters across invocations",
        "source": "title",
        "interpretation": "Clearly identifies a systematic bug in P/Invoke parameter lifetime management"
      },
      {
        "text": "this can be collected even while you are executing an instance method on that object",
        "source": "body",
        "interpretation": "Quotes Microsoft documentation confirming the GC behavior that causes the race"
      },
      {
        "text": "once execution hits SkiaApi.sk_canvas_draw_picture(), nothing ensures that picture is kept alive",
        "source": "body",
        "interpretation": "Identifies the exact point where the race can occur in SkiaSharp"
      },
      {
        "text": "The fix: audit the code (is there a generator?) such that all reference type parameters are explicitly kept alive across P/Invoke boundaries",
        "source": "body",
        "interpretation": "Reporter proposes systematic fix via GC.KeepAlive and asks about generator support"
      },
      {
        "text": "unoplatform/uno#21660 is a Skia-related example of this",
        "source": "body",
        "interpretation": "Real-world evidence from Uno Platform where this race was observed"
      },
      {
        "text": "Platform: Android, All",
        "source": "body",
        "interpretation": "Affects all platforms, not just Android \u2014 the GC race is a .NET runtime behavior"
      }
    ],
    "fieldRationales": [
      {
        "field": "type",
        "chosen": "type/bug",
        "expandedReason": "This is a real bug \u2014 a GC race condition that can cause use-after-free crashes. The reporter provides Microsoft documentation, a concrete reproduction scenario via Uno Platform, and a clear fix. This is not a feature request or question.",
        "alternatives": [
          {
            "value": "type/enhancement",
            "whyRejected": "While the fix involves adding code, the underlying behavior (potential crash due to premature GC) is broken, not just suboptimal."
          }
        ]
      },
      {
        "field": "area",
        "chosen": "area/SkiaSharp",
        "expandedReason": "The bug is in the core SkiaSharp binding layer where P/Invoke wrapper methods extract Handle properties without protecting the managed objects from GC. This spans all of binding/SkiaSharp/.",
        "alternatives": [
          {
            "value": "area/SkiaSharp.Views",
            "whyRejected": "The Views layer is not the source of the problem \u2014 it\u0027s the core P/Invoke wrappers in SKCanvas, etc."
          }
        ]
      },
      {
        "field": "classification.platforms",
        "chosen": "null",
        "expandedReason": "While Android is mentioned in the form, the reporter explicitly says \u0027All\u0027 platforms are affected. The GC race is a .NET runtime behavior, not platform-specific. Removing os/Android is appropriate since this is cross-platform."
      },
      {
        "field": "tenets",
        "chosen": "tenet/reliability",
        "expandedReason": "Use-after-free due to GC racing with native code causes crashes, data corruption, or undefined behavior. This is a reliability concern."
      },
      {
        "field": "partner",
        "chosen": "partner/unoplatform",
        "expandedReason": "The Uno Platform team discovered this in practice (uno#21660) and the reporter (jonpryor) references their PR as evidence. Flagging for partner visibility."
      },
      {
        "field": "bugSignals.severity",
        "chosen": "high",
        "expandedReason": "Non-deterministic use-after-free crash affecting the entire public API surface. The race is hard to reproduce but real, as demonstrated by the Uno Platform team. No easy workaround for consumers."
      },
      {
        "field": "actionability.suggestedAction",
        "chosen": "needs-investigation",
        "expandedReason": "Valid bug with a clear fix pattern (GC.KeepAlive), but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant.",
        "alternatives": [
          {
            "value": "ready-to-fix",
            "whyRejected": "While the fix pattern is known, a full audit of hundreds of P/Invoke wrappers is needed before implementation can begin."
          }
        ]
      },
      {
        "field": "regression.isRegression",
        "chosen": "false",
        "expandedReason": "This has always been the case \u2014 the GC race exists in every version of SkiaSharp. The P/Invoke wrappers were never systematically protected with GC.KeepAlive calls."
      },
      {
        "field": "versionAnalysis.currentRelevance",
        "chosen": "likely",
        "expandedReason": "This is a latent bug present since the inception of the P/Invoke wrappers and has never been systematically addressed. Only a handful of methods currently have GC.KeepAlive calls."
      }
    ],
    "uncertainties": [
      "How many of the ~hundreds of P/Invoke wrapper methods need GC.KeepAlive added \u2014 a full audit is needed",
      "Whether the code generator (utils/generate.ps1) can be extended to automatically emit GC.KeepAlive calls, or if hand-written wrappers must be individually patched",
      "Whether GC.KeepAlive(this) should also be added to instance methods, or if callers are expected to keep \u0060this\u0060 alive"
    ],
    "assumptions": [
      "Assumed the handful of existing GC.KeepAlive calls (in SKData, SKImage, SKSurface, etc.) were added ad-hoc, not as part of a systematic effort",
      "Assumed the bug affects all .NET runtimes (CoreCLR, Mono, NativeAOT) since the GC behavior is specified by the ECMA CLI standard"
    ],
    "resolution": {
      "hypothesis": "The .NET GC can collect managed SkiaSharp objects after their Handle property is read but before the P/Invoke call completes, because the runtime cannot see into native code. If the finalizer runs during this window, it frees the native handle, causing use-after-free in Skia.",
      "proposals": [
        {
          "title": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
          "description": "Audit all public methods in binding/SkiaSharp/ that call SkiaApi.* and add GC.KeepAlive() for every reference-type parameter (including \u0060this\u0060 for instance methods) after the P/Invoke call. This is the approach the reporter suggests and is the most thorough fix.",
          "confidence": 0.9,
          "effort": "high"
        },
        {
          "title": "Extend code generator to emit GC.KeepAlive",
          "description": "Modify the binding generator (utils/generate.ps1 or the underlying tool) to automatically emit GC.KeepAlive calls in generated P/Invoke wrappers. This prevents future regressions and reduces manual effort, but requires understanding the generator\u0027s architecture.",
          "confidence": 0.8,
          "effort": "high"
        },
        {
          "title": "Targeted fix for highest-risk methods first",
          "description": "Add GC.KeepAlive to the most commonly used methods (SKCanvas.Draw*, SKPaint, SKPath operations) as an incremental first step, with a follow-up for the full audit. Lower effort but leaves long-tail risk.",
          "confidence": 0.85,
          "effort": "medium"
        }
      ],
      "recommendedProposal": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
      "recommendedReason": "The reporter is an experienced .NET runtime engineer (jonpryor) who clearly understands the problem. A systematic fix is the only way to fully address this \u2014 partial fixes leave the same class of bug in less-used code paths."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.9,
      "reason": "Valid bug with clear fix pattern, but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant."
    },
    "actions": [
      {
        "id": "labels-1",
        "type": "update-labels",
        "risk": "low",
        "description": "Add partner/unoplatform label and remove os/Android since issue affects all platforms",
        "reason": "Issue is cross-platform (reporter selected \u0027All\u0027), and Uno Platform is directly involved via their PR #21660",
        "confidence": 0.85,
        "payload": {
          "labelsToAdd": [
            "partner/unoplatform"
          ],
          "labelsToRemove": [
            "os/Android"
          ]
        }
      },
      {
        "id": "comment-1",
        "type": "add-comment",
        "risk": "high",
        "description": "Acknowledge the bug report and outline investigation plan",
        "reason": "High-quality report from a knowledgeable contributor deserves a substantive response confirming the issue is understood",
        "confidence": 0.85,
        "dependsOn": "labels-1",
        "payload": {
          "commentType": "request-info",
          "draftBody": "Thanks for the thorough write-up and the Microsoft documentation references \u2014 this is a well-documented GC race that we need to address systematically.\n\nA quick audit shows that only a handful of methods (in SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) currently have \u0060GC.KeepAlive\u0060 calls, so the vast majority of P/Invoke wrappers are unprotected.\n\nThe main question is whether to extend the code generator to emit these automatically, or do a manual audit. Do you have a sense of whether the Uno Platform team has hit this in practice beyond the \u0060DrawPicture\u0060 case, or if that\u0027s been the primary trigger?",
          "requiresHumanEdit": true,
          "finalBody": null,
          "dedupeToken": "triage-3393-comment-1"
        }
      }
    ]
  },
  "url": "https://github.com/mono/SkiaSharp/issues/3393"
}