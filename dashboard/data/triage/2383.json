{
  "meta": {
    "schemaVersion": "1.0",
    "number": 2383,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-12T15:53:16Z",
    "currentLabels": []
  },
  "summary": "Question: Does SkiaSharp support a 24-bit RGB color type (Format24bppRgb equivalent from System.Drawing)?",
  "classification": {
    "type": {
      "value": "type/question",
      "confidence": 0.95
    },
    "area": {
      "value": "area/SkiaSharp",
      "confidence": 0.95
    }
  },
  "evidence": {
    "reproEvidence": {
      "relatedIssues": [
        1176
      ]
    },
    "versionAnalysis": {
      "currentRelevance": "likely",
      "relevanceReason": "Skia\u0027s color type set has never included a 24-bit (3 bytes per pixel) type. Rgb888x is still 32-bit. This limitation is inherent to the Skia library and hasn\u0027t changed."
    }
  },
  "analysis": {
    "summary": "User asks whether SkiaSharp supports a 24-bit pixel format equivalent to System.Drawing.Imaging.PixelFormat.Format24bppRgb. Skia (and therefore SkiaSharp) does not support a true 24-bit (3 bytes per pixel) color type. The closest option is SKColorType.Rgb888x, which stores R, G, B in 8 bits each but uses a 32-bit word (4 bytes per pixel with the alpha byte ignored). The user can convert 24bpp data to 32bpp by expanding each pixel with a padding byte.",
    "codeInvestigation": [
      {
        "file": "binding/SkiaSharp/Definitions.cs",
        "finding": "SKColorType enum has no 24-bit (3 bytes per pixel) entry. Smallest RGB type with 8 bits per channel is Rgb888x at 4 bytes per pixel.",
        "relevance": "direct",
        "lines": "36-63"
      },
      {
        "file": "binding/SkiaSharp/Definitions.cs",
        "finding": "GetBytesPerPixel confirms Rgb888x returns 4 bytes, not 3. No color type returns 3 bytes per pixel.",
        "relevance": "direct",
        "lines": "79-115"
      },
      {
        "file": "externals/skia/include/core/SkColorType.h",
        "finding": "Upstream Skia defines kRGB_888x_SkColorType as \u0027pixel with 8 bits each for red, green, blue; in 32-bit word\u0027 \u2014 confirms the padding byte at C\u002B\u002B level.",
        "relevance": "context",
        "lines": "25"
      },
      {
        "file": "binding/SkiaSharp/SKBitmap.cs",
        "finding": "InstallPixels accepts SKImageInfo with custom colorType and rowBytes \u2014 user can use this with Rgb888x after converting pixel data from 24bpp to 32bpp.",
        "relevance": "direct",
        "lines": "591-615"
      }
    ],
    "rationale": "Classified as question because the user asks \u0027does skia support...\u0027 \u2014 there is no bug or feature request. Area is core SkiaSharp since SKColorType and SKImageInfo are in the binding/SkiaSharp layer. Issue #1176 asked the same question about BGR888 and was answered by the maintainer confirming no 24-bit type exists.",
    "keySignals": [
      {
        "text": "I want to convert an image which is in 24-bit color type to SKBitmap",
        "source": "issue body",
        "interpretation": "User has raw 24bpp pixel data and needs to load it into SkiaSharp. This is a usage question, not a bug."
      },
      {
        "text": "use 8 bits for each colors, no alpha, necessary to specify width, height and stride",
        "source": "issue body",
        "interpretation": "User understands the format requirements. They need to know the closest SKColorType and how to use InstallPixels."
      },
      {
        "text": "Does SKColorType support BGR888 type? \u2014 Unfortunately not at this point. There is a RGB 888x, but that is still 32-bit pixels.",
        "source": "issue #1176, mattleibow comment",
        "interpretation": "Identical question previously answered. Confirms Skia has no 24-bit color type."
      }
    ],
    "workarounds": [
      "Use SKColorType.Rgb888x with SKAlphaType.Opaque \u2014 this uses 4 bytes per pixel (R, G, B \u002B padding byte). Convert 24bpp source data to 32bpp by inserting a 0xFF padding byte after every 3 bytes.",
      "Use SKBitmap.Decode or SKImage.FromEncodedData to load encoded image files (PNG, JPEG, BMP) \u2014 Skia automatically converts from the file\u0027s pixel format to an appropriate internal format."
    ],
    "resolution": {
      "hypothesis": "User needs to load raw 24bpp pixel data into an SKBitmap. Since Skia has no 24-bit color type, the data must be expanded to 32bpp first.",
      "proposals": [
        {
          "description": "Convert the 24-bit pixel data to 32-bit by inserting a padding byte (0xFF) for each pixel, then use SKBitmap with SKColorType.Rgb888x and SKAlphaType.Opaque.",
          "title": "Expand 24bpp to Rgb888x",
          "codeSnippet": "// Convert 24bpp RGB data to 32bpp for SKBitmap\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex];     // R\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex \u002B 2]; // B\n            dest[3] = 0xFF;                   // padding\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();",
          "confidence": 0.9,
          "effort": "small"
        },
        {
          "description": "Alternatively, expand to BGRA format with alpha set to 0xFF. This is the platform-native format on most systems and may perform better for drawing.",
          "title": "Use Bgra8888 with Opaque alpha",
          "codeSnippet": "var info = new SKImageInfo(width, height, SKColorType.Bgra8888, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex \u002B 2]; // B\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex];     // R\n            dest[3] = 0xFF;                   // A\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();",
          "confidence": 0.85,
          "effort": "small"
        },
        {
          "description": "If the source is an image file (not raw pixels), use SKBitmap.Decode() which handles format conversion automatically.",
          "title": "Load from encoded file",
          "confidence": 0.7,
          "effort": "trivial"
        }
      ],
      "recommendedProposal": "Expand 24bpp to Rgb888x",
      "recommendedReason": "Most direct translation of the user\u0027s requirements. Preserves the RGB channel order and is the closest SkiaSharp type to Format24bppRgb."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "close-with-docs",
      "confidence": 0.9,
      "reason": "This is a usage question fully answerable from existing API knowledge. Same question was answered in #1176. No code change needed."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Apply question and core SkiaSharp labels",
        "risk": "low",
        "confidence": 0.95,
        "labels": [
          "type/question",
          "area/SkiaSharp"
        ]
      },
      {
        "type": "add-comment",
        "description": "Post answer explaining no 24-bit type exists and provide workaround code",
        "risk": "high",
        "confidence": 0.9,
        "comment": "SkiaSharp (and the underlying Skia library) does not have a true 24-bit (3 bytes per pixel) color type. All pixel formats use 1, 2, 4, 8, or 16 bytes per pixel.\n\nThe closest equivalent is \u0060SKColorType.Rgb888x\u0060, which stores 8 bits each for red, green, and blue in a **32-bit word** (the 4th byte is padding). To load 24bpp data, expand it to 32bpp by writing directly into the bitmap\u0027s pixel buffer:\n\n\u0060\u0060\u0060csharp\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex];     // R\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex \u002B 2]; // B\n            dest[3] = 0xFF;                   // padding\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();\n\u0060\u0060\u0060\n\nIf you\u0027re loading an encoded image file (PNG, JPEG, BMP), \u0060SKBitmap.Decode()\u0060 handles format conversion automatically \u2014 no manual pixel expansion needed.\n\nSee also #1176 which covers the same topic."
      },
      {
        "type": "link-related",
        "description": "Cross-reference #1176 (same question about 24-bit color type)",
        "risk": "low",
        "confidence": 0.9,
        "linkedIssue": 1176
      },
      {
        "type": "close-issue",
        "description": "Close as answered",
        "risk": "medium",
        "confidence": 0.85
      }
    ]
  }
}