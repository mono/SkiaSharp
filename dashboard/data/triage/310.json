{
  "meta": {
    "schemaVersion": "1.0",
    "number": 310,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-12T15:00:19Z",
    "currentLabels": [
      "type/enhancement",
      "status/low-priority",
      "os/Windows-Classic",
      "area/SkiaSharp.Views"
    ]
  },
  "summary": "Re-entrant OnPaint in WinForms SKControl causes ExternalException in Bitmap.UnlockBits. When the user resizes the SKControl from within the PaintSurface event handler, a parent container (DevExpress XtraScrollableControl) can trigger a nested OnPaint call. The re-entrant call disposes and recreates the GDI\u002B bitmap via CreateBitmap(), so when the outer OnPaint tries to call UnlockBits on the now-disposed bitmap, GDI\u002B throws. The code still has no re-entrancy guard.",
  "classification": {
    "type": {
      "value": "type/bug",
      "confidence": 0.88
    },
    "area": {
      "value": "area/SkiaSharp.Views",
      "confidence": 0.98
    },
    "platforms": [
      "os/Windows-Classic"
    ],
    "tenets": [
      "tenet/reliability"
    ]
  },
  "evidence": {
    "reproEvidence": {
      "stepsToReproduce": [
        "Place an SKControl inside a scrollable container (e.g., DevExpress XtraScrollableControl)",
        "Resize the SKControl.Height from within the PaintSurface event handler",
        "Scroll the container so the SKControl is partially or fully offscreen",
        "Trigger a content change that causes the height resize during paint"
      ],
      "environmentDetails": "Windows, WinForms, .NET Framework (2017-era report)"
    },
    "bugSignals": {
      "severity": "medium",
      "errorType": "ExternalException",
      "errorMessage": "A generic error occurred in GDI\u002B.",
      "stackTrace": "System.Runtime.InteropServices.ExternalException (0x80004005): A generic error occurred in GDI\u002B.\n   at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata)\n   at SkiaSharp.Views.Desktop.SKControl.OnPaint(PaintEventArgs e)\n   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer)\n   at System.Windows.Forms.Control.WmPaint(Message\u0026 m)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)",
      "reproQuality": "partial"
    },
    "versionAnalysis": {
      "currentRelevance": "likely",
      "relevanceReason": "The SKControl.OnPaint code path has not changed since the issue was filed. No re-entrancy guard has been added. The bitmap LockBits/UnlockBits pattern is still identical."
    }
  },
  "analysis": {
    "summary": "The WinForms SKControl.OnPaint locks a GDI\u002B bitmap, fires the user\u0027s PaintSurface event, then unlocks the bitmap. If the user\u0027s PaintSurface handler triggers a re-entrant OnPaint (e.g. by resizing the control, causing a parent container to synchronously repaint), the re-entrant call disposes and recreates the bitmap, and the outer call crashes on UnlockBits. The reporter investigated this thoroughly and confirmed the re-entrancy as the root cause. A simple boolean re-entrancy guard would prevent the crash.",
    "codeInvestigation": [
      {
        "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
        "finding": "OnPaint calls LockBits (line 43), then OnPaintSurface (line 49), then UnlockBits (line 55). No re-entrancy guard exists. If OnPaintSurface triggers a nested OnPaint, CreateBitmap() (line 38) disposes the locked bitmap and creates a new one, causing UnlockBits to fail on the disposed bitmap.",
        "relevance": "direct",
        "lines": "30-57"
      },
      {
        "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
        "finding": "CreateBitmap() calls FreeBitmap() which disposes the existing bitmap when size changes. During re-entrant OnPaint after a resize, this disposes the bitmap that is still locked by the outer OnPaint call.",
        "relevance": "direct",
        "lines": "72-85"
      },
      {
        "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
        "finding": "WPF SKElement uses the same Lock/OnPaintSurface/Unlock pattern with WriteableBitmap. Could be similarly vulnerable to re-entrancy, though WPF\u0027s rendering pipeline makes synchronous re-entrant OnRender less likely.",
        "relevance": "related",
        "lines": "45-88"
      }
    ],
    "rationale": "Classified as type/bug (not enhancement) because the control crashes due to lack of defensive coding \u2014 re-entrant OnPaint should be handled gracefully, not crash. The current type/enhancement label is incorrect. The area is clearly SkiaSharp.Views (WinForms SKControl). Severity is medium: it\u0027s a crash, but only triggered by modifying the control during paint, which is an unusual (though not invalid) pattern. The WPF SKElement has the same Lock/Unlock pattern and could be similarly vulnerable.",
    "keySignals": [
      {
        "text": "OnPaint event is being called from within the OnPaint event (due to my height resize code)",
        "source": "comment #2",
        "interpretation": "Re-entrant OnPaint is the root cause. The bitmap is locked in the outer call and disposed/recreated in the inner call."
      },
      {
        "text": "I am changing the SKControl.Height value from within the PaintSurface event, which is inside the bitmap lock/unlock",
        "source": "comment #1",
        "interpretation": "The user is resizing during paint, which causes the parent container to trigger a synchronous repaint."
      },
      {
        "text": "It would be easy enough to handle this situation in the SKControl itself so it doesn\u0027t crash",
        "source": "comment #2",
        "interpretation": "Reporter suggests a defensive fix in SKControl. A re-entrancy guard is straightforward."
      },
      {
        "text": "This issue serves to act as a note for further investigation",
        "source": "comment #5 (mattleibow)",
        "interpretation": "Maintainer acknowledged the issue and kept it open for investigation. No fix has been applied since."
      }
    ],
    "errorFingerprint": "ExternalException-GDI-UnlockBits-SKControl-OnPaint-reentrant",
    "workarounds": [
      "Do not resize the SKControl from within the PaintSurface event handler. Calculate layout dimensions separately and apply the resize outside of the paint event.",
      "Reset the parent scrollable container\u0027s scroll position before resizing the SKControl to avoid the parent triggering a synchronous repaint."
    ],
    "nextQuestions": [
      "Should a re-entrancy guard be added to SKControl.OnPaint (e.g. a bool _painting field that causes early return on re-entry)?",
      "Is the WPF SKElement vulnerable to the same re-entrancy issue?",
      "Should the bitmap be captured in a local variable before LockBits so UnlockBits always uses the same reference?"
    ],
    "resolution": {
      "hypothesis": "Re-entrant OnPaint disposes the locked bitmap. The outer OnPaint then calls UnlockBits on a disposed bitmap, causing the GDI\u002B ExternalException.",
      "proposals": [
        {
          "description": "Add a boolean field (_painting) that is set to true at the start of OnPaint and cleared at the end. If OnPaint is called while _painting is true, return immediately. This prevents the nested call from disposing the bitmap.",
          "title": "Add re-entrancy guard",
          "codeSnippet": "private bool _painting;\n\nprotected override void OnPaint(PaintEventArgs e)\n{\n    if (designMode || _painting)\n        return;\n    _painting = true;\n    try\n    {\n        // existing OnPaint body\n    }\n    finally\n    {\n        _painting = false;\n    }\n}",
          "confidence": 0.9,
          "effort": "trivial"
        },
        {
          "description": "Store the bitmap reference in a local variable after LockBits. Use the local variable for UnlockBits and DrawImage so that even if CreateBitmap disposes the field, the locked reference remains valid for the outer call to unlock.",
          "title": "Capture bitmap reference locally",
          "confidence": 0.65,
          "effort": "small"
        }
      ],
      "recommendedProposal": "Add re-entrancy guard",
      "recommendedReason": "Simplest and most defensive fix. Prevents all re-entrancy issues, not just the bitmap disposal race. Trivial to implement and low risk."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.82,
      "reason": "The root cause is well-understood and the fix is straightforward, but the code hasn\u0027t changed since 2017. Needs a developer to add the re-entrancy guard and verify the WPF SKElement isn\u0027t similarly affected."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Correct type from enhancement to bug and add reliability tenet",
        "risk": "low",
        "confidence": 0.88,
        "labels": [
          "type/bug",
          "area/SkiaSharp.Views",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      {
        "type": "add-comment",
        "description": "Acknowledge the bug is still present and describe the proposed fix",
        "risk": "high",
        "confidence": 0.85,
        "comment": "Thanks for the thorough investigation back in 2017, @Craig-TSS \u2014 your diagnosis was spot-on.\n\nThe \u0060SKControl.OnPaint\u0060 code path still has no re-entrancy guard. The \u0060LockBits\u0060 \u2192 \u0060OnPaintSurface\u0060 \u2192 \u0060UnlockBits\u0060 sequence is vulnerable whenever a nested \u0060OnPaint\u0060 is triggered during the paint event (e.g., by resizing the control from within \u0060PaintSurface\u0060).\n\nHere\u0027s a workaround you can use: avoid resizing the control from within the \u0060PaintSurface\u0060 handler. Calculate layout dimensions separately and apply resizes outside the paint event.\n\nThe fix on the SkiaSharp side would be a simple re-entrancy guard \u2014 a \u0060bool _painting\u0060 field that causes \u0060OnPaint\u0060 to return immediately if it\u0027s already executing. We\u0027ll also check whether the WPF \u0060SKElement\u0060 has the same vulnerability."
      }
    ]
  }
}