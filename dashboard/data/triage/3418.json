{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3418,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-13T00:25:00Z",
    "currentLabels": []
  },
  "summary": "Draft PR investigating significant rendering performance gap between native C\u002B\u002B Skia (~120fps) and SkiaSharp C# (\u003C10fps) using MotionMark benchmark, with partial improvements to ~40fps via OpenGL configuration changes",
  "classification": {
    "type": {
      "value": "type/enhancement",
      "confidence": 0.9
    },
    "area": {
      "value": "area/SkiaSharp.Views",
      "confidence": 0.85
    },
    "platforms": [
      "os/macOS"
    ],
    "backends": [
      "backend/OpenGL"
    ],
    "tenets": [
      "tenet/performance"
    ]
  },
  "evidence": {
    "reproEvidence": {
      "stepsToReproduce": [
        "Run the MotionMark benchmark from https://github.com/wieslawsoltes/FastSkiaSharp (C\u002B\u002B native)",
        "Compare FPS with the equivalent SkiaSharp C# implementation in the macOS sample",
        "Observe ~120fps in C\u002B\u002B vs \u003C10fps in SkiaSharp"
      ],
      "screenshots": [
        {
          "url": "https://github.com/user-attachments/assets/b4a89a55-21b4-40e6-8222-b7731b43f3d0",
          "description": "Performance comparison showing C\u002B\u002B vs SkiaSharp FPS"
        }
      ],
      "environmentDetails": "macOS, OpenGL backend, SkiaSharp current version, net9.0-macos",
      "repoLinks": [
        {
          "url": "https://github.com/wieslawsoltes/FastSkiaSharp",
          "description": "Original C\u002B\u002B MotionMark benchmark showing 120fps"
        },
        {
          "url": "https://github.com/mattleibow/FastSkiaSharp",
          "description": "Maintainer fork with downgraded Skia (111-119fps)"
        }
      ]
    },
    "versionAnalysis": {
      "mentionedVersions": [
        "current (Skia m119 equivalent)"
      ],
      "currentRelevance": "likely",
      "relevanceReason": "The performance gap is structural \u2014 it exists across Skia versions (newer Skia only marginally faster: 120fps vs 111-119fps). The C\u002B\u002B to C# overhead is the core issue."
    }
  },
  "analysis": {
    "summary": "Maintainer-authored draft PR investigating a 10x\u002B rendering performance gap between native C\u002B\u002B Skia and SkiaSharp. The PR identifies multiple contributing factors: VSync locking, suboptimal OpenGL pixel format (multisample 4x), display queue overhead, and potentially P/Invoke marshaling cost. Partial fixes achieve ~40fps but a significant gap remains.",
    "codeInvestigation": [
      {
        "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKGLView.cs",
        "finding": "Current production code uses multisample 4x (SampleBuffers=1, Samples=4), 32-bit color, 24-bit depth, and no explicit OpenGL profile. The PR changes to: no multisample (SampleBuffers=0), OpenGL 3.2 Core profile, 24-bit color \u002B 8-bit alpha, 0-bit depth \u2014 matching C\u002B\u002B sk_app pixel format exactly.",
        "relevance": "direct",
        "lines": "62-81"
      },
      {
        "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKGLView.cs",
        "finding": "Current code does not set SwapInterval. The PR adds SwapInterval=0 (VSync disabled) in PrepareOpenGL, matching C\u002B\u002B behavior. VSync at 60Hz would cap fps to 60, but the sub-10fps baseline suggests VSync alone doesn\u0027t explain the gap.",
        "relevance": "direct",
        "lines": "88-95"
      },
      {
        "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKGLView.cs",
        "finding": "DrawRect creates surface only when null, but PR restructures to RenderDirect() bypassing the NSView display queue. The PR also changes flush pattern from canvas.Flush()\u002Bcontext.Flush() to the new gr_direct_context_flush_surface API.",
        "relevance": "direct",
        "lines": "108-176"
      },
      {
        "file": "binding/SkiaSharp/GRContext.cs",
        "finding": "PR adds new Flush(SKSurface) method wrapping gr_direct_context_flush_surface \u2014 a combined surface\u002Bcontext flush matching C\u002B\u002B pattern. This is a new API addition.",
        "relevance": "direct",
        "lines": "153-158"
      },
      {
        "file": "externals/skia/src/c/gr_context.cpp",
        "finding": "gr_direct_context_flush_surface implementation exists in the C API layer, calling through to Skia\u0027s surface flush \u002B context submit pattern.",
        "relevance": "direct",
        "lines": "146"
      },
      {
        "file": "samples/Basic/macOS/SkiaSharpSample/MotionMarkScene.cs",
        "finding": "New benchmark scene using paths (lines, quads, cubics) with configurable complexity (1K-120K elements). Uses CollectionsMarshal.AsSpan for zero-copy iteration \u2014 well-optimized C# code.",
        "relevance": "context"
      },
      {
        "file": "samples/Basic/macOS/SkiaSharpSample/Main.cs",
        "finding": "PR replaces NSApplication.Main(args) with a manual tight render loop: process pending events \u2192 RenderFrame \u2192 repeat. This matches the C\u002B\u002B sk_app pattern and bypasses macOS display queue latency.",
        "relevance": "direct"
      }
    ],
    "rationale": "This is an enhancement PR, not a bug \u2014 SkiaSharp renders correctly, just slowly. Classified as area/SkiaSharp.Views because the primary changes target SKGLView\u0027s OpenGL initialization and render loop on macOS. The performance tenet applies directly. The PR is a draft investigation by the maintainer (mattleibow), including a MotionMark benchmark scene, OpenGL configuration changes, a new GRContext.Flush(SKSurface) API, and a tight render loop bypassing NSRunLoop.",
    "keySignals": [
      {
        "text": "The native code is 120fps, but skiasharp is sub 10fps",
        "source": "PR description",
        "interpretation": "10x\u002B performance gap indicates structural overhead, not a simple configuration issue."
      },
      {
        "text": "I got to 40fps by using the new opengl flags in the SKGLView",
        "source": "PR description",
        "interpretation": "OpenGL pixel format changes (removing multisample, adding VSync disable) provide ~4x improvement, but 3x gap remains."
      },
      {
        "text": "My fork which downgrades skia to the same version in skiasharp is a tiny bit slower, 111-119 fps",
        "source": "PR description",
        "interpretation": "Newer Skia version is only marginally faster \u2014 the perf gap is NOT caused by Skia version differences."
      },
      {
        "text": "This all appears to be inside the skia code, which appears to be using similar compiler args",
        "source": "PR description",
        "interpretation": "Compiler optimizations are similar; the gap is likely in the C#\u2192C interop layer, render loop architecture, or GPU synchronization patterns."
      }
    ],
    "nextQuestions": [
      "What proportion of the remaining gap (40fps vs 120fps) is P/Invoke overhead vs GPU synchronization differences?",
      "Would the newer interop primitives from Epic #2615 (source generators, LibraryImport) reduce the P/Invoke overhead measurably?",
      "Is the gap similar on other platforms (Android, iOS) or specific to macOS OpenGL?",
      "Does the #3393 GC.KeepAlive issue contribute to performance (GC pressure from unprotected P/Invoke sites)?",
      "How does Metal backend compare \u2014 macOS OpenGL is deprecated and may have driver overhead"
    ],
    "resolution": {
      "hypothesis": "The performance gap has multiple contributing factors: (1) VSync and multisample overhead in OpenGL config (~4x improvement when fixed), (2) NSView display queue adds latency vs tight render loop, (3) remaining gap likely from P/Invoke marshaling overhead on hot render paths and GRContext flush pattern differences.",
      "proposals": [
        {
          "description": "Apply the pixel format changes from this PR: disable multisample, use OpenGL 3.2 Core, disable VSync, match C\u002B\u002B sk_app pixel format. This alone achieved ~4x improvement (sub-10fps \u2192 ~40fps).",
          "title": "OpenGL configuration optimization",
          "confidence": 0.85,
          "effort": "small"
        },
        {
          "description": "The new GRContext.Flush(SKSurface) API combines surface and context flush in a single P/Invoke call, reducing interop overhead on the hot path.",
          "title": "Surface flush API",
          "confidence": 0.7,
          "effort": "small"
        },
        {
          "description": "Related to Epic #2615 \u2014 use LibraryImport source generators and newer interop primitives to reduce marshaling overhead on hot rendering paths.",
          "title": "Modernize P/Invoke layer",
          "confidence": 0.5,
          "effort": "large"
        },
        {
          "description": "macOS OpenGL is deprecated since Mojave. Metal backend may have less driver overhead and better performance characteristics. Worth benchmarking.",
          "title": "Investigate Metal backend",
          "confidence": 0.4,
          "effort": "medium"
        }
      ],
      "recommendedProposal": "OpenGL configuration optimization",
      "recommendedReason": "Already proven to deliver ~4x improvement with minimal code changes. Should be merged independently of ongoing investigation."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.9,
      "reason": "This is an active investigation by the maintainer. The PR identifies partial fixes but the root cause of the remaining 3x gap (40fps vs 120fps) is still under investigation. The OpenGL config changes and new flush API could be extracted and merged independently."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Apply enhancement, views, macOS, OpenGL, and performance labels",
        "risk": "low",
        "confidence": 0.9,
        "labels": [
          "type/enhancement",
          "area/SkiaSharp.Views",
          "os/macOS",
          "backend/OpenGL",
          "tenet/performance"
        ]
      },
      {
        "type": "add-comment",
        "description": "Respond to community question about perf findings and status",
        "risk": "high",
        "confidence": 0.75,
        "comment": "Thanks for the interest. This is still an active investigation.\n\nSo far we\u0027ve identified several factors contributing to the performance gap:\n\n1. **OpenGL configuration** \u2014 The default SKGLView pixel format used 4x multisample and didn\u0027t disable VSync. Matching the C\u002B\u002B sk_app configuration (no multisample, VSync off, OpenGL 3.2 Core profile) improved from sub-10fps to ~40fps.\n\n2. **Render loop architecture** \u2014 The standard NSView display queue adds latency. A tight render loop matching the C\u002B\u002B pattern helps.\n\n3. **Remaining gap** \u2014 Even with these optimizations, there\u0027s still a ~3x gap (40fps vs 120fps) that needs further investigation. Potential factors include P/Invoke marshaling overhead on hot paths and GPU flush pattern differences.\n\nThe investigation is ongoing. Some of the configuration improvements (pixel format, VSync) could be shipped independently."
      },
      {
        "type": "link-related",
        "description": "Cross-reference P/Invoke modernization epic",
        "risk": "low",
        "confidence": 0.7,
        "linkedIssue": 2615
      }
    ]
  }
}