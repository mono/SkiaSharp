{
  "generatedAt": "2026-02-12T16:27:03.8844237Z",
  "totalCount": 27,
  "summary": {
    "needsInvestigation": 7,
    "closeable": 7,
    "quickWins": 7,
    "regressions": 7
  },
  "byType": [
    {
      "label": "type/bug",
      "count": 17
    },
    {
      "label": "type/question",
      "count": 3
    },
    {
      "label": "type/feature-request",
      "count": 3
    },
    {
      "label": "type/documentation",
      "count": 2
    },
    {
      "label": "type/enhancement",
      "count": 2
    }
  ],
  "byArea": [
    {
      "label": "area/SkiaSharp",
      "count": 10
    },
    {
      "label": "area/SkiaSharp.Views",
      "count": 6
    },
    {
      "label": "area/libSkiaSharp.native",
      "count": 4
    },
    {
      "label": "area/SkiaSharp.Views.Forms",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.HarfBuzz",
      "count": 2
    },
    {
      "label": "area/Docs",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.Views.Maui",
      "count": 1
    }
  ],
  "byAction": [
    {
      "label": "needs-investigation",
      "count": 7
    },
    {
      "label": "close-with-docs",
      "count": 6
    },
    {
      "label": "keep-open",
      "count": 6
    },
    {
      "label": "close-as-fixed",
      "count": 4
    },
    {
      "label": "close-as-duplicate",
      "count": 3
    },
    {
      "label": "request-info",
      "count": 1
    }
  ],
  "bySeverity": [
    {
      "label": "medium",
      "count": 9
    },
    {
      "label": "high",
      "count": 4
    },
    {
      "label": "low",
      "count": 3
    },
    {
      "label": "critical",
      "count": 2
    }
  ],
  "issues": [
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3379,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:18:05Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp.Views",
          "tenet/compatibility"
        ]
      },
      "summary": "SkiaSharp.Views.WPF references OpenTK.GLWpfControl 3.3.0 for .NET Framework targets, which is not strong-named. This causes FileLoadException in applications that enable strong-name signing (SignAssembly), since all dependencies must also be strong-named. OpenTK.GLWpfControl 3.3.1 added strong-name signing, so bumping the version from 3.3.0 to 3.3.1 resolves the issue. A community PR #3380 already proposes this fix.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET Framework 4.8 WPF project with strong-name signing enabled (SignAssembly=true)",
            "Add a PackageReference to SkiaSharp.Views.WPF 3.119.1",
            "Build and run the application",
            "Observe FileLoadException for GLWpfControl assembly"
          ],
          "codeSnippets": [
            "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EWinExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet48\u003C/TargetFramework\u003E\n    \u003CSignAssembly\u003Etrue\u003C/SignAssembly\u003E\n    \u003CAssemblyOriginatorKeyFile\u003EMyStrongNameKey.snk\u003C/AssemblyOriginatorKeyFile\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp.Views.WPF\u0022 Version=\u00223.119.1\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E"
          ],
          "environmentDetails": "Windows, .NET Framework 4.8, Visual Studio (Windows), strong-name signing enabled",
          "relatedIssues": [
            1767
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "FileLoadException",
          "errorMessage": "Could not load file or assembly \u0027GLWpfControl, Version=3.3.0.0, Culture=neutral, PublicKeyToken=null\u0027 or one of its dependencies. A strongly-named assembly is required. (Exception from HRESULT: 0x80131044)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net48"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The csproj on main still references OpenTK.GLWpfControl 3.3.0 for .NET Framework targets. The issue persists in all 3.x releases."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.75,
          "reason": "Reporter says 2.88.9 worked. The SKGLElement class (and its dependency on OpenTK.GLWpfControl) was introduced in SkiaSharp 3.0 via PR #2317, so the strong-naming incompatibility started with the 3.x line. In 2.88.x, the WPF view didn\u0027t depend on GLWpfControl.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "The csproj on main still shows OpenTK.GLWpfControl 3.3.0. PR #3380 proposes the fix but has not been merged.",
          "relatedPRs": [
            3380
          ]
        }
      },
      "analysis": {
        "summary": "SkiaSharp.Views.WPF depends on OpenTK.GLWpfControl 3.3.0 for .NET Framework targets (net4*). That version lacks strong-name signing. When the consuming application enables SignAssembly, the CLR refuses to load the unsigned GLWpfControl assembly, throwing FileLoadException. The upstream OpenTK project added strong-naming in GLWpfControl 3.3.1. The fix is a one-line version bump in the csproj.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "For net4* targets, references OpenTK 3.3.1 (strong-named) and OpenTK.GLWpfControl 3.3.0 (NOT strong-named). The GLWpfControl version is the problem.",
            "relevance": "direct",
            "lines": "13-16"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "SignAssembly is explicitly disabled for non-net4 targets but remains enabled for net4*. This means the WPF assembly itself is strong-named for .NET Framework, requiring all dependencies to also be strong-named.",
            "relevance": "direct",
            "lines": "10"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "For modern .NET targets, OpenTK.GLWpfControl is at 4.2.3 \u2014 a different major version line not affected by this issue.",
            "relevance": "context",
            "lines": "17-20"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKGLElement.cs",
            "finding": "SKGLElement inherits from GLWpfControl, making it a direct dependency that cannot be avoided.",
            "relevance": "related",
            "lines": "29"
          },
          {
            "file": "scripts/VERSIONS.txt",
            "finding": "VERSIONS.txt lists OpenTK.GLWpfControl at 4.3.4, which is the modern .NET version. The net4* 3.x line version is not tracked here.",
            "relevance": "context",
            "lines": "27"
          }
        ],
        "rationale": "This is clearly a bug \u2014 a dependency version choice that breaks strong-named applications. It\u0027s area/SkiaSharp.Views because the issue is in the WPF views package dependency, not core SkiaSharp. Windows-Classic because it only affects .NET Framework WPF. tenet/compatibility because strong-naming is a .NET compatibility requirement. Severity is medium \u2014 the app won\u0027t load the GL control at all, but only affects the subset of users who strong-name their .NET Framework apps.",
        "keySignals": [
          {
            "text": "PackageReference Include=\u0022OpenTK.GLWpfControl\u0022 Version=\u00223.3.0\u0022",
            "source": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj:15",
            "interpretation": "Root cause \u2014 version 3.3.0 is not strong-named; 3.3.1 is."
          },
          {
            "text": "SignAssembly Condition=\u0022!$(TargetFramework.StartsWith(\u0027net4\u0027))\u0022\u003Efalse\u003C/SignAssembly\u003E",
            "source": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj:10",
            "interpretation": "SkiaSharp.Views.WPF itself IS strong-named for net4* targets, creating a mismatch with unsigned GLWpfControl."
          },
          {
            "text": "FileLoadException: A strongly-named assembly is required (0x80131044)",
            "source": "issue body",
            "interpretation": "CLR enforces that strong-named assemblies can only reference other strong-named assemblies."
          },
          {
            "text": "Strong-naming was added in OpenTK.GLWpfControl 3.3.1",
            "source": "issue body \u002B opentk/GLWpfControl#164",
            "interpretation": "Upstream already fixed this; SkiaSharp just needs to bump the dependency version."
          }
        ],
        "errorFingerprint": "FileLoadException-GLWpfControl-StrongName-net4",
        "workarounds": [
          "Use a binding redirect in app.config to force-load the unsigned assembly (may not work in all strong-naming scenarios)",
          "Target modern .NET (net6.0-windows\u002B) instead of .NET Framework, which uses OpenTK.GLWpfControl 4.x and doesn\u0027t require strong-naming"
        ],
        "nextQuestions": [
          "Should VERSIONS.txt also be updated to track the net4* version of OpenTK.GLWpfControl separately?",
          "Are there any breaking API changes between OpenTK.GLWpfControl 3.3.0 and 3.3.1 that could affect SKGLElement?"
        ],
        "resolution": {
          "hypothesis": "OpenTK.GLWpfControl 3.3.0 is not strong-named, but SkiaSharp.Views.WPF IS strong-named for .NET Framework targets. The CLR enforces that strong-named assemblies can only reference other strong-named assemblies, causing FileLoadException at runtime.",
          "proposals": [
            {
              "description": "Change the PackageReference from OpenTK.GLWpfControl 3.3.0 to 3.3.1 in the net4* ItemGroup. Version 3.3.1 is strong-named. Community PR #3380 already implements this exact change.",
              "title": "Bump GLWpfControl to 3.3.1",
              "codeSnippet": "\u003CPackageReference Include=\u0022OpenTK.GLWpfControl\u0022 Version=\u00223.3.1\u0022 NoWarn=\u0022NU1701\u0022 /\u003E",
              "confidence": 0.98,
              "effort": "trivial"
            },
            {
              "description": "Users can work around the issue by targeting net6.0-windows or later instead of net48, which uses the OpenTK 4.x line (already strong-name compatible).",
              "title": "Migrate to modern .NET",
              "confidence": 0.9,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Bump GLWpfControl to 3.3.1",
          "recommendedReason": "Trivial one-line version bump with zero risk. The upstream already fixed strong-naming in 3.3.1. PR #3380 from the reporter implements this exact change and should be reviewed and merged."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.9,
          "reason": "The fix is trivial (one-line version bump) and a community PR #3380 already implements it. Review and merge the PR to resolve this."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp.Views, os/Windows-Classic, tenet/compatibility",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the issue and point to PR #3380 as the fix",
            "risk": "high",
            "confidence": 0.92,
            "comment": "Thanks for the detailed report and the fix in #3380.\n\nYou\u0027re right \u2014 \u0060OpenTK.GLWpfControl\u0060 3.3.0 isn\u0027t strong-named, and since \u0060SkiaSharp.Views.WPF\u0060 is strong-named for .NET Framework targets, the CLR rejects the unsigned dependency at load time. Bumping to 3.3.1 (which added strong-naming) is the correct fix.\n\nIn the meantime, if you need a workaround: targeting \u0060net6.0-windows\u0060 or later avoids this entirely, since the modern .NET path uses OpenTK.GLWpfControl 4.x which doesn\u0027t have this issue."
          },
          {
            "type": "link-related",
            "description": "Link to community PR #3380 which implements the fix",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3380
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3378,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:18:05Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "os/Android",
          "area/SkiaSharp",
          "backend/Metal",
          "tenet/reliability"
        ]
      },
      "summary": "Memory leak in ToHarfBuzzBlob() extension method: when SKStreamAsset.GetMemoryBase() returns IntPtr.Zero, the stream data is copied to unmanaged memory but the SKStreamAsset itself is never disposed. In the other code path (memoryBase != IntPtr.Zero), the asset IS disposed via the Blob\u0027s release callback, creating inconsistent ownership semantics. The reporter\u0027s code creates SKShaper instances (which internally call ToHarfBuzzBlob), and even with proper disposal of SKShaper, the underlying SKStreamAsset leaks. First observed on Android with SkiaSharp 3.116.0, also reproducible on Windows.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "class TextSegmentShaper : IDisposable\n{\n    public SKPaint Paint { get; set; }\n    public SKShaper Shaper { get; set; }\n    ...\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposedValue)\n        {\n            Paint?.Dispose();\n            Shaper?.Dispose();\n            Paint = null;\n            Shaper = null;\n            disposedValue = true;\n        }\n    }\n}"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), first observed on Android, also on Windows",
          "relatedIssues": [
            3376,
            3466,
            3467
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "memory-leak",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The ToHarfBuzzBlob code has not changed since 3.116.0. The leak still exists on main. PR #3466 proposes a fix but is not yet merged."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.9,
          "reason": "Two open PRs address this: #3376 (reporter\u0027s fix, adds dispose in else path) and #3466 (preferred fix, removes dispose from both paths and fixes SKShaper caller). Neither is merged yet.",
          "relatedPRs": [
            3376,
            3466,
            3467
          ]
        }
      },
      "analysis": {
        "summary": "ToHarfBuzzBlob() has two code paths: when GetMemoryBase() returns a valid pointer, the Blob\u0027s release callback disposes the SKStreamAsset; when it returns IntPtr.Zero, data is copied but the SKStreamAsset is never disposed. The SKShaper constructor calls Typeface.OpenStream().ToHarfBuzzBlob() in a using block for the blob only \u2014 the intermediate SKStreamAsset is never assigned to a variable and leaks in the else path. The agreed fix direction (per maintainer mattleibow) is PR #3466: remove dispose from both paths in ToHarfBuzzBlob (it shouldn\u0027t take ownership), and fix SKShaper to explicitly dispose the stream.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob has two paths: line 24 disposes asset via blob callback when memoryBase is valid; line 30 copies data but NEVER disposes asset when memoryBase is IntPtr.Zero. This is the root cause of the leak.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "SKShaper constructor calls Typeface.OpenStream(out index).ToHarfBuzzBlob() in a using block for the blob only. The SKStreamAsset returned by OpenStream() is not stored or disposed separately \u2014 it relies entirely on ToHarfBuzzBlob to handle it.",
            "relevance": "direct",
            "lines": "19-22"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "OpenStream() returns a new SKStreamAsset wrapping native memory via SkiaApi.sk_typeface_open_stream. This is the object that leaks when ToHarfBuzzBlob\u0027s else path is hit.",
            "relevance": "related",
            "lines": "295-300"
          }
        ],
        "rationale": "Classified as type/bug because this is confirmed broken behavior \u2014 a native resource leak in a well-defined code path. Area is SkiaSharp.HarfBuzz (not SkiaSharp) because the bug is in BlobExtensions.cs and SKShaper.cs, both in the SkiaSharp.HarfBuzz package. The title says \u0027SKShader\u0027 but the report is about SKShaper/ToHarfBuzzBlob. Not platform-specific \u2014 it\u0027s a managed code logic error affecting all platforms equally. Current labels incorrectly include backend/Metal (no rendering backend is involved) and area/SkiaSharp (should be area/SkiaSharp.HarfBuzz). Severity is medium: it\u0027s a gradual memory leak, not a crash, but can degrade long-running apps.",
        "keySignals": [
          {
            "text": "I think the bug is in ToHarfBuzzBlob() extension - it doesn\u0027t dispose SKStreamAsset in all paths",
            "source": "issue body",
            "interpretation": "Reporter correctly identified the root cause \u2014 the else branch in BlobExtensions.cs line 30 copies data but never disposes the asset."
          },
          {
            "text": "First observed bug on Android, but seems to be a problem also on Windows",
            "source": "issue body",
            "interpretation": "Cross-platform issue \u2014 managed code bug, not platform-specific. Current os/ and backend/ labels are overly specific."
          },
          {
            "text": "The extension method copies the data and does not own or keep a reference to the asset. Would it be better to maybe fix the caller?",
            "source": "PR #3376 comment by mattleibow",
            "interpretation": "Maintainer confirms the bug and prefers the caller (SKShaper) to handle disposal, not the extension method."
          },
          {
            "text": "I\u0027ve put an alternate PR here to remove the stream disposal on the other path and fix the SKShaper constructor",
            "source": "PR #3376 comment by jeremy-visionaid",
            "interpretation": "PR #3466 is the preferred fix direction: consistent non-ownership in ToHarfBuzzBlob, explicit disposal in SKShaper."
          }
        ],
        "errorFingerprint": "memory-leak-ToHarfBuzzBlob-SKStreamAsset-undisposed",
        "workarounds": [
          "No user-level workaround \u2014 the leak is internal to SKShaper\u0027s constructor. Users cannot access the intermediate SKStreamAsset."
        ],
        "nextQuestions": [
          "Does GetMemoryBase() typically return IntPtr.Zero for most typefaces, or only certain ones? This determines how frequently the leak path is hit.",
          "Are there other callers of ToHarfBuzzBlob outside of SKShaper that might also leak?"
        ],
        "resolution": {
          "hypothesis": "ToHarfBuzzBlob has inconsistent ownership: one path disposes the asset, the other doesn\u0027t. The SKShaper constructor doesn\u0027t compensate because it assumes the blob handles it. Fix: make ToHarfBuzzBlob never take ownership, and have the caller (SKShaper) explicitly dispose the stream.",
          "proposals": [
            {
              "description": "Remove dispose from both paths in ToHarfBuzzBlob (it copies data, shouldn\u0027t own the asset). Fix SKShaper to wrap OpenStream() result in a using statement. This is the maintainer-approved approach.",
              "title": "Merge PR #3466",
              "codeSnippet": "// SKShaper.cs constructor fix:\nusing (var stream = Typeface.OpenStream(out index))\nusing (var blob = stream.ToHarfBuzzBlob())\nusing (var face = new Face(blob, index))\n{ ... }",
              "confidence": 0.92,
              "effort": "small"
            },
            {
              "description": "Reporter\u0027s original fix: add asset.Dispose() after reading in the else path. Simpler but maintains inconsistent ownership \u2014 one path disposes via callback, one disposes inline.",
              "title": "Add dispose in else path (PR #3376)",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3466",
          "recommendedReason": "Cleaner ownership semantics: ToHarfBuzzBlob never takes ownership, caller is always responsible. Maintainer mattleibow explicitly approved this direction."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "Confirmed bug with an open PR (#3466) that has maintainer approval in principle. Issue should stay open until the PR is merged."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix labels: change area from SkiaSharp to SkiaSharp.HarfBuzz, remove incorrect backend/Metal, remove platform labels since this is cross-platform managed code",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference PR #3466 which contains the maintainer-approved fix",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3466
          },
          {
            "type": "add-comment",
            "description": "Acknowledge confirmed bug, note the preferred fix direction",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for identifying this \u2014 the analysis is spot on. The leak is in \u0060ToHarfBuzzBlob()\u0060 (BlobExtensions.cs): when \u0060GetMemoryBase()\u0060 returns \u0060IntPtr.Zero\u0060, the \u0060SKStreamAsset\u0060 is read but never disposed.\n\nPR #3466 takes the cleaner approach here: remove the dispose responsibility from \u0060ToHarfBuzzBlob\u0060 entirely (it copies data and shouldn\u0027t own the asset), and fix the \u0060SKShaper\u0060 constructor to explicitly dispose the stream:\n\n\u0060\u0060\u0060csharp\nusing (var stream = Typeface.OpenStream(out index))\nusing (var blob = stream.ToHarfBuzzBlob())\nusing (var face = new Face(blob, index))\n{\n    // ...\n}\n\u0060\u0060\u0060\n\nThere\u0027s no user-level workaround since the leak is internal to \u0060SKShaper\u0060\u0027s constructor. The fix in #3466 is the path forward."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3375,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:20:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "Stack overflow crash on Windows x86 with .NET 8/9 due to missing Cdecl calling convention on LibraryImport P/Invoke declarations",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability",
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET 8 or .NET 9 project referencing SkiaSharp 3.116\u002B",
            "Target x86 (win-x86) platform",
            "Call any SkiaSharp API that P/Invokes into the native library (e.g., SKBitmap.GetPixel)",
            "Observe stack overflow crash"
          ],
          "environmentDetails": "Windows 11, .NET 8.0/9.0, x86 target, SkiaSharp 3.116\u002B / 3.119.1",
          "relatedIssues": []
        },
        "bugSignals": {
          "severity": "critical",
          "isRegression": true,
          "errorType": "crash",
          "errorMessage": "Stack overflow at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color(IntPtr, Int32, Int32)",
          "stackTrace": "at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color(IntPtr, Int32, Int32)",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0",
            "net9.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The code generator (Generator.cs line 546) still emits [LibraryImport] without Cdecl calling convention. The generated file SkiaApi.generated.cs still lacks the necessary [UnmanagedCallConv] attribute. The bug is present on the main branch."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "SkiaSharp 2.88.x used DllImport with CallingConvention.Cdecl exclusively. SkiaSharp 3.x introduced LibraryImport for .NET 7\u002B but omitted the Cdecl calling convention. On x64 this is invisible (one calling convention), on x86 it causes stack corruption.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "The P/Invoke code generator emits [LibraryImport(SKIA)] without specifying a calling convention. On .NET 7\u002B x86 Windows, LibraryImport defaults to CallingConvention.Winapi which resolves to StdCall. The native C API functions use Cdecl (the C default). This calling convention mismatch causes stack corruption on x86, manifesting as a stack overflow. On x64, there is only one calling convention, so the mismatch is invisible.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaApi.generated.cs",
            "finding": "[LibraryImport(SKIA)] at line 1647 does not specify calling convention. The [DllImport] fallback at line 1650 correctly specifies CallingConvention.Cdecl. This pattern repeats for ALL P/Invoke declarations in the file.",
            "relevance": "direct",
            "lines": "1644-1660"
          },
          {
            "file": "utils/SkiaSharpGenerator/Generate/Generator.cs",
            "finding": "Line 546 emits \u0060[LibraryImport ({config.DllName})]\u0060 without calling convention. Line 552 emits \u0060[DllImport ({config.DllName}, CallingConvention = CallingConvention.Cdecl)]\u0060. The LibraryImport path should also specify Cdecl via [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })].",
            "relevance": "direct",
            "lines": "545-555"
          },
          {
            "file": "binding/SkiaSharp/SkiaSharp.csproj",
            "finding": "USE_DELEGATES is defined for net4x (Framework), USE_LIBRARY_IMPORT for net7.0\u002B. This confirms .NET Framework uses correct Cdecl delegates while .NET 7\u002B uses the broken LibraryImport path.",
            "relevance": "direct",
            "lines": "12-17"
          },
          {
            "file": "externals/skia/include/c/sk_types.h",
            "finding": "SK_C_API macro only specifies dllexport/dllimport visibility, NOT a calling convention. Native functions default to __cdecl (C default on Windows).",
            "relevance": "direct",
            "lines": "25-38"
          },
          {
            "file": "externals/skia/src/c/sk_bitmap.cpp",
            "finding": "sk_bitmap_get_pixel_color is a plain C function with no explicit calling convention \u2014 uses default __cdecl.",
            "relevance": "context",
            "lines": "87-89"
          }
        ],
        "rationale": "Both reporters describe x86-only crashes with .NET 8/9 that work fine on x64. The second reporter provides a clear stack overflow trace at sk_bitmap_get_pixel_color. Code investigation confirms the generated [LibraryImport] declarations lack Cdecl specification while the [DllImport] fallback correctly specifies it. The native SK_C_API macro contains no calling convention specifier, defaulting to Cdecl. This is clearly a code-generation bug, not a usage issue. Severity is critical because ALL P/Invoke calls on x86 .NET 7\u002B are affected \u2014 the library is fundamentally broken on this platform.",
        "keySignals": [
          {
            "text": "x86 crash, x64 works",
            "source": "issue body \u002B comment 2",
            "interpretation": "Classic calling convention mismatch symptom \u2014 only matters on x86 where StdCall and Cdecl differ."
          },
          {
            "text": "Stack overflow at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color",
            "source": "comment 2 (TomPMoleman)",
            "interpretation": "Stack corruption from calling convention mismatch causes stack overflow at the P/Invoke boundary."
          },
          {
            "text": "x86 \u002B net472: working, x86 \u002B Net8.0: ISSUE",
            "source": "comment 2 (TomPMoleman)",
            "interpretation": ".NET Framework uses USE_DELEGATES path with correct Cdecl convention; .NET 8 uses USE_LIBRARY_IMPORT path missing Cdecl."
          },
          {
            "text": "Rollback to 2.88.9 fixes it",
            "source": "issue body",
            "interpretation": "SkiaSharp 2.88.x didn\u0027t have LibraryImport \u2014 used DllImport with CallingConvention.Cdecl only."
          },
          {
            "text": "[LibraryImport(SKIA)] without calling convention in generated code",
            "source": "SkiaApi.generated.cs:1647-1648, Generator.cs:546",
            "interpretation": "Root cause \u2014 generator emits LibraryImport without Cdecl, defaulting to StdCall on x86 Windows."
          }
        ],
        "errorFingerprint": "stack-overflow::sk_*::x86::net7\u002B::libraryimport-missing-cdecl",
        "workarounds": [
          "Target x64 instead of x86 (x64 has a single calling convention, so the bug is invisible)",
          "Downgrade to SkiaSharp 2.88.x which uses DllImport with correct Cdecl convention"
        ],
        "nextQuestions": [
          "Confirm that adding [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })] to the generator output fixes x86 .NET 8/9",
          "Check if HarfBuzzSharp has the same LibraryImport calling convention issue"
        ],
        "resolution": {
          "hypothesis": "LibraryImport without Cdecl calling convention defaults to StdCall on x86 Windows, causing stack corruption on every P/Invoke call into the native Cdecl library.",
          "proposals": [
            {
              "description": "Update Generator.cs line 546 to also emit [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })] after the [LibraryImport] attribute. Then regenerate SkiaApi.generated.cs with \u0060pwsh ./utils/generate.ps1\u0060.",
              "title": "Fix code generator to emit Cdecl for LibraryImport",
              "confidence": 0.95,
              "effort": "small"
            },
            {
              "description": "As a workaround, compile for x64 or AnyCPU (prefer 64-bit) instead of x86. On x64 Windows there is only one calling convention, so the mismatch is invisible.",
              "title": "Target x64 instead of x86",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Downgrade to SkiaSharp 2.88.9 which uses DllImport with CallingConvention.Cdecl exclusively. This avoids the LibraryImport path entirely.",
              "title": "Downgrade to SkiaSharp 2.88.x",
              "confidence": 0.9,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Fix code generator to emit Cdecl for LibraryImport",
          "recommendedReason": "This is a straightforward code generator fix. The DllImport path already has the correct pattern. Adding the equivalent attribute for LibraryImport is a small, low-risk change that fixes the platform entirely."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Root cause identified with high confidence (calling convention mismatch in generated code). Needs a fix in the code generator and regeneration of bindings. Should be verified on x86 .NET 8/9 before shipping."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp, os/Windows-Classic, tenet/reliability are all accurate",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis confirming root cause and providing workaround",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the detailed stack trace \u2014 that confirmed this.\n\nThe root cause is a calling convention mismatch in the P/Invoke bindings. SkiaSharp 3.x uses \u0060[LibraryImport]\u0060 for .NET 7\u002B, but the generated declarations don\u0027t specify \u0060Cdecl\u0060 calling convention. On x86 Windows, \u0060LibraryImport\u0060 defaults to \u0060StdCall\u0060, while the native C API uses \u0060Cdecl\u0060. This stack corruption manifests as a stack overflow. On x64 there\u0027s only one calling convention, which is why it works there. On .NET Framework, SkiaSharp uses a different code path (\u0060DllImport\u0060) that correctly specifies \u0060Cdecl\u0060.\n\nWorkaround: target x64 instead of x86 if possible \u2014 the calling convention mismatch is invisible on x64.\n\nThe fix is to update the code generator to emit \u0060[UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]\u0060 alongside the \u0060[LibraryImport]\u0060 attribute."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3372,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:15:00Z",
        "currentLabels": [
          "area/SkiaSharp.Views",
          "type/feature-request",
          "os/Windows-WinUI"
        ]
      },
      "summary": "Replace Microsoft.WindowsAppSDK metapackage with Microsoft.WindowsAppSDK.WinUI sub-package (v1.8) to avoid forcing full metapackage on downstream consumers",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "tenets": [
          "tenet/compatibility"
        ],
        "partner": "partner/maui"
      },
      "evidence": {
        "reproEvidence": {
          "environmentDetails": "Windows, WinAppSDK 1.8\u002B, .NET MAUI",
          "relatedIssues": []
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.4.230913002",
            "1.8"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "SkiaSharp still references Microsoft.WindowsAppSDK 1.4.230913002 metapackage. The WinAppSDK 1.8 package split has shipped, making this request actionable."
        }
      },
      "analysis": {
        "summary": "SkiaSharp.Views.WinUI currently references the Microsoft.WindowsAppSDK metapackage at v1.4, which forces all downstream consumers (including MAUI) to pull in the entire WinAppSDK. Since WinAppSDK 1.8 split the packages, SkiaSharp could reference only Microsoft.WindowsAppSDK.WinUI \u2014 the only component it actually uses. This would unblock downstream projects from reducing their dependency footprint.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj",
            "finding": "References Microsoft.WindowsAppSDK v1.4.230913002 (the full metapackage). This is the primary reference that needs to change to Microsoft.WindowsAppSDK.WinUI.",
            "relevance": "direct",
            "lines": "17"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/*.cs",
            "finding": "Only uses Microsoft.UI.Dispatching, Microsoft.UI.Xaml.* namespaces \u2014 all WinUI XAML types. No usage of other WinAppSDK components (notifications, lifecycle, etc.). Confirms the metapackage is unnecessarily broad.",
            "relevance": "direct"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native.vcxproj",
            "finding": "The native C\u002B\u002B project also references Microsoft.WindowsAppSDK 1.4.230913002 via NuGet packages.config. This would also need updating if the managed package changes.",
            "relevance": "direct",
            "lines": "3, 181, 192-193"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/packages.config",
            "finding": "Lists Microsoft.WindowsAppSDK 1.4.230913002 as a native NuGet dependency. Must be updated in tandem with the managed project.",
            "relevance": "direct"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/SkiaSharp.Views.Maui.Core.csproj",
            "finding": "MAUI project references SkiaSharp.Views.WinUI via ProjectReference. The WindowsAppSDK metapackage flows transitively to MAUI consumers through this chain.",
            "relevance": "related",
            "lines": "23"
          },
          {
            "file": "samples/Basic/WinUI/SkiaSharpSample/SkiaSharpSample.csproj",
            "finding": "Sample project references Microsoft.WindowsAppSDK v1.4.231219000 (slightly newer than the library). Sample should also be updated for consistency.",
            "relevance": "related",
            "lines": "16"
          }
        ],
        "rationale": "This is clearly a feature request (package dependency restructuring, not a bug). The area is SkiaSharp.Views because the change targets SkiaSharp.Views.WinUI.csproj and its native counterpart. The MAUI partner label applies because dotMorten explicitly discusses MAUI RC2 being unable to properly reduce dependencies without this change. The compatibility tenet applies because bumping from WinAppSDK 1.4 to 1.8 may force consumers to upgrade their WinAppSDK version.",
        "keySignals": [
          {
            "text": "Please upgrade the WinUI package to reference Microsoft.WindowsAppSDK.WinUI 1.8, so that it no longer relies on the Microsoft.WindowsAppSDK metapackage",
            "source": "issue body",
            "interpretation": "Clear request to swap metapackage for sub-package to reduce dependency footprint."
          },
          {
            "text": "It\u0027s a bit on all us 3rd party library developers to fix the low level dependencies first so higher-level projects can reap the benefits",
            "source": "comment #3 (dotMorten)",
            "interpretation": "Ecosystem argument \u2014 SkiaSharp is a foundational library that blocks MAUI and others from adopting the split packages."
          },
          {
            "text": "1.8 upgrade is planned for RC2, but it can\u0027t be done right without this",
            "source": "comment #5 (dotMorten)",
            "interpretation": "MAUI RC2 is blocked on this change for proper WinAppSDK dependency reduction."
          },
          {
            "text": "1.8 breaks some maui features with net10-rc1\u002BWebView2",
            "source": "comment #4 (jeromelaban)",
            "interpretation": "Version bump carries risk \u2014 WinAppSDK 1.8 has known compatibility issues with .NET 10 RC1 and WebView2 in MAUI."
          }
        ],
        "nextQuestions": [
          "Does Microsoft.WindowsAppSDK.WinUI 1.8 include native C\u002B\u002B build props/targets equivalent to the metapackage, or does the native project need a different sub-package?",
          "What is the minimum WinAppSDK version that supports the split packages \u2014 is 1.8 the first, or can a lower version be used?",
          "Will bumping from 1.4 to 1.8 cause TargetPlatformMinVersion or API compatibility issues for existing consumers?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp.Views.WinUI only uses WinUI XAML types, so the Microsoft.WindowsAppSDK metapackage can be replaced with the Microsoft.WindowsAppSDK.WinUI sub-package at version 1.8\u002B. This requires updating both the managed .csproj and the native .vcxproj \u002B packages.config.",
          "proposals": [
            {
              "description": "Change PackageReference in SkiaSharp.Views.WinUI.csproj from Microsoft.WindowsAppSDK to Microsoft.WindowsAppSDK.WinUI at version 1.8.x. Also update the native C\u002B\u002B project (vcxproj \u002B packages.config) to use the equivalent native WinUI sub-package. Update the sample project for consistency.",
              "title": "Replace metapackage with WinUI sub-package",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "As a less disruptive alternative, bump Microsoft.WindowsAppSDK from 1.4 to 1.8 without switching to the sub-package. This doesn\u0027t solve the metapackage bloat but modernizes the version. Lower risk but doesn\u0027t address the core request.",
              "title": "Bump metapackage version only",
              "confidence": 0.6,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Replace metapackage with WinUI sub-package",
          "recommendedReason": "Directly addresses the request and unblocks downstream MAUI dependency reduction. The code investigation confirms only WinUI types are used, so no other WinAppSDK components are needed."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "Valid feature request with clear ecosystem benefit. Needs investigation into whether the WinUI sub-package provides equivalent native C\u002B\u002B build support and whether the version bump introduces compatibility issues."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/feature-request, area/SkiaSharp.Views, os/Windows-WinUI. Add partner/maui since MAUI is directly impacted.",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views",
              "os/Windows-WinUI",
              "partner/maui"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the request, confirm code investigation findings, and note that only WinUI types are used.",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for filing this. We\u0027ve confirmed that SkiaSharp.Views.WinUI only uses \u0060Microsoft.UI.Xaml.*\u0060 and \u0060Microsoft.UI.Dispatching\u0060 \u2014 no other WinAppSDK components \u2014 so switching from the metapackage to \u0060Microsoft.WindowsAppSDK.WinUI\u0060 is viable.\n\nThe change involves both the managed project (\u0060SkiaSharp.Views.WinUI.csproj\u0060) and the native C\u002B\u002B project (\u0060SkiaSharp.Views.WinUI.Native.vcxproj\u0060 \u002B \u0060packages.config\u0060), which also reference the metapackage at 1.4. We\u0027ll need to verify the native sub-package provides equivalent build props/targets before making the switch.\n\nThe version bump from 1.4 to 1.8 is the main compatibility concern \u2014 it raises the minimum WinAppSDK version for consumers."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3365,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:15:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "Duplicate of #3267 \u2014 libSkiaSharp.dll has hard link-time dependency on d3d12.dll, crashing on Windows systems without DX12",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility",
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET app referencing SkiaSharp 3.116.0\u002B",
            "Deploy to a Windows 10 machine that lacks DX12 support (unpatched or older hardware)",
            "Run the app \u2014 crash on load because libSkiaSharp.dll imports d3d12.dll which is missing"
          ],
          "environmentDetails": "Windows 10 without DX12 (approx 0.1% of 1M installations). Also reproduced on Windows 7 (#3267) and Windows Server 2012 R2 (#3300).",
          "relatedIssues": [
            3267,
            3300,
            2305,
            2235
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "crash",
          "errorMessage": "Hard crash on load \u2014 d3d12.dll not found on systems without DX12 support",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The native Windows build still sets skia_use_direct3d=true by default, which links d3d12.lib at compile time. No /DELAYLOAD is configured. The dependency is still present in the current build."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "SkiaSharp 2.88.x did not link d3d12.lib. The Direct3D backend was added in the 3.x series, introducing a hard import dependency on d3d12.dll.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "The Windows native build (native/windows/build.cake) passes skia_use_direct3d=true to GN, which causes Skia\u0027s BUILD.gn to link d3d12.lib, dxgi.lib, and d3dcompiler.lib directly. This creates a hard import-table dependency on d3d12.dll in the resulting libSkiaSharp.dll. On Windows systems without DX12 (older Win10, Win7, Server 2012 R2), the DLL loader fails immediately \u2014 before any SkiaSharp code runs \u2014 because d3d12.dll is missing.",
        "codeInvestigation": [
          {
            "file": "native/windows/build.cake",
            "finding": "SUPPORT_DIRECT3D defaults to true. Line 76 passes skia_use_direct3d=true to GN args. This is the root configuration that enables the d3d12.lib linkage.",
            "relevance": "direct",
            "lines": "11-12"
          },
          {
            "file": "externals/skia/BUILD.gn",
            "finding": "When skia_use_direct3d is true, BUILD.gn adds libs \u002B= [\u0027d3d12.lib\u0027, \u0027dxgi.lib\u0027, \u0027d3dcompiler.lib\u0027]. These are static import libs \u2014 the resulting DLL will fail to load if d3d12.dll is not present on the system.",
            "relevance": "direct",
            "lines": "1037-1049"
          },
          {
            "file": "externals/skia/BUILD.gn",
            "finding": "There is also a dawn_enable_d3d12 code path that links the same libs, but this is only active when skia_use_dawn=true (currently false by default).",
            "relevance": "related",
            "lines": "917-922"
          },
          {
            "file": "scripts/cake/native-shared.cake",
            "finding": "CheckWindowsDependencies verifies DLL imports post-build but only excludes VCRUNTIME/MSVCP. d3d12.dll is not flagged. No /DELAYLOAD is configured anywhere in the build.",
            "relevance": "related",
            "lines": "52-86"
          }
        ],
        "rationale": "This is clearly a bug (type/bug) \u2014 the crash happens at DLL load time, not during any D3D12 API call. SkiaSharp defaults to CPU/raster rendering, so the D3D12 dependency should never be required for basic usage. The area is libSkiaSharp.native since the issue is in the native build configuration, not the C# bindings. Severity is high: it affects real production deployments (0.1% of 1M installs) with no user-side workaround except downgrading. This is a duplicate of #3267 which reports the identical root cause but on Win7 \u2014 the underlying problem (link-time d3d12.lib) is the same regardless of Windows version.",
        "keySignals": [
          {
            "text": "out of a sample of 1 million installations around 0.1% are crashing because their systems don\u0027t have DX12",
            "source": "issue body",
            "interpretation": "Real production impact \u2014 approximately 1000 users affected. Not theoretical."
          },
          {
            "text": "This should be a runtime dependency that is dynamically loaded",
            "source": "issue body",
            "interpretation": "Reporter correctly identifies the root cause: link-time vs runtime dependency."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "issue body",
            "interpretation": "Confirms regression \u2014 D3D12 backend was not present in 2.88.x series."
          },
          {
            "text": "While this is in reference to Windows 7, all of our crashes occur on Windows 10",
            "source": "comment #3",
            "interpretation": "Same root cause as #3267 but broader impact \u2014 not just Win7, also unpatched Win10."
          },
          {
            "text": "the common theme is that they\u0027re on systems that don\u0027t support DX12",
            "source": "comment #4 (molesmoke)",
            "interpretation": "Community correctly identifies this as a duplicate of #3267 with the same resolution path."
          }
        ],
        "nextQuestions": [
          "Would adding /DELAYLOAD:d3d12.dll to extra_ldflags be a safe fix? This would defer loading until D3D12 APIs are actually called.",
          "Alternatively, should SUPPORT_DIRECT3D default to false, requiring opt-in?",
          "Does Skia internally handle the case where d3d12.dll is delay-loaded but unavailable at runtime?"
        ],
        "resolution": {
          "hypothesis": "libSkiaSharp.dll statically imports d3d12.dll via link-time dependency. On systems without DX12, the Windows loader fails before any code executes. The fix is to either delay-load d3d12.dll or disable D3D12 by default.",
          "proposals": [
            {
              "description": "Add /DELAYLOAD:d3d12.dll, /DELAYLOAD:dxgi.dll, and /DELAYLOAD:d3dcompiler.dll to extra_ldflags in native/windows/build.cake and add delayimp.lib to the link. This defers loading until D3D12 functions are actually called, allowing SkiaSharp to work on systems without DX12 as long as D3D12 features are not used.",
              "title": "Add /DELAYLOAD for d3d12.dll",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Change SUPPORT_DIRECT3D default from \u0027true\u0027 to \u0027false\u0027 in native/windows/build.cake. Users who need D3D12 rendering would opt in via build argument. This eliminates the dependency entirely for the default build.",
              "title": "Disable Direct3D by default",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "As an immediate workaround, downgrade to SkiaSharp 2.88.9 which does not have the D3D12 dependency. This is the version the reporter confirmed as working.",
              "title": "Downgrade to SkiaSharp 2.88.x",
              "confidence": 0.95,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Add /DELAYLOAD for d3d12.dll",
          "recommendedReason": "Delay loading preserves D3D12 capability for users who need it while eliminating the hard dependency. This is the standard Windows pattern for optional system DLLs. The downgrade workaround is viable immediately but loses all 3.x improvements."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.9,
          "reason": "Same root cause as #3267 (d3d12.dll hard dependency). The only difference is the reporter\u0027s Windows version (Win10 vs Win7), but the fix is identical. Community commenter also confirms this is a duplicate."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Current labels are already correct \u2014 type/bug, area/libSkiaSharp.native, os/Windows-Classic, tenet/reliability. Add tenet/compatibility.",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/Windows-Classic",
              "tenet/reliability",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report, confirm duplicate status, and note the production impact data as valuable evidence for #3267",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed production data \u2014 knowing this affects ~0.1% of 1M installations is valuable evidence.\n\nThis is the same root cause as #3267: \u0060libSkiaSharp.dll\u0060 statically imports \u0060d3d12.dll\u0060 because the Windows native build links \u0060d3d12.lib\u0060 at compile time (via \u0060skia_use_direct3d=true\u0060). On any system without DX12 support, the Windows loader fails before SkiaSharp code runs.\n\nThe fix is the same regardless of Windows version \u2014 either delay-load the D3D12 DLLs or make D3D12 opt-in. I\u0027m closing this as a duplicate; your production impact data has been noted in #3267\u0027s tracking.\n\nAs an immediate workaround, downgrading to SkiaSharp 2.88.9 avoids the dependency entirely (as you\u0027ve confirmed)."
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #3267",
            "risk": "medium",
            "confidence": 0.9,
            "linkedIssue": 3267
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #3267",
            "risk": "medium",
            "confidence": 0.9
          },
          {
            "type": "link-related",
            "description": "Cross-reference #3300 (same issue on Windows Server 2012 R2)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3300
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3357,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:13:03Z",
        "currentLabels": [
          "area/Docs"
        ]
      },
      "summary": "Maintainer request to migrate API documentation from external XML files (docs/SkiaSharpAPI/*.xml, ~240 files) into inline C# XML doc comments in the binding source files. PR #3363 attempted this but was closed without merging because NuGet doc tooling cannot handle packages with different APIs across target frameworks. The issue remains open as a desired long-term goal, blocked on tooling.",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.98
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.98
        }
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            3356,
            3358,
            3363,
            3410
          ]
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "PR #3363 attempted the migration but was closed without merging. Maintainer commented: \u0027the automated tooling to process nugets do not support nugets with different apis in different tfms. For now, we still have to use a separate docs repo.\u0027 The migration is blocked on NuGet documentation tooling, not on the content itself.",
          "relatedPRs": [
            3363
          ]
        }
      },
      "analysis": {
        "summary": "This is a maintainer-initiated docs migration task. The goal is to move all API documentation from the external XML doc repo (docs/SkiaSharpAPI/) into triple-slash (///) XML doc comments directly in the C# source (binding/SkiaSharp/*.cs). Multiple attempts were made (#3356 partial WIP, #3358 closed, PR #3363 with 40 commits touching 165 files). PR #3363 was the most complete attempt but was closed by the maintainer because NuGet doc generation tooling cannot produce correct documentation for packages that expose different APIs across different TFMs (e.g., net8.0 vs net8.0-ios). The issue remains open and desired.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "Zero inline XML doc comments (/// \u003Csummary\u003E). No triple-slash comments on any public member. Confirms the migration has not been done for this major class.",
            "relevance": "direct",
            "lines": "1-15"
          },
          {
            "file": "docs/SkiaSharpAPI/SkiaSharp/SKBitmap.xml",
            "finding": "Full XML API documentation exists externally \u2014 type summary, remarks, member docs. This is the source material that needs to be migrated into the C# source.",
            "relevance": "direct",
            "lines": "1-30"
          },
          {
            "file": "docs/SkiaSharpAPI/SkiaSharp/",
            "finding": "~240 XML doc files exist covering SkiaSharp types. Corresponding 85 C# source files in binding/SkiaSharp/ have essentially no inline docs.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/documentation because the issue is entirely about moving documentation content between formats (external XML \u2192 inline C# comments). Area is area/Docs because it concerns the documentation infrastructure, not any specific SkiaSharp API component. No platforms, backends, or tenets apply since this is a cross-cutting docs task.",
        "keySignals": [
          {
            "text": "Can you help migrate my docs from the docs folder into the c# source",
            "source": "issue body",
            "interpretation": "Maintainer-initiated documentation migration request. Clear intent \u2014 not a question or bug."
          },
          {
            "text": "Closing this for now as the automated tooling to process nugets do not support nugets with different apis in different tfms",
            "source": "PR #3363 comment by mattleibow",
            "interpretation": "The migration is technically feasible but blocked on NuGet doc tooling. The issue is NOT abandoned \u2014 maintainer said \u0027for now\u0027 and \u0027I will continue to investigate\u0027."
          },
          {
            "text": "Each type should be migrated and committed separately",
            "source": "issue body",
            "interpretation": "Maintainer wants atomic commits per type for review workflow. This constraint makes the migration a large but well-structured task."
          },
          {
            "text": "Fixes #3357",
            "source": "PR #3363 body",
            "interpretation": "PR #3363 was the official attempt to resolve this issue. Its closure without merge confirms the issue is still open."
          }
        ],
        "nextQuestions": [
          "Has the NuGet doc tooling limitation been resolved since PR #3363 was closed (Jan 2026)?",
          "Should the migration proceed in stages (e.g., types with consistent APIs across TFMs first)?",
          "Are the migration guide files (API.Docs.Migration.Guide.md, API.Docs.Migration.Checklist.md) available somewhere or need to be recreated?"
        ],
        "resolution": {
          "hypothesis": "The migration is blocked on NuGet documentation tooling not supporting different APIs across TFMs. Once that tooling limitation is resolved (either upstream fix or a workaround like conditional XML doc generation), the migration can proceed using the PR #3363 approach.",
          "proposals": [
            {
              "description": "Monitor NuGet/dotnet SDK updates for support of per-TFM XML documentation in packages. The migration content is ready (proven by PR #3363\u0027s 40 commits) but cannot ship until tooling supports it.",
              "title": "Wait for tooling fix",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Use #if directives or partial classes to provide different docs per TFM, allowing the NuGet doc extractor to process each TFM separately. This adds complexity but may unblock the migration.",
              "title": "Migrate with conditional compilation",
              "confidence": 0.4,
              "effort": "large"
            },
            {
              "description": "Identify types whose public API surface is identical across all TFMs and migrate those first. This sidesteps the multi-TFM tooling issue for a subset of the docs.",
              "title": "Migrate common-API types first",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Wait for tooling fix",
          "recommendedReason": "The maintainer explicitly closed PR #3363 to wait for tooling improvements. Forcing the migration now would reproduce the same problem. The content is ready and can be re-applied quickly once tooling supports it."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "The maintainer opened this issue and explicitly said the PR was closed \u0027for now\u0027 \u2014 indicating this remains a desired goal. The issue is blocked on external tooling, not abandoned. Keep open to track when the tooling limitation is resolved."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply documentation type label alongside existing area/Docs",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/documentation",
              "area/Docs"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference the closed PR that attempted this migration",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3363
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3346,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:05:45Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "Published Windows ARM64 app using SkiaSharp 3.116.0 crashes immediately on launch. Works fine in Debug and Release modes, only fails when published. Reporter found that installing the Microsoft Visual C\u002B\u002B Redistributable resolves the crash, suggesting a missing dynamic CRT dependency in the native binaries. Issue was closed after PR #3510 added build-time verification that ANGLE DLLs (libEGL.dll, libGLESv2.dll) and all Windows native binaries are statically linked against the CRT, preventing future regressions.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.82
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a SkiaSharp app targeting Windows ARM64",
            "Build in Release mode \u2014 works fine",
            "Publish the app for Windows ARM64",
            "Run the published executable on a fresh ARM64 Windows machine without VC\u002B\u002B Redistributable installed",
            "App crashes immediately on launch"
          ],
          "environmentDetails": "Windows 10 and 11, ARM64, SkiaSharp 3.116.0, Visual Studio (Windows)",
          "repoLinks": [
            {
              "url": "https://github.com/riccardomartins/ArmDemoTryout/tree/main/ArmDemoTryout",
              "description": "Minimal repro project from reporter"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "crash",
          "errorMessage": "Application crashes immediately on launch when published for Windows ARM64",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "PR #3510 added build-time dependency verification for all Windows native DLLs. CI confirms ANGLE, libSkiaSharp, and libHarfBuzzSharp are statically linked and do not depend on VCRUNTIME or MSVCP."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.9,
          "reason": "PR #3510 merged into main on 2026-02-11. CI confirmed all Windows native binaries (ANGLE, libSkiaSharp, libHarfBuzzSharp) do not dynamically link VCRUNTIME or MSVCP. Build-time CheckWindowsDependencies verification now prevents regressions across all Windows build targets.",
          "relatedPRs": [
            3510
          ]
        }
      },
      "analysis": {
        "summary": "Published Windows ARM64 app crashes on fresh machines without VC\u002B\u002B Redistributable. The root cause was a dynamic CRT dependency in one of the shipped native DLLs, most likely the ANGLE DLLs (libEGL.dll, libGLESv2.dll) used for GPU rendering. Publishing trims the output and runs on machines that may not have the VC\u002B\u002B Redistributable pre-installed, exposing the missing dependency. PR #3510 confirmed via dumpbin that current builds are statically linked and added CI verification across all Windows native build targets.",
        "codeInvestigation": [
          {
            "file": "native/winui-angle/build.cake",
            "finding": "VERIFY_EXCLUDED array defines [\u0027VCRUNTIME\u0027, \u0027MSVCP\u0027] \u2014 CheckWindowsDependencies rejects any ANGLE DLL that dynamically links these CRT libraries.",
            "relevance": "direct",
            "lines": "7"
          },
          {
            "file": "native/winui-angle/build.cake",
            "finding": "ANGLE build targets arm64, x64, x86. Uses is_component_build=false (static linking). CheckWindowsDependencies called after each build to verify no CRT dependencies.",
            "relevance": "direct",
            "lines": "115-158"
          },
          {
            "file": "native/windows/build.cake",
            "finding": "libSkiaSharp.dll and libHarfBuzzSharp.dll also use VERIFY_EXCLUDED = [\u0027VCRUNTIME\u0027, \u0027MSVCP\u0027] with CheckWindowsDependencies verification, added in PR #3510.",
            "relevance": "related",
            "lines": "14, 87, 109"
          },
          {
            "file": "scripts/cake/native-shared.cake",
            "finding": "CheckWindowsDependencies uses dumpbin /dependents to enumerate DLL imports, then rejects any matching the excluded list. Shared across all Windows native builds.",
            "relevance": "related",
            "lines": "52-86"
          }
        ],
        "rationale": "Classified as type/bug because the app crashes (not a usage question or feature request). Area is libSkiaSharp.native because the crash stems from native DLL dynamic linking, not managed code. Platform is Windows-Classic since the reporter used standard Windows (not WinUI). Severity is high \u2014 the crash prevents the app from launching at all in published form. The tenet/reliability label is appropriate for crash-on-launch behavior.",
        "keySignals": [
          {
            "text": "App crashes immediately on launch when published for Windows ARM64",
            "source": "issue body",
            "interpretation": "Publish-only crash suggests stripped/self-contained deployment exposes a missing native dependency that the development environment satisfies."
          },
          {
            "text": "Installing Microsoft Visual C\u002B\u002B Redistributable fixes the crash",
            "source": "comment by riccardomartins (2025-09-03)",
            "interpretation": "Confirms the root cause is a dynamic VCRUNTIME/MSVCP dependency in shipped native DLLs \u2014 fresh ARM64 machines lack the CRT without explicit installation."
          },
          {
            "text": "Were you using the GPU rendering? If so, I am trying to release a fix for that.",
            "source": "comment by mattleibow (2025-09-06)",
            "interpretation": "Maintainer suspected ANGLE (GPU) DLLs as the source of the dynamic CRT dependency, directing the investigation."
          },
          {
            "text": "CI on PR #3510 confirms ANGLE DLLs do not depend on VCRUNTIME or MSVCP \u2014 already statically linked",
            "source": "closing comment by mattleibow (2026-02-11)",
            "interpretation": "Current builds verified clean. PR adds build-time CI gates to catch future regressions."
          }
        ],
        "workarounds": [
          "Install Microsoft Visual C\u002B\u002B Redistributable on the target ARM64 machine (confirmed by reporter to resolve the crash)",
          "Use software/raster rendering instead of GPU rendering to avoid ANGLE DLL dependency"
        ],
        "nextQuestions": [
          "Was the reporter\u0027s 3.116.0 build actually shipping ANGLE DLLs with dynamic CRT links, or was the crash from a different dependency?",
          "Which specific DLL was the source of the VCRUNTIME dependency in the 3.116.0 timeframe?"
        ],
        "resolution": {
          "hypothesis": "One or more native Windows DLLs shipped with SkiaSharp 3.116.0 had a dynamic dependency on VCRUNTIME/MSVCP. On fresh ARM64 Windows machines without the VC\u002B\u002B Redistributable, this caused immediate crash on load. The ANGLE DLLs (libEGL.dll, libGLESv2.dll) were the most likely culprits since the maintainer specifically asked about GPU rendering.",
          "proposals": [
            {
              "description": "Install the Microsoft Visual C\u002B\u002B Redistributable on target machines. This is the reporter\u0027s confirmed workaround.",
              "title": "Install VC\u002B\u002B Redistributable",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Add CheckWindowsDependencies CI verification to all Windows native builds, rejecting any DLL that dynamically links VCRUNTIME or MSVCP. Already merged.",
              "title": "Build-time dependency verification (PR #3510)",
              "confidence": 0.95,
              "effort": "small"
            },
            {
              "description": "Switch to software/raster rendering to avoid ANGLE DLL loading entirely, sidestepping the CRT dependency.",
              "title": "Disable GPU rendering",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Build-time dependency verification (PR #3510)",
          "recommendedReason": "Addresses the root cause at the build level with CI regression prevention. Already merged and verified across all 62 native build jobs."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.92,
          "reason": "PR #3510 merged 2026-02-11 adds build-time verification that all Windows native DLLs are statically linked. Issue already closed by maintainer with explanation."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, os/Windows-Classic, tenet/reliability all match",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Link to PR #3510 which adds the build-time dependency verification fix",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3510
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3188,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:05:45Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "DrawVertices outputs black triangle instead of colored gradient in v3 due to upstream Skia behavior change \u2014 default paint color (black) is now modulated with vertex colors",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an SKSurface with RGBA8888 color type",
            "Clear the canvas to white",
            "Create an SKPaint with IsAntialias = true (default color is black)",
            "Call DrawVertices with SKVertexMode.Triangles, 3 vertices, and RGB colors (Red, Green, Blue)",
            "Snapshot and encode to PNG",
            "Observe output is a solid black triangle instead of a gradient"
          ],
          "codeSnippets": [
            "surface.Canvas.DrawVertices(SKVertexMode.Triangles, vertices, colors, paint);"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/afa656d4-1966-496c-be0f-50d3d325f554",
              "description": "Expected: gradient triangle (v2.88.9)"
            },
            {
              "url": "https://github.com/user-attachments/assets/5a9f1421-92d4-49f6-8f65-e7fb990cb82f",
              "description": "Actual: black triangle (v3.116.1)"
            }
          ],
          "environmentDetails": "Windows 11, .NET 8, Visual Studio, SkiaSharp 3.116.1",
          "relatedIssues": [
            3319
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "wrong-output",
          "errorMessage": "DrawVertices produces a solid black triangle instead of a gradient triangle with vertex colors",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.1",
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The DrawVertices overloads still hardcode SKBlendMode.Modulate, and Skia\u0027s behavior for drawVertices with opaque paint color has not changed back."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Upstream Skia changed how drawVertices interacts with the paint color. In newer Skia (used by SkiaSharp v3), drawVertices blends the paint\u0027s opaque color (src) with vertex colors (dst) using the blend mode. Since SkPaint defaults to opaque black and the blend mode is Modulate (src \u00D7 dst), black \u00D7 anything = black. Older Skia (used by v2.88) handled vertex colors differently.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "DrawVertices produces black output in SkiaSharp v3 because all convenience overloads hardcode SKBlendMode.Modulate, and Skia now modulates the paint\u0027s opaque color (default = black) with vertex colors. Black \u00D7 any color = black.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "All 3 convenience DrawVertices overloads hardcode SKBlendMode.Modulate. The 4th overload (line 930) accepts a blend mode parameter. The core method (line 936) passes vertices, mode, and paint directly to the C API.",
            "relevance": "direct",
            "lines": "912-942"
          },
          {
            "file": "externals/skia/src/core/SkPaint.cpp",
            "finding": "SkPaint default constructor initializes fColor4f to {0,0,0,1} (opaque black). This is the src color for Modulate blending in drawVertices.",
            "relevance": "direct",
            "lines": "38-39"
          },
          {
            "file": "externals/skia/include/core/SkCanvas.h",
            "finding": "Skia docs specify: drawVertices combines \u0027the opaque SkPaint color\u0027 (when no shader) as src with \u0027interpolated vertex colors\u0027 as dst using the blend mode. Modulate = src \u00D7 dst.",
            "relevance": "direct",
            "lines": "1938-1955"
          },
          {
            "file": "externals/skia/src/c/sk_canvas.cpp",
            "finding": "C API passes through to Skia\u0027s drawVertices without modification: AsCanvas(ccanvas)-\u003EdrawVertices(AsVertices(vertices), (SkBlendMode)mode, *AsPaint(paint))",
            "relevance": "context",
            "lines": "244-246"
          },
          {
            "file": "binding/SkiaSharp/SKVertices.cs",
            "finding": "SKVertices.CreateCopy correctly passes vertex colors to Skia. No color transformation or loss occurs in the C# wrapper.",
            "relevance": "context",
            "lines": "25-54"
          }
        ],
        "rationale": "This is a real regression from v2 to v3 caused by an upstream Skia behavior change in how drawVertices blends paint color with vertex colors. The SkiaSharp wrapper code itself hasn\u0027t changed \u2014 it still passes Modulate as the blend mode \u2014 but Skia now uses the paint\u0027s opaque color as the blend source. Since SKPaint defaults to opaque black {0,0,0,1}, and Modulate = src \u00D7 dst, the result is always black. The area is core SkiaSharp (SKCanvas.DrawVertices), not views or native. Severity is medium because there\u0027s a straightforward workaround (set paint color to white), but it\u0027s a breaking change that affects all DrawVertices users who relied on v2 behavior.",
        "keySignals": [
          {
            "text": "Passing in a color array works fine in v2.88.9 but after updating to 3.116.1 the output is simply black",
            "source": "issue body",
            "interpretation": "Confirms regression \u2014 same code, different results between v2 and v3."
          },
          {
            "text": "SkPaint::SkPaint() : fColor4f{0, 0, 0, 1}  // opaque black",
            "source": "externals/skia/src/core/SkPaint.cpp:38-39",
            "interpretation": "Default paint color is opaque black \u2014 this is the root cause when modulated with vertex colors."
          },
          {
            "text": "the opaque SkPaint color if SkPaint does not contain SkShader as the src of the blend and the interpolated vertex colors as the dst",
            "source": "externals/skia/include/core/SkCanvas.h:1943-1944",
            "interpretation": "Skia documentation confirms paint color is used as blend source for drawVertices when no shader is set."
          },
          {
            "text": "DrawVertices(vert, SKBlendMode.Modulate, paint)",
            "source": "binding/SkiaSharp/SKCanvas.cs:915",
            "interpretation": "All convenience overloads hardcode Modulate blend mode \u2014 no way to override without using the lower-level overload."
          },
          {
            "text": "This will give you the result you were after: Shader = SKShader.CreateColor(SKColors.White)",
            "source": "comment by @molesmoke",
            "interpretation": "Community-provided workaround confirmed \u2014 setting a white shader makes modulate preserve vertex colors."
          }
        ],
        "workarounds": [
          "Set paint.Color = SKColors.White before calling DrawVertices \u2014 white (1,1,1,1) modulated with vertex colors preserves the original colors",
          "Set paint.Shader = SKShader.CreateColor(SKColors.White) to achieve the same result via a shader",
          "Use the overload DrawVertices(SKVertexMode, SKPoint[], SKPoint[], SKColor[], SKBlendMode, UInt16[], SKPaint) with SKBlendMode.Dst to ignore paint color entirely"
        ],
        "nextQuestions": [
          "Should SkiaSharp add a compatibility shim in the convenience overloads to default paint color to white when only vertex colors are provided?",
          "Is this a deliberate upstream Skia change or an unintended side effect of Skia refactoring?",
          "Should the SkiaSharp v3 migration guide document this behavior change?"
        ],
        "resolution": {
          "hypothesis": "Upstream Skia changed drawVertices blending semantics. The paint\u0027s opaque color is now used as the src in blend mode, and default SKPaint color is black. Modulate(black, vertex_color) = black.",
          "proposals": [
            {
              "description": "The simplest workaround: set paint.Color = SKColors.White before calling DrawVertices. Since Modulate = src \u00D7 dst, white (1,1,1,1) \u00D7 vertex_color = vertex_color, preserving the original gradient.",
              "title": "Set paint color to white",
              "codeSnippet": "var paint = new SKPaint\n{\n    IsAntialias = true,\n    Color = SKColors.White\n};",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Set paint.Shader = SKShader.CreateColor(SKColors.White) to provide a white shader that gets modulated with vertex colors. Functionally equivalent to setting Color to white.",
              "title": "Use white shader on paint",
              "codeSnippet": "var paint = new SKPaint\n{\n    IsAntialias = true,\n    Shader = SKShader.CreateColor(SKColors.White)\n};",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Use the lower-level DrawVertices overload with SKBlendMode.Dst to ignore the paint color entirely and render only vertex colors.",
              "title": "Use Dst blend mode",
              "codeSnippet": "var vert = SKVertices.CreateCopy(SKVertexMode.Triangles, vertices, colors);\ncanvas.DrawVertices(vert, SKBlendMode.Dst, paint);",
              "confidence": 0.8,
              "effort": "trivial"
            },
            {
              "description": "Add this behavior change to the v3 migration guide. DrawVertices now requires paint color or shader to be set appropriately since Skia blends it with vertex colors via the blend mode.",
              "title": "Document as v3 breaking change",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Set paint color to white",
          "recommendedReason": "Simplest fix \u2014 one property change. Directly addresses the root cause (black paint color being modulated) without requiring API changes or overload switching."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "Root cause identified as upstream Skia behavior change. Workaround is trivial (set paint.Color = SKColors.White). Community comment already provided a working solution. Could alternatively keep open to track as a breaking change for documentation."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm type/bug and add compatibility tenet and Windows platform labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Confirm root cause, provide workaround with paint.Color = White, and acknowledge as v3 behavior change",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the clear repro \u2014 this is a behavior change in the upstream Skia library used by SkiaSharp v3.\n\nIn v3, \u0060drawVertices\u0060 blends the paint\u0027s color (src) with vertex colors (dst) using the blend mode. The convenience \u0060DrawVertices\u0060 overloads use \u0060SKBlendMode.Modulate\u0060 (src \u00D7 dst), and since \u0060SKPaint\u0060 defaults to opaque black, the result is \u0060black \u00D7 vertex_color = black\u0060.\n\nHere\u0027s a workaround \u2014 set the paint color to white so modulate preserves vertex colors:\n\n\u0060\u0060\u0060csharp\nvar paint = new SKPaint\n{\n    IsAntialias = true,\n    Color = SKColors.White\n};\n\u0060\u0060\u0060\n\nAlternatively, as @molesmoke noted, you can use \u0060Shader = SKShader.CreateColor(SKColors.White)\u0060 which achieves the same result.\n\nThis is documented in the [Skia \u0060drawVertices\u0060 API](https://api.skia.org/classSkCanvas.html): \u0022the opaque SkPaint color if SkPaint does not contain SkShader as the src of the blend.\u0022"
          },
          {
            "type": "link-related",
            "description": "Link to PR #3319 which addresses DrawVertices disposal of temporary vertices",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 3319
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3175,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:05:45Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SKBitmap.Decode reads only a single chunk from chunked/network streams (Azure Blob), producing truncated images for large PNG/BMP files \u2014 duplicate of #1962",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Linux",
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Download a PNG/BMP image larger than 4MB from Azure Blob Storage (default chunk size is 4MB)",
            "Pass the blob stream directly to SKBitmap.Decode(stream)",
            "Observe that only the first ~4MB of image data is decoded \u2014 the image dimensions are correct but pixel data is truncated",
            "Workaround: copy the blob stream to a MemoryStream first, then decode from the MemoryStream"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Azure Blob Storage stream, Linux and Windows"
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "wrong-output",
          "errorMessage": "Only specific data length downloads into image for png/bmp \u2014 image created from first chunk only, but image size is correct",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "2.80.3",
          "currentRelevance": "likely",
          "relevanceReason": "The incomplete stream reading bug in SKManagedStream.OnReadManagedStream was introduced in PR #1510 (v2.80.3) and has not been fixed. The reporter claims 2.88.9 worked, which may indicate they used a different code path or MemoryStream in the older version."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "The root cause was introduced in PR #1510 (commit 61b71d6e4893) which changed from BinaryReader.ReadBytes() (loops until all bytes read) to a single stream.Read() call that can return partial data. Reporter states 2.88.9 worked but bug was introduced in 2.80.3.",
          "brokeInVersion": "2.80.3"
        }
      },
      "analysis": {
        "summary": "SKManagedStream.OnReadManagedStream performs a single stream.Read() call which can return fewer bytes than requested per the .NET Stream contract. Chunked streams (Azure Blob, network streams) commonly return partial reads. This causes Skia\u0027s codec to receive truncated data, producing images with correct dimensions but incomplete pixel data.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKManagedStream.cs",
            "finding": "OnReadManagedStream performs a single stream.Read() call at line 99. Per the .NET Stream contract, Read() may return fewer bytes than requested even when more data is available. Network and chunked streams commonly do this. The method should loop until all bytes are read or the stream ends.",
            "relevance": "direct",
            "lines": "89-111"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "WrapManagedStream wraps seekable streams with SKManagedStream directly, and non-seekable streams with SKFrontBufferedManagedStream (which itself wraps SKManagedStream). Both paths are affected since the underlying Read is in SKManagedStream.",
            "relevance": "direct",
            "lines": "278-290"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(Stream) creates an SKCodec from the stream, which goes through WrapManagedStream \u2192 SKManagedStream \u2192 single stream.Read() call.",
            "relevance": "context",
            "lines": "461-472"
          },
          {
            "file": "binding/SkiaSharp/SKFrontBufferedManagedStream.cs",
            "finding": "SKFrontBufferedManagedStream.OnRead also calls stream.Read() without looping (lines 91, 111) though this wraps an SKStream not a .NET Stream, so the inner SKManagedStream is the actual issue.",
            "relevance": "related",
            "lines": "64-124"
          }
        ],
        "rationale": "This is clearly a bug \u2014 Stream.Read() returning fewer bytes than requested is normal .NET behavior, and the caller must loop to read the full amount. The issue exactly matches #1962 (incomplete stream reading in SKManagedStream introduced in 2.80.3) and #2514 (partial reads from non-seekable streams). Classification as type/bug in area/SkiaSharp core is straightforward since the defect is in SKManagedStream, not in any view or platform layer.",
        "keySignals": [
          {
            "text": "Default stream downloading chunk size is 4mb. When png is larger than 4mb it looks like image creates only for first 4mb",
            "source": "issue body",
            "interpretation": "Azure Blob stream returns data in chunks; stream.Read() returns only the first chunk without looping for the rest."
          },
          {
            "text": "When I\u0027m copying blob stream into memory stream it works correctly",
            "source": "issue body",
            "interpretation": "MemoryStream.Read() returns all requested bytes since data is already in memory \u2014 confirms the issue is in how SkiaSharp reads from the stream, not in decoding."
          },
          {
            "text": "Even if I change default size of stream chunk for example into 50mb png/bmp images below 50mb downloads correctly",
            "source": "issue body",
            "interpretation": "Increasing chunk size makes the single read.Read() call return all data in one shot, bypassing the missing loop. This confirms the root cause."
          },
          {
            "text": "var len = stream.Read(managedBuffer.Array, 0, managedBuffer.Length);",
            "source": "SKManagedStream.cs:99",
            "interpretation": "Single Read() call without retry loop \u2014 violates Stream contract which allows partial reads."
          }
        ],
        "workarounds": [
          "Copy the source stream to a MemoryStream before decoding: await stream.CopyToAsync(memoryStream); memoryStream.Seek(0, SeekOrigin.Begin); SKBitmap.Decode(memoryStream);",
          "Use SKBitmap.Decode(SKData) instead: read all bytes first with await BinaryData.FromStreamAsync(stream), then decode from the byte array or SKData."
        ],
        "nextQuestions": [
          "Should the fix be a read loop in OnReadManagedStream, or should WrapManagedStream always copy non-seekable streams to memory first?",
          "Does the same issue affect SKImage.FromEncodedData(Stream)?",
          "Should SKFrontBufferedManagedStream also be fixed to loop on reads from the underlying stream?"
        ],
        "resolution": {
          "hypothesis": "SKManagedStream.OnReadManagedStream performs a single stream.Read() instead of looping until the requested number of bytes is read or the stream ends. This causes chunked/network streams to produce truncated data.",
          "proposals": [
            {
              "description": "Copy the source stream to a MemoryStream before passing to SKBitmap.Decode. This is what the reporter already discovered.",
              "title": "Copy to MemoryStream first (workaround)",
              "codeSnippet": "await using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var bitmap = SKBitmap.Decode(memoryStream);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Read all bytes into memory first, then use SKBitmap.Decode(byte[]) or SKBitmap.Decode(SKData) to avoid the stream reading issue entirely.",
              "title": "Use SKData.Create from byte array (workaround)",
              "codeSnippet": "using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nusing var bitmap = SKBitmap.Decode(memoryStream.ToArray());",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Replace the single stream.Read() call in SKManagedStream.OnReadManagedStream with a loop that reads until all requested bytes are obtained or the stream truly ends. This is the proper fix matching the old BinaryReader.ReadBytes() behavior.",
              "title": "Add read loop in OnReadManagedStream (fix)",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Copy to MemoryStream first (workaround)",
          "recommendedReason": "The reporter already found this workaround. It\u0027s reliable and trivial to implement. The proper fix requires a code change in SKManagedStream that should be done as part of addressing #1962."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.9,
          "reason": "This is a duplicate of #1962 (incomplete stream reading in SKManagedStream introduced in 2.80.3). The same root cause \u2014 single stream.Read() instead of a loop \u2014 and the same workaround (copy to MemoryStream). Also related to #2514 and #2249."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and platform labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Linux",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug, confirm it\u0027s a known issue, provide workaround context",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the report. This is a known issue with how SkiaSharp reads from chunked or network streams \u2014 \u0060SKManagedStream.OnReadManagedStream\u0060 performs a single \u0060stream.Read()\u0060 call instead of looping until all requested bytes are read. Azure Blob streams return data in chunks, so only the first chunk gets decoded.\n\nYou\u0027ve already found the correct workaround: copy to a \u0060MemoryStream\u0060 first. Alternatively, you can read all bytes and use \u0060SKBitmap.Decode(byte[])\u0060 to avoid the stream path entirely.\n\nThis is a duplicate of #1962, which tracks the root cause (introduced in v2.80.3 when \u0060BinaryReader.ReadBytes()\u0060 was replaced with a single \u0060stream.Read()\u0060 call). See also #2514 for the same issue with non-seekable streams."
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #1962 (incomplete stream reading in SKManagedStream)",
            "risk": "medium",
            "confidence": 0.9,
            "linkedIssue": 1962
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #1962",
            "risk": "medium",
            "confidence": 0.88
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2997,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:58:59Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SKMatrix.MapRect normalizes (sorts) the output rectangle \u2014 this is upstream Skia behavior, not a SkiaSharp bug",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.35
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an SKRect with Left=25, Right=15, Bottom=2, Top=10 (non-standard/inverted coordinates)",
            "Call SKMatrix.CreateIdentity().MapRect(inputRect)",
            "Observe that resultRect has Left/Right and Top/Bottom swapped compared to input"
          ],
          "environmentDetails": "SkiaSharp 2.88.3, Windows, Visual Studio"
        },
        "bugSignals": {
          "severity": "low",
          "isRegression": false,
          "errorType": "wrong-output",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3",
            "2.88.2"
          ],
          "workedIn": "2.88.2",
          "brokeIn": "2.88.3",
          "currentRelevance": "likely",
          "relevanceReason": "The behavior is inherent to Skia\u0027s SkMatrix::mapRect which calls sort_as_rect() to normalize the output. This has been Skia behavior since at least 2020; the reporter\u0027s regression claim is likely inaccurate or based on a different code path in 2.88.2."
        }
      },
      "analysis": {
        "summary": "SKMatrix.MapRect delegates to Skia\u0027s SkMatrix::mapRect which intentionally normalizes the output rectangle via sort_as_rect(). This ensures left\u2264right and top\u2264bottom in the result. This is upstream Skia behavior by design, not a SkiaSharp wrapper bug.",
        "codeInvestigation": [
          {
            "file": "externals/skia/src/core/SkMatrix.cpp",
            "finding": "sort_as_rect() takes LTRB float4, computes min/max pairs, returns sorted LTRB. Called by both mapRect and mapRectScaleTranslate. This is the function that normalizes the output rect.",
            "relevance": "direct",
            "lines": "1120-1127"
          },
          {
            "file": "externals/skia/src/core/SkMatrix.cpp",
            "finding": "SkMatrix::mapRect has three code paths (translate-only, scale-translate, general). All three produce normalized output \u2014 translate/scale paths use sort_as_rect, general path uses setBoundsNoCheck on mapped quad points.",
            "relevance": "direct",
            "lines": "1142-1169"
          },
          {
            "file": "externals/skia/src/c/sk_matrix.cpp",
            "finding": "sk_matrix_map_rect is a direct pass-through to SkMatrix::mapRect \u2014 no SkiaSharp-specific normalization added.",
            "relevance": "direct",
            "lines": "47-49"
          },
          {
            "file": "binding/SkiaSharp/SKMatrix.cs",
            "finding": "C# MapRect method calls SkiaApi.sk_matrix_map_rect and returns the result. No C#-side normalization. The behavior comes entirely from upstream Skia.",
            "relevance": "direct",
            "lines": "299-306"
          },
          {
            "file": "binding/SkiaSharp/MathTypes.cs",
            "finding": "SKRect.Standardized property exists and explicitly normalizes a rect. Reporter already knows about it \u2014 their expectation is that MapRect should NOT auto-standardize.",
            "relevance": "context",
            "lines": "382-398"
          }
        ],
        "rationale": "Classified as low-confidence bug because the behavior is intentional in upstream Skia \u2014 sort_as_rect (SkMatrix.cpp:1120-1127) explicitly sorts coordinates to produce a normalized rect. The SkiaSharp C API (sk_matrix_map_rect) and C# wrapper (SKMatrix.MapRect) are thin pass-throughs with no additional normalization logic. The community comment from molesmoke correctly identifies this as Skia behavior. The reporter\u0027s expectation that MapRect preserves inverted coordinates is understandable but conflicts with Skia\u0027s rect invariant. The regression claim (2.88.2\u21922.88.3) is unsubstantiated \u2014 no changes to SKMatrix.MapRect or sk_matrix_map_rect appear in the git history.",
        "keySignals": [
          {
            "text": "sort_as_rect(skvx::float4::Load(\u0026src.fLeft) \u002B trans).store(\u0026dst-\u003EfLeft)",
            "source": "externals/skia/src/core/SkMatrix.cpp:1149",
            "interpretation": "Skia\u0027s mapRect always sorts the output coordinates via sort_as_rect, which computes min/max of left/right and top/bottom. This is the root cause of the \u0027standardization\u0027 the reporter observes."
          },
          {
            "text": "void sk_matrix_map_rect(sk_matrix_t *matrix, sk_rect_t *dest, sk_rect_t *source) { AsMatrix(matrix).mapRect(AsRect(dest), *AsRect(source)); }",
            "source": "externals/skia/src/c/sk_matrix.cpp:47-49",
            "interpretation": "The C API is a direct pass-through to Skia\u0027s mapRect with no additional logic \u2014 the normalization comes from upstream."
          },
          {
            "text": "That\u0027s what Skia does, it\u0027s not really an issue with the bindings themselves",
            "source": "comment by molesmoke",
            "interpretation": "Community member correctly identified this as upstream Skia behavior and linked to the Skia source."
          }
        ],
        "workarounds": [
          "Use SKMatrix.MapPoints to transform the four corners of the rect individually, then construct a new SKRect from the mapped points without sorting.",
          "Map the TopLeft and BottomRight points separately using SKMatrix.MapPoint, then construct the result rect preserving the original coordinate ordering."
        ],
        "nextQuestions": [
          "Should SkiaSharp document that MapRect always returns a normalized rect?",
          "Is the reporter\u0027s regression claim accurate, or did their code path change between 2.88.2 and 2.88.3?"
        ],
        "resolution": {
          "hypothesis": "This is upstream Skia behavior by design. SkMatrix::mapRect always normalizes the output rectangle. SkiaSharp cannot change this without diverging from Skia\u0027s behavior.",
          "proposals": [
            {
              "description": "Instead of MapRect, transform the rect corners individually using MapPoint to preserve the original coordinate ordering.",
              "title": "Use MapPoint for corner-preserving transformation",
              "codeSnippet": "var matrix = SKMatrix.CreateIdentity(); // or your actual matrix\nvar topLeft = matrix.MapPoint(inputRect.Left, inputRect.Top);\nvar bottomRight = matrix.MapPoint(inputRect.Right, inputRect.Bottom);\nvar resultRect = new SKRect(topLeft.X, topLeft.Y, bottomRight.X, bottomRight.Y);",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Add documentation to SKMatrix.MapRect noting that the output rect is always normalized (sorted), consistent with upstream Skia behavior. Suggest MapPoint as an alternative for coordinate-preserving transforms.",
              "title": "Document MapRect normalization behavior",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Use MapPoint for corner-preserving transformation",
          "recommendedReason": "Provides an immediate workaround that preserves coordinate ordering while being fully supported and correct."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "This is upstream Skia behavior by design. The SkiaSharp wrapper correctly delegates to Skia. A workaround using MapPoint exists. The issue could be closed as by-design with an explanation and workaround."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply area label, keep existing type/bug pending maintainer review of by-design classification",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain upstream Skia behavior and provide MapPoint workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed repro.\n\nThis is upstream Skia behavior \u2014 \u0060SkMatrix::mapRect\u0060 always normalizes (sorts) the output rectangle so that \u0060left \u2264 right\u0060 and \u0060top \u2264 bottom\u0060. The SkiaSharp wrapper delegates directly to Skia with no additional processing. The \u0060sort_as_rect\u0060 function in Skia\u0027s \u0060SkMatrix.cpp\u0060 handles this normalization. As @molesmoke noted, this isn\u0027t a binding issue.\n\nHere\u0027s a workaround that preserves coordinate ordering by transforming the corners individually:\n\n\u0060\u0060\u0060csharp\nvar topLeft = matrix.MapPoint(inputRect.Left, inputRect.Top);\nvar bottomRight = matrix.MapPoint(inputRect.Right, inputRect.Bottom);\nvar resultRect = new SKRect(topLeft.X, topLeft.Y, bottomRight.X, bottomRight.Y);\n\u0060\u0060\u0060\n\nThis gives you the transformed coordinates without the normalization step. Would this approach work for your use case?"
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2759,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:00:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "Reporter claims SKBitmap.Decode returns null when decoding a PNG file on SkiaSharp 2.88.3 (also mentions 2.88.6). Filed as a follow-up to #933, which was closed as a duplicate of #1981. The #1981 fix (zlib update for SSE decompression bugs) shipped in v2.88.1. No sample image, stack trace, or reproduction project is provided, making it impossible to verify whether this is the same zlib issue or a different PNG decoding problem.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.8
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "SkiaSharp.SKBitmap bmp = SkiaSharp.SKBitmap.Decode(@\u0022C:\\Temp\\image1.png\u0022);\nAssert.IsNotNull(bmp);"
          ],
          "environmentDetails": "Visual Studio (Windows), all platforms (claimed)",
          "relatedIssues": [
            933,
            1981,
            2429
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "silent failure",
          "errorMessage": "SKBitmap.Decode returns null",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3",
            "2.88.6",
            "2.88.2"
          ],
          "workedIn": "2.88.2",
          "brokeIn": "2.88.3",
          "currentRelevance": "unknown",
          "relevanceReason": "The reporter is on 2.88.x. The zlib fix shipped in 2.88.1. Without the actual PNG file, we cannot determine whether this is still reproducible on 3.x. The current main branch uses a significantly newer Skia with updated native dependencies."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.6,
          "reason": "Reporter claims it worked in 2.88.2 but not 2.88.3. However, the zlib fix for #1981 shipped in 2.88.1, so 2.88.2 should have had the fix. The version info is internally inconsistent \u2014 the body says 2.88.6 but the version field says 2.88.3. Low confidence because no sample image is provided.",
          "workedInVersion": "2.88.2",
          "brokeInVersion": "2.88.3"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.45,
          "reason": "The zlib/SSE fix from #1981 shipped in v2.88.1 and should have been present in 2.88.2\u002B. Either: (a) this is a different PNG decoding issue not fixed by that zlib update, or (b) the reporter\u0027s version info is inaccurate. Without the actual image file, we cannot determine if this specific PNG triggers a different code path.",
          "fixedInVersion": "2.88.1"
        }
      },
      "analysis": {
        "summary": "SKBitmap.Decode returning null for a PNG. The decode path is: SKBitmap.Decode(string) \u2192 SKCodec.Create(string) \u2192 sk_codec_new_from_stream. If SKCodec.Create returns null (meaning Skia\u0027s codec can\u0027t parse the image), the method returns null. The original #933/#1981 bug was traced to a zlib SSE decompression bug and fixed in 2.88.1 by updating zlib. The reporter claims the issue persists in 2.88.3/2.88.6, but provides no sample image to verify this claim.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(string) creates an SKCodec from the filename and returns null if codec creation fails. No error information is surfaced to the caller \u2014 the null return is completely opaque.",
            "relevance": "direct",
            "lines": "539-550"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(string) opens an SKFileStream and delegates to SKCodec.Create(SKStream). The overload with \u0027out SKCodecResult\u0027 would provide the failure reason, but SKBitmap.Decode doesn\u0027t use it.",
            "relevance": "direct",
            "lines": "229-241"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(SKStream) calls sk_codec_new_from_stream. If Skia cannot create a codec for the image format, it returns null. The SKCodecResult out parameter would reveal why (e.g., InvalidInput, IncompleteInput).",
            "relevance": "related",
            "lines": "252-264"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(SKCodec, SKImageInfo) calls codec.GetPixels and returns null if result is not Success or IncompleteInput. This is a second failure point after codec creation.",
            "relevance": "related",
            "lines": "446-458"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes a decode failure (null return) that is clearly unintended behavior. Area is area/SkiaSharp because the failing API is SKBitmap.Decode in the core library, not a view or native-loading issue. Severity is medium (not critical) because it\u0027s a silent null return, not a crash, and only affects specific PNGs. The regression claim has low confidence because the version information is inconsistent (body says 2.88.6, template says 2.88.3, and the fix was already in 2.88.1).",
        "keySignals": [
          {
            "text": "This is follow-up of #933 issue, which is closed as resolved, but the problem is still there 2.88.6 version",
            "source": "issue body",
            "interpretation": "Reporter believes the zlib fix in 2.88.1 did not resolve their specific PNG. Without the image, we can\u0027t verify."
          },
          {
            "text": "Version with issue: 2.88.3 (Current), Last Known Good: 2.88.2 (Previous)",
            "source": "issue template fields",
            "interpretation": "Inconsistent with body text (2.88.6). The zlib fix shipped in 2.88.1, so 2.88.2 should include it. This suggests a different root cause or inaccurate version info."
          },
          {
            "text": "#1981 closed \u2014 \u0027I think it was a bug in zlib so updating to a later version fixes the issue\u0027",
            "source": "mattleibow comment on #1981",
            "interpretation": "The parent issue was definitively diagnosed as a zlib SSE decompression bug. If this reporter\u0027s PNG is different, it\u0027s a new bug."
          },
          {
            "text": "#2429 also open: SKBitmap.Decode always returns null for a specific image",
            "source": "issue search",
            "interpretation": "Another open issue with the same symptom on a JPG. There may be a pattern of specific images failing to decode."
          }
        ],
        "errorFingerprint": "SKBitmap.Decode-null-PNG",
        "workarounds": [
          "Use SKCodec.Create(filename, out SKCodecResult result) to get the specific failure reason before calling Decode",
          "Re-save the PNG with a different tool (Paint.NET, ImageMagick) to re-encode with standard compression \u2014 worked for #1981 reporters",
          "Try SKImage.FromEncodedData() as an alternative decode path"
        ],
        "nextQuestions": [
          "What specific PNG characteristics trigger the failure? (bit depth, compression method, metadata)",
          "Is this the same PNG referenced in #933, or a different file?",
          "Does SKCodec.Create with out SKCodecResult give InvalidInput or IncompleteInput?",
          "Does the issue reproduce on 3.x (SkiaSharp 3.116\u002B) with the newer Skia engine?",
          "Does converting the PNG to 8-bit resolve the issue (as reported in #1981)?"
        ],
        "resolution": {
          "hypothesis": "Either (a) the reporter\u0027s specific PNG triggers a different libpng/zlib code path not fixed by the 2.88.1 zlib update, or (b) the reporter hasn\u0027t actually tested with the fixed version. Without the sample image, we cannot distinguish between these two possibilities.",
          "proposals": [
            {
              "description": "Ask the reporter to attach the actual PNG file and run SKCodec.Create with the out SKCodecResult parameter to get the specific failure reason. This is the blocking prerequisite for any further investigation.",
              "title": "Request sample image and diagnostic output",
              "codeSnippet": "var codec = SKCodec.Create(@\u0022C:\\Temp\\image1.png\u0022, out SKCodecResult result);\nConsole.WriteLine($\u0022Codec: {codec != null}, Result: {result}\u0022);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "SkiaSharp 3.x uses a significantly newer Skia engine with updated libpng and zlib. If this is a native decoding bug, upgrading may resolve it.",
              "title": "Upgrade to SkiaSharp 3.x",
              "confidence": 0.6,
              "effort": "small"
            },
            {
              "description": "Re-save the problematic PNG using a tool like Paint.NET, GIMP, or ImageMagick to normalize compression. This was a successful workaround for #1981.",
              "title": "Re-save PNG with standard encoder",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Request sample image and diagnostic output",
          "recommendedReason": "Cannot make progress without the actual PNG file and diagnostic data. Every other proposal is speculative without knowing what\u0027s unique about this image."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.9,
          "reason": "No sample image attached, inconsistent version info, no error details. The original #933/#1981 issue was fixed in 2.88.1, so we need to understand why the reporter still sees the problem. Cannot investigate without the actual PNG file."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Keep type/bug, add area/SkiaSharp and tenet/compatibility",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Link to #1981 (parent issue with zlib fix) and #2429 (similar Decode-returns-null symptom)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 1981
          },
          {
            "type": "link-related",
            "description": "Link to #2429 (similar SKBitmap.Decode returns null symptom)",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 2429
          },
          {
            "type": "add-comment",
            "description": "Request sample PNG and diagnostic output to continue investigation",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. The original #933 was closed as a duplicate of #1981, which was traced to a zlib decompression bug and fixed in v2.88.1. Since you\u0027re on 2.88.3\u002B, we\u0027d need to understand what\u0027s different about your PNG.\n\nTo help us investigate, would you be able to:\n\n1. **Attach the actual PNG file** (\u0060image1.png\u0060) \u2014 without it, we can\u0027t reproduce or diagnose the failure.\n2. **Run this diagnostic** to get the specific failure reason:\n\n\u0060\u0060\u0060csharp\nvar codec = SKCodec.Create(@\u0022C:\\Temp\\image1.png\u0022, out SKCodecResult result);\nConsole.WriteLine($\u0022Codec created: {codec != null}, Result: {result}\u0022);\n\u0060\u0060\u0060\n\n3. **Confirm your exact SkiaSharp version** \u2014 the issue body mentions 2.88.6 but the version field says 2.88.3.\n\nAs a workaround, re-saving the PNG with a tool like Paint.NET or ImageMagick may resolve the issue \u2014 that worked for reporters on #1981. You could also try upgrading to SkiaSharp 3.x, which uses a significantly updated Skia engine."
          }
        ],
        "missingInfo": [
          "The actual PNG file that fails to decode (image1.png is not attached)",
          "Output of SKCodec.Create(filename, out SKCodecResult result) showing the specific failure reason",
          "Confirmation of exact SkiaSharp version (body says 2.88.6, template says 2.88.3)",
          "Whether upgrading to SkiaSharp 3.x resolves the issue"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2511,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:00:00Z",
        "currentLabels": []
      },
      "summary": "AccessViolationException in NonAlertableWin32Lock.EnterCriticalSection during finalizer-driven handle deregistration on WinForms app close \u2014 duplicate of #2194, fixed in v2.88.1 by #2195",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Run a WinForms application that uses SkiaSharp",
            "Close the application",
            "Observe AccessViolationException in the finalizer thread"
          ],
          "environmentDetails": "Windows, WinForms application",
          "relatedIssues": [
            2194,
            2195,
            1383,
            1817
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "crash",
          "errorMessage": "System.AccessViolationException: An attempt was made to read or write protected memory.",
          "stackTrace": "at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterCriticalSection(IntPtr lpCriticalSection)\n   at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterWriteLock()\n   at SkiaSharp.HandleDictionary.DeregisterHandle(IntPtr handle, SKObject instance)\n   at SkiaSharp.SKObject.DeregisterHandle(IntPtr handle, SKObject instance)\n   at SkiaSharp.SKObject.set_Handle(IntPtr value)\n   at SkiaSharp.SKNativeObject.Dispose(Boolean disposing)\n   at SkiaSharp.SKNativeObject.Finalize()",
          "reproQuality": "partial",
          "targetFrameworks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "Fixed in v2.88.1 by PR #2195. The current code in PlatformLock.cs includes null-checks before entering/leaving the critical section. Reporter did not mention a version, but the stack trace exactly matches the known bug #2194 that was fixed."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.92,
          "reason": "PR #2195 (commit dc54fa5cd) added null-checks for _cs before calling EnterCriticalSection/LeaveCriticalSection, preventing the crash when the NonAlertableWin32Lock finalizer runs before SKObject finalizers during app shutdown. The fix was included in v2.88.1.",
          "relatedPRs": [
            2195
          ],
          "fixedInVersion": "2.88.1"
        }
      },
      "analysis": {
        "summary": "Classic finalizer ordering bug on Windows. During WinForms app shutdown, the GC finalizes both SKObject instances and the static NonAlertableWin32Lock. If the lock\u0027s finalizer runs first (deleting the CRITICAL_SECTION native memory), subsequent SKObject finalizers crash when trying to enter the already-freed critical section during handle deregistration. This exact bug was reported as #2194 and fixed by #2195 in v2.88.1.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/PlatformLock.cs",
            "finding": "NonAlertableWin32Lock allocates a CRITICAL_SECTION via Marshal.AllocHGlobal in the constructor and frees it in the finalizer (~NonAlertableWin32Lock). The Enter() method (line 122) now has a null-check \u0027if (_cs != IntPtr.Zero)\u0027 before calling EnterCriticalSection \u2014 this is the fix from PR #2195. Without this check (pre-v2.88.1), the freed pointer would be passed directly to EnterCriticalSection, causing the exact AccessViolationException in the reporter\u0027s stack trace.",
            "relevance": "direct",
            "lines": "99-174"
          },
          {
            "file": "binding/SkiaSharp/HandleDictionary.cs",
            "finding": "DeregisterHandle calls instancesLock.EnterWriteLock() (line 184). The instancesLock is a static readonly field (line 27) created by PlatformLock.Create(). During AppDomain unload, the static NonAlertableWin32Lock instance can be finalized before all SKObject instances that reference it through the static dictionary.",
            "relevance": "direct",
            "lines": "176-227"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKObject.Handle setter: when set to IntPtr.Zero (during disposal), it first calls DeregisterHandle(Handle, this) which triggers the lock acquisition. This is the entry point from the Dispose path into the lock that crashes.",
            "relevance": "direct",
            "lines": "59-70"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKNativeObject finalizer sets fromFinalizer=true then calls Dispose(false), which sets Handle=IntPtr.Zero, triggering DeregisterHandle. This confirms the crash path originates from GC finalization.",
            "relevance": "direct",
            "lines": "229-234"
          }
        ],
        "rationale": "The stack trace is identical to #2194: Finalize \u2192 Dispose(false) \u2192 set_Handle(Zero) \u2192 DeregisterHandle \u2192 EnterWriteLock \u2192 EnterCriticalSection. This is a known finalizer ordering race condition specific to the Win32 CRITICAL_SECTION lock used on Windows (introduced to fix #1383\u0027s STA re-entrancy issue). The reporter does not mention a SkiaSharp version, but since the fix shipped in v2.88.1 (August 2022) and this was reported June 2023, they were likely on v2.88.0 or earlier. The current code has the null-check guard from #2195. Classified as type/bug, area/SkiaSharp (HandleDictionary/PlatformLock is core infrastructure), Windows-Classic (WinForms), medium severity (crash on exit, not during normal operation).",
        "keySignals": [
          {
            "text": "at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterCriticalSection(IntPtr lpCriticalSection)",
            "source": "issue body",
            "interpretation": "Crash in the Win32 CRITICAL_SECTION P/Invoke \u2014 the native memory backing the critical section has been freed by the NonAlertableWin32Lock finalizer before this SKObject\u0027s finalizer ran."
          },
          {
            "text": "at SkiaSharp.SKNativeObject.Finalize()",
            "source": "issue body",
            "interpretation": "Crash occurs during GC finalization, not during normal operation. This is a finalizer ordering problem during app shutdown."
          },
          {
            "text": "When I close my winform program, this error will be reported",
            "source": "issue body",
            "interpretation": "Trigger is app close \u2014 AppDomain unload causes non-deterministic finalizer ordering, explaining the race condition."
          }
        ],
        "workarounds": [
          "Upgrade to SkiaSharp v2.88.1 or later, which includes the fix from PR #2195",
          "Explicitly dispose all SkiaSharp objects before the application exits to avoid finalizer-based cleanup"
        ],
        "nextQuestions": [
          "What SkiaSharp version was the reporter using? If v2.88.1\u002B then the TOCTOU race in the null-check is still theoretically possible."
        ],
        "resolution": {
          "hypothesis": "The reporter was using a SkiaSharp version prior to v2.88.1 which lacked the null-check guard in NonAlertableWin32Lock.Enter(). During WinForms app shutdown, non-deterministic finalizer ordering caused the CRITICAL_SECTION to be freed before all SKObjects were finalized.",
          "proposals": [
            {
              "description": "Upgrade to SkiaSharp v2.88.1 or later which includes the null-check fix from PR #2195. This prevents the AccessViolationException by skipping the critical section entry when the lock has already been finalized.",
              "title": "Upgrade SkiaSharp to v2.88.1\u002B",
              "confidence": 0.92,
              "effort": "trivial"
            },
            {
              "description": "Dispose all SkiaSharp objects explicitly (via using statements or Dispose() calls) before the application exits. This avoids relying on the GC finalizer, which has non-deterministic ordering during AppDomain unload.",
              "title": "Explicit disposal before exit",
              "confidence": 0.8,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Upgrade SkiaSharp to v2.88.1\u002B",
          "recommendedReason": "The fix is trivial (NuGet version bump) and directly addresses the root cause. The fix has been shipping since August 2022."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.92,
          "reason": "Identical stack trace and root cause as #2194, fixed by PR #2195 in v2.88.1. Reporter provided no version info but the crash signature matches exactly. Issue was already closed with no comments."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, core area, and Windows labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #2194 \u2014 same AccessViolationException in NonAlertableWin32Lock finalizer race",
            "risk": "medium",
            "confidence": 0.92,
            "linkedIssue": 2194
          },
          {
            "type": "add-comment",
            "description": "Post explanation of the known issue and the fix version",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for reporting this. This is a known finalizer ordering issue on Windows where the native CRITICAL_SECTION used by SkiaSharp\u0027s handle dictionary can be freed before all SkiaSharp objects are finalized during app shutdown.\n\nThis was fixed in SkiaSharp v2.88.1 (PR #2195). If you\u0027re on an earlier version, upgrading should resolve the crash. As a general best practice, explicitly disposing SkiaSharp objects (via \u0060using\u0060 statements) before your application exits will also prevent finalizer-related issues.\n\nClosing as duplicate of #2194."
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #2194",
            "risk": "medium",
            "confidence": 0.9
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2421,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:53:00Z",
        "currentLabels": []
      },
      "summary": "DllNotFoundException for libSkiaSharp.framework on real iOS device \u2014 works on simulator and Android. Likely iOS managed linker stripping the native framework or Hot Restart limitation.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.92
        },
        "platforms": [
          "os/iOS"
        ],
        "tenets": [
          "tenet/compatibility"
        ],
        "partner": "partner/maui"
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET MAUI app using OxyPlot.Maui.Skia (or any SkiaSharp consumer)",
            "Add SkiaSharp.Views.Maui.Controls 2.88.3 and SkiaSharp.HarfBuzz 2.88.3",
            "Deploy to iOS simulator \u2014 works",
            "Deploy to real iOS device \u2014 crashes with DllNotFoundException"
          ],
          "environmentDetails": "SkiaSharp 2.88.3, .NET MAUI, iOS real device (specific device/version unknown)",
          "relatedIssues": [
            2437,
            1129,
            1264,
            1770
          ],
          "repoLinks": [
            {
              "url": "https://github.com/iniceice88/OxyPlot.Maui.Skia",
              "description": "Third-party OxyPlot MAUI library using SkiaSharp"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "crash",
          "errorMessage": "@rpath/libSkiaSharp.framework/libSkiaSharp",
          "stackTrace": "at SkiaSharp.SKPaint..ctor() \u2192 OxyPlot.Maui.Skia.SkiaRenderContext..ctor()",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net7.0-ios"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "SkiaSharp 2.88.x is superseded by 3.x which has improved MAUI integration and iOS packaging. The underlying cause (linker stripping or Hot Restart) may still affect 3.x in certain configurations, but the version is very outdated."
        }
      },
      "analysis": {
        "summary": "DllNotFoundException on real iOS device but not simulator. The native framework libSkiaSharp.framework is not being loaded at runtime. Three known causes match: (1) iOS managed linker stripping the native framework, (2) Windows Hot Restart not supporting native frameworks, (3) third-party library not propagating NativeAssets correctly.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaApi.cs",
            "finding": "iOS uses \u0060@rpath/libSkiaSharp.framework/libSkiaSharp\u0060 as the P/Invoke library name. This requires the .framework bundle to be embedded in the app\u0027s Frameworks/ directory with correct rpath.",
            "relevance": "direct",
            "lines": "9-13"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.iOS/SkiaSharp.NativeAssets.iOS.csproj",
            "finding": "Package includes framework bundles for both \u0060runtimes/ios/native/\u0060 and \u0060runtimes/iossimulator/native/\u0060. The packaging is correct \u2014 the issue is downstream (linker or deployment tool).",
            "relevance": "direct",
            "lines": "8-10"
          },
          {
            "file": "binding/IncludeNativeAssets.SkiaSharp.targets",
            "finding": "iOS framework is included via NativeReference with Kind=\u0027Framework\u0027, conditioned on RuntimeIdentifier. For non-simulator (real device), uses \u0060ios/libSkiaSharp.framework\u0060. This is the standard approach for iOS native framework bundling.",
            "relevance": "context",
            "lines": "28-31"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.iOS/buildTransitive/SkiaSharp.targets",
            "finding": "The buildTransitive targets file is empty \u2014 no additional MSBuild logic for ensuring the framework survives linker passes. This may contribute to the linker stripping issue.",
            "relevance": "related"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes a crash (DllNotFoundException) that prevents SkiaSharp from functioning on real iOS devices. Area is libSkiaSharp.native because the root cause is native library deployment/loading, not the managed wrapper. The \u0027works on simulator, fails on device\u0027 pattern is a strong signal for linker stripping \u2014 the simulator uses a different code signing and linking pipeline. Issue #2437 (identical error, same SkiaSharp version, filed 3 weeks later) was resolved by community identifying two root causes: MtouchLink stripping the framework, and Windows Hot Restart not supporting native frameworks. Severity is high because the app is completely non-functional on physical iOS devices.",
        "keySignals": [
          {
            "text": "\u0027@rpath/libSkiaSharp.framework/libSkiaSharp\u0027",
            "source": "issue body (stack trace)",
            "interpretation": "The iOS-specific P/Invoke path for libSkiaSharp. DllNotFoundException here means the .framework bundle is not in the app bundle at runtime."
          },
          {
            "text": "it works in the emulator but not on a real device",
            "source": "issue body",
            "interpretation": "Classic signal for iOS linker stripping native frameworks. The simulator uses a different build pipeline (no signing, different linking) that preserves the framework."
          },
          {
            "text": "it works good on android and iOS simulator but not on a real IOS device",
            "source": "issue body",
            "interpretation": "Cross-platform confirmation rules out a SkiaSharp code bug. The managed code is correct \u2014 the native binary isn\u0027t being deployed."
          },
          {
            "text": "I have built a release build since I saw one post claiming you need to build it in release mode for the DLL to show up",
            "source": "issue body",
            "interpretation": "Reporter tried release mode, still fails. This rules out debug-only configuration issues but not linker behavior (which is typically more aggressive in release)."
          }
        ],
        "errorFingerprint": "DllNotFoundException:@rpath/libSkiaSharp.framework/libSkiaSharp:ios-device",
        "workarounds": [
          "Add \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E to the iOS .csproj to disable the managed linker (prevents framework stripping)",
          "For release builds, use \u003CMtouchLink\u003ESdkOnly\u003C/MtouchLink\u003E instead of full linking to preserve the native framework",
          "Ensure you are NOT using Windows Hot Restart for iOS deployment \u2014 it doesn\u0027t support native framework embedding. Deploy from a Mac.",
          "Add SkiaSharp.Views.Maui.Controls as a direct PackageReference in the application project (not just in the library) to ensure NativeAssets flow correctly",
          "Upgrade to SkiaSharp 3.x which has improved .NET MAUI integration"
        ],
        "nextQuestions": [
          "Is the reporter using Windows Hot Restart or deploying from a Mac?",
          "What specific iOS device and iOS version is being used?",
          "Does adding \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E resolve the issue?",
          "Is the NativeAssets.iOS package present in the build output?"
        ],
        "resolution": {
          "hypothesis": "The iOS managed linker strips the libSkiaSharp.framework from the app bundle during the build for real devices. The simulator build pipeline doesn\u0027t perform the same linking, which is why it works there. Alternatively, deploying via Windows Hot Restart doesn\u0027t embed native frameworks at all.",
          "proposals": [
            {
              "description": "Add \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E to the .csproj for the iOS target. This prevents the managed linker from stripping the native framework. For release builds, use \u003CMtouchLink\u003ESdkOnly\u003C/MtouchLink\u003E instead.",
              "title": "Disable iOS linker",
              "codeSnippet": "\u003CPropertyGroup Condition=\u0022$(TargetFramework.Contains(\u0027-ios\u0027))\u0022\u003E\n  \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E\n\u003C/PropertyGroup\u003E",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "If using Visual Studio on Windows with Hot Restart, switch to deploying from a Mac. Hot Restart does not support embedding native frameworks.",
              "title": "Deploy from Mac instead of Hot Restart",
              "confidence": 0.6,
              "effort": "trivial"
            },
            {
              "description": "Add SkiaSharp and SkiaSharp.Views.Maui.Controls as direct PackageReference in the executable MAUI project, not just via the OxyPlot.Maui.Skia transitive reference. This ensures NativeAssets.iOS is properly resolved.",
              "title": "Direct PackageReference in app project",
              "codeSnippet": "\u003CPackageReference Include=\u0022SkiaSharp.Views.Maui.Controls\u0022 Version=\u00222.88.3\u0022 /\u003E",
              "confidence": 0.65,
              "effort": "trivial"
            },
            {
              "description": "SkiaSharp 3.x includes improved MAUI integration and iOS packaging. Upgrading may resolve the deployment issue.",
              "title": "Upgrade to SkiaSharp 3.x",
              "confidence": 0.55,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Disable iOS linker",
          "recommendedReason": "This was confirmed as working by a community member in #2437. Simplest change with immediate effect. For production, can be refined to SdkOnly linking."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.78,
          "reason": "This is a well-understood iOS deployment issue with multiple workarounds identified in #2437. The issue is 3 years old with no comments, using outdated SkiaSharp 2.88.3. The same issue was already reported and resolved in #2437."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, native, iOS, MAUI labels",
            "risk": "low",
            "confidence": 0.92,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/iOS",
              "partner/maui"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #2437 (identical error, has community workarounds)",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 2437
          },
          {
            "type": "add-comment",
            "description": "Post diagnosis with workarounds from #2437",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the report. This is a known issue with the iOS managed linker stripping the native \u0060libSkiaSharp.framework\u0060 from the app bundle when deploying to real devices. The simulator uses a different build pipeline that doesn\u0027t have this problem.\n\nHere are workarounds you can try:\n\n1. **Disable the iOS linker** \u2014 add this to your \u0060.csproj\u0060:\n\n\u0060\u0060\u0060xml\n\u003CPropertyGroup Condition=\u0022$(TargetFramework.Contains(\u0027-ios\u0027))\u0022\u003E\n  \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E\n\u003C/PropertyGroup\u003E\n\u0060\u0060\u0060\n\nFor release builds, use \u0060\u003CMtouchLink\u003ESdkOnly\u003C/MtouchLink\u003E\u0060 instead.\n\n2. **If deploying from Windows with Hot Restart** \u2014 switch to deploying from a Mac. Hot Restart doesn\u0027t support embedding native frameworks.\n\n3. **Add a direct PackageReference** to \u0060SkiaSharp.Views.Maui.Controls\u0060 in your application project (not just via OxyPlot.Maui.Skia).\n\nSee also #2437 which has the same error and additional discussion. Additionally, upgrading to SkiaSharp 3.x may help as it has improved MAUI packaging."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2383,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:53:16Z",
        "currentLabels": []
      },
      "summary": "Question: Does SkiaSharp support a 24-bit RGB color type (Format24bppRgb equivalent from System.Drawing)?",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        }
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            1176
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "Skia\u0027s color type set has never included a 24-bit (3 bytes per pixel) type. Rgb888x is still 32-bit. This limitation is inherent to the Skia library and hasn\u0027t changed."
        }
      },
      "analysis": {
        "summary": "User asks whether SkiaSharp supports a 24-bit pixel format equivalent to System.Drawing.Imaging.PixelFormat.Format24bppRgb. Skia (and therefore SkiaSharp) does not support a true 24-bit (3 bytes per pixel) color type. The closest option is SKColorType.Rgb888x, which stores R, G, B in 8 bits each but uses a 32-bit word (4 bytes per pixel with the alpha byte ignored). The user can convert 24bpp data to 32bpp by expanding each pixel with a padding byte.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "SKColorType enum has no 24-bit (3 bytes per pixel) entry. Smallest RGB type with 8 bits per channel is Rgb888x at 4 bytes per pixel.",
            "relevance": "direct",
            "lines": "36-63"
          },
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "GetBytesPerPixel confirms Rgb888x returns 4 bytes, not 3. No color type returns 3 bytes per pixel.",
            "relevance": "direct",
            "lines": "79-115"
          },
          {
            "file": "externals/skia/include/core/SkColorType.h",
            "finding": "Upstream Skia defines kRGB_888x_SkColorType as \u0027pixel with 8 bits each for red, green, blue; in 32-bit word\u0027 \u2014 confirms the padding byte at C\u002B\u002B level.",
            "relevance": "context",
            "lines": "25"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "InstallPixels accepts SKImageInfo with custom colorType and rowBytes \u2014 user can use this with Rgb888x after converting pixel data from 24bpp to 32bpp.",
            "relevance": "direct",
            "lines": "591-615"
          }
        ],
        "rationale": "Classified as question because the user asks \u0027does skia support...\u0027 \u2014 there is no bug or feature request. Area is core SkiaSharp since SKColorType and SKImageInfo are in the binding/SkiaSharp layer. Issue #1176 asked the same question about BGR888 and was answered by the maintainer confirming no 24-bit type exists.",
        "keySignals": [
          {
            "text": "I want to convert an image which is in 24-bit color type to SKBitmap",
            "source": "issue body",
            "interpretation": "User has raw 24bpp pixel data and needs to load it into SkiaSharp. This is a usage question, not a bug."
          },
          {
            "text": "use 8 bits for each colors, no alpha, necessary to specify width, height and stride",
            "source": "issue body",
            "interpretation": "User understands the format requirements. They need to know the closest SKColorType and how to use InstallPixels."
          },
          {
            "text": "Does SKColorType support BGR888 type? \u2014 Unfortunately not at this point. There is a RGB 888x, but that is still 32-bit pixels.",
            "source": "issue #1176, mattleibow comment",
            "interpretation": "Identical question previously answered. Confirms Skia has no 24-bit color type."
          }
        ],
        "workarounds": [
          "Use SKColorType.Rgb888x with SKAlphaType.Opaque \u2014 this uses 4 bytes per pixel (R, G, B \u002B padding byte). Convert 24bpp source data to 32bpp by inserting a 0xFF padding byte after every 3 bytes.",
          "Use SKBitmap.Decode or SKImage.FromEncodedData to load encoded image files (PNG, JPEG, BMP) \u2014 Skia automatically converts from the file\u0027s pixel format to an appropriate internal format."
        ],
        "resolution": {
          "hypothesis": "User needs to load raw 24bpp pixel data into an SKBitmap. Since Skia has no 24-bit color type, the data must be expanded to 32bpp first.",
          "proposals": [
            {
              "description": "Convert the 24-bit pixel data to 32-bit by inserting a padding byte (0xFF) for each pixel, then use SKBitmap with SKColorType.Rgb888x and SKAlphaType.Opaque.",
              "title": "Expand 24bpp to Rgb888x",
              "codeSnippet": "// Convert 24bpp RGB data to 32bpp for SKBitmap\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex];     // R\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex \u002B 2]; // B\n            dest[3] = 0xFF;                   // padding\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "Alternatively, expand to BGRA format with alpha set to 0xFF. This is the platform-native format on most systems and may perform better for drawing.",
              "title": "Use Bgra8888 with Opaque alpha",
              "codeSnippet": "var info = new SKImageInfo(width, height, SKColorType.Bgra8888, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex \u002B 2]; // B\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex];     // R\n            dest[3] = 0xFF;                   // A\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "If the source is an image file (not raw pixels), use SKBitmap.Decode() which handles format conversion automatically.",
              "title": "Load from encoded file",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Expand 24bpp to Rgb888x",
          "recommendedReason": "Most direct translation of the user\u0027s requirements. Preserves the RGB channel order and is the closest SkiaSharp type to Format24bppRgb."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.9,
          "reason": "This is a usage question fully answerable from existing API knowledge. Same question was answered in #1176. No code change needed."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply question and core SkiaSharp labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/question",
              "area/SkiaSharp"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post answer explaining no 24-bit type exists and provide workaround code",
            "risk": "high",
            "confidence": 0.9,
            "comment": "SkiaSharp (and the underlying Skia library) does not have a true 24-bit (3 bytes per pixel) color type. All pixel formats use 1, 2, 4, 8, or 16 bytes per pixel.\n\nThe closest equivalent is \u0060SKColorType.Rgb888x\u0060, which stores 8 bits each for red, green, and blue in a **32-bit word** (the 4th byte is padding). To load 24bpp data, expand it to 32bpp by writing directly into the bitmap\u0027s pixel buffer:\n\n\u0060\u0060\u0060csharp\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex];     // R\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex \u002B 2]; // B\n            dest[3] = 0xFF;                   // padding\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();\n\u0060\u0060\u0060\n\nIf you\u0027re loading an encoded image file (PNG, JPEG, BMP), \u0060SKBitmap.Decode()\u0060 handles format conversion automatically \u2014 no manual pixel expansion needed.\n\nSee also #1176 which covers the same topic."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1176 (same question about 24-bit color type)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 1176
          },
          {
            "type": "close-issue",
            "description": "Close as answered",
            "risk": "medium",
            "confidence": 0.85
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 1898,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:53:16Z",
        "currentLabels": []
      },
      "summary": "Reporter observes that SkiaSharp.Views.Forms 2.88.0-preview.179 has an empty netcoreapp3.1 directory in NuGet Package Explorer. The directory actually contains _._placeholder files, which is a standard NuGet convention for declaring TFM support without dedicated assemblies \u2014 the netstandard2.0 assembly is used at runtime. Both netcoreapp3.1 (EOL Dec 2022) and Xamarin.Forms (superseded by MAUI) are obsolete, and SkiaSharp 3.x removed Views.Forms entirely.",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Install SkiaSharp.Views.Forms 2.88.0-preview.179",
            "Open the package in NuGet Package Explorer",
            "Observe the netcoreapp3.1 directory appears empty"
          ],
          "relatedIssues": [
            1561,
            1774
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.0-preview.127",
            "2.88.0-preview.179"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "The issue concerns netcoreapp3.1 support in SkiaSharp.Views.Forms, both of which are obsolete. netcoreapp3.1 reached EOL December 2022. Xamarin.Forms has been superseded by .NET MAUI. SkiaSharp 3.x removed Views.Forms entirely (PR #2505)."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.9,
          "reason": "The _._files in the netcoreapp3.1 directory are intentional NuGet packaging \u2014 they declare TFM support while falling back to netstandard2.0 assemblies. The stable 2.88.0 release shipped with the same packaging and netcoreapp3.1 WPF apps worked. The perceived \u0027missing DLLs\u0027 were never actually missing; the netstandard2.0 assembly provides the runtime support. Additionally, the entire Views.Forms package was removed in SkiaSharp 3.x.",
          "relatedPRs": [
            1774
          ]
        }
      },
      "analysis": {
        "summary": "The reporter misidentified NuGet _._placeholder files as missing DLL content. The netcoreapp3.1 support in SkiaSharp.Views.Forms was added via PR #1774 using the standard NuGet convention: _._placeholders in lib/netcoreapp3.1/ declare TFM compatibility while the netstandard2.0 assembly provides the actual runtime implementation. The .targets file in build/netcoreapp3.1/ handles WPF build integration. This is working-as-designed NuGet packaging, not a bug.",
        "codeInvestigation": [
          {
            "file": "nuget/SkiaSharp.Views.Forms.nuspec",
            "finding": "At v2.88.0-preview.179, the nuspec includes: dependency group for netcoreapp3.1 (with Xamarin.Forms and Xamarin.Forms.Platform.WPF), _._placeholder files in lib/netcoreapp3.1/ and ref/netcoreapp3.1/, and the SkiaSharp.Views.Forms.targets file copied to build/netcoreapp3.1/. This is the correct NuGet packaging pattern for declaring TFM support via netstandard fallback.",
            "relevance": "direct"
          },
          {
            "file": "nuget/SkiaSharp.Views.Forms.nuspec",
            "finding": "The nuspec was completely removed in commit bc5020b9e (PR #2505 \u2014 \u0027Modernize the repository and prepare SkiaSharp 3.0\u0027). SkiaSharp 3.x does not include Views.Forms at all, making this issue moot for current versions.",
            "relevance": "related"
          }
        ],
        "rationale": "Classified as type/question because the reporter describes expected behavior (empty directory in NuGet Package Explorer) as a bug, but the _._files ARE the intended support mechanism. The nuspec at v2.88.0-preview.179 correctly declares netcoreapp3.1 with _._placeholders, dependency groups, and .targets files \u2014 matching the pattern added in PR #1774. This is area/SkiaSharp.Views.Forms as it concerns the Views.Forms NuGet package specifically. Platform is Windows-Classic because netcoreapp3.1 \u002B Xamarin.Forms.WPF is the WPF desktop scenario.",
        "keySignals": [
          {
            "text": "netcoreapp3.1 directory is empty in Nuget Package Explorer",
            "source": "issue body",
            "interpretation": "Reporter is viewing _._placeholder files, which NuGet Package Explorer may display as empty. This is standard NuGet packaging for declaring TFM support without dedicated assemblies."
          },
          {
            "text": "Support for netcore 3.1 was added in 2.88.0-preview.127",
            "source": "issue body",
            "interpretation": "Correctly identifies PR #1774. The support WAS added \u2014 via _._placeholders \u002B netstandard2.0 fallback, not dedicated assemblies."
          },
          {
            "text": "nuspec includes _._in lib/netcoreapp3.1/ and ref/netcoreapp3.1/, plus .targets file",
            "source": "code search (v2.88.0-preview.179:nuget/SkiaSharp.Views.Forms.nuspec)",
            "interpretation": "Confirms the packaging is intentional and correct. The _._marker \u002B .targets file is the standard pattern for framework compatibility."
          }
        ],
        "workarounds": [
          "The netcoreapp3.1 support is working as designed \u2014 the _._files are NuGet placeholders that cause the netstandard2.0 assembly to be used at runtime. No workaround needed.",
          "For modern development, migrate to SkiaSharp.Views.Maui (for .NET MAUI) or SkiaSharp.Views.WPF (for WPF on .NET 6\u002B)."
        ],
        "resolution": {
          "hypothesis": "The reporter misunderstood NuGet _._placeholder files as missing content. The netcoreapp3.1 directory intentionally contains only _._files because the actual assembly comes from netstandard2.0 fallback resolution.",
          "proposals": [
            {
              "description": "The _._files are the standard NuGet mechanism for declaring TFM support without dedicated assemblies. The netstandard2.0 assembly provides the runtime implementation for netcoreapp3.1. Both TFMs (netcoreapp3.1 and Xamarin.Forms) are now obsolete.",
              "title": "Close as by-design",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Migrate from Xamarin.Forms \u002B netcoreapp3.1 to .NET MAUI \u002B net8.0 (or later) with SkiaSharp.Views.Maui. This is the supported path forward.",
              "title": "Upgrade to modern stack",
              "confidence": 0.95,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Close as by-design",
          "recommendedReason": "The packaging is correct \u2014 _._files are intentional NuGet convention. The issue doesn\u0027t describe any actual runtime failure. Both netcoreapp3.1 and Xamarin.Forms are EOL."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.88,
          "reason": "The _._files are working-as-designed NuGet packaging. No runtime issue was reported. Both netcoreapp3.1 and Xamarin.Forms are EOL, and SkiaSharp 3.x has removed Views.Forms entirely."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply question and Views.Forms labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/question",
              "area/SkiaSharp.Views.Forms",
              "os/Windows-Classic",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain NuGet _._convention and obsolescence of netcoreapp3.1 \u002B Xamarin.Forms",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. The \u0060netcoreapp3.1\u0060 directory in the NuGet package intentionally contains \u0060_._\u0060 placeholder files \u2014 this is a standard NuGet convention that declares framework compatibility while using the \u0060netstandard2.0\u0060 assembly at runtime. The \u0060.targets\u0060 file in \u0060build/netcoreapp3.1/\u0060 handles the WPF build integration. So the package does support netcoreapp3.1; it just doesn\u0027t need a dedicated assembly for it.\n\nThat said, both \u0060netcoreapp3.1\u0060 and \u0060Xamarin.Forms\u0060 have reached end-of-life. For new projects, SkiaSharp 3.x with \u0060SkiaSharp.Views.Maui\u0060 (for .NET MAUI) or \u0060SkiaSharp.Views.WPF\u0060 (for WPF on .NET 8\u002B) is the supported path forward."
          },
          {
            "type": "close-issue",
            "description": "Close as answered \u2014 packaging is by-design and both technologies are EOL",
            "risk": "medium",
            "confidence": 0.85
          },
          {
            "type": "link-related",
            "description": "Cross-reference original netcoreapp3.1 support issue",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 1561
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 1773,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:47:00Z",
        "currentLabels": []
      },
      "summary": "Accidental/test issue with no technical content \u2014 self-closed immediately by reporter",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.4
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.3
        }
      },
      "evidence": {
        "versionAnalysis": {
          "currentRelevance": "unlikely",
          "relevanceReason": "Issue has no technical content \u2014 title is \u0027TO DELETE PLEASE\u0027 with an empty body. Reporter self-closed within 26 minutes."
        }
      },
      "analysis": {
        "summary": "Empty issue opened accidentally or as a test. Title is \u0027TO DELETE PLEASE\u0027, body is empty, no comments. Reporter (vd3d) closed it themselves within 26 minutes. Issue is now locked with reason \u0027resolved\u0027.",
        "codeInvestigation": [
          {
            "file": "N/A",
            "finding": "No code investigation possible \u2014 issue contains no technical content, no types, no methods, no error messages, and no description of any behavior.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/question with low confidence because no type label fits an empty/accidental issue. Area defaults to area/SkiaSharp since no component is mentioned. No investigation is possible \u2014 there is zero technical content to analyze.",
        "keySignals": [
          {
            "text": "TO DELETE PLEASE",
            "source": "issue title",
            "interpretation": "Reporter explicitly indicates this issue was created in error and should be removed."
          },
          {
            "text": "Body is empty string",
            "source": "issue body",
            "interpretation": "No bug report, question, or feature request was ever filed."
          },
          {
            "text": "Closed by same user (vd3d) within 26 minutes",
            "source": "issue metadata",
            "interpretation": "Self-closed \u2014 reporter recognized the mistake immediately."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.99,
          "reason": "Issue is already closed and locked. It was an accidental creation with no technical content \u2014 no further action needed."
        },
        "actions": []
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 911,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:46:26Z",
        "currentLabels": []
      },
      "summary": "Feature request to add a \u0027Getting Started\u0027 section to README.md with curated links to introductory tutorials, platform-specific guides (Xamarin Forms, WPF, etc.), and API documentation to help new users find resources quickly.",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.92
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.95
        }
      },
      "evidence": {
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The README still lacks a dedicated \u0027Getting Started\u0027 section. While badge links to API docs and guides exist in the header, there is no curated section with introductory tutorials or platform-specific guides."
        }
      },
      "analysis": {
        "summary": "The reporter requests a \u0027Getting Started\u0027 section in README.md to centralize learning resources for new users. The README currently has badge links to API docs and guides in the header and a \u0027Using SkiaSharp\u0027 section with NuGet install instructions, but no curated onboarding section with tutorials or platform-specific guides. The request is straightforward documentation improvement.",
        "codeInvestigation": [
          {
            "file": "README.md",
            "finding": "Badge links to SkiaSharp API Docs, HarfBuzzSharp API Docs, and SkiaSharp Guides exist but are small badges in the header \u2014 easy to miss for newcomers.",
            "relevance": "direct",
            "lines": "11-13"
          },
          {
            "file": "README.md",
            "finding": "The \u0027Using SkiaSharp\u0027 section only covers NuGet installation. No tutorial links, no getting started guidance, no platform-specific setup instructions.",
            "relevance": "direct",
            "lines": "38-55"
          },
          {
            "file": "README.md",
            "finding": "The \u0027Building SkiaSharp\u0027 section links to documentation/building.md \u2014 shows precedent for linking to detailed guides from README.",
            "relevance": "context",
            "lines": "57-64"
          },
          {
            "file": "documentation/",
            "finding": "Contains architecture, building, packages, and API design docs. No \u0027getting-started.md\u0027 or tutorial content exists in the repo.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/documentation (not feature-request) because the ask is specifically about improving documentation content in README.md \u2014 no code changes needed. Area is area/Docs since it\u0027s purely about documentation structure. The request remains relevant: while the README has some doc links as badges, it still lacks the kind of curated \u0027Getting Started\u0027 section the reporter describes. Note that some of the specific links suggested by the reporter (Xamarin-era tutorials) may now be outdated and would need updating to current .NET/MAUI equivalents.",
        "keySignals": [
          {
            "text": "I am just starting with using SkiaSharp and the first thing I noticed was it wasn\u0027t obvious as to where to go to get started",
            "source": "issue body",
            "interpretation": "New user perspective \u2014 onboarding friction is real. README is the first thing users see."
          },
          {
            "text": "Could we add a \u0027Getting Started\u0027 to the readme.md?",
            "source": "issue body",
            "interpretation": "Concrete, actionable proposal with example content structure."
          },
          {
            "text": "I\u0027d be happy to collaborate on this and help out",
            "source": "issue body",
            "interpretation": "Reporter offered to contribute \u2014 could be invited to submit a PR."
          }
        ],
        "nextQuestions": [
          "Which tutorials and guides should be linked? The Xamarin-era links suggested in 2019 may be outdated.",
          "Should the Getting Started section link to Microsoft Learn docs for MAUI/SkiaSharp integration?",
          "Should the repo include its own getting-started guide, or just link to external resources?"
        ],
        "resolution": {
          "hypothesis": "The README lacks a discoverable \u0027Getting Started\u0027 section. Adding one with curated links to current documentation would improve the new user experience.",
          "proposals": [
            {
              "description": "Add a \u0027Getting Started\u0027 section between the introductory paragraph and \u0027Using SkiaSharp\u0027, with links to the Microsoft Learn SkiaSharp guides, API documentation, and platform-specific setup guides. Update the suggested links from the 2019 issue to current .NET/MAUI equivalents.",
              "title": "Add Getting Started section to README",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Since the reporter offered to collaborate, invite them to submit a PR with their proposed Getting Started section. This leverages their newcomer perspective for the best onboarding content.",
              "title": "Invite reporter to submit PR",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Add Getting Started section to README",
          "recommendedReason": "Low effort, high impact for new users. Can be done by maintainer or invited contributor. The reporter\u0027s template is a good starting point but needs updated links."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Valid documentation improvement that hasn\u0027t been addressed. The README still lacks a Getting Started section. Low effort to implement."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply documentation and docs area labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/documentation",
              "area/Docs"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the request and note that links need updating for current .NET ecosystem",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for this suggestion \u2014 a Getting Started section in the README would definitely help new users find their way.\n\nThe README currently has badge links to the API docs and guides, but they\u0027re easy to miss. A dedicated section with curated links would be a nice improvement.\n\nNote that some of the links you suggested (the Xamarin-era tutorials) have been superseded by newer .NET/MAUI resources. An updated version would want to link to the current Microsoft Learn documentation. If you\u0027re still interested in contributing this, a PR would be welcome."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 607,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:46:27Z",
        "currentLabels": [
          "type/enhancement",
          "os/iOS",
          "os/Android",
          "area/SkiaSharp.Views",
          "type/feature-request"
        ]
      },
      "summary": "SKTouchAction.Entered and SKTouchAction.Exited events are not fired on iOS and Android \u2014 only implemented on Windows and Tizen",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.9
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.88
        },
        "platforms": [
          "os/iOS",
          "os/Android"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Subscribe to Touch event on SKCanvasView on iOS or Android",
            "Observe that SKTouchAction.Entered and SKTouchAction.Exited are never raised when touch enters/exits the view bounds",
            "Same code works on Windows where PointerEntered/PointerExited are wired up"
          ],
          "environmentDetails": "Originally filed against Xamarin.Forms (2018). Still applies to MAUI as of current main branch.",
          "relatedIssues": [
            2106,
            2722,
            2493,
            309
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.x (Xamarin.Forms era, 2018)"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The MAUI-era Android and Apple SKTouchHandler classes still do not fire Entered/Exited events. The gap has persisted through the Xamarin.Forms to MAUI migration."
        }
      },
      "analysis": {
        "summary": "The SKTouchAction enum defines Entered and Exited values, but the iOS (Apple) and Android platform touch handlers never produce these actions. Windows fully implements them via PointerEntered/PointerExited, and Tizen partially implements Exited via PointStateType.Leave. This creates an inconsistent cross-platform API surface where developers write code expecting Entered/Exited on all platforms but it silently never fires on mobile.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/SKTouchEventArgs.cs",
            "finding": "SKTouchAction enum defines Entered (line 62) and Exited (line 67) as valid values, establishing the API contract.",
            "relevance": "direct",
            "lines": "60-69"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Windows/SKTouchHandler.cs",
            "finding": "Windows handler wires up PointerEntered to SKTouchAction.Entered and PointerExited to SKTouchAction.Exited. Full implementation.",
            "relevance": "direct",
            "lines": "59-66"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "finding": "Android handler only maps MotionEventActions Down/PointerDown/Move/Up/PointerUp/Cancel. No Entered/Exited handling. Would need to track touch position relative to view bounds during Move events.",
            "relevance": "direct",
            "lines": "63-108"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "finding": "Apple handler only maps TouchesBegan/TouchesMoved/TouchesEnded/TouchesCancelled. UIKit has no native entered/exited gesture \u2014 would need manual hit-testing during TouchesMoved.",
            "relevance": "direct",
            "lines": "54-95"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Tizen/SKTouchHandler.cs",
            "finding": "Tizen partially implements: PointStateType.Leave maps to SKTouchAction.Exited, but no Entered equivalent.",
            "relevance": "related",
            "lines": "65-73"
          }
        ],
        "rationale": "This is a feature request, not a bug \u2014 the enum values exist by design but were never wired up on iOS and Android. The reporter correctly identifies the inconsistency: UWP/Windows fires these events, but iOS/Android silently don\u0027t. The original Xamarin.Forms issue from 2018 still applies to MAUI because the same gap exists in the current platform touch handlers. Area is SkiaSharp.Views.Maui (not the older Forms package) since MAUI is the current implementation. The tenet/compatibility label applies because this is a cross-platform consistency gap.",
        "keySignals": [
          {
            "text": "Currently iOS is implemented only on UWP (because it is connected as a passthrough)",
            "source": "issue body",
            "interpretation": "Reporter identified that Entered/Exited only works on UWP, not iOS/Android."
          },
          {
            "text": "their absence isn\u0027t noted and is a bit confusing",
            "source": "issue body",
            "interpretation": "The API surface implies cross-platform support (enum values exist) but behavior differs silently."
          },
          {
            "text": "I spent a few hours fixing the behavior... then discovering that entered/exited wouldn\u0027t fire",
            "source": "comment #2",
            "interpretation": "Silent failure causes significant debugging time for developers who assume cross-platform parity."
          },
          {
            "text": "This is something that we will be looking at in the future.",
            "source": "comment #4 (mattleibow, maintainer)",
            "interpretation": "Maintainer acknowledged the request in Dec 2018 but it remains unimplemented."
          }
        ],
        "workarounds": [
          "Track touch position relative to canvas size during SKTouchAction.Moved events and synthesize Entered/Exited logic in application code (as reporter demonstrates in comment #3)"
        ],
        "nextQuestions": [
          "Should the implementation use the reporter\u0027s approach (track bounds during Move events) or platform-specific hover/pointer APIs?",
          "Should Entered/Exited also work for mouse hover (not just touch) on platforms that support it?",
          "Does SKGLView need the same treatment?"
        ],
        "resolution": {
          "hypothesis": "iOS and Android native touch APIs don\u0027t have direct Entered/Exited equivalents. Implementation requires manual hit-testing during move events to detect when the touch crosses view bounds.",
          "proposals": [
            {
              "description": "In the Android and Apple SKTouchHandler classes, track whether the touch is inside the view bounds. During Move events, compare current position to view bounds and fire SKTouchAction.Entered or SKTouchAction.Exited when the inside/outside state changes. This matches the reporter\u0027s pseudocode and the approach they used as a workaround.",
              "title": "Synthesize Entered/Exited during Move events",
              "confidence": 0.75,
              "effort": "small"
            },
            {
              "description": "Developers can track entered/exited state themselves in their Touch event handler by comparing touch coordinates to canvas bounds during Moved events, as demonstrated by the reporter in comment #3. Use CanvasSize from OnPaintSurface for accurate bounds that account for DPI scaling.",
              "title": "Application-level workaround",
              "codeSnippet": "// Store canvas size from OnPaintSurface:\nSKSize _canvasSize;\nvoid OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    _canvasSize = e.Info.Size;\n    // ... drawing code\n}\n\n// Track entered/exited in Touch handler:\nbool _wasInside = true;\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    if (e.ActionType == SKTouchAction.Moved)\n    {\n        var inside = e.Location.X \u003E= 0 \u0026\u0026 e.Location.Y \u003E= 0\n            \u0026\u0026 e.Location.X \u003C _canvasSize.Width\n            \u0026\u0026 e.Location.Y \u003C _canvasSize.Height;\n        if (inside != _wasInside)\n        {\n            _wasInside = inside;\n            // Handle entered/exited logic here\n        }\n    }\n    e.Handled = true;\n}",
              "confidence": 0.75,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Application-level workaround",
          "recommendedReason": "Immediate solution reporters can use today. The framework-level fix requires changes to platform handlers and should be a separate PR."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "Well-understood gap with clear implementation path. Needs design decision on hover vs touch-only semantics before implementation."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Update labels to reflect current MAUI area and add compatibility tenet",
            "risk": "low",
            "confidence": 0.88,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views.Maui",
              "os/iOS",
              "os/Android",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the gap persists in MAUI, provide workaround with canvas-size-based bounds, note related issues",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for reporting this \u2014 the gap still exists in the MAUI-era codebase. The Windows handler wires up \u0060PointerEntered\u0060/\u0060PointerExited\u0060 to \u0060SKTouchAction.Entered\u0060/\u0060Exited\u0060, but the Android and iOS handlers don\u0027t synthesize these during move events.\n\nAs a workaround, you can track entered/exited state in your Touch handler by comparing the touch location to canvas bounds during \u0060Moved\u0060 events. Use \u0060CanvasSize\u0060 from \u0060OnPaintSurface\u0060 for accurate bounds that respect DPI scaling:\n\n\u0060\u0060\u0060csharp\nSKSize _canvasSize;\nbool _wasInside = true;\n\nvoid OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    _canvasSize = e.Info.Size;\n    // ... drawing code\n}\n\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    if (e.ActionType == SKTouchAction.Moved)\n    {\n        var inside = e.Location.X \u003E= 0 \u0026\u0026 e.Location.Y \u003E= 0\n            \u0026\u0026 e.Location.X \u003C _canvasSize.Width\n            \u0026\u0026 e.Location.Y \u003C _canvasSize.Height;\n        if (inside != _wasInside)\n        {\n            _wasInside = inside;\n            // Handle entered/exited logic here\n        }\n    }\n    e.Handled = true;\n}\n\u0060\u0060\u0060\n\nNote: this only detects entry/exit during active touch-move gestures \u2014 it won\u0027t fire if the touch is released outside without a preceding move. For full coverage, also check bounds on \u0060Pressed\u0060 and \u0060Released\u0060.\n\nRelated: #2106, #2722, #2493."
          },
          {
            "type": "link-related",
            "description": "Cross-reference pointer events issue on iOS/Android",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 2106
          },
          {
            "type": "link-related",
            "description": "Cross-reference Touch not firing all events on iOS",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 2722
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 576,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:38:00Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp",
          "backend/OpenGL"
        ]
      },
      "summary": "GPU-backed SKSurface memory leak on Intel HD Graphics 520 caused by not disposing SKImage instances returned by Snapshot() before overwriting references. The reporter creates a GPU surface with GRContext/OpenGL, calls Snapshot() to capture the rendered content, and stores the resulting SKImage \u2014 but overwrites the previous SKImage reference without disposing it first, causing 30-40MB memory step-ups per iteration until crash.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.65
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create GPU-backed SKSurface with GRContext (OpenGL) and SKImageInfo",
            "Draw to the surface\u0027s Canvas",
            "Call surface.Snapshot() and store the resulting SKImage in a collection",
            "Dispose the surface but NOT the previous SKImage at the same dictionary key",
            "Repeat \u2014 observe 30-40MB memory growth per iteration"
          ],
          "codeSnippets": [
            "var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n//var surface = SKSurface.Create(new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\nsurface.Dispose();\n_skiaMain.DisplayPlaneRecompose[plane] = false;"
          ],
          "screenshots": [
            {
              "url": "https://user-images.githubusercontent.com/41022806/42469527-fdefdc92-8385-11e8-96d5-cfa8b693ae34.png",
              "description": "Visual Studio memory usage showing escalating memory consumption"
            }
          ],
          "environmentDetails": "Intel HD Graphics 520, Windows, OpenGL backend",
          "relatedIssues": [
            705,
            1244,
            3388
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "memory-leak",
          "errorMessage": "30-40MB step ups in memory usage until eventually it crashes",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The Snapshot() method still returns a new SKImage that the caller must dispose. The fundamental pattern of GPU-backed SKImage requiring explicit disposal hasn\u0027t changed. However, the root cause was user code not disposing \u2014 SkiaSharp itself does not leak."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.85,
          "reason": "This is not a SkiaSharp bug \u2014 it\u0027s a usage issue. The reporter confirmed the leak was caused by overwriting SKImage references without disposing the previous image. The \u0027fix\u0027 is in user code, not in SkiaSharp. No code change is needed."
        }
      },
      "analysis": {
        "summary": "The memory leak is caused by the reporter\u0027s code overwriting SKImage references (from Snapshot()) without first disposing the previous image. Each GPU-backed SKImage holds a GPU texture that is only released when Dispose is called (or the finalizer runs, which is non-deterministic and insufficient for GPU resources). The maintainer correctly identified the cause, and the reporter confirmed it.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKSurface.cs",
            "finding": "Snapshot() creates a new SKImage via sk_surface_new_image_snapshot. Returns a new owned object \u2014 caller is responsible for disposal. No caching or reuse of previous snapshot.",
            "relevance": "direct",
            "lines": "274-278"
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "finding": "SKImage implements ISKReferenceCounted. Dispose calls SafeUnRef to decrement the Skia refcount. Finalizer will eventually release, but GC timing is non-deterministic \u2014 especially insufficient for GPU textures that consume VRAM.",
            "relevance": "direct",
            "lines": "16-24"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "DisposeNative for ISKReferenceCounted objects calls SafeUnRef. This is the mechanism that releases the underlying GPU resource when Dispose is called.",
            "relevance": "related",
            "lines": "94-98"
          },
          {
            "file": "binding/SkiaSharp/GRContext.cs",
            "finding": "GRContext exposes PurgeResources(), PurgeUnusedResources(), and PurgeUnlockedResources() \u2014 these can be used as additional mitigation to force GPU resource cleanup.",
            "relevance": "related",
            "lines": "159-169"
          }
        ],
        "rationale": "Classified as type/bug with reduced confidence (0.65) because the root cause is user code not following proper disposal patterns, not a defect in SkiaSharp. The area is area/SkiaSharp since the core SKSurface/SKImage APIs are involved. The backend is OpenGL since the reporter explicitly mentions GPU rendering via GRContext. The issue was reopened (state_reason: reopened) despite being resolved in comments, suggesting it may need a formal close with explanation. The severity is medium because while memory exhaustion and crash occur, the fix is straightforward user-side disposal.",
        "keySignals": [
          {
            "text": "_skiaMain.DisplayImages[plane] = surface.Snapshot();",
            "source": "issue body",
            "interpretation": "Overwrites dictionary entry without disposing previous SKImage \u2014 classic leak of IDisposable GPU resource."
          },
          {
            "text": "when I would overwrite the SkImage without disposing first then the ref was getting lost and when it was getting lost in the GPU memory GC.Collect was not cleaning up the lost reference",
            "source": "comment by mclose90 (reporter)",
            "interpretation": "Reporter confirmed root cause is not disposing SKImage before overwriting. GC finalizer alone is insufficient for timely GPU resource release."
          },
          {
            "text": "This line: _skiaMain.DisplayImages[plane] = surface.Snapshot(); may be the cause. What is happening here is that you are making a copy of the surface, and storing it in memory.",
            "source": "comment by mattleibow (maintainer)",
            "interpretation": "Maintainer correctly diagnosed the issue as user-side disposal problem."
          },
          {
            "text": "The the issue only occurs when my laptop is attempting to run my application using Intels HD Graphics 520 to render.",
            "source": "issue body",
            "interpretation": "Intel integrated GPU may have tighter memory constraints making the leak more visible, but the fundamental cause is disposal, not driver-specific."
          }
        ],
        "errorFingerprint": "memory-leak-SKImage-Snapshot-GPU-OpenGL",
        "workarounds": [
          "Dispose the previous SKImage before overwriting the reference: if (_skiaMain.DisplayImages.TryGetValue(plane, out var old)) old?.Dispose();",
          "Call GRContext.PurgeUnusedResources() periodically to reclaim GPU memory from unreferenced resources",
          "Use \u0027using\u0027 statements or try/finally blocks to ensure SKImage disposal"
        ],
        "nextQuestions": [
          "Is the issue still open because the reporter has a remaining leak even after fixing disposal, or was it reopened automatically?",
          "Should SkiaSharp warn or document the pattern of disposing previous Snapshot results more prominently?"
        ],
        "resolution": {
          "hypothesis": "The user\u0027s code overwrites SKImage references returned by Snapshot() without disposing the previous instance, leaking GPU texture memory. On Intel integrated GPUs with limited VRAM, this manifests as rapid 30-40MB growth until crash. The GC finalizer eventually decrements the Skia refcount, but not fast enough to prevent VRAM exhaustion.",
          "proposals": [
            {
              "description": "Before assigning a new Snapshot to the dictionary, dispose the existing image at that key. This is the direct fix for the leak.",
              "title": "Dispose previous SKImage before overwriting",
              "codeSnippet": "// Before: _skiaMain.DisplayImages[plane] = surface.Snapshot();\n// After:\nif (_skiaMain.DisplayImages.TryGetValue(plane, out var previousImage))\n    previousImage?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Call GRContext.Flush() followed by PurgeUnusedResources() periodically as a supplemental safety net. This is NOT a substitute for explicit disposal \u2014 use in addition to Proposal 1.",
              "title": "Periodic GPU resource purge",
              "codeSnippet": "// Supplemental \u2014 use in addition to explicit disposal:\n_skiaGlControl.GRContext.Flush();\n_skiaGlControl.GRContext.PurgeUnusedResources(5000);",
              "confidence": 0.6,
              "effort": "trivial"
            },
            {
              "description": "Restructure the code to use \u0027using\u0027 statements or try/finally to ensure deterministic cleanup of both surfaces and images.",
              "title": "Use using pattern for surface and snapshot",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Dispose previous SKImage before overwriting",
          "recommendedReason": "Directly addresses the confirmed root cause. The reporter themselves confirmed this was the issue. Trivial code change with near-certain fix."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "Root cause was confirmed by both maintainer and reporter as user-side disposal issue. The fix is to dispose SKImage before overwriting. No SkiaSharp code change needed. Issue was reopened but the resolution in comments is complete."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp, backend/OpenGL all match",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "backend/OpenGL"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post closing comment summarizing the confirmed root cause and workaround",
            "risk": "high",
            "confidence": 0.8,
            "comment": "This issue was diagnosed in the original discussion \u2014 the memory leak occurs because \u0060SKImage\u0060 instances returned by \u0060Snapshot()\u0060 are overwritten in the dictionary without disposing the previous image first.\n\nHere\u0027s the fix:\n\n\u0060\u0060\u0060csharp\nif (_skiaMain.DisplayImages.TryGetValue(plane, out var previousImage))\n    previousImage?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\n\u0060\u0060\u0060\n\nGPU-backed \u0060SKImage\u0060 objects hold GPU texture memory that is only released when \u0060Dispose()\u0060 is called. The GC finalizer will eventually run, but not fast enough to prevent VRAM exhaustion \u2014 especially on integrated GPUs with limited memory like Intel HD Graphics 520.\n\nAs a supplemental safety measure, you can periodically flush and purge unused GPU resources (this is not a substitute for explicit disposal):\n\n\u0060\u0060\u0060csharp\ngrContext.Flush();\ngrContext.PurgeUnusedResources(5000);\n\u0060\u0060\u0060\n\n**Note:** If you access \u0060DisplayImages\u0060 from multiple threads, protect dictionary access with a lock to prevent race conditions.\n\nClosing as the root cause was confirmed by the original reporter."
          },
          {
            "type": "close-issue",
            "description": "Close as resolved \u2014 root cause identified and confirmed by reporter",
            "risk": "medium",
            "confidence": 0.8
          },
          {
            "type": "link-related",
            "description": "Related GPU memory management issue in SKGLView",
            "risk": "low",
            "confidence": 0.65,
            "linkedIssue": 705
          },
          {
            "type": "link-related",
            "description": "Related GPU memory leak report with AccessViolationException",
            "risk": "low",
            "confidence": 0.6,
            "linkedIssue": 1244
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 552,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:33:51Z",
        "currentLabels": [
          "type/enhancement",
          "area/SkiaSharp.Views"
        ]
      },
      "summary": "Maintainer-filed enhancement to investigate reusing SKSurface instances across draw calls in all SkiaSharp view implementations. Constructing SKSurface each frame is reported as expensive, and related issue #534 identified slow GTK rendering from this pattern. Currently, most views (WPF, WinForms, WinUI, Blazor, Android, Apple) create a new SKSurface per frame even though they reuse the underlying backing buffer. Only the GTK3 SKDrawingArea actually caches and reuses the SKSurface object itself.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            534,
            1251,
            1617,
            2190
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "Most view implementations still create a new SKSurface per frame. Only GTK3 reuses the surface. The core pattern has not changed since the issue was filed, though #1617 refactored the Android surface factory without addressing surface reuse."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.9,
          "reason": "Code investigation shows most platforms still create SKSurface per frame. GTK3 is the only view that reuses the SKSurface object. #1617 refactored Android but didn\u0027t add surface reuse.",
          "relatedPRs": [
            1617
          ]
        }
      },
      "analysis": {
        "summary": "All SkiaSharp view implementations except GTK3 create a new SKSurface per draw frame via SKSurface.Create(). The backing memory (bitmaps, pixel buffers) is already reused when the size doesn\u0027t change, but the SKSurface object itself is allocated and disposed each frame. GTK3\u0027s SKDrawingArea demonstrates the reuse pattern \u2014 it stores the surface as a field and only recreates it when dimensions change. Applying this pattern across all views would eliminate per-frame SKSurface allocations, reducing GC pressure in high-frame-rate scenarios.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Gtk3/SKDrawingArea.cs",
            "finding": "GTK3 stores SKSurface as field \u0027surface\u0027, only recreates when pix dimensions change (line 78-88). This is the ONLY view that reuses SKSurface. Model to follow for other platforms.",
            "relevance": "direct",
            "lines": "12-87"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Apple/SKCGSurfaceFactory.cs",
            "finding": "CreateSurface() reuses the bitmapData/dataProvider when memory size matches, but always calls SKSurface.Create() returning a new surface per frame (line 66). Surface itself is not cached.",
            "relevance": "direct",
            "lines": "25-66"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SurfaceFactory.cs",
            "finding": "CreateSurface() reuses the Android Bitmap when dimensions match, but calls SKSurface.Create() every frame with bitmap.LockPixels() (line 50). Surface not cached.",
            "relevance": "direct",
            "lines": "30-50"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "finding": "OnRender creates SKSurface in a using block every frame (line 73). WriteableBitmap is reused but surface is not.",
            "relevance": "direct",
            "lines": "71-84"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "OnPaint creates SKSurface in a using block every frame (line 46). System.Drawing.Bitmap reused, surface not.",
            "relevance": "direct",
            "lines": "43-52"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SKCanvasView.razor.cs",
            "finding": "OnRenderFrame creates SKSurface in a using block every frame (line 95). Pixel buffer reused, surface not.",
            "relevance": "direct",
            "lines": "93-106"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "finding": "DoInvalidate creates SKSurface in a using block every frame (line 195). WriteableBitmap reused, surface not.",
            "relevance": "direct",
            "lines": "193-206"
          }
        ],
        "rationale": "Classified as enhancement (not bug) because the existing code works correctly \u2014 this is a performance optimization opportunity. The issue was filed by the maintainer (mattleibow) and explicitly labeled as type/enhancement. The area is clearly SkiaSharp.Views since all affected code is in the view layer. The performance tenet applies since this is about reducing per-frame allocations.",
        "keySignals": [
          {
            "text": "constructing a SKSurface is expensive, so we should see if we can reuse instances across draws",
            "source": "issue body",
            "interpretation": "Maintainer identifies per-frame SKSurface construction as a performance concern."
          },
          {
            "text": "PR that was created to improve drawing: #534",
            "source": "issue body",
            "interpretation": "GTK slow rendering was the original catalyst \u2014 #534 was about flickering/slow resize on Linux."
          },
          {
            "text": "GTK3 SKDrawingArea stores surface as a field and only recreates on resize",
            "source": "code search",
            "interpretation": "One platform already implements the reuse pattern, proving feasibility."
          },
          {
            "text": "SkSwapChainPanel makes unnecessary per-frame heap allocations (#1251)",
            "source": "related issue",
            "interpretation": "Community also reports per-frame allocation as a performance issue in WinUI view."
          }
        ],
        "nextQuestions": [
          "How expensive is SKSurface.Create() when given pre-allocated memory? Need benchmarks comparing new-per-frame vs reuse.",
          "For views using LockPixels/BackBuffer patterns (Android, WPF), can a cached SKSurface be re-pointed at the locked memory each frame, or does a new surface need to be created?",
          "Does SKSurface.Create with the same memory pointer return an internally cached surface, or always allocate a new Skia object?",
          "Should SKPaintSurfaceEventArgs also be reused per #1251\u0027s suggestion to further reduce per-frame allocations?"
        ],
        "resolution": {
          "hypothesis": "SKSurface.Create() has non-trivial cost even when wrapping pre-allocated memory, because it creates a new SkSurface C\u002B\u002B object each call. Caching the SKSurface and reusing it when the backing memory and dimensions haven\u0027t changed would eliminate this cost.",
          "proposals": [
            {
              "description": "Store SKSurface as a field in each factory/view. Only recreate when dimensions change (like GTK3\u0027s SKDrawingArea already does). For Apple\u0027s SKCGSurfaceFactory: cache the surface alongside bitmapData. For Android\u0027s SurfaceFactory: cache alongside bitmap. For WPF/WinForms/WinUI/Blazor: promote from local using-block to field with disposal on resize.",
              "title": "Apply GTK3 pattern to all factory classes",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "Before changing all views, benchmark SKSurface.Create() with pre-allocated memory to quantify the actual cost. If trivial, the optimization may not be worth the added complexity. Use BenchmarkDotNet to compare new-per-frame vs reuse patterns.",
              "title": "Benchmark first, then optimize",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Create a surface pool keyed by SKImageInfo. Views check out a surface, use it, and return it. More complex but handles dynamic sizing better than per-field caching.",
              "title": "Pool SKSurface instances",
              "confidence": 0.5,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Benchmark first, then optimize",
          "recommendedReason": "Without benchmarks, it\u0027s unclear if SKSurface.Create() with pre-allocated memory is truly expensive. The GTK3 pattern works but adding cached state to all views increases complexity and risk of use-after-dispose bugs. Measure first, then apply the GTK3 pattern selectively to views where the cost is meaningful."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Valid performance enhancement filed by maintainer. Most views still exhibit the per-frame SKSurface allocation pattern. Related issue #1251 also reports per-frame allocation concerns. The issue remains actionable."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add performance tenet label; existing type/enhancement and area/SkiaSharp.Views labels are already correct",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "tenet/performance"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1251 which reports the same per-frame allocation concern for SKSwapChainPanel",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 1251
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 533,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:25:36Z",
        "currentLabels": [
          "type/bug",
          "type/enhancement",
          "status/help-wanted",
          "os/Android",
          "area/SkiaSharp.Views",
          "backend/OpenGL"
        ]
      },
      "summary": "Android SKGLView renders at uncapped framerate (300\u002B FPS) after switch from GLSurfaceView to GLTextureView in v1.60.1. The custom GLTextureView does not call eglSwapInterval, so VSync is not enforced, causing excessive CPU/GPU/battery drain when HasRenderLoop is enabled.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.85
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Android"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an Android app with SKGLView (or SKGLTextureView)",
            "Set HasRenderLoop = true (or RenderMode = Rendermode.Continuously)",
            "Measure FPS using Stopwatch in PaintSurface handler",
            "Observe FPS of 300-1200\u002B instead of display-capped 60 FPS"
          ],
          "environmentDetails": "Originally reported on Samsung Galaxy S7 Edge, Android 7 API 24, SkiaSharp 1.60.1. Confirmed on emulators (1200 FPS) and Motorola Moto g6 (140 FPS), Galaxy Note 3 (230 FPS).",
          "relatedIssues": [
            729
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "performance",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net7.0-android",
            "net8.0-android"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.59.3",
            "1.60.1"
          ],
          "workedIn": "1.59.3",
          "brokeIn": "1.60.1",
          "currentRelevance": "likely",
          "relevanceReason": "The GLTextureView code is still in the current codebase and still does not call eglSwapInterval. The same Rendermode.Continuously loop runs without any frame pacing. SKGLTextureView is the default GL view for Android in both Xamarin.Forms and MAUI."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "GLSurfaceView (used in v1.59.3) internally calls eglSwapInterval(1) which enforces VSync. The replacement GLTextureView (v1.60.1\u002B) does not, so the render loop runs uncapped.",
          "workedInVersion": "1.59.3",
          "brokeInVersion": "1.60.1"
        }
      },
      "analysis": {
        "summary": "When SkiaSharp switched from Android\u0027s GLSurfaceView to a custom GLTextureView in v1.60.1, VSync-based frame pacing was lost. GLSurfaceView internally uses eglSwapInterval(1), capping rendering to the display\u0027s refresh rate. The custom GLTextureView never calls eglSwapInterval, so Rendermode.Continuously loops as fast as the GPU can render \u2014 300-1200\u002B FPS, wasting battery and CPU/GPU resources.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "finding": "EglHelper.Swap() calls egl.EglSwapBuffers but never calls eglSwapInterval. Without eglSwapInterval(1), EGL swap does not block on VSync, so the render loop runs uncapped.",
            "relevance": "direct",
            "lines": "634-641"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "finding": "IsReadyToDraw() returns true continuously when renderMode == Rendermode.Continuously, with no frame-pacing delay. The while loop in GuardedRun spins as fast as swap\u002Brender allows.",
            "relevance": "direct",
            "lines": "1081-1083"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLTextureView.cs",
            "finding": "SKGLTextureView.Initialize() does not set any frame pacing \u2014 just sets EGL version, config, and renderer. No Choreographer or eglSwapInterval setup.",
            "relevance": "direct",
            "lines": "36-43"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLSurfaceView.cs",
            "finding": "SKGLSurfaceView extends Android.Opengl.GLSurfaceView which internally manages eglSwapInterval. This was the previous implementation that DID have VSync.",
            "relevance": "related",
            "lines": "9"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.Android.cs",
            "finding": "MAUI handler maps HasRenderLoop to Rendermode.Continuously/WhenDirty on the same SKGLTextureView \u2014 confirming MAUI apps are also affected by the uncapped framerate.",
            "relevance": "related",
            "lines": "61-68"
          }
        ],
        "rationale": "Classified as enhancement rather than bug because the maintainer explicitly stated \u0027SkiaSharp will always render as fast as possible\u0027 and that frame-rate limiting was never an intentional feature. However, this is a regression in practical behavior (VSync was inherited from GLSurfaceView) and causes real resource waste. The area is SkiaSharp.Views (Android GL view layer), with performance tenet due to battery drain. Medium severity \u2014 not a crash but a significant resource problem for render-loop apps.",
        "keySignals": [
          {
            "text": "Application framerate went from a capped 60fps to a ~300fps",
            "source": "issue body",
            "interpretation": "Clear regression in frame pacing behavior after the GLSurfaceView to TextureView switch."
          },
          {
            "text": "I _see_ the change, and I think it has to do with the fact that we are no longer using the old GLSurfaceView but the new TextureView",
            "source": "comment #2 (mattleibow)",
            "interpretation": "Maintainer confirmed root cause is the view type change."
          },
          {
            "text": "Having uncapped is nice, but a heavy drain. Also, it is no point having the updates faster than the screen - that wastes resources.",
            "source": "comment #8 (mattleibow)",
            "interpretation": "Maintainer agrees this should be fixed \u2014 rendering faster than display refresh is wasteful."
          },
          {
            "text": "We might be able to look at Choreographer",
            "source": "comment #9 (mattleibow)",
            "interpretation": "Maintainer identified Android Choreographer as the proper fix approach for display-synced rendering."
          },
          {
            "text": "Noticing 1.2K FPS in some emulators",
            "source": "comment #6 (mattleibow)",
            "interpretation": "Problem persists and is extreme in some environments."
          }
        ],
        "workarounds": [
          "Use time-based animation (delta-time) instead of frame-based animation to decouple logic from frame rate",
          "Implement a manual frame limiter using Stopwatch to skip rendering when elapsed time is less than target interval (e.g., 1000/60 ms)",
          "Use RenderMode = Rendermode.WhenDirty and call RequestRender() from a timer at the desired interval"
        ],
        "nextQuestions": [
          "Would adding eglSwapInterval(1) to the EglHelper.CreateSurface path be sufficient, or would it break apps that want uncapped rendering?",
          "Should frame pacing be opt-in (new property like TargetFrameRate) or opt-out (VSync by default with an option to disable)?",
          "Is Android Choreographer the right approach, or is eglSwapInterval(1) simpler and sufficient for most use cases?"
        ],
        "resolution": {
          "hypothesis": "The GLTextureView never calls eglSwapInterval(1), so EGL swap buffers returns immediately instead of blocking until VSync. Adding eglSwapInterval or integrating Android Choreographer would cap rendering to the display refresh rate.",
          "proposals": [
            {
              "description": "Call eglSwapInterval(display, 1) in the EglHelper after creating the EGL surface. This is the simplest fix and mirrors what GLSurfaceView does internally. It caps rendering to the display\u0027s refresh rate via VSync.",
              "title": "Add eglSwapInterval(1) to EglHelper",
              "confidence": 0.75,
              "effort": "small"
            },
            {
              "description": "Use Android\u0027s Choreographer.postFrameCallback to schedule rendering at the display\u0027s refresh rate. This is the approach recommended by the maintainer and provides better frame pacing than eglSwapInterval alone. The Frame Pacing Library (games SDK) is an even more sophisticated option but harder to integrate.",
              "title": "Integrate Android Choreographer for frame pacing",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "As a workaround, set RenderMode to WhenDirty and use a timer to call RequestRender() at the desired frame rate. Note: System.Timers.Timer may not be ideal on Android \u2014 consider using Android.OS.Handler or View.PostDelayed() instead. Be sure to dispose the timer when the view is destroyed, and call OnPause/OnResume for proper lifecycle management.",
              "title": "Use WhenDirty mode with timer-based invalidation",
              "codeSnippet": "// Set the view to only render on demand\nskglView.RenderMode = Rendermode.WhenDirty;\n\n// Timer-based invalidation at ~60 FPS\n// Note: store timer as a field and dispose on cleanup\nvar timer = new System.Timers.Timer(16.67);\ntimer.Elapsed \u002B= (s, e) =\u003E skglView.RequestRender();\ntimer.Start();\n\n// In cleanup/Dispose:\n// timer.Stop();\n// timer.Dispose();",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Decouple animation from frame rate by using elapsed time between frames. This doesn\u0027t reduce GPU usage but makes animations correct regardless of FPS. Initialize lastFrame before first use to avoid a large delta on the first frame.",
              "title": "Use delta-time for animation logic",
              "codeSnippet": "Stopwatch sw = Stopwatch.StartNew();\nTimeSpan lastFrame = sw.Elapsed; // Initialize to avoid large first-frame delta\n\nvoid OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = sw.Elapsed;\n    var deltaTime = (now - lastFrame).TotalSeconds;\n    lastFrame = now;\n    \n    // Use deltaTime for all animation:\n    position \u002B= velocity * (float)deltaTime;\n}",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Use WhenDirty mode with timer-based invalidation",
          "recommendedReason": "Gives immediate relief with no engine changes needed. Users can control exact frame rate. The proper fix (eglSwapInterval or Choreographer) requires engine-level changes and design decisions about opt-in vs opt-out."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.8,
          "reason": "Root cause is well-understood (missing eglSwapInterval/Choreographer in GLTextureView), but the fix requires a design decision: should VSync be default, opt-in, or configurable? The maintainer has been tracking this since 2018 and identified Choreographer as the approach."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Normalize labels to single type (enhancement, not bug \u2014 maintainer confirmed uncapped was by design)",
            "risk": "low",
            "confidence": 0.85,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "os/Android",
              "backend/OpenGL",
              "tenet/performance"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround for frame pacing",
            "risk": "high",
            "confidence": 0.75,
            "comment": "This issue is still relevant in the current codebase. The root cause is confirmed: \u0060GLTextureView\u0060 (which replaced \u0060GLSurfaceView\u0060 in v1.60.1) does not call \u0060eglSwapInterval\u0060, so the render loop runs uncapped when using \u0060Rendermode.Continuously\u0060.\n\nHere\u0027s a workaround you can use: switch to \u0060Rendermode.WhenDirty\u0060 and drive rendering from a timer at your target frame rate:\n\n\u0060\u0060\u0060csharp\n// Set the view to only render on demand\nskglView.RenderMode = Rendermode.WhenDirty;\n\n// Timer-based invalidation at ~60 FPS\n// Store timer as a field and dispose on cleanup\nvar timer = new System.Timers.Timer(16.67);\ntimer.Elapsed \u002B= (s, e) =\u003E skglView.RequestRender();\ntimer.Start();\n\n// In cleanup/Dispose:\n// timer.Stop();\n// timer.Dispose();\n\u0060\u0060\u0060\n\n**Note:** On Android, \u0060Android.OS.Handler\u0060 or \u0060View.PostDelayed()\u0060 may be more reliable than \u0060System.Timers.Timer\u0060 for frame timing. Be sure to call \u0060OnPause()\u0060/\u0060OnResume()\u0060 for proper lifecycle management.\n\nFor animation correctness regardless of frame rate, use delta-time (initialize \u0060lastFrame\u0060 to avoid a large first-frame delta):\n\n\u0060\u0060\u0060csharp\nvar sw = Stopwatch.StartNew();\nvar lastFrame = sw.Elapsed;\n\nvoid OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = sw.Elapsed;\n    var deltaTime = (now - lastFrame).TotalSeconds;\n    lastFrame = now;\n    position \u002B= velocity * (float)deltaTime;\n}\n\u0060\u0060\u0060\n\nA proper engine-level fix would involve either adding \u0060eglSwapInterval(1)\u0060 to the EGL setup, or integrating Android\u0027s Choreographer API for display-synced rendering. Both approaches have tradeoffs around whether VSync should be default or opt-in."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 528,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:18:16Z",
        "currentLabels": [
          "status/help-wanted",
          "os/Android"
        ]
      },
      "summary": "SKShaper.Shape() returns all-zero Codepoints on Android when the typeface is loaded via SKTypeface.FromStream(). The issue is Android-specific \u2014 WPF and iOS work correctly with the same code. The reporter discovered that switching to SKTypeface.FromData(SKData.Create(stream)) resolves the problem, suggesting a bug in how stream-based typefaces interact with HarfBuzz\u0027s font table reading on Android.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.92
        },
        "platforms": [
          "os/Android"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Load a custom font via SKTypeface.FromStream(stream) on Android",
            "Create an SKShaper with that typeface",
            "Call shaper.Shape(text, x, y, paint)",
            "Observe that result.Codepoints are all 0 (works on WPF and iOS)"
          ],
          "codeSnippets": [
            "var shaper = new SKShaper(paint.Typeface);\nvar result = shaper.Shape(\u0022Hello world!\u0022, 10, 300, paint); // result.Codepoints are all 0"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/2035982/HarfBuzzDemo.zip",
              "filename": "HarfBuzzDemo.zip",
              "description": "Complete repro project demonstrating the issue"
            }
          ],
          "environmentDetails": "Android emulator (x86) and LG G4 (ARMv8), tested with arial/Roboto/SF-UI-Display fonts in otf and ttf"
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "wrong-output",
          "errorMessage": "SKShaper.Result.Codepoints are all 0 on Android",
          "reproQuality": "complete",
          "targetFrameworks": [
            "monoandroid"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.60.x"
          ],
          "currentRelevance": "unknown",
          "relevanceReason": "Issue is from 2018 (SkiaSharp 1.x era). HarfBuzz has been updated significantly since then, but the core code path (SKShaper constructor calling Typeface.OpenStream().ToHarfBuzzBlob()) hasn\u0027t fundamentally changed. Needs verification with SkiaSharp 3.x."
        }
      },
      "analysis": {
        "summary": "The SKShaper constructor calls Typeface.OpenStream() to get font data, then converts it to a HarfBuzz blob via ToHarfBuzzBlob(). When a typeface is created via FromStream() on Android, the subsequent OpenStream() call may return invalid or empty data, causing HarfBuzz\u0027s hb_shape() to fail silently \u2014 it produces zero codepoints because it can\u0027t read the font tables. FromData() avoids this by keeping the font data fully in memory as an SKData object, which OpenStream() can reliably return.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "Constructor calls Typeface.OpenStream(out index).ToHarfBuzzBlob() to create the HarfBuzz font. If OpenStream returns invalid data on Android for stream-created typefaces, HarfBuzz gets an empty/bad blob.",
            "relevance": "direct",
            "lines": "19-30"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob() first checks GetMemoryBase() \u2014 if non-null, wraps that pointer directly. Otherwise allocates and reads. If the stream asset from OpenStream is empty/invalid, this produces a zero-length or garbage blob.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "FromStream converts SKManagedStream to memory stream, calls sk_typeface_create_from_stream which takes ownership of the stream. The native Skia code may not preserve the stream data for later OpenStream calls on some platforms.",
            "relevance": "direct",
            "lines": "100-113"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "FromData calls sk_typeface_create_from_data which keeps the data in memory via native reference counting. OpenStream on this typeface reliably returns the font data because it\u0027s backed by an SKData (in-memory buffer), not a consumed stream.",
            "relevance": "related",
            "lines": "115-121"
          }
        ],
        "rationale": "This is clearly a bug: the same code produces correct output on WPF/iOS but all-zero codepoints on Android. The area is SkiaSharp.HarfBuzz because the problem manifests in SKShaper.Shape() and traces back to the SKShaper constructor\u0027s interaction with typeface streams. The root cause is in the FromStream/OpenStream code path on Android, not in HarfBuzz itself. Severity is medium because there\u0027s a reliable workaround (FromData) and it\u0027s not a crash.",
        "keySignals": [
          {
            "text": "result.Codepoints are all 0 on Android",
            "source": "issue body",
            "interpretation": "HarfBuzz shaping silently fails \u2014 returns placeholder zeros instead of glyph IDs, indicating it can\u0027t read the font tables."
          },
          {
            "text": "When testing on WPF or iOS, everything seems ok",
            "source": "issue body",
            "interpretation": "Android-specific. The typeface data is valid (works elsewhere), so the problem is in how Android handles the stream-based typeface."
          },
          {
            "text": "hb_shape(Handle, buffer.Handle, IntPtr.Zero, 0) set all buffer.GlipInfo.CodePoints from utf8 to 0",
            "source": "comment #2",
            "interpretation": "Confirms the HarfBuzz C\u002B\u002B hb_shape call itself is the point of failure. The HB font blob must be empty or invalid."
          },
          {
            "text": "Using SKData.Create(stream) then SKTypeface.FromData(data) works",
            "source": "comment #10",
            "interpretation": "Confirms the stream data is valid. The bug is specifically in FromStream\u0027s interaction with OpenStream on Android."
          },
          {
            "text": "SKTypeface.FromFamilyName(\u0027Times New Roman\u0027) works",
            "source": "comment #5 (mattleibow)",
            "interpretation": "System-installed fonts work \u2014 the issue is limited to fonts loaded from streams/files."
          }
        ],
        "errorFingerprint": "HarfBuzz-Shape-ZeroCodes-Android-FromStream",
        "workarounds": [
          "Use SKTypeface.FromData(SKData.Create(stream)) instead of SKTypeface.FromStream(stream)"
        ],
        "nextQuestions": [
          "Is this still reproducible with SkiaSharp 3.x and the updated HarfBuzz?",
          "Does OpenStream() on a FromStream-created typeface actually return different data on Android vs other platforms?",
          "Was this partially addressed by HarfBuzz updates (issue #904)?"
        ],
        "resolution": {
          "hypothesis": "SKTypeface.FromStream() on Android creates a typeface where the native stream data is consumed/released after typeface construction. When SKShaper later calls OpenStream() to extract font data for HarfBuzz, the returned stream is empty or invalid on Android. FromData() avoids this because SKData keeps the font bytes in memory indefinitely via reference counting.",
          "proposals": [
            {
              "description": "Replace SKTypeface.FromStream(stream) with SKTypeface.FromData(SKData.Create(stream)) to ensure font data persists for HarfBuzz. Validated: reporter and another user confirmed this works.",
              "title": "Use FromData workaround",
              "codeSnippet": "using var data = SKData.Create(stream);\nvar typeface = SKTypeface.FromData(data);\nif (typeface == null)\n    throw new InvalidOperationException(\u0022Failed to load typeface\u0022);\nusing var shaper = new SKShaper(typeface);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Modify SKTypeface.FromStream to internally convert to SKData before creating the typeface, ensuring OpenStream always has valid data. This would make FromStream behave identically to FromData on all platforms.",
              "title": "Fix FromStream to preserve data for OpenStream",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "Test whether the issue persists in SkiaSharp 3.x, which includes significant HarfBuzz updates and internal changes to stream handling.",
              "title": "Verify with SkiaSharp 3.x",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Use FromData workaround",
          "recommendedReason": "Confirmed working by the reporter and another user. Trivial code change with no side effects."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The workaround is well-established, but the underlying bug in FromStream\u002BOpenStream on Android has never been root-caused or fixed. The issue is also very old (2018) and needs verification with SkiaSharp 3.x before deciding whether to fix or close."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and HarfBuzz area labels, keep Android platform label",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz",
              "os/Android"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the long-standing bug, confirm the workaround, and ask whether it still reproduces on SkiaSharp 3.x",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the thorough investigation on this, and apologies it\u0027s been open so long.\n\nThe workaround @michaldobrodenka found is the right approach \u2014 use \u0060SKTypeface.FromData\u0060 instead of \u0060SKTypeface.FromStream\u0060:\n\n\u0060\u0060\u0060csharp\nusing var data = SKData.Create(stream);\nvar typeface = SKTypeface.FromData(data);\nif (typeface == null)\n    throw new InvalidOperationException(\u0022Failed to load typeface\u0022);\nusing var shaper = new SKShaper(typeface);\n\u0060\u0060\u0060\n\nThe underlying cause appears to be that \u0060SKTypeface.FromStream()\u0060 on Android doesn\u0027t reliably preserve the font data for later \u0060OpenStream()\u0060 calls \u2014 which \u0060SKShaper\u0060 depends on to extract font tables for HarfBuzz. \u0060FromData()\u0060 keeps the bytes in memory via reference counting, so \u0060OpenStream()\u0060 always returns valid data.\n\nA lot has changed since 2018 \u2014 both SkiaSharp and HarfBuzz have had major updates. Would anyone be able to confirm whether this still reproduces with SkiaSharp 3.x? If the issue persists, we should look at having \u0060FromStream\u0060 internally use \u0060FromData\u0060 to avoid this class of bug."
          },
          {
            "type": "link-related",
            "description": "Link to RTL text support issue which motivated the original report",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 272
          }
        ],
        "missingInfo": [
          "Whether this issue still reproduces with SkiaSharp 3.x on modern Android"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 425,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:09:01Z",
        "currentLabels": [
          "type/bug",
          "status/skia-update-required"
        ]
      },
      "summary": "SKCodecOrigin (now SKEncodedOrigin) returns TopLeft for DNG and CR2 RAW files instead of their actual EXIF orientation",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.9
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Open a DNG or CR2 file with SKCodec.Create()",
            "Read codec.EncodedOrigin (formerly codec.Origin)",
            "Observe it returns TopLeft regardless of actual EXIF orientation",
            "Compare with Chrome browser which correctly auto-orients these files"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616452/APC_0316.zip",
              "filename": "APC_0316.zip",
              "description": "DNG sample with incorrect orientation"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616453/APC_0193.zip",
              "filename": "APC_0193.zip",
              "description": "DNG sample with incorrect orientation"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1645431/IMG_1361.zip",
              "filename": "IMG_1361.zip",
              "description": "CR2 sample reported as TopLeft but should be LeftBottom"
            }
          ],
          "environmentDetails": "Cross-platform, all SkiaSharp versions",
          "relatedIssues": [
            836
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "wrong-output",
          "errorMessage": "SKCodecOrigin reports TopLeft for DNG/CR2 files that have non-TopLeft EXIF orientation",
          "reproQuality": "complete",
          "targetFrameworks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "likely",
          "relevanceReason": "The SkRawCodec constructor still does not pass EXIF orientation to the base SkCodec class. The default kTopLeft_SkEncodedOrigin is hardcoded in the SkCodec base constructor signature."
        }
      },
      "analysis": {
        "summary": "Skia\u0027s SkRawCodec constructor does not extract or pass EXIF orientation data from DNG/CR2 files. The base SkCodec constructor defaults the origin parameter to kTopLeft_SkEncodedOrigin when not provided. Only JPEG and WebP codecs parse and pass EXIF orientation.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.EncodedOrigin directly wraps sk_codec_get_origin(). The C# binding is correct \u2014 it faithfully returns whatever Skia reports.",
            "relevance": "context",
            "lines": "36-37"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "SkRawCodec constructor calls INHERITED(SkEncodedInfo::Make(...), skcms_PixelFormat_RGBA_8888, nullptr) \u2014 only 3 args. The 4th param (SkEncodedOrigin) defaults to kTopLeft_SkEncodedOrigin. This is the root cause.",
            "relevance": "direct",
            "lines": "826-831"
          },
          {
            "file": "externals/skia/include/codec/SkCodec.h",
            "finding": "SkCodec constructor has default parameter SkEncodedOrigin = kTopLeft_SkEncodedOrigin, confirming RAW codec never provides orientation.",
            "relevance": "direct",
            "lines": "765-768"
          },
          {
            "file": "externals/skia/src/codec/SkJpegCodec.cpp",
            "finding": "SkJpegCodec correctly parses EXIF orientation via SkParseEncodedOrigin and passes it to the base SkCodec constructor. This is the model for how RAW should work.",
            "relevance": "related",
            "lines": "245-250"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "SkDngImage class has access to dng_negative (fNegative) which contains EXIF metadata after SynchronizeMetadata(). The orientation could potentially be extracted from fNegative but is not implemented.",
            "relevance": "direct",
            "lines": "456-642"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "MakeFromStream has a PIEX fast path that returns SkJpegCodec for JPEG-compressed previews (which WOULD have correct orientation). The bug only manifests when the full DNG decode path is used (line 714).",
            "relevance": "related",
            "lines": "649-715"
          }
        ],
        "rationale": "This is confirmed as a bug by the maintainer. The reporter provides sample DNG and CR2 files and demonstrates that SKCodecOrigin always returns TopLeft. The root cause is in upstream Skia\u0027s SkRawCodec, not in SkiaSharp\u0027s C# bindings \u2014 the C# wrapper correctly exposes whatever value Skia returns. The existing label status/skia-update-required is accurate. Severity is low because RAW file orientation is a niche use case and workarounds exist (read EXIF manually).",
        "keySignals": [
          {
            "text": "The following sample code results in SKCodecOrigin.TopLeft, which is incorrect",
            "source": "issue body",
            "interpretation": "Reporter confirms the origin value is wrong for DNG files."
          },
          {
            "text": "not limited to just dng. Here\u0027s a sample cr2 that is also affected. It is reported as TopLeft but it should be LeftBottom",
            "source": "comment 1 by OP",
            "interpretation": "Bug affects multiple RAW formats, not just DNG. Confirms expected value (LeftBottom vs TopLeft)."
          },
          {
            "text": "the DNG codec ignores this. The only ones that appear to respect this are jpeg and webp",
            "source": "comment 2 by mattleibow",
            "interpretation": "Maintainer confirms this is an upstream Skia limitation in the RAW codec."
          }
        ],
        "workarounds": [
          "Use a separate EXIF library (e.g., MetadataExtractor for .NET) to read orientation from DNG/CR2 files, then apply the rotation transform manually using SKCanvas",
          "For DNG files with embedded JPEG previews, extract the preview JPEG and decode that instead \u2014 it will report correct orientation via the JPEG codec path"
        ],
        "nextQuestions": [
          "Does the DNG SDK expose orientation metadata via dng_negative that could be passed to the SkCodec base constructor?",
          "Would an upstream Skia patch be accepted to extract orientation in SkRawCodec?",
          "Does the PIEX fast path (returning SkJpegCodec) correctly handle orientation for the reporter\u0027s specific files?"
        ],
        "resolution": {
          "hypothesis": "SkRawCodec in Skia does not extract EXIF orientation from DNG/CR2 metadata and does not pass it to the base SkCodec constructor, causing it to default to TopLeft for all RAW files.",
          "proposals": [
            {
              "description": "Install the MetadataExtractor NuGet package to read EXIF orientation from RAW files independently, then use the orientation value to transform the decoded image.",
              "title": "Use MetadataExtractor to read EXIF orientation",
              "codeSnippet": "// NuGet: MetadataExtractor\nusing MetadataExtractor;\nusing MetadataExtractor.Formats.Exif;\n\nvar directories = ImageMetadataReader.ReadMetadata(path);\nvar ifd0 = directories.OfType\u003CExifIfd0Directory\u003E().FirstOrDefault();\nif (ifd0 != null \u0026\u0026 ifd0.TryGetUInt16(ExifDirectoryBase.TagOrientation, out var orientation))\n{\n    var origin = (SKEncodedOrigin)orientation;\n    // Use origin to apply the correct rotation transform\n}",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Modify SkRawCodec to extract EXIF orientation from the DNG SDK\u0027s dng_negative metadata after SynchronizeMetadata(), then pass it to the SkCodec base constructor. This matches the pattern used by SkJpegCodec.",
              "title": "Upstream Skia fix to SkRawCodec",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Use MetadataExtractor to read EXIF orientation",
          "recommendedReason": "This workaround is independent of the upstream Skia fix and gives the reporter a solution today. The upstream fix requires changes to Skia\u0027s SkRawCodec which is outside SkiaSharp\u0027s direct control."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Confirmed bug in Skia\u0027s SkRawCodec \u2014 the orientation is never extracted from DNG/CR2 EXIF metadata. Requires changes in upstream Skia code. The existing status/skia-update-required label is already correct."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add area/libSkiaSharp.native to existing labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "status/skia-update-required"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround using MetadataExtractor for EXIF orientation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the detailed report and sample files.\n\nThis is a limitation in Skia\u0027s RAW codec (\u0060SkRawCodec\u0060). The codec does not extract EXIF orientation from DNG or CR2 metadata \u2014 it always defaults to \u0060TopLeft\u0060. By contrast, the JPEG and WebP codecs do parse EXIF orientation correctly.\n\nAs a workaround, you can use a .NET EXIF library like [MetadataExtractor](https://www.nuget.org/packages/MetadataExtractor) to read the orientation independently:\n\n\u0060\u0060\u0060csharp\nusing MetadataExtractor;\nusing MetadataExtractor.Formats.Exif;\n\nvar directories = ImageMetadataReader.ReadMetadata(path);\nvar ifd0 = directories.OfType\u003CExifIfd0Directory\u003E().FirstOrDefault();\nif (ifd0 != null \u0026\u0026 ifd0.TryGetUInt16(ExifDirectoryBase.TagOrientation, out var orientation))\n{\n    var origin = (SKEncodedOrigin)orientation;\n    // Use origin to apply the correct rotation transform\n}\n\u0060\u0060\u0060\n\nA proper fix would require changes to Skia\u0027s \u0060SkRawCodec\u0060 to extract orientation from the DNG SDK metadata and pass it to the base codec constructor."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #836 (Image auto orientation method) \u2014 related feature request for auto-orient",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 836
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 315,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:03:53Z",
        "currentLabels": []
      },
      "summary": "Pinch and pan gestures conflict with SkiaSharp touch events on Android in Xamarin.Forms",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.7
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.9
        },
        "platforms": [
          "os/Android"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Xamarin.Forms app with SKCanvasView and touch events enabled",
            "Add PinchGestureRecognizer and PanGestureRecognizer to the containing view",
            "Attempt to draw (finger paint) on Android while using pinch/pan gestures",
            "Observe that touch events do not work correctly on Android (works on iOS)"
          ],
          "environmentDetails": "Xamarin.Forms, Android, SkiaSharp circa 2017 (pre-1.x era)",
          "relatedIssues": [
            309,
            909,
            1048
          ],
          "repoLinks": [
            {
              "url": "https://github.com/JavedAppdevelopment/DrawTrackingForms",
              "description": "Reporter\u0027s Xamarin.Forms finger-paint sample with pinch/pan"
            }
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "incorrect-behavior",
          "reproQuality": "partial",
          "targetFrameworks": [
            "xamarinandroid"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "Xamarin.Forms is end-of-life. SkiaSharp.Views.Forms has been removed from the codebase, replaced by SkiaSharp.Views.Maui. The Android touch handler has been rewritten for MAUI with a different architecture. The underlying gesture conflict between native touch handling and framework gesture recognizers is an inherent platform integration challenge that may still exist in MAUI, but the specific code paths are entirely different."
        }
      },
      "analysis": {
        "summary": "Reporter describes Xamarin.Forms pinch/pan gesture recognizers interfering with SkiaSharp touch events on Android. Drawing with touch works on iOS but not Android when combined with gesture recognizers. Issue #909 describes the identical problem from the iOS perspective. This is a known limitation of mixing native touch handling with framework-level gesture recognizers \u2014 Android\u0027s View.Touch event and Xamarin.Forms gesture recognizers compete for touch ownership via the Handled flag.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "finding": "Current MAUI Android SKTouchHandler hooks into View.Touch and sets e.Handled = args.Handled. When Handled is true, the parent gesture recognizers (pan/pinch) are starved of touch events. When false, SkiaSharp doesn\u0027t track the touch. This mutual exclusion is the root of the gesture conflict \u2014 it exists in both the old Forms and new MAUI implementations.",
            "relevance": "direct",
            "lines": "41-109"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "finding": "iOS SKTouchHandler extends UIGestureRecognizer directly, which participates in iOS gesture recognition system and can coexist with other recognizers. This architectural difference explains why iOS handles the combination better than Android.",
            "relevance": "related",
            "lines": "10-111"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKCanvasView.cs",
            "finding": "Legacy Android SKCanvasView (non-Forms) extends android.view.View directly. No touch handling built in \u2014 the Xamarin.Forms renderer layer would have added touch support. SkiaSharp.Views.Forms source has been fully removed from the codebase.",
            "relevance": "context",
            "lines": "1-156"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes behavior that works on iOS but not Android \u2014 a platform-specific defect in gesture handling, not a usage question. Area is SkiaSharp.Views.Forms since the issue is specifically about the Xamarin.Forms SKCanvasView and gesture recognizer interaction. Severity is low because (1) SkiaSharp.Views.Forms has been removed from the codebase in favor of MAUI, (2) the issue is from 2017 with only one follow-up comment from 2019, and (3) Xamarin.Forms itself is end-of-life.",
        "keySignals": [
          {
            "text": "Pinch and Pan with Touch works in iOS version but not work in Android version",
            "source": "issue body",
            "interpretation": "Platform-specific behavior difference in how Android dispatches touch events when gesture recognizers are attached. On Android, View.Touch handler and gesture recognizers compete for touch ownership."
          },
          {
            "text": "#309 introduces TouchEvents but somehow they interfere with Xamarin.Forms GestureRecognizers on Android",
            "source": "comment #1 (nor0x)",
            "interpretation": "Confirms this is a known interaction issue between SkiaSharp\u0027s touch event system (added in #309) and Xamarin.Forms gesture recognizers."
          },
          {
            "text": "Issue filed 2017-06-16, last community comment 2019-03-26, no maintainer response",
            "source": "issue metadata",
            "interpretation": "Nearly 9 years old with no maintainer engagement. The underlying platform (Xamarin.Forms) is now end-of-life."
          }
        ],
        "nextQuestions": [
          "Does the same gesture conflict still exist in MAUI with the new SKTouchHandler?",
          "Could Android\u0027s requestDisallowInterceptTouchEvent() help coordinate touch ownership?"
        ],
        "resolution": {
          "hypothesis": "On Android, SkiaSharp\u0027s touch handler and Xamarin.Forms gesture recognizers (Pan/Pinch) compete for touch event ownership. Setting e.Handled=true in the touch handler prevents gestures from receiving events; setting it false prevents SkiaSharp from tracking touches. iOS doesn\u0027t have this problem because its SKTouchHandler is a UIGestureRecognizer that participates in the native gesture recognition system.",
          "proposals": [
            {
              "description": "Xamarin.Forms is end-of-life. Migrate to .NET MAUI with SkiaSharp.Views.Maui, which has a rewritten touch handler. This is the recommended path forward.",
              "title": "Migrate to .NET MAUI",
              "confidence": 0.7,
              "effort": "large"
            },
            {
              "description": "Instead of mixing Xamarin.Forms gesture recognizers with SkiaSharp touch events, implement pinch and pan detection entirely within the SKTouchAction handler. Track multiple touch points manually: compute distance between points for pinch, track centroid movement for pan.",
              "title": "Use only SkiaSharp touch events for all gestures",
              "confidence": 0.8,
              "effort": "medium"
            },
            {
              "description": "The Xamarin.Forms platform is end-of-life and SkiaSharp.Views.Forms has been removed from the codebase. This issue cannot be fixed in the current codebase. Close with guidance to migrate to MAUI.",
              "title": "Close as stale \u2014 Xamarin.Forms EOL",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Close as stale \u2014 Xamarin.Forms EOL",
          "recommendedReason": "Xamarin.Forms is end-of-life and SkiaSharp.Views.Forms has been entirely removed from the codebase. There is no code to fix. The reporter should migrate to MAUI."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.85,
          "reason": "Xamarin.Forms is end-of-life, SkiaSharp.Views.Forms has been removed from the codebase, and the touch handler has been rewritten for MAUI. The specific code paths causing this issue no longer exist."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views.forms, and android labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Forms",
              "os/Android"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post closure guidance with migration recommendation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for reporting this. The underlying issue was a conflict between Android\u0027s touch event dispatch and Xamarin.Forms gesture recognizers \u2014 SkiaSharp\u0027s touch handler and Pan/Pinch gesture recognizers compete for touch ownership on Android (unlike iOS, where the touch handler participates in the native gesture recognition system).\n\nXamarin.Forms has reached end-of-life and SkiaSharp.Views.Forms has been removed from the codebase, so this can\u0027t be addressed in current versions. If you\u0027re still working with SkiaSharp, we recommend migrating to .NET MAUI with \u0060SkiaSharp.Views.Maui\u0060, which has a rewritten touch handler.\n\nIf the gesture conflict persists in MAUI, please open a new issue with a MAUI reproduction project.\n\nClosing as the affected platform is no longer supported."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #909 (same gesture conflict on iOS/Forms)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 909
          },
          {
            "type": "close-issue",
            "description": "Close \u2014 Xamarin.Forms is end-of-life and code has been removed",
            "risk": "medium",
            "confidence": 0.85
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 310,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:00:19Z",
        "currentLabels": [
          "type/enhancement",
          "status/low-priority",
          "os/Windows-Classic",
          "area/SkiaSharp.Views"
        ]
      },
      "summary": "Re-entrant OnPaint in WinForms SKControl causes ExternalException in Bitmap.UnlockBits. When the user resizes the SKControl from within the PaintSurface event handler, a parent container (DevExpress XtraScrollableControl) can trigger a nested OnPaint call. The re-entrant call disposes and recreates the GDI\u002B bitmap via CreateBitmap(), so when the outer OnPaint tries to call UnlockBits on the now-disposed bitmap, GDI\u002B throws. The code still has no re-entrancy guard.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Place an SKControl inside a scrollable container (e.g., DevExpress XtraScrollableControl)",
            "Resize the SKControl.Height from within the PaintSurface event handler",
            "Scroll the container so the SKControl is partially or fully offscreen",
            "Trigger a content change that causes the height resize during paint"
          ],
          "environmentDetails": "Windows, WinForms, .NET Framework (2017-era report)"
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "ExternalException",
          "errorMessage": "A generic error occurred in GDI\u002B.",
          "stackTrace": "System.Runtime.InteropServices.ExternalException (0x80004005): A generic error occurred in GDI\u002B.\n   at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata)\n   at SkiaSharp.Views.Desktop.SKControl.OnPaint(PaintEventArgs e)\n   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer)\n   at System.Windows.Forms.Control.WmPaint(Message\u0026 m)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The SKControl.OnPaint code path has not changed since the issue was filed. No re-entrancy guard has been added. The bitmap LockBits/UnlockBits pattern is still identical."
        }
      },
      "analysis": {
        "summary": "The WinForms SKControl.OnPaint locks a GDI\u002B bitmap, fires the user\u0027s PaintSurface event, then unlocks the bitmap. If the user\u0027s PaintSurface handler triggers a re-entrant OnPaint (e.g. by resizing the control, causing a parent container to synchronously repaint), the re-entrant call disposes and recreates the bitmap, and the outer call crashes on UnlockBits. The reporter investigated this thoroughly and confirmed the re-entrancy as the root cause. A simple boolean re-entrancy guard would prevent the crash.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "OnPaint calls LockBits (line 43), then OnPaintSurface (line 49), then UnlockBits (line 55). No re-entrancy guard exists. If OnPaintSurface triggers a nested OnPaint, CreateBitmap() (line 38) disposes the locked bitmap and creates a new one, causing UnlockBits to fail on the disposed bitmap.",
            "relevance": "direct",
            "lines": "30-57"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "CreateBitmap() calls FreeBitmap() which disposes the existing bitmap when size changes. During re-entrant OnPaint after a resize, this disposes the bitmap that is still locked by the outer OnPaint call.",
            "relevance": "direct",
            "lines": "72-85"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "finding": "WPF SKElement uses the same Lock/OnPaintSurface/Unlock pattern with WriteableBitmap. Could be similarly vulnerable to re-entrancy, though WPF\u0027s rendering pipeline makes synchronous re-entrant OnRender less likely.",
            "relevance": "related",
            "lines": "45-88"
          }
        ],
        "rationale": "Classified as type/bug (not enhancement) because the control crashes due to lack of defensive coding \u2014 re-entrant OnPaint should be handled gracefully, not crash. The current type/enhancement label is incorrect. The area is clearly SkiaSharp.Views (WinForms SKControl). Severity is medium: it\u0027s a crash, but only triggered by modifying the control during paint, which is an unusual (though not invalid) pattern. The WPF SKElement has the same Lock/Unlock pattern and could be similarly vulnerable.",
        "keySignals": [
          {
            "text": "OnPaint event is being called from within the OnPaint event (due to my height resize code)",
            "source": "comment #2",
            "interpretation": "Re-entrant OnPaint is the root cause. The bitmap is locked in the outer call and disposed/recreated in the inner call."
          },
          {
            "text": "I am changing the SKControl.Height value from within the PaintSurface event, which is inside the bitmap lock/unlock",
            "source": "comment #1",
            "interpretation": "The user is resizing during paint, which causes the parent container to trigger a synchronous repaint."
          },
          {
            "text": "It would be easy enough to handle this situation in the SKControl itself so it doesn\u0027t crash",
            "source": "comment #2",
            "interpretation": "Reporter suggests a defensive fix in SKControl. A re-entrancy guard is straightforward."
          },
          {
            "text": "This issue serves to act as a note for further investigation",
            "source": "comment #5 (mattleibow)",
            "interpretation": "Maintainer acknowledged the issue and kept it open for investigation. No fix has been applied since."
          }
        ],
        "errorFingerprint": "ExternalException-GDI-UnlockBits-SKControl-OnPaint-reentrant",
        "workarounds": [
          "Do not resize the SKControl from within the PaintSurface event handler. Calculate layout dimensions separately and apply the resize outside of the paint event.",
          "Reset the parent scrollable container\u0027s scroll position before resizing the SKControl to avoid the parent triggering a synchronous repaint."
        ],
        "nextQuestions": [
          "Should a re-entrancy guard be added to SKControl.OnPaint (e.g. a bool _painting field that causes early return on re-entry)?",
          "Is the WPF SKElement vulnerable to the same re-entrancy issue?",
          "Should the bitmap be captured in a local variable before LockBits so UnlockBits always uses the same reference?"
        ],
        "resolution": {
          "hypothesis": "Re-entrant OnPaint disposes the locked bitmap. The outer OnPaint then calls UnlockBits on a disposed bitmap, causing the GDI\u002B ExternalException.",
          "proposals": [
            {
              "description": "Add a boolean field (_painting) that is set to true at the start of OnPaint and cleared at the end. If OnPaint is called while _painting is true, return immediately. This prevents the nested call from disposing the bitmap.",
              "title": "Add re-entrancy guard",
              "codeSnippet": "private bool _painting;\n\nprotected override void OnPaint(PaintEventArgs e)\n{\n    if (designMode || _painting)\n        return;\n    _painting = true;\n    try\n    {\n        // existing OnPaint body\n    }\n    finally\n    {\n        _painting = false;\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Store the bitmap reference in a local variable after LockBits. Use the local variable for UnlockBits and DrawImage so that even if CreateBitmap disposes the field, the locked reference remains valid for the outer call to unlock.",
              "title": "Capture bitmap reference locally",
              "confidence": 0.65,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Add re-entrancy guard",
          "recommendedReason": "Simplest and most defensive fix. Prevents all re-entrancy issues, not just the bitmap disposal race. Trivial to implement and low risk."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.82,
          "reason": "The root cause is well-understood and the fix is straightforward, but the code hasn\u0027t changed since 2017. Needs a developer to add the re-entrancy guard and verify the WPF SKElement isn\u0027t similarly affected."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Correct type from enhancement to bug and add reliability tenet",
            "risk": "low",
            "confidence": 0.88,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug is still present and describe the proposed fix",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the thorough investigation back in 2017, @Craig-TSS \u2014 your diagnosis was spot-on.\n\nThe \u0060SKControl.OnPaint\u0060 code path still has no re-entrancy guard. The \u0060LockBits\u0060 \u2192 \u0060OnPaintSurface\u0060 \u2192 \u0060UnlockBits\u0060 sequence is vulnerable whenever a nested \u0060OnPaint\u0060 is triggered during the paint event (e.g., by resizing the control from within \u0060PaintSurface\u0060).\n\nHere\u0027s a workaround you can use: avoid resizing the control from within the \u0060PaintSurface\u0060 handler. Calculate layout dimensions separately and apply resizes outside the paint event.\n\nThe fix on the SkiaSharp side would be a simple re-entrancy guard \u2014 a \u0060bool _painting\u0060 field that causes \u0060OnPaint\u0060 to return immediately if it\u0027s already executing. We\u0027ll also check whether the WPF \u0060SKElement\u0060 has the same vulnerability."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 243,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T14:56:44Z",
        "currentLabels": [
          "os/Windows-Classic",
          "area/Build",
          "type/feature-request"
        ]
      },
      "summary": "Feature request to bundle ANGLE (OpenGL ES over DirectX) with SkiaSharp for Windows desktop runtimes (WPF/WinForms). Originally filed for Win7 with DX9 support, the discussion evolved into how SkiaSharp could ship GPU-accelerated views for classic Windows desktop by packaging ANGLE as a separate NuGet dependency. SkiaSharp already has ANGLE interop code (GRGlInterface.CreateAngle, AngleSwapChainPanel for WinUI) and a Direct3D backend (GRContext.CreateDirect3D), but no GPU-accelerated views ship for WPF/WinForms.",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.8
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/OpenGL",
          "backend/Direct3D"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://i.imgur.com/DZWkJdg.png",
              "description": "ANGLE DX9 rendering support diagram"
            }
          ],
          "relatedIssues": [
            2817,
            2996,
            2104,
            2968
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "SkiaSharp still has no GPU-accelerated views for WPF/WinForms. The ANGLE interop exists in WinUI views only. While Win7 is EOL, the broader need for GPU rendering on classic Windows desktop remains. The D3D backend exists but isn\u0027t surfaced in views."
        }
      },
      "analysis": {
        "summary": "This is a long-standing feature request to ship ANGLE with SkiaSharp for Windows desktop. SkiaSharp already has significant ANGLE infrastructure (GRGlInterface.CreateAngle, AngleSwapChainPanel, GlesContext/Egl interop) but only for WinUI/UWP. WPF/WinForms views use raster-only rendering. Since filing, Skia gained a native Direct3D backend (GRContext.CreateDirect3D), which could be an alternative to ANGLE for GPU-accelerated desktop views. The maintainer discussed packaging ANGLE as a separate NuGet but noted DLL conflict concerns with AMD\u0027s system-wide libEGL.dll.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/GRGlInterface.cs",
            "finding": "GRGlInterface.Create() already falls back to CreateAngle() on Windows. CreateAngle() loads ANGLE\u0027s libEGL/libGLESv2 via AngleLoader. The API exists but requires the ANGLE DLLs to be present at runtime.",
            "relevance": "direct",
            "lines": "27-48"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "finding": "Full ANGLE SwapChainPanel implementation exists for WinUI \u2014 creates GlesContext, manages render loop, handles composition scale. This is the model for what a WPF/WinForms equivalent would look like.",
            "relevance": "direct",
            "lines": "1-307"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/Egl.cs",
            "finding": "Complete EGL interop with ANGLE-specific constants (D3D9, D3D11, WARP device types). Infrastructure for ANGLE is mature.",
            "relevance": "related",
            "lines": "60-80"
          },
          {
            "file": "binding/SkiaSharp/GRContext.cs",
            "finding": "GRContext.CreateDirect3D exists with GRD3DBackendContext. This provides a native D3D12 path that could bypass ANGLE entirely for GPU rendering on Windows.",
            "relevance": "related",
            "lines": "66-79"
          },
          {
            "file": "binding/SkiaSharp/GRD3DBackendContext.cs",
            "finding": "D3D backend context wraps IDXGIAdapter, ID3D12Device, and ID3D12CommandQueue \u2014 full D3D12 interop is available.",
            "relevance": "related",
            "lines": "1-37"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "WinForms SKControl uses System.Drawing.Bitmap (raster only) \u2014 no GPU path exists. This is the gap the feature request targets.",
            "relevance": "direct",
            "lines": "1-50"
          }
        ],
        "rationale": "Classified as feature-request because no current SkiaSharp API or packaging is broken \u2014 the request is for new capability (GPU views for WPF/WinForms). Area is SkiaSharp.Views rather than Build because the core deliverable is GPU-accelerated view controls, not just packaging ANGLE. The existing label area/Build reflects the original framing but the discussion shows this is really about shipping new view infrastructure. Windows-Classic platform and OpenGL\u002BDirect3D backends reflect the target surface area.",
        "keySignals": [
          {
            "text": "Angle has support even for DX9-based rendering which is preinstalled on Win7",
            "source": "issue body",
            "interpretation": "Original motivation was Win7 GPU support via ANGLE\u0027s DX9 backend."
          },
          {
            "text": "Packaging ANGLE as a separate package and referencing it from WPF/Winforms views should work",
            "source": "comment by kekekeks (2020-04-25)",
            "interpretation": "Avalonia maintainer confirms the packaging approach is viable."
          },
          {
            "text": "AMD ships their own libEGL.dll in system32. Including ANGLE with Skia will break users who are using AMD EGL implementation",
            "source": "comment by kekekeks (2020-04-25)",
            "interpretation": "DLL naming conflicts are a real deployment risk that needs design work."
          },
          {
            "text": "Maybe skia will get a DX backend - I see some work on that now",
            "source": "comment by mattleibow (2020-04-25)",
            "interpretation": "Skia\u0027s native D3D backend has since materialized (GRContext.CreateDirect3D exists), providing an alternative path."
          },
          {
            "text": "GRGlInterface.Create() falls back to CreateAngle() on Windows",
            "source": "code search: binding/SkiaSharp/GRGlInterface.cs:28",
            "interpretation": "ANGLE GL interface creation is already built into SkiaSharp\u0027s API surface \u2014 the gap is packaging and view controls."
          }
        ],
        "workarounds": [
          "Use GRGlInterface.CreateAngle() with manually-supplied ANGLE DLLs (libEGL.dll, libGLESv2.dll) in the output directory",
          "Use GRContext.CreateDirect3D() with a manually-created D3D12 device for GPU-accelerated rendering without ANGLE",
          "Use Avalonia.Angle.Windows.Natives NuGet package to supply ANGLE binaries (as referenced in the discussion)"
        ],
        "nextQuestions": [
          "Should the solution use ANGLE (OpenGL ES over DX) or Skia\u0027s native Direct3D12 backend?",
          "Should ANGLE be a separate NuGet package or bundled with views?",
          "How to handle DLL naming conflicts with AMD\u0027s system libEGL.dll?",
          "Is a cross-platform GPU view (#2104) the right umbrella for this work?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp needs GPU-accelerated view controls for WPF/WinForms. Two viable paths exist: (1) package ANGLE as a separate NuGet and create ANGLE-based views mirroring AngleSwapChainPanel, or (2) use Skia\u0027s native D3D12 backend via GRContext.CreateDirect3D to build D3D-native views without ANGLE.",
          "proposals": [
            {
              "description": "Build GPU-accelerated WPF/WinForms views using GRContext.CreateDirect3D (already in SkiaSharp API). This avoids ANGLE entirely and uses Skia\u0027s native D3D12 support. Requires creating D3D12 device/queue in the view and managing swap chains via DXGI.",
              "title": "Native D3D12 backend views",
              "confidence": 0.65,
              "effort": "large"
            },
            {
              "description": "Package ANGLE binaries as SkiaSharp.NativeAssets.ANGLE NuGet, referenced by WPF/WinForms view packages. Mirror the AngleSwapChainPanel pattern for WPF/WinForms hosting. Address DLL conflicts by loading from app-local directory.",
              "title": "Separate ANGLE NuGet package",
              "confidence": 0.6,
              "effort": "large"
            },
            {
              "description": "Document using Avalonia.Angle.Windows.Natives or similar third-party ANGLE NuGet with GRGlInterface.CreateAngle() for GPU rendering in WPF/WinForms. Low effort workaround users can apply today.",
              "title": "Use third-party ANGLE package",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Native D3D12 backend views",
          "recommendedReason": "Skia\u0027s native D3D12 backend avoids the ANGLE dependency, DLL conflict issues, and the maintenance burden of shipping ANGLE. It\u0027s the modern path forward for GPU rendering on Windows, aligned with #2817 and #2104."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Legitimate feature gap \u2014 no GPU-accelerated views for WPF/WinForms. The underlying infrastructure (ANGLE interop, D3D backend) exists but isn\u0027t surfaced in view controls. Related to #2104 (cross-platform GPU views) which is the likely umbrella for this work."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Update area label from Build to Views \u2014 the feature is about GPU view controls, not build packaging",
            "risk": "low",
            "confidence": 0.8,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "backend/OpenGL",
              "backend/Direct3D",
              "tenet/performance"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #2104 (cross-platform GPU backend views) \u2014 this is a subset of that work",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 2104
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #2817 (Direct3D support) \u2014 D3D backend is an alternative approach",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 2817
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 209,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T14:50:00Z",
        "currentLabels": [
          "type/bug",
          "status/help-wanted"
        ]
      },
      "summary": "Concurrent calls to SKBitmap.Decode from multiple threads cause AccessViolationException crashes. Reported across IIS, ASP.NET Core, Azure Functions, and .NET console apps. The underlying Skia C\u002B\u002B codec is not thread-safe, and simultaneous decode operations on separate SKBitmap instances still crash. Multiple reporters confirm a SemaphoreSlim(1,1) workaround eliminates the crash but serializes decoding. The issue has persisted across SkiaSharp versions from 1.x through 2.88.5, with reports spanning 2016\u20132024.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.92
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a multi-threaded application (IIS, Azure Functions, or console app with Task.Run)",
            "Call SKBitmap.Decode concurrently from multiple threads on separate byte arrays or files",
            "Observe AccessViolationException crash after a few iterations under concurrent load"
          ],
          "codeSnippets": [
            "const int numThreads = 100;\nconst int numIterationsPerThread = 1000;\nvar tasks = new List\u003CTask\u003E();\nfor (int i = 0; i \u003C numThreads; i\u002B\u002B) {\n    var task = Task.Run(() =\u003E {\n        for (int j = 0; j \u003C numIterationsPerThread; j\u002B\u002B) {\n            var imageData = ComputeThumbnail(referenceFile);\n        }\n    });\n    tasks.Add(task);\n}\nTask.WaitAll(tasks.ToArray());"
          ],
          "environmentDetails": "Windows (IIS), .NET Framework 4.x, .NET Core, .NET 5, .NET 7, Azure Functions Isolate Container",
          "relatedIssues": [
            235,
            1174,
            2194,
            2456
          ],
          "repoLinks": [
            {
              "url": "https://github.com/ncthbrt/skia-fsharp",
              "description": "F# repro project showing concurrent SKBitmap.Decode crash on .NET Core"
            }
          ]
        },
        "bugSignals": {
          "severity": "critical",
          "errorType": "AccessViolationException",
          "errorMessage": "Attempted to read or write protected memory. This is often an indication that other memory is corrupt.",
          "stackTrace": "at SkiaSharp.SkiaApi.sk_codec_get_info(IntPtr, SKImageInfo ByRef)\n  at SkiaSharp.SKBitmap.Decode(SKCodec)\n  at SkiaSharp.SKBitmap.Decode(SKStream)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net461",
            "netcoreapp2.0",
            "net5.0",
            "net7.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.56.2",
            "1.57.0",
            "2.80.2",
            "2.80.3",
            "2.88.5"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The SKBitmap.Decode code path has not changed structurally. It still creates an SKCodec per call, calls sk_codec_get_pixels, and there is no synchronization in the C# layer or the Skia C API layer. The SkiaSharp 3.x HandleDictionary uses locks for handle tracking but does not protect the underlying Skia codec operations."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "This appears to be a longstanding limitation rather than a regression. Reporter in comment 25 states reverting to 2.80.2 fixed the issue for them, but others report the same crash on older versions. The core thread-safety limitation of Skia codecs has existed throughout all versions."
        }
      },
      "analysis": {
        "summary": "SKBitmap.Decode is not thread-safe because the underlying Skia C\u002B\u002B codec operations (sk_codec_get_info, sk_codec_get_pixels, sk_codec_new_from_stream) are not designed for concurrent use. Each call to SKBitmap.Decode creates its own SKCodec instance, but Skia\u0027s internal state (global allocators, codec registries) may have shared mutable state that is not protected by locks. The C# wrapper (SKBitmap.cs:434-458) has no synchronization, and the P/Invoke calls go directly to native code. The GC.KeepAlive fix (commit 643e1b4c5) addressed a related but different issue \u2014 premature GC of objects during P/Invoke calls. The fundamental thread-safety gap in concurrent codec operations remains.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(SKCodec) and Decode(SKCodec, SKImageInfo) create a new SKBitmap, call codec.GetPixels to decode. No locking or synchronization. Each concurrent call gets its own codec and bitmap, but native Skia may share internal state.",
            "relevance": "direct",
            "lines": "434-458"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "All Decode overloads (Stream, SKStream, SKData, string, byte[], ReadOnlySpan\u003Cbyte\u003E) follow the same pattern: create SKCodec via SKCodec.Create, then call Decode(codec). No thread protection at any entry point.",
            "relevance": "direct",
            "lines": "461-586"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(SKStream) calls sk_codec_new_from_stream, which goes to native Skia. The stream ownership is transferred (RevokeOwnership). No locking around the native call.",
            "relevance": "direct",
            "lines": "252-264"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.GetPixels calls sk_codec_get_pixels \u2014 the native function where most AccessViolationExceptions occur in reporter stack traces. Parameters are local (nInfo, nOptions) but the native implementation may access global Skia state.",
            "relevance": "direct",
            "lines": "119-137"
          },
          {
            "file": "binding/SkiaSharp/HandleDictionary.cs",
            "finding": "HandleDictionary uses a PlatformLock (read-write lock) for instance tracking. This protects the C# handle dictionary but does not protect native Skia operations.",
            "relevance": "context",
            "lines": "21-27"
          }
        ],
        "rationale": "Classified as type/bug because multiple reporters demonstrate a consistent crash (AccessViolationException) during normal concurrent use of a public API. The area is area/SkiaSharp (core binding) rather than any View/Platform component since the crash is in SKBitmap.Decode and SKCodec \u2014 the core decoding pipeline. Severity is critical because it terminates the process without being catchable. The reliability tenet applies because server-side applications depend on concurrent image processing.",
        "keySignals": [
          {
            "text": "AccessViolationException at sk_codec_get_info during concurrent SKBitmap.Decode",
            "source": "issue body",
            "interpretation": "Native crash in Skia\u0027s codec layer proves this is a native thread-safety issue, not a C# bug."
          },
          {
            "text": "SemaphoreSlim with max count of 1 increases stability but sacrifices speed",
            "source": "issue body",
            "interpretation": "Serializing decode calls eliminates the crash \u2014 confirms the root cause is concurrent native access."
          },
          {
            "text": "Maintainer says SkiaSharp is \u0027thread safe\u0027 in that two threads can load a bitmap, but two threads shouldn\u0027t access the same object",
            "source": "comment 1",
            "interpretation": "The expectation is that separate instances should be safe concurrently. The crash contradicts this expectation, suggesting shared native state."
          },
          {
            "text": "Multiple reporters across versions 1.56.2 through 2.88.5 report the same crash",
            "source": "comments 9, 21, 23",
            "interpretation": "Longstanding issue across all major versions \u2014 not version-specific."
          },
          {
            "text": "Loading stream into byte array first makes the issue go away for some reporters",
            "source": "comment 24",
            "interpretation": "Suggests the managed stream wrapper (SKManagedStream) may have additional thread-safety issues beyond the codec itself."
          },
          {
            "text": "SKBitmap.Decode creates a new SKCodec per call with no shared state in C#",
            "source": "code search",
            "interpretation": "C# layer is clean \u2014 each call creates independent objects. The contention must be in native Skia code."
          }
        ],
        "errorFingerprint": "AccessViolationException-sk_codec-concurrent-decode",
        "workarounds": [
          "Use SemaphoreSlim(1,1) to serialize all SKBitmap.Decode calls \u2014 eliminates crashes but serializes throughput",
          "Load image data into a byte array before decoding instead of passing a stream \u2014 some reporters find this reduces (but may not eliminate) crashes",
          "Use SKImage.FromEncodedData(SKData) instead of SKBitmap.Decode \u2014 SKImage is immutable and may have better thread-safety characteristics for the decode path"
        ],
        "nextQuestions": [
          "Does Skia upstream document thread-safety guarantees for SkCodec? Is there a global mutex or codec registry that causes contention?",
          "Does SKImage.FromEncodedData truly avoid the same native thread-safety issue, or does it use the same codec path internally?",
          "Has the GC.KeepAlive fix (commit 643e1b4c5) or SkiaSharp 3.x\u0027s HandleDictionary locking partially mitigated this?",
          "Should SkiaSharp add an internal lock around codec creation/decode to protect against concurrent native access?"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s native codec implementation has shared mutable state (global codec registry, memory allocators, or image format decoders) that is not thread-safe. Even when each C# call creates independent SKCodec and SKBitmap objects, the underlying native code shares state that causes memory corruption under concurrent access.",
          "proposals": [
            {
              "description": "Use SemaphoreSlim(1,1) to serialize all SKBitmap.Decode calls. This is the proven workaround from the original reporter.",
              "title": "Serialize with SemaphoreSlim",
              "codeSnippet": "private static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try\n    {\n        return SKBitmap.Decode(data);\n    }\n    finally\n    {\n        _decodeLock.Release();\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Use SKImage.FromEncodedData(SKData.CreateCopy(bytes)) for concurrent image loading. SKImage is immutable and uses deferred decoding, which may avoid the codec thread-safety issue. Pixels are decoded lazily on first access.",
              "title": "Use SKImage instead of SKBitmap",
              "codeSnippet": "using var data = SKData.CreateCopy(bytes);\nusing var image = SKImage.FromEncodedData(data);\n// Use image directly for drawing, or convert to bitmap when needed on a single thread:\nusing var bitmap = SKBitmap.FromImage(image);",
              "confidence": 0.65,
              "effort": "small"
            },
            {
              "description": "Add a static lock or SemaphoreSlim inside SKCodec.GetPixels to serialize native codec operations within the SkiaSharp library itself. This would protect all callers transparently but would limit throughput to single-threaded decoding.",
              "title": "Add internal codec lock in SkiaSharp",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Serialize with SemaphoreSlim",
          "recommendedReason": "Proven workaround from the original reporter and multiple commenters. Trivial to implement, eliminates crashes completely. While it serializes decode throughput, it\u0027s the safest option until the root cause in native Skia is resolved."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real bug confirmed by multiple reporters across versions. Needs investigation into whether Skia upstream has addressed codec thread-safety, and whether SkiaSharp 3.x changes (HandleDictionary locking, GC.KeepAlive) have partially mitigated this."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, core area, and reliability labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround and status update",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the thorough investigation \u2014 this thread has been invaluable for understanding the scope of this issue.\n\nSkia\u0027s native codec operations are not designed for concurrent use, even when each call creates independent C# objects. The underlying native code shares state that can corrupt memory under concurrent access.\n\nHere\u0027s a workaround you can use while we investigate further:\n\n\u0060\u0060\u0060csharp\nprivate static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap?\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try\n    {\n        return SKBitmap.Decode(data);\n    }\n    finally\n    {\n        _decodeLock.Release();\n    }\n}\n\u0060\u0060\u0060\n\nNote that \u0060SKBitmap.Decode()\u0060 can return \u0060null\u0060 if decoding fails \u2014 callers should check the return value. The returned bitmap must be disposed by the caller when done.\n\nThis serializes decode operations and eliminates the crash, at the cost of concurrent throughput. We\u0027re evaluating whether an internal lock in SkiaSharp itself would be the right long-term fix, or whether Skia upstream has improved codec thread-safety in recent versions."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related concurrent access issues",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 2456
          },
          {
            "type": "link-related",
            "description": "Cross-reference thread-safety discussion",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 1174
          }
        ]
      }
    }
  ]
}