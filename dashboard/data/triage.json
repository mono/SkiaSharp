{
  "generatedAt": "2026-02-10T00:47:29.7794851Z",
  "totalCount": 30,
  "summary": {
    "needsInvestigation": 14,
    "closeable": 8,
    "quickWins": 5,
    "needsHumanReview": 6,
    "regressions": 14,
    "abandoned": 2
  },
  "byType": [
    {
      "label": "bug",
      "count": 23
    },
    {
      "label": "question",
      "count": 3
    },
    {
      "label": "feature-request",
      "count": 3
    },
    {
      "label": "documentation",
      "count": 1
    }
  ],
  "byArea": [
    {
      "label": "SkiaSharp",
      "count": 10
    },
    {
      "label": "libSkiaSharp.native",
      "count": 7
    },
    {
      "label": "SkiaSharp.Views",
      "count": 3
    },
    {
      "label": "SkiaSharp.Views.Maui",
      "count": 2
    },
    {
      "label": "SkiaSharp.Views.Blazor",
      "count": 2
    },
    {
      "label": "SkiaSharp.HarfBuzz",
      "count": 1
    },
    {
      "label": "Docs",
      "count": 1
    },
    {
      "label": "HarfBuzzSharp",
      "count": 1
    },
    {
      "label": "SkiaSharp.Views.Forms",
      "count": 1
    },
    {
      "label": "SkiaSharp.Views.Uno",
      "count": 1
    }
  ],
  "byAction": [
    {
      "label": "needs-investigation",
      "count": 14
    },
    {
      "label": "keep-open",
      "count": 5
    },
    {
      "label": "close-with-docs",
      "count": 3
    },
    {
      "label": "close-as-fixed",
      "count": 3
    },
    {
      "label": "request-info",
      "count": 3
    },
    {
      "label": "close-as-duplicate",
      "count": 2
    }
  ],
  "bySeverity": [
    {
      "label": "high",
      "count": 10
    },
    {
      "label": "medium",
      "count": 10
    },
    {
      "label": "critical",
      "count": 2
    },
    {
      "label": "low",
      "count": 1
    }
  ],
  "issues": [
    {
      "schemaVersion": "1.0",
      "number": 3509,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T21:30:00Z",
      "summary": "Vague report of images not appearing on screen \u2014 no code, no repro, no details provided",
      "type": {
        "value": "bug",
        "confidence": 0.55,
        "reason": "Title uses [BUG] prefix and type/bug label is applied, but the body contains no evidence of a bug \u2014 just a single vague sentence with no code, no error, no expected/actual behavior. Could equally be a usage question."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.40,
        "reason": "No specific API, class, or component mentioned. \u0027Images not appearing\u0027 could involve core SkiaSharp, Views, or even a MAUI/platform rendering issue. Defaulting to SkiaSharp as the broadest applicable area."
      },
      "backends": null,
      "platforms": [
        {
          "value": "macOS",
          "confidence": 0.75,
          "reason": "Reporter selected \u0027macOS\u0027 in the platform field, though IDE is listed as \u0027Visual Studio (Windows)\u0027 which is contradictory \u2014 may be running VS for Mac or cross-compiling."
        }
      ],
      "tenets": null,
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.50,
        "reason": "Reporter listed \u0027Last Known Good Version\u0027 as 2.88.9, implying it worked before. However, no details confirm this \u2014 the field may have been filled mechanically from the template defaults.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "none",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "severity": "low",
        "severityReason": "No crash, no data loss, no stack trace. Description is too vague to assess actual impact. \u0027Images not appearing\u0027 could range from a rendering bug to a simple API misuse."
      },
      "reproEvidence": {
        "repoLinks": [
          {
            "url": "https://github.com/user/repo/tree/bug-123",
            "description": "Placeholder repo link from the issue template \u2014 not an actual reproduction project."
          }
        ],
        "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), macOS. No OS version, no device info, no .NET version specified."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "unknown",
        "reason": "Version 3.116.0 is the current release. Last known good is 2.88.9 which is the previous major era. Without details on what changed or what API is involved, relevance cannot be determined.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "request-info",
        "confidence": 0.92,
        "reason": "The issue contains essentially no actionable information \u2014 no code, no expected/actual behavior, no screenshots, no error messages. Cannot investigate without basic details.",
        "requiresHumanReview": true,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "missingInfo": [
          "reproduction-steps",
          "expected-behavior",
          "actual-behavior",
          "sample-project",
          "stack-trace",
          "platform"
        ],
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "request-info",
        "confidence": 0.90,
        "reason": "Almost every required detail is missing. Need code, expected behavior, actual behavior, and ideally a minimal repro project before any investigation is possible.",
        "draft": "Thanks for filing this. To look into the images not appearing, we\u0027d need a bit more detail:\n\n- A minimal code snippet or sample project showing how you\u0027re loading and displaying images\n- What you expect to see vs. what actually happens (blank canvas? exception? partial rendering?)\n- Any error output or warnings in the console/log\n\nThe version info is helpful \u2014 if this worked in 2.88.9 but not 3.116.0, a small repro project would let us narrow down the regression quickly. Would you be able to share one?"
      },
      "analysisNotes": {
        "summary": "This is an extremely low-information bug report. The body contains one vague sentence (\u0027I have some code that puts things on the screen, but nothing appears\u0027), template placeholder code blocks, and no expected or actual behavior. Filed by mattleibow (a project contributor). The issue cannot be investigated in its current state.",
        "keySignals": [
          {
            "text": "I have some code that puts things on the screen, but nothing appears.",
            "source": "body",
            "interpretation": "The only substantive sentence in the issue. Too vague to determine if this is a rendering bug, API misuse, or platform issue. No specific API or behavior mentioned.",
            "supportedFields": [
              "type"
            ]
          },
          {
            "text": "// some C# code here",
            "source": "body",
            "interpretation": "Template placeholder \u2014 no actual code was provided. The code section is completely empty of real content.",
            "supportedFields": [
              "bugSignals.reproQuality",
              "actionability"
            ]
          },
          {
            "text": "Expected Behavior: _No response_; Actual Behavior: _No response_",
            "source": "body",
            "interpretation": "Reporter did not fill in expected or actual behavior sections, making it impossible to understand what\u0027s broken.",
            "supportedFields": [
              "actionability",
              "bugSignals.reproQuality"
            ]
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "body",
            "interpretation": "Suggests a regression from 2.x to 3.x, but without details this could be a template default selection rather than confirmed regression testing.",
            "supportedFields": [
              "regression"
            ]
          },
          {
            "text": "IDE: Visual Studio (Windows), Platform: macOS",
            "source": "body",
            "interpretation": "Contradictory \u2014 Visual Studio for Windows but targeting macOS. Could mean VS for Mac, remote debugging, or cross-compilation. Adds uncertainty to platform classification.",
            "supportedFields": [
              "platforms"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The [BUG] title prefix and type/bug label indicate the reporter intended this as a bug. However, with no error, no crash, and no actual behavior described, this could equally be a usage question. Confidence is low (0.55).",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Reporter explicitly chose the bug template and the title says [BUG]. Deferring to their classification despite insufficient evidence."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "No specific component, class, or API is mentioned. \u0027Images not appearing\u0027 is too generic to narrow down. Using SkiaSharp as the broadest default.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views",
                "whyRejected": "\u0027Appearing on screen\u0027 could imply a view component, but this is speculative without any code."
              },
              {
                "value": "SkiaSharp.Views.Maui",
                "whyRejected": "No mention of MAUI, Xamarin, or any UI framework."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "macOS",
            "expandedReason": "Reporter selected macOS in the platform field. The contradiction with \u0027Visual Studio (Windows)\u0027 IDE lowers confidence but the explicit platform selection is the best signal available."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "low",
            "expandedReason": "No crash, no data loss, no stack trace. The vague description of \u0027images not appearing\u0027 could range from cosmetic to critical, but without evidence, defaulting to low.",
            "alternatives": [
              {
                "value": "medium",
                "whyRejected": "No evidence of functional breakage beyond the vague claim. Cannot justify medium without more detail."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "The issue is missing nearly every required detail: no code, no expected behavior, no actual behavior, no error messages, no screenshots. Investigation is impossible without more information.",
            "alternatives": [
              {
                "value": "needs-investigation",
                "whyRejected": "Nothing to investigate \u2014 there\u0027s no code, no error, and no specific behavior described."
              },
              {
                "value": "convert-to-discussion",
                "whyRejected": "Reporter chose the bug template, so giving them a chance to provide details before converting."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/triage-schema.json",
            "relevance": "Referenced for field definitions, allowed enum values, and cross-field validation rules.",
            "usedFor": [
              "type",
              "area",
              "actionability",
              "bugSignals"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated output format and severity/confidence levels against example issues.",
            "usedFor": [
              "type",
              "bugSignals.severity",
              "actionability"
            ]
          },
          {
            "path": "references/research-by-type.md",
            "relevance": "Checked bug research checklist. Most research steps are inapplicable due to lack of information in the issue.",
            "usedFor": [
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult documentation/packages.md, references/skia-patterns.md, or API docs because the issue provides no specific technical details (no API names, no error messages, no platform-specific symptoms) that would make those references relevant.",
        "uncertainties": [
          "Whether this is a real bug report or a test/template issue filed by the maintainer",
          "What \u0027images not appearing\u0027 actually means \u2014 blank canvas, missing file, rendering error, or display issue",
          "Whether the IDE/platform contradiction (VS Windows \u002B macOS) indicates cross-compilation or a form-filling error",
          "Whether the 2.88.9 last-known-good version is a confirmed regression or a template default"
        ],
        "assumptions": [
          "Assumed the reporter intends this as a genuine bug report despite the lack of detail, because the type/bug label was applied",
          "Assumed macOS is the target platform despite the VS Windows IDE selection, because the platform field was explicitly chosen"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The reporter is experiencing images not rendering in a SkiaSharp application on macOS, possibly a regression from 2.88.9 to 3.116.0. Without code or details, the root cause could be anything from incorrect API usage to a genuine rendering regression.",
        "researchDone": [
          "Reviewed issue body \u2014 found no actionable technical details",
          "Checked for code snippets \u2014 only template placeholders present",
          "Noted version gap from 2.88.9 to 3.116.0 \u2014 major version jump with many breaking changes",
          "Checked for similar open issues \u2014 cannot narrow search without specific symptoms"
        ],
        "proposals": [
          {
            "title": "Request minimal reproduction project",
            "description": "Ask the reporter to provide a minimal project or code snippet that demonstrates the issue, along with expected vs actual behavior.",
            "steps": [
              "Comment requesting a minimal repro project with specific code that fails",
              "Ask for expected vs actual behavior description",
              "Ask for any console output or error messages",
              "Wait for response before investigating further"
            ],
            "pros": [
              "Gets the essential information needed for any investigation",
              "Respects reporter\u0027s time by asking once"
            ],
            "cons": [
              "Delays resolution until reporter responds",
              "Reporter may not respond"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Check 2.x to 3.x migration breaking changes",
            "description": "If this is a regression from 2.88.9 to 3.116.0, review the migration guide and breaking changes between these versions for image-related APIs.",
            "steps": [
              "Review SkiaSharp 3.x migration guide for image API changes",
              "Check if SKBitmap/SKImage APIs changed between versions",
              "Identify common migration pitfalls for image loading/rendering",
              "Share relevant migration notes with reporter"
            ],
            "pros": [
              "Addresses the most likely cause if this is a real regression",
              "Proactive \u2014 helps even before full repro"
            ],
            "cons": [
              "Speculative without knowing which APIs are involved",
              "May not apply if it\u0027s a usage error"
            ],
            "confidence": 0.40,
            "effort": "medium"
          },
          {
            "title": "Close as incomplete after timeout",
            "description": "If no response after a reasonable period (e.g., 30 days), close the issue as incomplete with a note that it can be reopened with more details.",
            "steps": [
              "Post request-info comment",
              "Wait 30 days for response",
              "If no response, close with \u0027incomplete\u0027 label",
              "Note that issue can be reopened with reproduction details"
            ],
            "pros": [
              "Keeps issue tracker clean",
              "Standard process for incomplete reports"
            ],
            "cons": [
              "May lose a valid bug report if reporter is busy",
              "Feels dismissive"
            ],
            "confidence": 0.70,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Request minimal reproduction project",
        "recommendedReason": "The single most effective action is getting actual code and behavior details. Everything else is speculative without this information."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3509"
    },
    {
      "schemaVersion": "1.0",
      "number": 3472,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-08T15:00:00Z",
      "summary": "HarfBuzzSharp Blob.FromStream uses fixed pinning that expires before native code finishes using the pointer, causing potential GC crash",
      "type": {
        "value": "bug",
        "confidence": 0.97,
        "reason": "The code uses a fixed block to pin a managed byte array, but the pin expires when the block exits while the native Blob retains the now-unpinned pointer. GC can relocate the array, causing memory corruption or crash."
      },
      "area": {
        "value": "HarfBuzzSharp",
        "confidence": 0.99,
        "reason": "The bug is in HarfBuzzSharp.Blob.FromStream() in binding/HarfBuzzSharp/Blob.cs, which is the HarfBuzzSharp binding layer."
      },
      "backends": null,
      "platforms": null,
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.97,
          "reason": "GC-induced memory corruption can cause random crashes, data corruption, or access violations \u2014 a core reliability issue."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": false,
        "confidence": 0.85,
        "reason": "The same bug was reported in issue #2323 (Nov 2022) with identical code. This has been present since the method was first written. The reporter selected 2.88.9 as \u0027last known good\u0027 but the same code existed in that version too."
      },
      "fixStatus": {
        "likelyFixed": false,
        "confidence": 0.90,
        "reason": "PR #3473 was submitted by the same reporter on the same day as the issue. It is still open and not yet merged.",
        "relatedPRs": [
          3473
        ],
        "fixedInVersion": null,
        "verificationStatus": "unverified"
      },
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Use Marshal.AllocCoTaskMem to allocate unmanaged memory, copy stream data into it via UnmanagedMemoryStream, and pass the unmanaged pointer to the Blob constructor with a FreeCoTaskMem release delegate.",
        "severity": "critical",
        "severityReason": "Memory corruption from GC relocating data that native code holds a pointer to. Can cause crashes, silent data corruption, or access violations at unpredictable times. Affects all platforms."
      },
      "reproEvidence": {
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "public static unsafe Blob FromStream (Stream stream)\n{\n    // TODO: check to see if we can avoid the second copy (the ToArray)\n    using var ms = new MemoryStream ();\n    stream.CopyTo (ms);\n    var data = ms.ToArray ();\n    fixed (byte* dataPtr = data) {\n        return new Blob ((IntPtr)dataPtr, data.Length, MemoryMode.ReadOnly, () =\u003E ms.Dispose ());\n    }\n}",
            "context": "Current buggy implementation \u2014 fixed block pins array only during constructor call, but Blob retains the pointer after the pin expires."
          },
          {
            "language": "csharp",
            "code": "public static unsafe Blob FromStream (Stream stream)\n{\n    var length = (int)(stream.Length - stream.Position);\n    var dataPtr = Marshal.AllocCoTaskMem (length);\n    using var ums = new UnmanagedMemoryStream ((byte*)dataPtr, length, length, FileAccess.ReadWrite);\n    stream.CopyTo (ums);\n    return new Blob (dataPtr, length, MemoryMode.ReadOnly, () =\u003E Marshal.FreeCoTaskMem (dataPtr));\n}",
            "context": "Reporter\u0027s proposed fix using unmanaged memory allocation to avoid GC interference."
          }
        ],
        "relatedIssues": [
          2323
        ],
        "stepsToReproduce": [
          "Call HarfBuzzSharp.Blob.FromStream() with any stream containing font data",
          "Trigger GC (e.g., GC.Collect() or natural GC pressure) after the Blob is created",
          "Access the Blob data \u2014 the pointer may now point to relocated or freed memory"
        ],
        "environmentDetails": "SkiaSharp 3.116.0, Visual Studio on Windows, reported as affecting all platforms"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "The buggy code exists in the current main branch at binding/HarfBuzzSharp/Blob.cs lines 71-82. The same code was present in 2.88.x \u2014 this is a latent bug, not a regression.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.92,
        "reason": "The bug is real and verified by code inspection. PR #3473 exists but needs review \u2014 the proposed fix has a limitation (assumes stream.Length is available). The fix approach is sound but implementation details need maintainer review.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "HarfBuzzSharp.Blob.FromStream() has a GC safety bug: it pins a managed byte array with a fixed block, passes the pointer to native code, but the pin expires when the fixed block exits. The native Blob retains the pointer, which becomes invalid if GC relocates the array. This is a latent bug present since the method was written, previously reported as #2323 in 2022. PR #3473 provides a fix.",
        "keySignals": [
          {
            "text": "If GC runs after the blob is created, the managed array memory might be moved resulting in a crash",
            "source": "body",
            "interpretation": "Reporter correctly identifies the core issue \u2014 fixed pinning is temporary but the native pointer outlives it.",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "fixed (byte* dataPtr = data) { return new Blob ((IntPtr)dataPtr, ...); }",
            "source": "body",
            "interpretation": "The fixed block exits immediately after the Blob constructor, releasing the pin while native code retains the pointer.",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          },
          {
            "text": "Should copy via an UnmanagedMemoryStream",
            "source": "body",
            "interpretation": "Reporter proposes allocating unmanaged memory instead, which is not subject to GC relocation.",
            "supportedFields": [
              "bugSignals.hasWorkaround"
            ]
          },
          {
            "text": "// TODO: check to see if we can avoid the second copy (the ToArray)",
            "source": "body",
            "interpretation": "Existing TODO in the code acknowledges the implementation is suboptimal. The fix would address both the TODO and the GC safety issue.",
            "supportedFields": [
              "type"
            ]
          },
          {
            "text": "Platform / Operating System: All",
            "source": "body",
            "interpretation": "GC safety issue affects all .NET runtimes and platforms equally.",
            "supportedFields": [
              "platforms"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The code has a clear memory safety bug: a managed array pointer is passed to native code but is not pinned for the lifetime of the native object. This can cause crashes or data corruption when GC runs.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "While the fix also improves performance (removes redundant copy), the core issue is a correctness bug that can cause crashes."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "HarfBuzzSharp",
            "expandedReason": "The bug is in binding/HarfBuzzSharp/Blob.cs, specifically in the HarfBuzzSharp.Blob class. The existing label area/SkiaSharp is incorrect \u2014 the correct area is HarfBuzzSharp.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "The Blob class is in the HarfBuzzSharp namespace, not SkiaSharp. No SkiaSharp code is involved."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "critical",
            "expandedReason": "Memory corruption from dangling pointers can cause crashes, silent data corruption, or security vulnerabilities. The issue is non-deterministic (depends on GC timing), making it hard to diagnose and potentially affecting production systems unpredictably.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "While a workaround exists (the reporter\u0027s proposed fix), the severity of memory corruption issues warrants critical rating because the consequences are unpredictable and potentially catastrophic."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "reliability",
            "expandedReason": "GC-induced memory corruption causes non-deterministic crashes \u2014 the hallmark of a reliability issue."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The bug is confirmed by code inspection and PR #3473 exists, but the PR needs maintainer review. The proposed fix assumes stream.Length is available, which doesn\u0027t hold for all Stream types (e.g., NetworkStream). The maintainer needs to review the fix approach.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "More urgency is warranted given the severity \u2014 this needs active investigation, not passive backlog treatment."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "binding/HarfBuzzSharp/Blob.cs",
            "relevance": "Verified the buggy code exists at lines 71-82, confirmed the fixed block only pins during the constructor call.",
            "usedFor": [
              "type",
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/research-by-type.md",
            "relevance": "Guided bug research workflow \u2014 checked source code, searched for duplicates, checked for existing fixes.",
            "usedFor": [
              "type",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "No native loading or platform-specific docs needed \u2014 this is a pure managed memory safety issue in C# code, not a native binary or platform-specific problem.",
        "uncertainties": [
          "Whether PR #3473\u0027s fix handles non-seekable streams (the proposed fix uses stream.Length which requires seekability)",
          "Whether there are other similar GC safety issues in HarfBuzzSharp or SkiaSharp bindings using the same fixed-block pattern",
          "Whether issue #2323 should be closed as duplicate of #3472 or vice versa (2323 was filed first in 2022)"
        ],
        "assumptions": [
          "Assumed the bug has existed since the method was written, not introduced in a specific version, based on the TODO comment being present in the code"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "Blob.FromStream() pins a managed byte array using a fixed block, but the pin is only active during the Blob constructor call. After the fixed block exits, the GC can relocate the array while native HarfBuzz code still holds a pointer to the original location, causing use-after-move memory corruption.",
        "researchDone": [
          "Inspected binding/HarfBuzzSharp/Blob.cs source code (lines 71-82) confirming the bug",
          "Found duplicate issue #2323 from Nov 2022 reporting the same exact concern",
          "Found open PR #3473 from the same reporter with a proposed fix",
          "Verified no other FromStream-like patterns exist in HarfBuzzSharp"
        ],
        "proposals": [
          {
            "title": "Merge PR #3473 with stream.Length fix",
            "description": "Review and merge the existing PR which uses Marshal.AllocCoTaskMem and UnmanagedMemoryStream to avoid GC interference. May need modification for non-seekable streams.",
            "steps": [
              "Review PR #3473 for correctness",
              "Address stream.Length assumption \u2014 add fallback for non-seekable streams (copy to MemoryStream first, then get length)",
              "Add unit tests for Blob.FromStream with various stream types",
              "Merge and close both #3472 and #2323"
            ],
            "pros": [
              "Fix already written and submitted by the reporter",
              "Uses unmanaged memory \u2014 completely avoids GC interference",
              "Also resolves the TODO about removing the redundant copy",
              "Performance improvement \u2014 eliminates double copy"
            ],
            "cons": [
              "Proposed fix assumes stream.Length is available \u2014 needs modification for non-seekable streams",
              "Changes memory ownership model (CoTaskMem vs managed array)"
            ],
            "confidence": 0.90,
            "effort": "low"
          },
          {
            "title": "Use GCHandle.Alloc with Pinned flag",
            "description": "Pin the managed byte array for the lifetime of the Blob using GCHandle.Alloc(data, GCHandleType.Pinned) instead of switching to unmanaged memory.",
            "steps": [
              "Replace fixed block with GCHandle.Alloc(data, GCHandleType.Pinned)",
              "Store GCHandle and free it in the release delegate",
              "Keep the managed array referenced to prevent GC collection",
              "Add unit tests"
            ],
            "pros": [
              "Minimal change to existing code structure",
              "Keeps managed memory \u2014 familiar pattern",
              "Works with all stream types (keeps MemoryStream.CopyTo approach)"
            ],
            "cons": [
              "Pinned objects fragment the managed heap",
              "Still has the redundant ToArray copy the TODO mentions",
              "Long-lived pins are generally discouraged in .NET"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Hybrid approach \u2014 MemoryStream buffer \u002B unmanaged copy",
            "description": "Keep the MemoryStream.CopyTo pattern for stream reading (works with all streams), then copy to unmanaged memory for the Blob pointer.",
            "steps": [
              "Read stream into MemoryStream as before (handles non-seekable streams)",
              "Allocate unmanaged memory with Marshal.AllocCoTaskMem(ms.Length)",
              "Copy from MemoryStream buffer to unmanaged memory using Marshal.Copy or Buffer.MemoryCopy",
              "Create Blob with unmanaged pointer and FreeCoTaskMem release delegate",
              "Add unit tests"
            ],
            "pros": [
              "Works with all stream types including non-seekable",
              "Uses unmanaged memory \u2014 no GC interference",
              "Clear ownership semantics"
            ],
            "cons": [
              "Still has double copy (stream \u2192 MemoryStream \u2192 unmanaged)",
              "Slightly more memory usage during the copy"
            ],
            "confidence": 0.85,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Merge PR #3473 with stream.Length fix",
        "recommendedReason": "The fix is already written and addresses both the GC safety bug and the performance TODO. It just needs a small modification to handle non-seekable streams. Lowest effort path to resolution."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3472"
    },
    {
      "schemaVersion": "1.0",
      "number": 3440,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T12:00:00Z",
      "summary": "MAUI app crashes on certain Windows systems with COMException in PropertySetExtensions WinRT activation during ANGLE surface creation",
      "type": {
        "value": "bug",
        "confidence": 0.97,
        "reason": "Reporter describes a crash with full stack trace during rendering initialization. The app crashes with COMException/TypeInitializationException, which is clearly broken behavior."
      },
      "area": {
        "value": "SkiaSharp.Views.Maui",
        "confidence": 0.90,
        "reason": "The crash occurs in SkiaSharp.Views.WinUI components (AngleSwapChainPanel, GlesContext, PropertySetExtensions) used through MAUI. The reporter is using a MAUI app with LiveCharts2. The existing label area/SkiaSharp.Views.Maui matches."
      },
      "backends": [
        {
          "value": "OpenGL",
          "confidence": 0.92,
          "reason": "The crash path goes through AngleSwapChainPanel \u2192 GlesContext.CreateSurface, which is the ANGLE OpenGL ES backend. ANGLE translates OpenGL ES to Direct3D on Windows."
        }
      ],
      "platforms": [
        {
          "value": "Windows-WinUI",
          "confidence": 0.97,
          "reason": "Explicitly Windows 11, WinUI 3 stack. The crash is in SkiaSharp.Views.WinUI.Native.PropertySetExtensions, a WinRT C\u002B\u002B/WinRT component specific to WinUI."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.97,
          "reason": "Application crash during rendering initialization. The COMException causes a TypeInitializationException that terminates rendering."
        }
      ],
      "partner": {
        "value": "maui",
        "confidence": 0.75,
        "reason": "The reporter is using .NET MAUI with LiveCharts2. However, the crash is in SkiaSharp\u0027s WinUI native component, not in MAUI itself. The MAUI partner may have insight into deployment of WinRT components in MAUI apps."
      },
      "regression": null,
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": true,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net8.0-windows",
          "net9.0-windows"
        ],
        "severity": "high",
        "severityReason": "Application crash with no known workaround. Occurs on certain deployed systems making it an environment-dependent failure that blocks production use. No way to fall back since the crash happens during view initialization."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a MAUI app with LiveCharts2 that uses SkiaSharp 3.119.1 for drawing charts",
          "Deploy the app to a Windows 11 system (reported on Lenovo 83C4, Windows 11 10.0.26100.7462)",
          "Launch the app \u2014 the app crashes when AngleSwapChainPanel loads and attempts to create the ANGLE render surface"
        ],
        "codeSnippets": [
          {
            "language": "xml",
            "code": "\u003CliveCharts:CartesianChart x:Name=\u0022Graph\u0022\n                                   AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022\n                                   AbsoluteLayout.LayoutFlags=\u0022PositionProportional,SizeProportional\u0022\n                                   ZoomMode=\u0022None\u0022\n                                   EasingFunction=\u0022{x:Null}\u0022\n                                   ... /\u003E",
            "context": "XAML markup for the LiveCharts2 CartesianChart that triggers the crash via SkiaSharp rendering"
          },
          {
            "language": "text",
            "code": "System.Runtime.InteropServices.COMException: Element not found.\n  at void Marshal.ThrowExceptionForHR(int errorCode)() in Marshal.cs:line 856\n  at new BaseActivationFactory(string typeNamespace, string typeFullName)()\n  at static PropertySetExtensions()()\n\nSystem.TypeInitializationException: The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception.\n  at IObjectReference PropertySetExtensions.get__objRef_global__SkiaSharp_Views_WinUI_Native_IPropertySetExtensionsStatics()()\n  at void PropertySetExtensions.AddSingle(PropertySet propertySet, string key, float value)()\n  at void GlesContext.CreateSurface(SwapChainPanel panel, Size? renderSurfaceSize, float? resolutionScale)()\n  at void AngleSwapChainPanel.EnsureRenderSurface()()\n  at void AngleSwapChainPanel.OnLoaded(object sender, RoutedEventArgs e)()\n  at int RoutedEventHandler.Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e)()",
            "context": "Full stack trace showing the COMException during WinRT activation of PropertySetExtensions"
          }
        ],
        "environmentDetails": "Windows 11 (10.0.26100.7462), Lenovo 83C4, SkiaSharp 3.119.1, MAUI app with LiveCharts2. Tried with HA (Hardware Acceleration) enabled and disabled \u2014 same result."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.119.1"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Version 3.119.1 is the current stable release. The WinRT activation issue with PropertySetExtensions has been reported across multiple 3.x versions (3.0-preview3.1 in #2948, 3.116.1 and 3.119.0-preview in #2968). This appears to be a persistent issue not yet resolved in the codebase.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.85,
        "reason": "This is a known pattern of WinRT activation failures for SkiaSharp.Views.WinUI.Native.PropertySetExtensions that has recurred across multiple versions (#2948, #2968, #2900). The root cause \u2014 WinRT component registration failing on certain systems \u2014 needs engineering investigation. The closely related #2968 (unpackaged mode crash) was being investigated by mattleibow but the underlying issue with PropertySetExtensions activation remains unresolved.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.75,
        "reason": "Can provide context from related issues and potential diagnostic steps, but no confirmed fix exists yet.",
        "draft": "Thanks for the detailed stack trace \u2014 that\u0027s very helpful for diagnosing this.\n\nThis is a known issue pattern where the WinRT activation factory for \u0060SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0060 fails on certain Windows configurations. We\u0027ve seen similar reports in #2948 (MS Store certification) and #2968 (unpackaged mode), both involving the same \u0060PropertySetExtensions\u0060 \u2192 \u0060GlesContext.CreateSurface\u0060 \u2192 \u0060AngleSwapChainPanel\u0060 call path.\n\nThe \u0060COMException: Element not found\u0060 during \u0060BaseActivationFactory\u0060 construction suggests the WinRT component DLL (\u0060SkiaSharp.Views.WinUI.Native.dll\u0060) either isn\u0027t deployed alongside the app or can\u0027t be found by the WinRT activation system on that particular system.\n\nA couple of questions that would help narrow this down:\n\n1. Is the app deployed as packaged (MSIX) or unpackaged (\u0060WindowsPackageType=None\u0060)?\n2. Can you confirm whether \u0060SkiaSharp.Views.WinUI.Native.dll\u0060 exists in the app\u0027s output directory on the failing system?\n\nAs a potential workaround, using \u0060SKCanvasView\u0060 instead of \u0060SKGLView\u0060 would bypass the ANGLE/OpenGL path entirely, though with CPU rendering instead of GPU-accelerated."
      },
      "analysisNotes": {
        "summary": "MAUI app with LiveCharts2 crashes on certain Windows 11 systems during ANGLE render surface creation. The WinRT activation factory for SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails with COMException \u0027Element not found\u0027. This is part of a recurring pattern of WinRT component activation failures seen in #2948, #2968, and #2900.",
        "keySignals": [
          {
            "text": "System.Runtime.InteropServices.COMException: Element not found.",
            "source": "stack-trace",
            "interpretation": "WinRT activation factory cannot find the SkiaSharp.Views.WinUI.Native component. This is different from #2948\u0027s REGDB_E_CLASSNOTREG but same root area \u2014 WinRT component registration/discovery failure.",
            "supportedFields": [
              "type",
              "bugSignals.severity",
              "area"
            ]
          },
          {
            "text": "The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception",
            "source": "stack-trace",
            "interpretation": "Static constructor failure in the WinRT projection class. Once this fails, all subsequent uses of PropertySetExtensions will also fail with TypeInitializationException.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "crashes on certain systems",
            "source": "body",
            "interpretation": "Environment-dependent failure \u2014 suggests deployment or system configuration issue rather than a universal code bug. May be related to packaged vs unpackaged mode, Windows App SDK installation, or GPU driver state.",
            "supportedFields": [
              "bugSignals.severity",
              "actionability"
            ]
          },
          {
            "text": "tried both with HA enabled and disabled but the result is the same",
            "source": "body",
            "interpretation": "Hardware acceleration toggle doesn\u0027t affect the crash, confirming the issue is in WinRT component activation (before any GPU interaction), not in the actual rendering pipeline.",
            "supportedFields": [
              "bugSignals"
            ]
          },
          {
            "text": "MAUI app with LiveCharts2 that uses SkiaSharp 3.119.1",
            "source": "body",
            "interpretation": "Third-party library (LiveCharts2) uses SkiaSharp for rendering. The user may not have direct control over which SkiaSharp view type is used (SKGLView vs SKCanvasView).",
            "supportedFields": [
              "area",
              "versionAnalysis"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The issue reports a crash with a full stack trace. The app terminates with COMException during normal rendering initialization. This is clearly broken behavior, not a usage question or feature request."
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views.Maui",
            "expandedReason": "The crash is in SkiaSharp.Views.WinUI components (PropertySetExtensions, GlesContext, AngleSwapChainPanel) used through a MAUI app. While the failing code is technically in the WinUI views layer, the reporter\u0027s context is MAUI and the existing label correctly scopes it.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views",
                "whyRejected": "SkiaSharp.Views.Maui is more specific and matches the existing label. The crash is in MAUI-deployed WinUI views."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Windows-WinUI",
            "expandedReason": "The crash is in SkiaSharp.Views.WinUI.Native, a WinUI 3 specific component. The reporter confirms Windows 11 and the stack trace shows WinUI-specific types (SwapChainPanel, RoutedEventHandler)."
          },
          {
            "field": "backends",
            "chosen": "OpenGL",
            "expandedReason": "The crash path is AngleSwapChainPanel \u2192 GlesContext \u2192 ANGLE (OpenGL ES translated to Direct3D). The ANGLE/GLES rendering backend is the specific path that triggers this failure because it requires PropertySetExtensions for EGL surface configuration."
          },
          {
            "field": "tenets",
            "chosen": "reliability",
            "expandedReason": "Application crash during view initialization. The COMException is unrecoverable and prevents any rendering from occurring."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Crash with no known workaround for users who need GPU-accelerated rendering via SKGLView. The crash occurs during initialization so there\u0027s no opportunity for graceful degradation. However, it only affects \u0027certain systems\u0027 so it\u0027s not universal \u2014 hence high rather than critical.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "The crash is environment-specific (\u0027certain systems\u0027), not universal. Apps using SKCanvasView are unaffected."
              },
              {
                "value": "medium",
                "whyRejected": "No confirmed workaround for affected users, and the crash is unrecoverable."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "This is part of a pattern of unresolved WinRT activation failures. #2948 was closed as externally fixed but #2968 is still open and assigned to mattleibow. The root cause in SkiaSharp (PropertySetExtensions as a WinRT component that may fail to activate) needs investigation for a robust solution.",
            "alternatives": [
              {
                "value": "close-as-duplicate",
                "whyRejected": "While related to #2968, this issue has a different COMException (Element not found vs REGDB_E_CLASSNOTREG) and different trigger context (deployed packaged app vs unpackaged mode). It provides additional data points for the same underlying problem area."
              },
              {
                "value": "request-info",
                "whyRejected": "While more info would help (packaged vs unpackaged, DLL presence), the stack trace and environment details are sufficient to classify and begin investigation."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for Windows-specific quirks. Found ARM64 \u002B VC\u002B\u002B Redistributable note but no specific WinRT activation pattern documented.",
            "usedFor": [
              "platforms",
              "bugSignals"
            ]
          },
          {
            "path": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/GlesContext.cs",
            "relevance": "Confirmed the crash path: CreateSurface calls PropertySetExtensions.AddSingle and AddSize to configure EGL surface properties. The PropertySetExtensions WinRT component is required for ANGLE surface creation.",
            "usedFor": [
              "area",
              "backends",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "relevance": "Confirmed OnLoaded creates GlesContext and calls EnsureRenderSurface which triggers CreateSurface. No error handling around the WinRT activation failure.",
            "usedFor": [
              "area",
              "resolutionAnalysis"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult documentation/packages.md as this is not a native loading/DllNotFoundException issue \u2014 it\u0027s a WinRT component activation failure. Did not consult .docs as this is not a usage question.",
        "uncertainties": [
          "Whether the reporter\u0027s app is deployed as packaged (MSIX) or unpackaged \u2014 this significantly affects WinRT component discovery",
          "Whether SkiaSharp.Views.WinUI.Native.dll is present in the app output on the failing systems",
          "Whether the failing systems have Windows App SDK runtime installed or if the app is self-contained",
          "The exact relationship between this failure mode (Element not found) and #2968\u0027s failure mode (REGDB_E_CLASSNOTREG) \u2014 same root cause or different paths"
        ],
        "assumptions": [
          "Assumed the app is using SKGLView (via LiveCharts2) since the crash path is through AngleSwapChainPanel, which is the GPU-accelerated OpenGL ES view",
          "Assumed target framework is net8.0-windows or net9.0-windows based on SkiaSharp 3.119.1 being a modern version"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The WinRT activation factory for SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails because the C\u002B\u002B/WinRT component DLL cannot be discovered by the WinRT activation system on certain Windows configurations. This is likely due to the component not being properly registered in the app manifest or the DLL not being in the expected location for WinRT discovery. The \u0027Element not found\u0027 COMException suggests the activation catalog entry exists but the backing DLL or class cannot be located.",
        "researchDone": [
          "Examined source code for GlesContext.CreateSurface and AngleSwapChainPanel.EnsureRenderSurface to understand the crash path",
          "Found closely related issues: #2948 (same stack trace, REGDB_E_CLASSNOTREG in MS Store cert, closed as externally fixed), #2968 (SKGLView crash in unpackaged mode, assigned to mattleibow, still being investigated), #2900 (similar WinRT activation crash pattern)",
          "Reviewed PropertySetExtensions native source location (native/winui/SkiaSharp.Views.WinUI.Native/)",
          "Analyzed the difference between COMException error codes: \u0027Element not found\u0027 vs \u0027Class not registered\u0027"
        ],
        "proposals": [
          {
            "title": "Use SKCanvasView instead of SKGLView as workaround",
            "description": "Configure LiveCharts2 to use SKCanvasView (CPU rendering) instead of SKGLView (GPU via ANGLE). This bypasses the entire AngleSwapChainPanel/GlesContext/PropertySetExtensions code path.",
            "steps": [
              "Check LiveCharts2 configuration for view type selection",
              "If LiveCharts2 supports it, configure to use SKCanvasView on Windows",
              "If LiveCharts2 doesn\u0027t expose this, fork or file an issue with LiveCharts2"
            ],
            "pros": [
              "Immediately bypasses the crash",
              "No changes needed in SkiaSharp",
              "SKCanvasView is more reliable on Windows"
            ],
            "cons": [
              "CPU rendering instead of GPU-accelerated \u2014 may impact performance for complex charts",
              "May not be configurable in LiveCharts2 without code changes",
              "Doesn\u0027t fix the underlying issue for other users"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Add try-catch around PropertySetExtensions in GlesContext.CreateSurface",
            "description": "Wrap the PropertySetExtensions calls in GlesContext.CreateSurface with try-catch to handle WinRT activation failures gracefully, either falling back to creating the surface without the optional properties or surfacing a clear error message.",
            "steps": [
              "In GlesContext.CreateSurface, wrap PropertySetExtensions.AddSize and AddSingle calls in try-catch(COMException)",
              "On failure, skip the optional resolution scale/surface size properties and attempt surface creation without them",
              "If surface creation fails without those properties, throw a descriptive exception suggesting SKCanvasView as alternative",
              "Add unit tests for the fallback path"
            ],
            "pros": [
              "Makes the rendering path more robust",
              "Graceful degradation instead of hard crash",
              "The resolution scale and surface size properties may be optional for basic rendering"
            ],
            "cons": [
              "May result in incorrect scaling or rendering quality without the properties",
              "Masks the underlying WinRT activation issue",
              "Needs testing to verify ANGLE works without these PropertySet entries"
            ],
            "confidence": 0.60,
            "effort": "medium"
          },
          {
            "title": "Replace WinRT PropertySetExtensions with managed alternative",
            "description": "Eliminate the dependency on the C\u002B\u002B/WinRT component (SkiaSharp.Views.WinUI.Native.dll) by implementing PropertySet manipulation in managed code using the WinRT interop APIs directly, avoiding the activation factory entirely.",
            "steps": [
              "Research whether PropertySet.Add with boxed float/Size values works via managed WinRT interop",
              "Implement managed equivalents of PropertySetExtensions.AddSingle and AddSize",
              "Remove dependency on SkiaSharp.Views.WinUI.Native C\u002B\u002B/WinRT component for this functionality",
              "Test across packaged and unpackaged deployment modes",
              "Verify ANGLE receives the correct EGL properties through the managed path"
            ],
            "pros": [
              "Eliminates the WinRT activation failure entirely",
              "Removes a native component dependency that causes deployment issues",
              "Fixes this class of issues across all deployment modes (packaged, unpackaged, Store)"
            ],
            "cons": [
              "Requires understanding of how ANGLE consumes PropertySet values \u2014 type boxing must match native expectations",
              "Higher development effort and risk",
              "May need careful testing of float/Size marshaling between managed and native WinRT"
            ],
            "confidence": 0.70,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Replace WinRT PropertySetExtensions with managed alternative",
        "recommendedReason": "This is the root-cause fix that would eliminate the entire class of WinRT activation failures seen across #2948, #2968, #2900, and #3440. The C\u002B\u002B/WinRT component exists solely to add typed values to a PropertySet, which should be achievable in managed code. While higher effort, it permanently solves the recurring deployment and activation issues."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3440"
    },
    {
      "schemaVersion": "1.0",
      "number": 3437,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-08T15:00:00Z",
      "summary": "SKSvgCanvas text elements lose content and x/y attributes when used in parallel threads on Windows",
      "type": {
        "value": "bug",
        "confidence": 0.98,
        "reason": "Reporter describes broken SVG output with text elements rendered with missing values. Clear expected vs actual behavior with regression from 2.88.9."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.90,
        "reason": "SKSvgCanvas.Create is in the core SkiaSharp binding (SKSVG.cs). The bug is in the underlying Skia SVG text rendering, not a view or platform-specific package."
      },
      "backends": [
        {
          "value": "SVG",
          "confidence": 0.98,
          "reason": "Issue exclusively involves SKSvgCanvas and its SVG text output."
        }
      ],
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.95,
          "reason": "Reporter explicitly states Windows-only. Confirmed in comment: tested on Ubuntu 22.04 WSL with 50 parallel tasks and 100 text elements with no bug."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "SVG output is silently corrupted without any error or exception. This is a data corruption and reliability issue."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.92,
        "reason": "Reporter explicitly states this is a regression from SkiaSharp 2.88.9. The 2.x to 3.x transition changed the underlying Skia version significantly.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "complete",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net8.0"
        ],
        "severity": "high",
        "severityReason": "Silent data corruption in SVG output with no workaround. Text content is dropped from rendered SVGs when using parallel tasks. No error is reported, making this hard to detect."
      },
      "reproEvidence": {
        "repoLinks": [
          {
            "url": "https://github.com/jankurianski/skiasharp-svg-text-missing-bug",
            "description": "Complete reproduction project demonstrating the threading bug with SKSvgCanvas text rendering on Windows."
          }
        ],
        "stepsToReproduce": [
          "Clone https://github.com/jankurianski/skiasharp-svg-text-missing-bug",
          "Run on Windows (Linux is unaffected)",
          "The program creates 5 parallel Task.Run() calls, each creating an independent SKSvgCanvas and drawing 10 text elements",
          "Inspect SVG output - some text elements will have empty x/y attributes and missing text content"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "await Task.WhenAll(Enumerable.Range(0, 5).Select(i =\u003E Task.Run(() =\u003E drawSvgFunc(i)))).ConfigureAwait(false);",
            "context": "Parallel SVG generation using Task.Run with separate SKSvgCanvas per task"
          },
          {
            "language": "xml",
            "code": "\u003Ctext font-size=\u002214\u0022 font-family=\u0022Arial\u0022 x=\u0022\u0022 y=\u0022\u0022\u003E\n\n\u003C/text\u003E",
            "context": "Actual broken output with missing text content and positions"
          }
        ],
        "environmentDetails": "Windows 11, Visual Studio Code, SkiaSharp 3.116.0 / 3.119.1 / 3.119.2-preview.1. Bug does NOT occur on Ubuntu 22.04.2 LTS (tested via WSL)."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "3.119.1",
          "3.119.2-preview.1",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Bug confirmed on latest preview (3.119.2-preview.1) and all 3.x versions tested. The underlying Skia text shaping code is unlikely to have changed between these versions.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.92,
        "reason": "Well-documented bug with complete reproduction, clear regression, and platform isolation. Needs investigation into Skia SVG text rendering thread safety on Windows.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "Thread-safety bug in SVG text rendering on Windows. Each parallel task creates its own independent SKSvgCanvas, SKPaint, SKTypeface, and SKFont. Despite no shared objects, text elements in the SVG output are silently corrupted. This points to shared global state in Skia\u0027s text pipeline (likely DirectWrite on Windows).",
        "keySignals": [
          {
            "text": "When creating an SKSvgCanvas in a thread (via Task.Run()), text elements will sometimes have their text value and x/y attribute values removed.",
            "source": "body",
            "interpretation": "Race condition in SVG text serialization causing non-deterministic output corruption under concurrency",
            "supportedFields": [
              "type",
              "bugSignals.severity",
              "tenets"
            ]
          },
          {
            "text": "This is a regression from SkiaSharp 2.88.9 which does not have the bug",
            "source": "body",
            "interpretation": "Regression introduced in the 2.x to 3.x transition, likely due to Skia engine upgrade changing text shaping pipeline",
            "supportedFields": [
              "regression"
            ]
          },
          {
            "text": "This affects all SkiaSharp 3.x versions on Windows. Linux is unaffected.",
            "source": "body",
            "interpretation": "Windows-specific, pointing to DirectWrite font system or Windows-specific text shaping code path",
            "supportedFields": [
              "platforms",
              "bugSignals"
            ]
          },
          {
            "text": "I tested the bug on Ubuntu 22.04.2 LTS (using WSL) and the bug does not occur there. I even increased the number of text elements per SVG drawn from 10 to 100, and the number of parallel tasks from 5 to 50.",
            "source": "comment 2",
            "interpretation": "Rigorous cross-platform testing by reporter confirms Windows-only. Linux uses FreeType/fontconfig while Windows uses DirectWrite.",
            "supportedFields": [
              "platforms"
            ]
          },
          {
            "text": "The more text elements being drawn and the more threads running the same task, the more likely the problem is to occur.",
            "source": "body",
            "interpretation": "Classic race condition symptom where increased concurrency increases probability of corruption",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Reporter describes clear broken behavior with SVG output silently corrupted. The issue template is BUG, expected vs actual behavior is documented, and there is a regression from a working version.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Not asking how to do something. Reporting incorrect output from a well-defined API operation."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "SKSvgCanvas is in the core SkiaSharp namespace (binding/SkiaSharp/SKSVG.cs). The C API call sk_svgcanvas_create_with_stream wraps SkSVGCanvas::Make. The thread-safety issue is in the native text pipeline, surfaced through the core binding.",
            "alternatives": [
              {
                "value": "libSkiaSharp.native",
                "whyRejected": "While the root cause is in native code, the issue is experienced through the managed API and the area/SkiaSharp label was already applied by maintainers."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "SVG",
            "expandedReason": "The bug is exclusively about SVG canvas output. SKSvgCanvas produces SVG markup, and the corruption is in the SVG text elements."
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "Explicitly Windows-only. Reporter tested Linux and confirmed no issue even with 50 parallel tasks and 100 text elements."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Silent data corruption with no workaround. The bug produces incorrect SVG output without any indication of failure. Server-side parallel SVG generation is a common use case.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "No crash, data loss, or security issue. The corruption is detectable by inspecting output."
              },
              {
                "value": "medium",
                "whyRejected": "No workaround exists. The only mitigation is to serialize SVG generation, which defeats the purpose of parallelism."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause needs to be identified in the Skia native SVG text rendering pipeline. The bug has an excellent reproduction and is clearly a real defect."
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked threading patterns. Confirms Skia is not thread-safe. However, this issue involves separate instances per thread, not shared objects.",
            "usedFor": [
              "type",
              "bugSignals"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Field definitions and enum values for generating valid triage JSON",
            "usedFor": [
              "type",
              "area",
              "backends",
              "platforms",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated JSON output format and confidence levels",
            "usedFor": [
              "type",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "path": "binding/SkiaSharp/SKSVG.cs",
            "relevance": "Confirmed SKSvgCanvas.Create wraps sk_svgcanvas_create_with_stream and returns a new SKCanvas instance per call.",
            "usedFor": [
              "area"
            ]
          },
          {
            "path": "externals/skia/src/c/sk_svg.cpp",
            "relevance": "C API calls SkSVGCanvas::Make which should create an independent canvas. Thread-safety issue must be deeper in text shaping or serialization.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          }
        ],
        "docsNotConsulted": "No native loading docs needed as this is not a DllNotFoundException or deployment issue. No packages.md consultation needed as the correct binaries are loaded and functioning.",
        "uncertainties": [
          "Exact location of the thread-safety violation: could be in SkSVGDevice text serialization, SkShaper/HarfBuzz text shaping, or DirectWrite font queries on Windows",
          "Whether the fix should be in Skia native code or in the C# wrapper with synchronization",
          "Whether other canvas backends (PDF, XPS) have similar threading issues with text rendering on Windows"
        ],
        "assumptions": [
          "Assumed net8.0 target framework since no explicit TFM was mentioned but the code uses modern C# features and runs on Windows 11",
          "Assumed the repro project at the GitHub link is accurate based on the inline code in the issue body"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "Skia\u0027s text shaping pipeline on Windows uses DirectWrite, which likely has global state or caching that is not thread-safe. When multiple threads simultaneously shape text for SVG serialization, the glyph positions and text content are corrupted by a race condition. This does not occur on Linux because FreeType/fontconfig have a different text shaping implementation. The regression from 2.88.9 to 3.x aligns with Skia\u0027s text pipeline rewrite between those engine versions.",
        "researchDone": [
          "Examined SKSvgCanvas C# binding (SKSVG.cs) - each Create call produces an independent SKCanvas",
          "Examined C API sk_svg.cpp - SkSVGCanvas::Make creates independent canvas instances",
          "Checked skia-patterns.md for known threading issues",
          "Searched GitHub issues for related SKSvgCanvas threading bugs - no duplicates found",
          "Reviewed issue comments - reporter confirmed Linux unaffected after rigorous testing"
        ],
        "proposals": [
          {
            "title": "Investigate and fix Skia SVG text thread safety",
            "description": "Debug the race condition in the Skia native SVG text rendering path on Windows. Identify the shared global state and add appropriate synchronization.",
            "steps": [
              "Clone the reproduction repo and confirm the bug on Windows",
              "Add logging in SkSVGDevice::drawGlyphRunList to trace text serialization",
              "Identify whether corruption occurs during text shaping or SVG XML serialization",
              "If in DirectWrite: add thread-local cache or mutex around font shaping calls",
              "If in SVG serialization: add synchronization to the affected global state",
              "Rebuild native library and verify fix with the reproduction project"
            ],
            "pros": [
              "Addresses root cause",
              "Fixes the issue for all users",
              "Maintains parallel performance once the specific bottleneck is synchronized"
            ],
            "cons": [
              "Requires native Skia code changes",
              "Synchronization may introduce minor performance overhead",
              "High effort requiring understanding of Skia text pipeline internals"
            ],
            "confidence": 0.80,
            "effort": "high"
          },
          {
            "title": "Add managed-side lock around SVG canvas text operations",
            "description": "Add a static lock in the SkiaSharp C# binding to serialize DrawText calls when using SKSvgCanvas. This is a workaround that prevents the race condition without fixing root cause.",
            "steps": [
              "Add a static object lock in SKCanvas or a helper class",
              "In the C# DrawText overloads detect if the canvas is an SVG canvas and acquire the lock",
              "Alternatively provide a thread-safe wrapper method",
              "Test with the reproduction project to confirm the fix"
            ],
            "pros": [
              "Can be implemented entirely in managed code with no Skia rebuild needed",
              "Quick to implement and ship"
            ],
            "cons": [
              "Serializes text drawing and reduces parallel performance",
              "Detecting SVG canvas type at runtime adds complexity",
              "Does not fix the root cause and may miss other thread-unsafe paths"
            ],
            "confidence": 0.65,
            "effort": "medium"
          },
          {
            "title": "Document thread-safety limitation and recommend serialization",
            "description": "Document that SKSvgCanvas text rendering is not thread-safe on Windows and recommend users serialize SVG generation or use SemaphoreSlim to limit concurrency.",
            "steps": [
              "Add a thread-safety warning to SKSvgCanvas documentation",
              "Provide a code sample showing SemaphoreSlim(1,1) pattern for parallel SVG generation",
              "Respond to the issue with the workaround"
            ],
            "pros": [
              "Immediate workaround for affected users",
              "No code changes needed",
              "Low risk"
            ],
            "cons": [
              "Does not fix the bug and shifts burden to users",
              "Serialization defeats the purpose of parallel SVG generation",
              "May not be discoverable as users hit the bug before finding the docs"
            ],
            "confidence": 0.50,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Investigate and fix Skia SVG text thread safety",
        "recommendedReason": "This is a regression with a clear reproduction and real-world impact on server-side parallel SVG generation. The root cause should be identified and fixed in the native layer. The reporter has done excellent work isolating the issue to Windows-only, which narrows the investigation to the DirectWrite text pipeline."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3437"
    },
    {
      "schemaVersion": "1.0",
      "number": 3435,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-07-15T12:00:00Z",
      "summary": "DllNotFoundException for libSkiaSharp in Blazor WASM after upgrading from .NET 9 to .NET 10 \u2014 duplicate of #3422",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "DllNotFoundException is a runtime failure. The app worked on .NET 9 and broke after upgrading to .NET 10, indicating broken behavior rather than a usage question."
      },
      "area": {
        "value": "SkiaSharp.Views.Blazor",
        "confidence": 0.90,
        "reason": "Issue is specific to Blazor WASM. On WASM, native assets are statically linked via NativeFileReference at build time (not dynamic P/Invoke), so this is a Blazor integration issue. The canonical issue #3422 also uses area/SkiaSharp.Views.Blazor."
      },
      "backends": null,
      "platforms": [
        {
          "value": "WASM",
          "confidence": 0.95,
          "reason": "Reporter explicitly states \u0027Blazor, WASM\u0027 as the platform and the issue title references DllNotFoundException in a Blazor app."
        }
      ],
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.90,
          "reason": "The issue is triggered by upgrading from .NET 9 to .NET 10, making it a cross-version compatibility problem."
        },
        {
          "value": "reliability",
          "confidence": 0.85,
          "reason": "The DllNotFoundException causes a hard runtime failure that prevents the app from functioning."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.90,
        "reason": "Reporter explicitly states \u0027.Net 9 app worked with 3.116.1\u0027 \u2014 the same SkiaSharp version that now fails after upgrading the target framework to .NET 10.",
        "workedInVersion": "3.116.1",
        "brokeInVersion": "3.116.1"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net10.0"
        ],
        "severity": "high",
        "severityReason": "Complete failure \u2014 SkiaSharp is entirely non-functional on Blazor WASM with .NET 10. No workaround has been identified. The DllNotFoundException prevents any SkiaSharp usage."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a Blazor WASM app targeting .NET 9 with SkiaSharp 3.116.1",
          "Verify it works on .NET 9",
          "Upgrade the app to target .NET 10",
          "Run the app \u2014 DllNotFoundException for libSkiaSharp occurs at runtime"
        ],
        "relatedIssues": [
          3422
        ],
        "environmentDetails": "Blazor WASM, .NET 10, SkiaSharp 3.116.1 and 3.119.2-preview.1 both fail"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.1",
          "3.119.2-preview.1"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Issue affects the current SkiaSharp 3.x line on the latest .NET 10 preview. Both stable (3.116.1) and preview (3.119.2-preview.1) versions are affected, indicating the issue is in the .NET 10 WASM toolchain or SkiaSharp\u0027s static linking integration, not a specific SkiaSharp version."
      },
      "actionability": {
        "suggestedAction": "close-as-duplicate",
        "confidence": 0.92,
        "reason": "Issue #3422 reports the identical problem (Blazor WASM \u002B .NET 10 \u002B DllNotFoundException/TypeInitializationException) with more detail, more community engagement (8 comments), and was filed a month earlier. Community member @Webreaper already identified this as a duplicate.",
        "requiresHumanReview": false,
        "closeable": true,
        "closeReason": "Duplicate of #3422 which tracks the same Blazor WASM \u002B .NET 10 native loading failure with more detail.",
        "duplicateOf": 3422,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "duplicate-notice",
        "confidence": 0.90,
        "reason": "Clear duplicate \u2014 same symptoms, same platform, same .NET version upgrade trigger. The canonical issue has more context and activity.",
        "draft": "Thanks for reporting this. This looks like the same Blazor WASM \u002B .NET 10 issue tracked in #3422, which has more discussion and context. Closing as duplicate \u2014 please follow #3422 for updates.\n\nThe underlying issue is that SkiaSharp\u0027s WASM native assets (statically linked \u0060.a\u0060 files) need to be updated to work with changes in the .NET 10 WebAssembly toolchain."
      },
      "analysisNotes": {
        "summary": "This is a duplicate of #3422. Both report DllNotFoundException for libSkiaSharp when running a Blazor WASM app after upgrading from .NET 9 to .NET 10. The issue affects all tested SkiaSharp versions (3.116.1 and 3.119.2-preview.1), pointing to a .NET 10 WASM toolchain incompatibility rather than a SkiaSharp version-specific bug.",
        "keySignals": [
          {
            "text": "[BUG] System.DllNotFoundException: libSkiaSharp",
            "source": "title",
            "interpretation": "Native library loading failure \u2014 on WASM this means static linking at build time failed to produce a working dotnet.wasm binary.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals"
            ]
          },
          {
            "text": "Started getting this runtime error after upgrading Blazor app from .Net 9 to .Net 10",
            "source": "body",
            "interpretation": "Regression triggered by .NET framework upgrade, not SkiaSharp version change. Points to .NET 10 WASM toolchain breaking change.",
            "supportedFields": [
              "type",
              "regression",
              "tenets"
            ]
          },
          {
            "text": ".Net 9 app worked with 3.116.1",
            "source": "body",
            "interpretation": "Confirms regression \u2014 same SkiaSharp version works on .NET 9 but not .NET 10.",
            "supportedFields": [
              "regression"
            ]
          },
          {
            "text": "Tried with 3.116.1 and 3.119.2-preview1",
            "source": "body",
            "interpretation": "Multiple SkiaSharp versions affected, ruling out a version-specific SkiaSharp bug.",
            "supportedFields": [
              "versionAnalysis"
            ]
          },
          {
            "text": "Platform / Operating System: Blazor, WASM",
            "source": "body",
            "interpretation": "WASM platform confirmed. WASM uses static linking, not dynamic P/Invoke, so DllNotFoundException indicates build-time linking failure.",
            "supportedFields": [
              "area",
              "platforms"
            ]
          },
          {
            "text": "Duplicate of https://github.com/mono/SkiaSharp/issues/3422",
            "source": "comment 2",
            "interpretation": "Community member identified this as a duplicate of #3422 which reports the same Blazor WASM \u002B .NET 10 failure with more detail.",
            "supportedFields": [
              "actionability"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "DllNotFoundException is a hard runtime failure. The reporter describes working functionality that broke after an environment change (.NET 10 upgrade). This is clearly broken behavior, not a question or feature request."
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views.Blazor",
            "expandedReason": "The issue is specific to Blazor WASM. On this platform, SkiaSharp.Views.Blazor auto-includes SkiaSharp.NativeAssets.WebAssembly which provides the static library (.a) linked into dotnet.wasm at build time. The failure is in this WASM-specific integration path.",
            "alternatives": [
              {
                "value": "libSkiaSharp.native",
                "whyRejected": "While the error is about loading the native library, WASM uses a fundamentally different mechanism (static linking vs dynamic loading). The issue is in the Blazor/WASM build integration, not the native binary itself. The canonical issue #3422 also uses SkiaSharp.Views.Blazor."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "WASM",
            "expandedReason": "Explicitly stated by the reporter. Blazor WASM is the only affected platform \u2014 the same SkiaSharp version works on other platforms."
          },
          {
            "field": "tenets",
            "chosen": "compatibility, reliability",
            "expandedReason": "Compatibility because it\u0027s a cross-version regression triggered by .NET 9\u219210 upgrade. Reliability because it\u0027s a hard runtime failure (DllNotFoundException)."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "SkiaSharp is completely non-functional on Blazor WASM with .NET 10 \u2014 no partial functionality, no workaround identified. However, not \u0027critical\u0027 because it\u0027s not a crash in production with data loss, and users can stay on .NET 9 as a temporary mitigation.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "No data loss or security impact. Users can temporarily remain on .NET 9."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "Issue #3422 was filed a month earlier, has 8 comments with more community engagement, includes reproduction code, and reports the identical problem. A community member already identified this as a duplicate in the comments."
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed WASM uses static linking (.a files via NativeFileReference), not dynamic P/Invoke. DllNotFoundException on WASM means the static linking at build time failed. Also confirmed SkiaSharp.Views.Blazor auto-includes NativeAssets.WebAssembly.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Confirmed WASM static linking pattern: \u0027.a files linked into dotnet.wasm at build time via NativeFileReference\u0027. No dynamic .so/.dll deployment on WASM.",
            "usedFor": [
              "area",
              "analysisNotes"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Field definitions, enum values, and cross-field validation rules.",
            "usedFor": [
              "type",
              "area",
              "platforms",
              "actionability"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated output format and confidence scoring against the duplicate and bug examples.",
            "usedFor": [
              "type",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult docs/SkiaSharpAPI/*.xml or .docs/ \u2014 this is a native loading/build infrastructure issue, not an API usage question.",
        "uncertainties": [
          "Whether this is caused by a breaking change in .NET 10\u0027s Emscripten/WASM toolchain or a SkiaSharp build configuration issue",
          "Whether the issue is fixed by a newer SkiaSharp preview beyond 3.119.2-preview.1",
          "The exact error chain \u2014 reporter did not provide detailed build output or browser console logs"
        ],
        "assumptions": [
          "Assumed the reporter is using SkiaSharp.Views.Blazor (which auto-includes NativeAssets.WebAssembly) since they mention a Blazor app, though this is not explicitly confirmed in the issue body"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The .NET 10 WASM toolchain introduced breaking changes to how native static libraries (.a files) are linked via NativeFileReference, causing SkiaSharp\u0027s pre-built Emscripten .a files to be incompatible. This affects all SkiaSharp versions because the native assets were built against an older Emscripten/WASM SDK.",
        "researchDone": [
          "Reviewed issue #3422 for additional context \u2014 same symptoms, Blazor WASM \u002B .NET 10, multiple SkiaSharp versions affected",
          "Read documentation/packages.md to understand WASM static linking mechanism",
          "Read references/skia-patterns.md for WASM-specific quirks",
          "Confirmed SkiaSharp.Views.Blazor auto-includes NativeAssets.WebAssembly"
        ],
        "proposals": [
          {
            "title": "Stay on .NET 9 until fix is available",
            "description": "Temporarily remain on .NET 9 where SkiaSharp works, and upgrade to .NET 10 once SkiaSharp releases a compatible version.",
            "steps": [
              "Keep the project targeting net9.0",
              "Monitor #3422 for updates on .NET 10 compatibility",
              "Upgrade once a compatible SkiaSharp version is released"
            ],
            "pros": [
              "No code changes needed",
              "Known working configuration"
            ],
            "cons": [
              "Blocks adoption of .NET 10 features",
              "Temporary \u2014 not a real fix"
            ],
            "confidence": 0.95,
            "effort": "low"
          },
          {
            "title": "Rebuild NativeAssets.WebAssembly against .NET 10 Emscripten SDK",
            "description": "SkiaSharp maintainers rebuild the WASM native assets against the Emscripten version shipped with .NET 10\u0027s WASM workload, ensuring ABI compatibility.",
            "steps": [
              "Identify the Emscripten version used by .NET 10 WASM workload",
              "Update SkiaSharp\u0027s WASM build to target that Emscripten version",
              "Build and test NativeAssets.WebAssembly",
              "Release updated NuGet packages"
            ],
            "pros": [
              "Root cause fix",
              "Enables .NET 10 support"
            ],
            "cons": [
              "Requires maintainer action",
              "May need to support multiple Emscripten versions for .NET 9 and 10"
            ],
            "confidence": 0.80,
            "effort": "medium"
          },
          {
            "title": "Manual NativeFileReference with custom-built .a",
            "description": "Advanced workaround: build libSkiaSharp.a manually against the .NET 10 Emscripten SDK and reference it directly instead of using the NuGet package\u0027s .a file.",
            "steps": [
              "Clone SkiaSharp source and build native WASM target",
              "Use the .NET 10 Emscripten SDK for compilation",
              "Add the resulting .a file as a NativeFileReference in the project",
              "Exclude the NuGet-provided .a file"
            ],
            "pros": [
              "Unblocks .NET 10 usage immediately"
            ],
            "cons": [
              "Complex and fragile",
              "Requires native build toolchain",
              "Not maintainable long-term"
            ],
            "confidence": 0.50,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Stay on .NET 9 until fix is available",
        "recommendedReason": "Simplest and safest option for the reporter. The root fix (rebuilding against .NET 10 Emscripten SDK) requires maintainer action and is being tracked in #3422."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3435"
    },
    {
      "schemaVersion": "1.0",
      "number": 3430,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-25T12:00:00Z",
      "summary": "NullReferenceException in SKXamlCanvas.DoInvalidate when canvas size changes due to FreeBitmap nullifying bitmap field",
      "type": {
        "value": "bug",
        "confidence": 0.97,
        "reason": "Reporter identifies a specific code path where FreeBitmap resets bitmap to null, causing NRE on subsequent access at line 72. This is broken behavior in resource management, not a usage question."
      },
      "area": {
        "value": "SkiaSharp.Views.Uno",
        "confidence": 0.99,
        "reason": "The bug is in SKXamlCanvas.Skia.cs which is in source/SkiaSharp.Views.Uno/. GitHub labels also confirm area/SkiaSharp.Views.Uno."
      },
      "backends": null,
      "platforms": [
        {
          "value": "WASM",
          "confidence": 0.80,
          "reason": "Uno Platform Skia backend targets WASM among other platforms. GitHub label os/WASM is applied."
        },
        {
          "value": "Windows-WinUI",
          "confidence": 0.80,
          "reason": "SKXamlCanvas.Skia.cs is compiled for WinUI targets. GitHub label os/Windows-WinUI is applied."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "NullReferenceException crash during normal canvas resize operation. This is a reliability issue \u2014 the canvas should handle resize without throwing."
        }
      ],
      "partner": {
        "value": "unoplatform",
        "confidence": 0.95,
        "reason": "SKXamlCanvas is part of SkiaSharp.Views.Uno, the Uno Platform integration. Reporter MartinZikmund is a known Uno Platform contributor."
      },
      "regression": {
        "isRegression": true,
        "confidence": 0.65,
        "reason": "Reporter selected \u00272.88.9 (Previous)\u0027 as last known good version and \u00273.116.0 (Current)\u0027 as the broken version, suggesting the issue was introduced between these versions. However, no explicit confirmation that resize worked in 2.88.x \u2014 the code structure may have been the same.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "severity": "high",
        "severityReason": "NullReferenceException crash during normal canvas resize operation with no known workaround. Any Uno Platform app using SKXamlCanvas that resizes will hit this."
      },
      "reproEvidence": {
        "repoLinks": [
          {
            "url": "https://github.com/mono/SkiaSharp/blob/fbd27f7ec2e2ad8bd0f0f0484dd467c5d8395ae1/source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs#L72",
            "description": "Direct link to the line that throws NRE \u2014 bitmap.PixelBuffer.AsStream() when bitmap is null"
          }
        ],
        "stepsToReproduce": [
          "Use SKXamlCanvas in an Uno Platform app",
          "Trigger a canvas size change (e.g., window resize)",
          "CreateBitmap detects size mismatch and calls FreeBitmap (sets bitmap=null, pixels=null)",
          "CreateBitmap creates new WriteableBitmap (bitmap is now valid)",
          "CreateBitmap detects pixels==null and calls FreeBitmap AGAIN (sets bitmap=null, destroying the just-created bitmap)",
          "CreateBitmap allocates new pixels array",
          "DoInvalidate accesses bitmap.PixelBuffer at line 72 \u2014 NRE because bitmap is null"
        ],
        "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), Uno Platform, all platforms"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "The bug is in current code (3.116.0) and the file on the main branch still has the same logic. The issue is structural and version-independent.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.90,
        "reason": "Clear bug with identifiable root cause in CreateBitmap\u0027s double-call to FreeBitmap. Needs a code fix to restructure the bitmap/pixel allocation logic so FreeBitmap doesn\u0027t null out a freshly created bitmap.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "The reporter correctly identified a race condition in SKXamlCanvas.CreateBitmap where the second call to FreeBitmap (in the pixel-reallocation block) nullifies the bitmap field that was just created in the bitmap-creation block. When DoInvalidate then accesses bitmap.PixelBuffer at line 72, it gets a NullReferenceException.",
        "keySignals": [
          {
            "text": "This line of code may throw NRE if the canvas changed its size, because the FreeBitmap method may have reset bitmap field to null",
            "source": "body",
            "interpretation": "Reporter has read the source code and identified the exact failure path. This is a code-level analysis, not a symptom report.",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "Link to SKXamlCanvas.Skia.cs#L72",
            "source": "body",
            "interpretation": "Points directly to bitmap.PixelBuffer.AsStream() which throws NRE when bitmap is null after FreeBitmap resets it.",
            "supportedFields": [
              "area",
              "reproEvidence"
            ]
          },
          {
            "text": "Version: 3.116.0, Last Known Good: 2.88.9",
            "source": "body",
            "interpretation": "Suggests regression from 2.88.x to 3.x, though the code structure may have had this latent bug for a while.",
            "supportedFields": [
              "regression",
              "versionAnalysis"
            ]
          },
          {
            "text": "Platform: All",
            "source": "body",
            "interpretation": "Bug is in shared Skia backend code, not platform-specific. Affects all Uno Platform Skia targets.",
            "supportedFields": [
              "platforms"
            ]
          },
          {
            "text": "Author: MartinZikmund (CONTRIBUTOR)",
            "source": "labels",
            "interpretation": "Trusted source \u2014 MartinZikmund is a well-known Uno Platform contributor, lending high credibility to the code analysis.",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The issue describes broken behavior \u2014 a NullReferenceException thrown during normal canvas operation. The reporter has identified the exact code path causing the failure. This is clearly a defect, not a feature request or question."
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views.Uno",
            "expandedReason": "The bug is in SKXamlCanvas.Skia.cs which is in the SkiaSharp.Views.Uno package. The GitHub labels also confirm this classification."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "NRE crash during normal resize with no workaround. Any Uno Platform app resizing its SKXamlCanvas window will hit this. Not critical because it doesn\u0027t cause data loss or security issues, but high because it\u0027s a crash with no workaround.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "No data loss or security implications \u2014 it\u0027s a crash in a UI rendering path that doesn\u0027t corrupt data."
              },
              {
                "value": "medium",
                "whyRejected": "No workaround exists, and the trigger (canvas resize) is a common user interaction."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Root cause is well understood from code analysis. Needs engineering effort to fix the CreateBitmap logic so that FreeBitmap doesn\u0027t destroy a freshly allocated bitmap. A PR is needed.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "This is actionable now \u2014 the root cause is clear and a fix is straightforward."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "unoplatform",
            "expandedReason": "SKXamlCanvas is the Uno Platform integration surface. The reporter is a known Uno Platform contributor. This directly affects Uno Platform apps."
          }
        ],
        "docsConsulted": [
          {
            "path": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs",
            "relevance": "Source code analysis confirmed the exact bug: CreateBitmap\u0027s second FreeBitmap call at line 106 nullifies bitmap created at line 91, causing NRE at line 72 in DoInvalidate.",
            "usedFor": [
              "type",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for known patterns around resource management and disposal issues. The \u0027Premature Disposal\u0027 pattern is relevant context.",
            "usedFor": [
              "type",
              "bugSignals"
            ]
          }
        ],
        "docsNotConsulted": "No native loading diagnostics needed \u2014 this is a managed code logic bug, not a native binary issue. No rendering backend docs needed \u2014 the bug is in bitmap management, not rendering.",
        "uncertainties": [
          "Whether the bug also existed in 2.88.x or if the code was restructured in 3.x \u2014 regression confidence is moderate",
          "Whether there are other callers of FreeBitmap that could also be affected",
          "Whether the fix should separate pixel management from bitmap management entirely or just reorder the logic"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s analysis is accurate based on their CONTRIBUTOR status and code-level description \u2014 confirmed by reading the source code directly"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "In CreateBitmap, when the canvas size changes: (1) FreeBitmap is called (bitmap=null, pixels=null), (2) a new bitmap is created, (3) the pixel check finds pixels==null and calls FreeBitmap AGAIN, which nullifies the just-created bitmap. The second FreeBitmap call is the root cause \u2014 it couples bitmap and pixel lifecycle incorrectly.",
        "researchDone": [
          "Analyzed SKXamlCanvas.Skia.cs CreateBitmap method line by line",
          "Traced the execution path during canvas size change",
          "Checked FreeBitmap implementation for side effects",
          "Searched for duplicate issues \u2014 none found"
        ],
        "proposals": [
          {
            "title": "Separate pixel and bitmap freeing logic",
            "description": "Split FreeBitmap into two methods: one for freeing the pixel buffer (FreePixels) and one for freeing the bitmap (FreeBitmap). The pixel reallocation block should only call FreePixels, not FreeBitmap.",
            "steps": [
              "Create a FreePixels method that frees pixelsHandle and sets pixels=null without touching bitmap",
              "Update FreeBitmap to call FreePixels and then set bitmap=null",
              "Change the pixel reallocation block (line 104-113) to call FreePixels instead of FreeBitmap",
              "Test canvas resize behavior to confirm NRE is fixed"
            ],
            "pros": [
              "Cleanly separates the two resource lifecycles",
              "Most architecturally correct solution",
              "Prevents future coupling bugs"
            ],
            "cons": [
              "Slightly more invasive \u2014 introduces a new method"
            ],
            "confidence": 0.92,
            "effort": "low"
          },
          {
            "title": "Move bitmap creation after pixel allocation",
            "description": "Restructure CreateBitmap so that all FreeBitmap calls happen before the bitmap is created. Free everything first, then allocate pixels, then create bitmap.",
            "steps": [
              "Combine the dimension checks into a single block that calls FreeBitmap once",
              "Allocate pixels array first",
              "Create WriteableBitmap last, after all freeing is done",
              "Test canvas resize behavior"
            ],
            "pros": [
              "No new methods needed \u2014 just reorder existing logic",
              "Eliminates the double-free pattern"
            ],
            "cons": [
              "May need careful handling of the \u0027bitmap exists but pixels changed\u0027 edge case",
              "Less explicit about the separate lifecycles"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Guard bitmap access with null check in DoInvalidate",
            "description": "Add a null check for bitmap before accessing bitmap.PixelBuffer in DoInvalidate, and early-return if bitmap is null.",
            "steps": [
              "Add \u0027if (bitmap == null) return;\u0027 before line 72 in DoInvalidate",
              "Test that the canvas recovers on the next invalidation"
            ],
            "pros": [
              "Simplest possible fix \u2014 one line",
              "Prevents the NRE crash immediately"
            ],
            "cons": [
              "Masks the root cause \u2014 CreateBitmap still has the coupling bug",
              "Canvas may silently skip frames after resize until a subsequent invalidation",
              "Doesn\u0027t fix the underlying resource management logic"
            ],
            "confidence": 0.60,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Separate pixel and bitmap freeing logic",
        "recommendedReason": "This is the cleanest fix that addresses the root cause: the coupling between bitmap and pixel lifecycles in FreeBitmap. By separating FreePixels from FreeBitmap, the pixel reallocation block can safely free/reallocate the pixel buffer without destroying the bitmap. Low effort, high correctness."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3430"
    },
    {
      "schemaVersion": "1.0",
      "number": 3429,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-25T12:00:00Z",
      "summary": "Memory leak in WPF on high-resolution monitors with Nvidia Quadro GPUs; mitigated by disabling hardware acceleration",
      "type": {
        "value": "bug",
        "confidence": 0.92,
        "reason": "Reporter describes a memory leak that occurs under specific hardware conditions (Nvidia Quadro \u002B high-res monitor). This is broken behavior \u2014 memory should not leak regardless of GPU driver."
      },
      "area": {
        "value": "SkiaSharp.Views",
        "confidence": 0.80,
        "reason": "The issue occurs when drawing patterns in WPF, which uses SkiaSharp.Views WPF controls (e.g., SKElement). The workaround targets WPF\u0027s RenderOptions, indicating the interaction between the SkiaSharp view control and WPF\u0027s rendering pipeline."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.95,
          "reason": "Reporter explicitly states Windows platform with WPF, and the workaround uses WPF-specific RenderOptions.ProcessRenderMode."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.90,
          "reason": "Memory leak is a reliability issue \u2014 the application\u0027s memory grows unbounded over time."
        },
        {
          "value": "performance",
          "confidence": 0.75,
          "reason": "Memory leak degrades performance over time, and the workaround (software rendering) is rejected due to performance impact on other features."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.80,
        "reason": "Reporter states \u0027Last Known Good Version of SkiaSharp: 2.88.9 (Previous)\u0027 and current broken version is 3.116.0. This spans a major version boundary (2.x to 3.x) where significant rendering changes occurred.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Set RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly in App.OnStartup to disable WPF hardware acceleration. Reporter states this is impractical due to performance requirements.",
        "severity": "medium",
        "severityReason": "Memory leak is serious but does not crash. A workaround exists (software rendering) though it is impractical for the reporter. The issue is limited to a specific GPU family (Nvidia Quadro) on high-resolution monitors."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a WPF application using SkiaSharp 3.116.0 to draw patterns",
          "Run on a high-resolution monitor with an Nvidia Quadro series GPU",
          "Observe memory growing over time (memory leak)",
          "Verify the leak does not occur with Nvidia GeForce or AMD GPUs",
          "Verify the leak does not occur when setting RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "protected override void OnStartup(StartupEventArgs e)\n{\n   // Mode to turn off hardware acceleration and enable software rendering only\n   // Completely exclude GPUs and handle all screen outputs with only CPU operations\n    RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly;\n\n    base.OnStartup(e);\n}",
            "context": "Workaround that disables WPF hardware acceleration to prevent the memory leak. Reporter confirms this fixes the leak but is impractical due to performance requirements."
          }
        ],
        "environmentDetails": "Windows, Visual Studio, SkiaSharp 3.116.0, Nvidia Quadro series GPU, high-resolution monitor"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Issue is reported on 3.116.0 which is the current version. The regression from 2.88.9 suggests a change in the 3.x rendering pipeline may have introduced this leak. This is likely still relevant in the latest builds.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "request-info",
        "confidence": 0.82,
        "reason": "This is a real bug but lacks critical reproduction details: no sample project, no memory profiler output, no indication of which SkiaSharp WPF control is used (SKElement vs SKGLElement), and no actual behavior description beyond \u0027memory leak\u0027. The GPU-specific nature makes it important but hard to investigate without more details.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "missingInfo": [
          "sample-project",
          "actual-behavior",
          "device-info"
        ],
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "request-info",
        "confidence": 0.80,
        "reason": "The issue is plausible and well-investigated by the reporter (they isolated GPU driver and found a workaround), but we need more details to investigate \u2014 especially which WPF control is being used and memory profiler data.",
        "draft": "Thanks for the thorough investigation \u2014 isolating the issue to Nvidia Quadro GPUs and finding the software rendering workaround is really helpful context.\n\nTo dig into this further, a few things would help:\n\n1. **Which SkiaSharp WPF control are you using?** (\u0060SKElement\u0060, \u0060SKGLElement\u0060, or a custom \u0060WriteableBitmap\u0060 approach?) This matters because \u0060SKGLElement\u0060 uses GPU rendering directly while \u0060SKElement\u0060 renders to a bitmap that WPF then composites.\n\n2. **Could you share a minimal sample project that reproduces the leak?** Even a simple WPF app that draws a pattern in a loop would help us profile what\u0027s being leaked.\n\n3. **Memory profiler output** \u2014 if you have any diagnostics showing what objects are accumulating (e.g., from Visual Studio\u0027s diagnostic tools or dotMemory), that would narrow down whether the leak is in managed objects, native Skia resources, or WPF\u0027s rendering layer.\n\nThe fact that \u0060RenderMode.SoftwareOnly\u0060 resolves it suggests the leak may be in how WPF composites the SkiaSharp surface with hardware acceleration \u2014 possibly a texture or render target not being released properly on Quadro drivers."
      },
      "analysisNotes": {
        "summary": "Memory leak in a WPF application using SkiaSharp 3.116.0 that only manifests with Nvidia Quadro GPUs on high-resolution monitors. The workaround of disabling WPF hardware acceleration confirms the issue is at the intersection of SkiaSharp\u0027s WPF view surface management and GPU-accelerated compositing. This is a regression from 2.88.9.",
        "keySignals": [
          {
            "text": "When drawing patterns in wpf, a memory leak issue was encountered on the high resolution monitor",
            "source": "body",
            "interpretation": "WPF \u002B high-DPI \u002B pattern drawing triggers the leak. High-DPI may cause larger backing surfaces that amplify a per-frame leak.",
            "supportedFields": [
              "type",
              "area",
              "platforms"
            ]
          },
          {
            "text": "it only occurred in the Nvidia Quadro series",
            "source": "body",
            "interpretation": "GPU-driver-specific issue. Quadro drivers handle GPU memory and texture management differently from GeForce consumer drivers. This points to a GPU resource leak (e.g., textures, render targets) that Quadro drivers don\u0027t auto-reclaim.",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly",
            "source": "body",
            "interpretation": "Disabling WPF hardware acceleration fixes the leak. This means the leak occurs when WPF uses GPU compositing to present the SkiaSharp surface, not in SkiaSharp\u0027s own rendering.",
            "supportedFields": [
              "bugSignals.hasWorkaround",
              "area"
            ]
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9",
            "source": "body",
            "interpretation": "Regression from 2.x to 3.x. The 3.x series changed how WPF views render and manage surfaces, which could have introduced a resource leak in the GPU compositing path.",
            "supportedFields": [
              "regression"
            ]
          },
          {
            "text": "Due to the performance of other features of the current application, it is impossible to use the code above",
            "source": "body",
            "interpretation": "The workaround is impractical, making this a real blocker for the reporter rather than a resolved question.",
            "supportedFields": [
              "bugSignals.severity",
              "actionability"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Memory leak is clearly broken behavior. The reporter describes a condition that should not happen \u2014 drawing in SkiaSharp should not leak memory regardless of GPU driver.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Though the reporter asks \u0027how can I solve that problem\u0027, the core issue is a genuine memory leak, not a usage question."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views",
            "expandedReason": "The issue is in WPF drawing with SkiaSharp, which involves the SkiaSharp.Views.WPF package. The workaround targeting WPF\u0027s RenderOptions confirms the issue is in how the view control interacts with WPF\u0027s rendering pipeline.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "Core SkiaSharp is GPU-agnostic. The issue is specific to the WPF view layer\u0027s surface management."
              },
              {
                "value": "libSkiaSharp.native",
                "whyRejected": "While the leak could be in native code, the WPF RenderOptions workaround points to the managed WPF integration layer."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "WPF is a Windows-Classic technology. Reporter explicitly states Windows platform."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Memory leak is serious for production applications but does not crash. A workaround exists (software rendering) even though it\u0027s impractical. The issue is limited to a specific GPU family.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Workaround exists and issue is limited to Nvidia Quadro on high-res monitors. Not affecting all users."
              },
              {
                "value": "low",
                "whyRejected": "Memory leaks are not cosmetic \u2014 they degrade over time and can eventually cause OOM."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "The bug is plausible and the reporter did good investigative work, but we need: which WPF control is used, a sample project, and memory profiler data to investigate the root cause.",
            "alternatives": [
              {
                "value": "needs-investigation",
                "whyRejected": "Without knowing which control is used and having a repro, investigation would be unfocused."
              },
              {
                "value": "keep-open",
                "whyRejected": "Requesting info is more actionable \u2014 it moves the issue forward."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for known Windows/WPF platform quirks and memory management patterns. No direct match for this GPU-specific leak pattern.",
            "usedFor": [
              "type",
              "area"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Field definitions and allowed enum values for classification.",
            "usedFor": [
              "type",
              "area",
              "platforms",
              "bugSignals"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated JSON output format and confidence scoring.",
            "usedFor": [
              "type",
              "bugSignals"
            ]
          },
          {
            "path": "references/response-guidelines.md",
            "relevance": "Tone and structure guidance for the suggested response draft.",
            "usedFor": [
              "suggestedResponse"
            ]
          }
        ],
        "docsNotConsulted": "Did not check documentation/packages.md \u2014 issue is not about native loading or DllNotFoundException. Did not check API XML docs \u2014 issue is about a resource leak, not API usage.",
        "uncertainties": [
          "Unknown which SkiaSharp WPF control is being used (SKElement vs SKGLElement vs custom). SKGLElement uses GPU rendering directly, which would be a very different leak path than SKElement\u0027s WritableBitmap approach.",
          "No memory profiler data \u2014 unclear whether the leak is managed objects, native Skia surfaces, or GPU textures held by the WPF compositor.",
          "The \u00273.116.0\u0027 version number appears non-standard (current versions are 3.x.y format like 3.116.1). This could be a typo or internal versioning.",
          "No information on high-resolution monitor resolution or scaling factor. DPI scaling could affect surface allocation size and frequency.",
          "Unclear what \u0027drawing patterns\u0027 means \u2014 it could be continuous redrawing (animation) or a specific draw pattern that leaks."
        ],
        "assumptions": [
          "Assumed the reporter is using a SkiaSharp.Views.WPF control (SKElement or SKGLElement) rather than a custom rendering approach, since they mention \u0027drawing patterns in wpf\u0027.",
          "Assumed the \u0027Nvidia Quadro series\u0027 refers to professional workstation GPUs with different driver behavior from consumer GeForce drivers."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "WPF\u0027s hardware-accelerated compositing path leaks GPU resources (textures or render targets) when presenting SkiaSharp surfaces on Nvidia Quadro drivers with high-DPI scaling. The Quadro driver\u0027s GPU memory management handles texture lifecycle differently than GeForce/AMD, causing resources that should be released after each frame to accumulate.",
        "researchDone": [
          "Searched mono/SkiaSharp issues for similar memory leak \u002B WPF \u002B GPU reports \u2014 no duplicates found",
          "Reviewed skia-patterns.md for known Windows/WPF quirks \u2014 no direct match",
          "Analyzed the WPF RenderOptions.ProcessRenderMode workaround to understand the compositing path",
          "Considered the 2.88.9 \u2192 3.116.0 version gap for rendering pipeline changes"
        ],
        "proposals": [
          {
            "title": "Use SKElement instead of SKGLElement",
            "description": "If the reporter is using SKGLElement (GPU-accelerated), switching to SKElement (software rendering in SkiaSharp, but still allows WPF hardware compositing) may avoid the leak by removing Skia\u0027s direct GPU usage while keeping WPF hardware acceleration for the rest of the app.",
            "steps": [
              "Confirm which control the reporter is currently using",
              "If SKGLElement, switch to SKElement in XAML",
              "Test if memory leak persists \u2014 SKElement doesn\u0027t use GPU for Skia rendering",
              "Measure performance impact of software SkiaSharp rendering vs GPU"
            ],
            "pros": [
              "Preserves WPF hardware acceleration for non-SkiaSharp content",
              "Simple code change",
              "Avoids GPU driver interaction for Skia rendering"
            ],
            "cons": [
              "May reduce SkiaSharp rendering performance",
              "Doesn\u0027t fix the root cause if the leak is in SKElement too"
            ],
            "confidence": 0.55,
            "effort": "low"
          },
          {
            "title": "Investigate and fix surface/texture leak in WPF view",
            "description": "Profile the application to identify exactly which resources are leaking (managed objects, native Skia surfaces, or WPF render targets), then fix the disposal or caching logic in the SkiaSharp WPF view control.",
            "steps": [
              "Get a minimal reproduction project from the reporter",
              "Profile with dotMemory and GPU profiler on Nvidia Quadro hardware",
              "Identify the leaking resource type (managed SKSurface/SKImage, native texture, WPF render target)",
              "Fix the resource lifecycle in the WPF view control code",
              "Test fix across multiple GPU vendors and DPI settings"
            ],
            "pros": [
              "Fixes the root cause",
              "Benefits all users with this GPU/DPI combination"
            ],
            "cons": [
              "Requires Nvidia Quadro hardware to reproduce",
              "High investigation effort",
              "May reveal a driver bug that can\u0027t be fixed from SkiaSharp\u0027s side"
            ],
            "confidence": 0.70,
            "effort": "high"
          },
          {
            "title": "Disable WPF hardware acceleration only for SkiaSharp elements",
            "description": "Instead of globally disabling hardware acceleration with RenderMode.SoftwareOnly, use WPF\u0027s per-element RenderOptions or BitmapCache to control compositing just for SkiaSharp views.",
            "steps": [
              "Set RenderOptions.ProcessRenderMode to Default (keep hardware acceleration)",
              "Apply CacheMode = new BitmapCache() or RenderOptions.BitmapScalingMode on the SkiaSharp host element",
              "Alternatively, host the SKElement in a HwndHost with software rendering while keeping the rest of the app hardware-accelerated",
              "Test memory behavior and overall app performance"
            ],
            "pros": [
              "Keeps hardware acceleration for non-SkiaSharp UI",
              "No SkiaSharp code changes needed",
              "Can be applied selectively"
            ],
            "cons": [
              "May not fully resolve the leak if WPF still touches GPU for compositing",
              "HwndHost approach adds airspace complexity"
            ],
            "confidence": 0.50,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Investigate and fix surface/texture leak in WPF view",
        "recommendedReason": "While higher effort, this is the only proposal that addresses the root cause. The other proposals are workarounds. Getting a repro project first (via request-info) will make this investigation feasible."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3429"
    },
    {
      "schemaVersion": "1.0",
      "number": 3428,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-12-05T12:00:00Z",
      "summary": "SKGLView fails to bind EAGLDrawable on .NET 10 MAUI iOS, rendering white canvas instead of content",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Reporter describes broken rendering \u2014 expected content but gets white canvas with \u0027Failed to bind EAGLDrawable\u0027 error. This is clearly broken behavior in a previously working scenario."
      },
      "area": {
        "value": "SkiaSharp.Views.Maui",
        "confidence": 0.95,
        "reason": "Issue is in the MAUI SKGLView rendering pipeline. The reporter uses SKPaintGLSurfaceEventArgs and _glView in a MAUI context. GitHub labels also confirm area/SkiaSharp.Views.Maui."
      },
      "backends": [
        {
          "value": "OpenGL",
          "confidence": 0.95,
          "reason": "EAGLDrawable is the iOS OpenGL ES rendering surface. SKGLView uses GLKView with EAGLContext (OpenGLES2). The error \u0027Failed to bind EAGLDrawable\u0027 is an OpenGL ES framebuffer binding failure."
        }
      ],
      "platforms": [
        {
          "value": "iOS",
          "confidence": 0.98,
          "reason": "Reporter explicitly states iOS. EAGLDrawable is iOS-specific OpenGL ES infrastructure. Labels include os/iOS."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.90,
          "reason": "The GL view fails silently (white canvas) rather than rendering content. This is unexpected behavior that breaks the user\u0027s application."
        },
        {
          "value": "compatibility",
          "confidence": 0.85,
          "reason": "Issue is specific to .NET 10 \u2014 works on .NET 9. This is a cross-version compatibility problem, likely related to Apple deprecating OpenGL ES and .NET 10 changing EAGL handling."
        }
      ],
      "partner": {
        "value": "maui",
        "confidence": 0.90,
        "reason": "Issue is in the MAUI rendering pipeline. The .NET 10 target framework change may be a MAUI or runtime-level change affecting EAGL context initialization."
      },
      "regression": {
        "isRegression": true,
        "confidence": 0.85,
        "reason": "Reporter states it works on .NET 9 but not .NET 10. The same code and SkiaSharp version (3.116.0) works on .NET 9 but fails on .NET 10, indicating a regression introduced by .NET 10 or its iOS runtime changes.",
        "workedInVersion": "3.116.0",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net10.0-ios"
        ],
        "severity": "high",
        "severityReason": "GL rendering is completely broken on iOS with .NET 10 \u2014 white canvas with no content. No workaround provided. This affects all users of SKGLView on .NET 10 iOS."
      },
      "reproEvidence": {
        "repoLinks": [
          {
            "url": "https://github.com/Mapsui/Mapsui/blob/main/Mapsui.UI.Maui/MapControl.cs",
            "description": "Mapsui MapControl source showing the GL paint surface handler code that triggers the issue."
          }
        ],
        "relatedIssues": [
          646,
          3388,
          2840
        ],
        "stepsToReproduce": [
          "Create a MAUI app targeting .NET 10 for iOS",
          "Add SkiaSharp 3.116.0 with SKGLView (GL-accelerated rendering)",
          "Run on an iOS device or simulator",
          "Observe white canvas and \u0027Failed to bind EAGLDrawable\u0027 in device logs"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "private void OnGLPaintSurface(object? sender, SKPaintGLSurfaceEventArgs args)\n{\n    if (_glView?.GRContext is null)\n    {\n        Logger.Log(LogLevel.Warning, \u0022Refresh can not be called because GRContext is null\u0022);\n        return;\n    }\n    PaintSurface(args.Surface.Canvas);\n}",
            "context": "Mapsui MapControl GL paint handler \u2014 the callback that should render content but results in white canvas."
          }
        ],
        "environmentDetails": "SkiaSharp 3.116.0, .NET 10, MAUI, iOS, Visual Studio macOS. Works on .NET 9, broken on .NET 10. Last known good SkiaSharp version: 2.88.9."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Issue is on latest SkiaSharp 3.116.0 with bleeding-edge .NET 10. The problem is likely related to .NET 10\u0027s iOS runtime changes rather than SkiaSharp version, since 3.116.0 works on .NET 9. Apple has deprecated OpenGL ES (EAGL) since iOS 12, and .NET 10 may have removed or changed EAGL support.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.85,
        "reason": "This is a real rendering failure on .NET 10 iOS that needs investigation. The root cause is likely .NET 10 or Apple\u0027s continued deprecation/removal of OpenGL ES (EAGL) on iOS. SkiaSharp\u0027s SKGLView uses GLKView with EAGLContext which is deprecated since iOS 12.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "missingInfo": [
          "device-info",
          "stack-trace"
        ],
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "request-info",
        "confidence": 0.80,
        "reason": "Need to confirm .NET 10 preview version and iOS version, and investigate whether this is a .NET 10 runtime change or an Apple SDK change.",
        "draft": "Thanks for reporting this \u2014 the EAGLDrawable binding failure is a significant signal.\n\nThe \u0060SKGLView\u0060 on iOS uses \u0060GLKView\u0060 with \u0060EAGLContext\u0060 (OpenGL ES 2), which Apple deprecated back in iOS 12 in favor of Metal. The fact that this works on .NET 9 but not .NET 10 suggests that .NET 10\u0027s iOS runtime or the underlying Apple SDK may have changed how EAGL contexts are initialized or bound.\n\nA few questions that would help narrow this down:\n\n1. Which .NET 10 preview version are you using? (e.g., Preview 1, Preview 2)\n2. Does switching from \u0060SKGLView\u0060 to \u0060SKCanvasView\u0060 (CPU rendering) work as a temporary workaround?\n3. Do you see the full error message that @charlenni shared (\u0060Failed to bind EAGLDrawable\u0060) in your device logs as well?\n\nLonger term, the path forward for iOS GPU rendering is likely Metal rather than OpenGL ES, given Apple\u0027s deprecation timeline. But we need to understand what specifically changed in .NET 10 first."
      },
      "analysisNotes": {
        "summary": "SKGLView fails to render on iOS when targeting .NET 10, producing a white canvas and \u0027Failed to bind EAGLDrawable\u0027 error. This is a regression from .NET 9 where the same SkiaSharp version works. The root cause is likely related to .NET 10\u0027s handling of the deprecated OpenGL ES (EAGL) APIs on iOS, since SKGLView depends on GLKView/EAGLContext which Apple deprecated in iOS 12.",
        "keySignals": [
          {
            "text": "Failed to bind EAGLDrawable on .NET 10 in MAUI iOS",
            "source": "title",
            "interpretation": "EAGLDrawable is the iOS OpenGL ES rendering surface. Failure to bind it means the GL framebuffer cannot be created, resulting in no rendering output.",
            "supportedFields": [
              "type",
              "backends",
              "platforms"
            ]
          },
          {
            "text": "not in .NET 9",
            "source": "body",
            "interpretation": "Explicitly a .NET 10-specific regression. Same SkiaSharp version works on .NET 9, pointing to a runtime or SDK change.",
            "supportedFields": [
              "regression",
              "tenets"
            ]
          },
          {
            "text": "Failed to bind EAGLDrawable: \u003CCAEAGLLayer: 0x1c2a3b840\u003E",
            "source": "comment 2 (charlenni)",
            "interpretation": "The actual iOS system error confirming EAGL layer binding failure. This is the same error pattern seen in historic issue #646.",
            "supportedFields": [
              "type",
              "backends",
              "bugSignals"
            ]
          },
          {
            "text": "No error and a white canvas",
            "source": "body (Actual Behavior)",
            "interpretation": "The GL view silently fails to render \u2014 no crash, just blank output. This is a silent rendering failure, not a hard crash.",
            "supportedFields": [
              "bugSignals.severity",
              "bugSignals.hasCrash"
            ]
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9 (Previous)",
            "source": "body",
            "interpretation": "Reporter considers 2.88.9 the last good version, but also clarifies the issue is .NET 10 specific. The SkiaSharp version may be less relevant than the .NET target framework.",
            "supportedFields": [
              "versionAnalysis",
              "regression"
            ]
          },
          {
            "text": "ObsoletedOSPlatform ios12.0 Use Metal instead",
            "source": "source code (SKGLView.cs line 23)",
            "interpretation": "SKGLView itself is marked as obsoleted on iOS 12\u002B, confirming this is a deprecated code path. The long-term fix is Metal.",
            "supportedFields": [
              "area",
              "resolutionAnalysis"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Reporter describes a rendering failure \u2014 expected content but gets white canvas. This is broken behavior, not a question or feature request. The [BUG] prefix and filed template confirm intent.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they have working code that broke on .NET 10."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views.Maui",
            "expandedReason": "The issue is in the MAUI SKGLView rendering pipeline. The code uses SKPaintGLSurfaceEventArgs in a MAUI context. GitHub automation already applied this label.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views",
                "whyRejected": "While the underlying SKGLView is in SkiaSharp.Views, the user is consuming it through MAUI controls, making SkiaSharp.Views.Maui more specific and accurate."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "OpenGL",
            "expandedReason": "EAGLDrawable and EAGLContext are the iOS-specific OpenGL ES rendering infrastructure. SKGLView.cs explicitly creates EAGLContext(EAGLRenderingAPI.OpenGLES2). The failure is in GL framebuffer binding."
          },
          {
            "field": "platforms",
            "chosen": "iOS",
            "expandedReason": "Reporter explicitly states iOS. EAGL is iOS-only. No mention of other platforms being affected."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "GL rendering is completely broken on iOS with .NET 10 \u2014 no content rendered at all. No workaround provided. This affects all SKGLView users targeting .NET 10 on iOS. Not critical because it does not crash and SKCanvasView (CPU) likely still works.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "No crash or data loss. The app still runs, just shows white canvas. SKCanvasView is likely a viable workaround."
              },
              {
                "value": "medium",
                "whyRejected": "Complete rendering failure with no confirmed workaround warrants high, not medium."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause needs investigation \u2014 is this a .NET 10 runtime change, an Apple SDK change, or something else? The fix may be in SkiaSharp (migrate to Metal), in MAUI, or may require a workaround recommendation.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "While more info would help (exact .NET 10 preview, device), there is enough to start investigating the EAGL deprecation angle."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/iOS/SKGLView.cs",
            "relevance": "Confirmed SKGLView uses GLKView with EAGLContext(OpenGLES2), and is marked ObsoletedOSPlatform for ios12.0 with \u0027Use Metal instead\u0027.",
            "usedFor": [
              "backends",
              "area",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for iOS platform quirks. Found macOS/iOS section but no specific EAGL deprecation guidance.",
            "usedFor": [
              "platforms"
            ]
          }
        ],
        "docsNotConsulted": "Did not check documentation/packages.md \u2014 issue is not about native loading or DllNotFoundException. Did not check .docs tutorials \u2014 this is a rendering backend failure, not API misuse.",
        "uncertainties": [
          "Exact .NET 10 preview version not specified \u2014 different previews may have different EAGL support levels",
          "Unknown whether Apple fully removed EAGL support in a recent iOS SDK or if .NET 10 changed its OpenGL ES bindings",
          "Unknown whether SKCanvasView (CPU rendering) works as a workaround on .NET 10",
          "Device model and iOS version not specified \u2014 could be relevant if newer hardware dropped EAGL support",
          "Whether this is a SkiaSharp issue, a MAUI issue, or a .NET runtime issue is unclear without deeper investigation"
        ],
        "assumptions": [
          "Assumed the reporter is using a recent .NET 10 preview since they mention .NET 10 specifically",
          "Assumed EAGLDrawable error from charlenni\u0027s comment is the same error the original reporter sees, since they are both Mapsui contributors reporting the same problem"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": ".NET 10\u0027s iOS runtime or Apple\u0027s latest SDK has changed how EAGLContext/EAGLDrawable binding works, breaking the deprecated OpenGL ES rendering path used by SKGLView. Apple deprecated OpenGL ES in iOS 12 (2018) and has been progressively removing support. SKGLView\u0027s GLKView\u002BEAGLContext approach may no longer function correctly under .NET 10\u0027s updated iOS bindings.",
        "researchDone": [
          "Examined SKGLView.cs iOS source \u2014 confirms use of GLKView, EAGLContext(OpenGLES2), marked ObsoletedOSPlatform ios12.0",
          "Searched for similar issues \u2014 found #646 (same \u0027Failed to bind EAGLDrawable\u0027 error from 2018, Xamarin era, closed 2024)",
          "Found #3388 (SKGLView memory issues on iOS, related but different problem)",
          "Found #2840 (SkiaSharp memory corruption on iOS with SKGLView, .NET 9 preview era)",
          "Checked issue #646 comments \u2014 pauldendulk cross-posted the .NET 10 error there, mattleibow asked about MAUI in 2024",
          "Reviewed charlenni\u0027s comment providing actual error message: \u0027Failed to bind EAGLDrawable\u0027"
        ],
        "proposals": [
          {
            "title": "Switch to SKCanvasView (CPU rendering) as workaround",
            "description": "Replace SKGLView with SKCanvasView which uses CPU-based raster rendering instead of OpenGL ES. This avoids the deprecated EAGL path entirely.",
            "steps": [
              "Replace SKGLView usage with SKCanvasView in MAUI XAML",
              "Change SKPaintGLSurfaceEventArgs handlers to SKPaintSurfaceEventArgs handlers",
              "Test on .NET 10 iOS to confirm CPU rendering works"
            ],
            "pros": [
              "Avoids deprecated OpenGL ES entirely",
              "Immediate workaround available now",
              "SKCanvasView is well-tested and stable"
            ],
            "cons": [
              "Loses GPU acceleration \u2014 slower rendering for complex scenes",
              "May not be acceptable for performance-critical apps like Mapsui map rendering"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Implement Metal backend for iOS SKGLView",
            "description": "Replace the OpenGL ES (EAGL) backend with Metal for iOS GPU rendering. This would follow Apple\u0027s recommended migration path from OpenGL ES to Metal.",
            "steps": [
              "Create a new SKMetalView (or update SKGLView) using MTKView instead of GLKView",
              "Implement Metal-based GRContext creation and surface management",
              "Update MAUI handlers to use Metal view on iOS",
              "Test across iOS versions and devices"
            ],
            "pros": [
              "Long-term correct solution \u2014 Metal is Apple\u0027s supported GPU API",
              "Better performance than OpenGL ES on modern iOS",
              "Future-proof against further EAGL deprecation"
            ],
            "cons": [
              "Significant engineering effort",
              "Requires Metal expertise",
              "May introduce new bugs in a new rendering path"
            ],
            "confidence": 0.90,
            "effort": "high"
          },
          {
            "title": "Investigate and patch .NET 10 EAGL context initialization",
            "description": "Debug why EAGLDrawable binding fails specifically on .NET 10. The issue may be a timing change, a missing API binding, or a configuration difference that can be patched.",
            "steps": [
              "Create minimal .NET 10 iOS repro with SKGLView",
              "Compare EAGL context state between .NET 9 and .NET 10 at bind time",
              "Check if .NET 10 iOS bindings removed or changed GLKit/EAGLContext APIs",
              "If a specific change is found, patch SKGLView initialization accordingly"
            ],
            "pros": [
              "Minimal change if root cause is simple",
              "Preserves existing GL rendering path",
              "Fastest fix if the issue is a small .NET 10 binding change"
            ],
            "cons": [
              "May be fighting Apple\u0027s deprecation \u2014 temporary fix at best",
              "Root cause may be in .NET runtime, not fixable in SkiaSharp"
            ],
            "confidence": 0.50,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Implement Metal backend for iOS SKGLView",
        "recommendedReason": "While higher effort, this is the correct long-term solution. Apple deprecated OpenGL ES in 2018 and has been progressively removing support. Patching EAGL is fighting a losing battle. The SKCanvasView workaround can be recommended to users immediately while Metal support is implemented."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3428"
    },
    {
      "schemaVersion": "1.0",
      "number": 3423,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-07-17T12:00:00Z",
      "summary": "ClickOnce deployment of .NET Framework 4.7.2 WinForms app fails to include libSkiaSharp.dll, causing DllNotFoundException",
      "type": {
        "value": "bug",
        "confidence": 0.92,
        "reason": "DllNotFoundException crash during normal usage. The native library is not being included in ClickOnce publish output, while MSIX works correctly. This is a deployment/packaging issue, not user misuse."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.95,
        "reason": "DllNotFoundException for libSkiaSharp \u2014 the native binary is not found at runtime. This is a native asset deployment issue, matching the area/libSkiaSharp.native label already applied."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.97,
          "reason": "Explicitly stated: .NET Framework 4.7.2 WinForms application on Windows 10/11. Windows-Classic covers WPF and WinForms .NET Framework apps."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.90,
          "reason": "Application crashes with TypeInitializationException wrapping DllNotFoundException on startup when using SkiaSharp features. This is a hard crash with no graceful fallback."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": true,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Manually add libSkiaSharp.dll from the NativeAssets.Win32 NuGet package (runtimes/win-x64/native/) as an existing item in the VS project, set Build Action to Content and Copy to Output Directory to \u0027Copy if newer\u0027, then verify it appears in ClickOnce Application Files as Include/Required.",
        "targetFrameworks": [
          "net472"
        ],
        "severity": "medium",
        "severityReason": "DllNotFoundException causes a hard crash, but a community workaround exists (manually adding the DLL as content). The issue is specific to ClickOnce deployment \u2014 other deployment methods (MSIX) work correctly."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a .NET Framework 4.7.2 WinForms application",
          "Add SkiaSharp NuGet package (3.119.1 or 3.116.0)",
          "Add SkiaSharp.NativeAssets.Win32 package",
          "Use SKBitmap.Decode() or any SkiaSharp API in the application",
          "Publish the application using ClickOnce deployment from Visual Studio",
          "Run the published ClickOnce application \u2014 DllNotFoundException occurs"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "var image = SKBitmap.Decode(imageData ?? throw new ArgumentNullException(nameof(imageData)))",
            "context": "Code that triggers the DllNotFoundException when run in a ClickOnce-deployed application"
          }
        ],
        "environmentDetails": ".NET Framework 4.7.2, WinForms, Visual Studio 2022 (Windows), SkiaSharp 3.119.1 (description) / 3.116.0 (version dropdown), Windows 10 and Windows 11, Dell workstations, ClickOnce deployment"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.119.1",
          "3.116.0"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "SkiaSharp 3.x is the current major version. The issue is about ClickOnce deployment not handling the runtimes/ folder structure from NuGet NativeAssets packages, which is a packaging/deployment concern that persists across versions. The user mentions 3.119.1 in the description but selected 3.116.0 in the version dropdown.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "close-with-docs",
        "confidence": 0.75,
        "reason": "The issue is a known ClickOnce limitation with NuGet runtime-specific native assets. A community workaround has been confirmed by both the reporter and another user. This is fundamentally a ClickOnce tooling limitation rather than a SkiaSharp bug \u2014 ClickOnce doesn\u0027t automatically deploy files from runtimes/ directories. However, SkiaSharp could potentially improve documentation or packaging to address this common scenario.",
        "requiresHumanReview": true,
        "closeable": true,
        "closeReason": "ClickOnce does not automatically deploy native assets from NuGet runtimes/ directories. Workaround: manually add libSkiaSharp.dll as Content with Copy if newer.",
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.80,
        "reason": "The workaround is confirmed by multiple users and the root cause is well-understood (ClickOnce vs runtimes/ folder). A response acknowledging the issue, explaining the root cause, and documenting the workaround would be helpful.",
        "draft": "Thanks for the detailed report and stack trace \u2014 and @ERPCG, thanks for documenting the workaround so thoroughly.\n\nThis is a known limitation of ClickOnce deployment with NuGet packages that use the \u0060runtimes/\u0060 folder convention for native assets. ClickOnce doesn\u0027t automatically pick up files from the \u0060runtimes/{rid}/native/\u0060 directory structure that \u0060SkiaSharp.NativeAssets.Win32\u0060 uses. MSIX handles this correctly because it processes the full NuGet output layout.\n\nThe workaround @ERPCG described is the right approach for ClickOnce:\n1. Locate \u0060libSkiaSharp.dll\u0060 in \u0060packages\\SkiaSharp.NativeAssets.Win32.{version}\\runtimes\\win-x64\\native\\\u0060 (or \u0060win-x86\u0060 for 32-bit)\n2. Add it to your project as an existing item\n3. Set **Build Action = Content** and **Copy to Output = Copy if newer**\n4. Verify it appears in **Project \u2192 Properties \u2192 Publish \u2192 Application Files** as Include/Required\n\nThis isn\u0027t specific to SkiaSharp \u2014 other packages with native assets (like Microsoft.Data.SqlClient, as @ajohnstone-ks noted) hit the same ClickOnce limitation."
      },
      "analysisNotes": {
        "summary": "ClickOnce deployment of a .NET Framework 4.7.2 WinForms app fails to include the native libSkiaSharp.dll from the NativeAssets.Win32 NuGet package, causing DllNotFoundException at runtime. This is a well-understood ClickOnce limitation with NuGet runtimes/ directory native assets, not a SkiaSharp defect. A community workaround exists and is confirmed working.",
        "keySignals": [
          {
            "text": "System.DllNotFoundException: Unable to load library \u0027libSkiaSharp\u0027",
            "source": "stack-trace",
            "interpretation": "Native binary not found at runtime \u2014 the DLL was not deployed to the ClickOnce application directory",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity"
            ]
          },
          {
            "text": "Our MSIX version of the app does not however, and I think its because libSkiaSharp.dylib is not being included in the ClickOnce publish",
            "source": "body",
            "interpretation": "User correctly identifies that ClickOnce is not including the native binary, while MSIX does. This points to a deployment mechanism issue, not a missing package.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": ".net winforms app (framework 4.7.2)",
            "source": "body",
            "interpretation": ".NET Framework 4.7.2 WinForms \u2014 maps to Windows-Classic platform label. Old-style project format may compound ClickOnce native asset issues.",
            "supportedFields": [
              "platforms"
            ]
          },
          {
            "text": "manually add libSkiaSharp.dll from NativeAssets.Win32 package as Content with Copy if newer",
            "source": "comment 2 (ERPCG)",
            "interpretation": "Community-confirmed workaround that addresses the deployment gap by forcing the native DLL into the ClickOnce output",
            "supportedFields": [
              "bugSignals.hasWorkaround",
              "actionability"
            ]
          },
          {
            "text": "That was how if I fixed it too. Had a similar issue with the native DLLs that are supposed to be part of Microsoft.Data.SqlClient",
            "source": "comment 3 (ajohnstone-ks, OP)",
            "interpretation": "OP confirms the workaround and notes this is a broader ClickOnce issue affecting multiple NuGet packages with native assets, not SkiaSharp-specific",
            "supportedFields": [
              "type",
              "actionability"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The native binary fails to deploy in ClickOnce, causing a crash. While this is arguably a ClickOnce tooling limitation rather than a SkiaSharp code defect, the user\u0027s app breaks when using SkiaSharp with ClickOnce, which qualifies as a bug from the user\u0027s perspective. The existing \u0027type/bug\u0027 label is appropriate.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Not asking how to do something \u2014 reporting a hard crash in a deployment scenario."
              },
              {
                "value": "enhancement",
                "whyRejected": "Could argue SkiaSharp should add ClickOnce-friendly packaging, but the immediate issue is broken behavior, not a feature gap."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "DllNotFoundException for the native library. The issue is about native binary deployment, not the managed C# API. The area/libSkiaSharp.native label accurately reflects this.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "The managed SkiaSharp code works correctly \u2014 the issue is the native binary not being present at runtime."
              },
              {
                "value": "Build",
                "whyRejected": "The build succeeds. The issue is in the ClickOnce publish/deployment step, which is outside SkiaSharp\u0027s build system."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": ".NET Framework 4.7.2 WinForms is definitively Windows-Classic (Win32 APIs). ClickOnce is a Windows-Classic deployment mechanism."
          },
          {
            "field": "tenets",
            "chosen": "reliability",
            "expandedReason": "The application crashes with an unhandled TypeInitializationException/DllNotFoundException. This is a reliability issue \u2014 the app fails to function at all when deployed via ClickOnce."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash (DllNotFoundException) but a workaround exists and is confirmed by multiple users. The issue is specific to one deployment method (ClickOnce) while others (MSIX) work. Severity would be \u0027high\u0027 without the workaround.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Workaround exists and is confirmed by OP. Other deployment methods work."
              },
              {
                "value": "critical",
                "whyRejected": "Not data loss or security. Deployment-specific with a known workaround."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The root cause is a ClickOnce limitation, not a SkiaSharp defect. A confirmed workaround exists. The issue could be closed with the documented workaround. However, human review is recommended because SkiaSharp might want to keep this open to track potential packaging improvements for ClickOnce compatibility.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "Valid option if the team wants to investigate ClickOnce-friendly packaging. Marked requiresHumanReview for this reason."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "The root cause and workaround are already known. No further investigation needed."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed NativeAssets.Win32 is auto-included and uses runtimes/ directory structure. Reviewed publishing modes and deployment guidance. ClickOnce is not explicitly covered but falls under framework-dependent deployment.",
            "usedFor": [
              "area",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Reviewed \u0027DllNotFoundException after publishing\u0027 pattern \u2014 confirms this is a known deployment issue category. The guidance about NativeAssets being in library vs application project is relevant but not the specific cause here.",
            "usedFor": [
              "type",
              "area"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult API XML docs, rendering/backend docs, or Linux-specific docs \u2014 this issue is purely about Windows ClickOnce deployment, not about API usage, rendering, or Linux.",
        "uncertainties": [
          "Whether SkiaSharp\u0027s NuGet packaging could be improved to better support ClickOnce (e.g., including native DLLs outside the runtimes/ folder for .NET Framework targets)",
          "Whether the user\u0027s project uses packages.config or PackageReference \u2014 this affects how NuGet native assets are handled",
          "The user mentions libSkiaSharp.dylib (macOS binary name) in the description but is on Windows \u2014 this may be a terminology confusion or copy-paste error"
        ],
        "assumptions": [
          "Assumed the user has SkiaSharp.NativeAssets.Win32 correctly referenced, since MSIX deployment works and the issue is ClickOnce-specific",
          "Assumed .NET Framework project format (not SDK-style) since it\u0027s .NET Framework 4.7.2 WinForms \u2014 this affects NuGet asset handling"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "ClickOnce deployment does not automatically include native binaries from NuGet packages that use the runtimes/{rid}/native/ directory convention. The SkiaSharp.NativeAssets.Win32 package places libSkiaSharp.dll in runtimes/win-x64/native/ (and win-x86), but ClickOnce\u0027s Application Files mechanism doesn\u0027t discover files in this path structure. MSIX handles this correctly because it processes the full output directory layout.",
        "researchDone": [
          "Reviewed documentation/packages.md for NativeAssets.Win32 deployment behavior",
          "Reviewed references/skia-patterns.md for known DllNotFoundException patterns",
          "Checked all 3 issue comments for workarounds and confirmations",
          "Searched GitHub issues for similar ClickOnce \u002B libSkiaSharp reports \u2014 no other issues found"
        ],
        "proposals": [
          {
            "title": "Manual DLL inclusion as Content (confirmed workaround)",
            "description": "Manually add libSkiaSharp.dll from the NativeAssets.Win32 package to the project as Content with \u0027Copy if newer\u0027. This forces ClickOnce to include the native binary in the deployment.",
            "steps": [
              "Locate libSkiaSharp.dll in packages/SkiaSharp.NativeAssets.Win32.{version}/runtimes/win-x64/native/ (or win-x86 for 32-bit)",
              "Right-click project in VS \u2192 Add \u2192 Existing Item \u2192 select the DLL",
              "Set Build Action = Content, Copy to Output Directory = Copy if newer",
              "Verify in Project \u2192 Properties \u2192 Publish \u2192 Application Files that libSkiaSharp.dll is listed as Include/Required",
              "Republish via ClickOnce"
            ],
            "pros": [
              "Confirmed working by multiple users",
              "No changes needed to SkiaSharp packages",
              "Simple to implement"
            ],
            "cons": [
              "Must be repeated when updating SkiaSharp version",
              "Architecture-specific (must choose x64 or x86 DLL)",
              "Fragile \u2014 easy to forget after package update"
            ],
            "confidence": 0.95,
            "effort": "low"
          },
          {
            "title": "MSBuild targets for ClickOnce-compatible native asset deployment",
            "description": "Add MSBuild targets to SkiaSharp.NativeAssets.Win32 that detect ClickOnce projects and copy native DLLs to the output directory as content files, bypassing the runtimes/ directory structure.",
            "steps": [
              "Detect ClickOnce publish profile or .NET Framework project type in MSBuild",
              "Add a target that copies the appropriate architecture\u0027s libSkiaSharp.dll to the output directory",
              "Mark the copied file as Content for ClickOnce inclusion",
              "Test with both x86 and x64 ClickOnce deployments"
            ],
            "pros": [
              "Permanent fix \u2014 no manual steps for users",
              "Would fix all future SkiaSharp \u002B ClickOnce scenarios",
              "Could benefit other similar NuGet packages if pattern is documented"
            ],
            "cons": [
              "Requires understanding ClickOnce MSBuild integration details",
              "May have side effects on non-ClickOnce .NET Framework projects",
              "ClickOnce is a legacy deployment method \u2014 investment may not be justified"
            ],
            "confidence": 0.60,
            "effort": "medium"
          },
          {
            "title": "Switch to MSIX deployment",
            "description": "Migrate the application from ClickOnce to MSIX deployment, which correctly handles the runtimes/ native asset structure.",
            "steps": [
              "Add Windows Application Packaging Project to the solution",
              "Configure MSIX packaging for the WinForms app",
              "Remove ClickOnce publish profile",
              "Test MSIX deployment on target machines"
            ],
            "pros": [
              "User confirmed MSIX already works for them",
              "Modern deployment method with better native asset support",
              "No SkiaSharp changes needed"
            ],
            "cons": [
              "Significant deployment infrastructure change",
              "May not be feasible due to organizational constraints",
              "ClickOnce has features (auto-update) that MSIX handles differently"
            ],
            "confidence": 0.85,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Manual DLL inclusion as Content (confirmed workaround)",
        "recommendedReason": "Already confirmed working by both the reporter and another community member. Zero risk, low effort, and immediately actionable. The MSBuild targets proposal is a better long-term solution but requires significant investigation into ClickOnce internals."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3423"
    },
    {
      "schemaVersion": "1.0",
      "number": 3422,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-01-15T12:00:00Z",
      "summary": "SkiaSharp fails with TypeInitializationException on Blazor WASM targeting .NET 10 due to native library static linking incompatibility",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Multiple users report TypeInitializationException and DllNotFoundException when using SkiaSharp in Blazor WASM on .NET 10. This is broken behavior \u2014 the library completely fails to initialize."
      },
      "area": {
        "value": "SkiaSharp.Views.Blazor",
        "confidence": 0.90,
        "reason": "The issue involves SkiaSharp.Views.Blazor package with SKCanvasView in a Blazor WebAssembly project. The root cause is in the WASM static linking pipeline which is managed by the Views.Blazor and NativeAssets.WebAssembly packages."
      },
      "backends": null,
      "platforms": [
        {
          "value": "WASM",
          "confidence": 0.98,
          "reason": "Explicitly a Blazor WebAssembly project. Multiple reporters confirm WASM-specific failure. The os/WASM label is already applied."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Complete failure to initialize \u2014 TypeInitializationException prevents any SkiaSharp usage in Blazor WASM on .NET 10."
        },
        {
          "value": "compatibility",
          "confidence": 0.90,
          "reason": "This is a .NET 10 compatibility issue. SkiaSharp works on earlier .NET versions but fails on .NET 10 WASM, indicating a cross-version compatibility gap."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.85,
        "reason": "SkiaSharp Blazor WASM worked on earlier .NET versions (e.g., .NET 8, .NET 9) but fails on .NET 10. However, it\u0027s not a SkiaSharp regression \u2014 the .NET 10 WASM toolchain changed. Even rolling back to SkiaSharp 2.88.9 does not fix it, confirming the regression is in the .NET platform, not SkiaSharp itself.",
        "workedInVersion": "3.119.1",
        "brokeInVersion": "3.119.1"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "complete",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Running \u0027dotnet workload restore\u0027 fixed the issue for one user (EngstromJimmy), but did not work for another user (Webreaper) on macOS. The workaround is inconsistent.",
        "targetFrameworks": [
          "net10.0"
        ],
        "severity": "high",
        "severityReason": "Complete failure \u2014 SkiaSharp cannot be used at all in Blazor WASM on .NET 10. No reliable workaround exists. Multiple users affected across different OS environments."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a new Blazor WebAssembly project targeting net10.0",
          "Add PackageReference to SkiaSharp.Views.Blazor (any version: 3.119.2-preview.1, 3.119.1, 3.118.0-preview.2.3, or even 2.88.x)",
          "Add a Razor component with SKCanvasView and OnPaintSurface handler",
          "Run the project and navigate to the page with the SkiaSharp component",
          "Observe TypeInitializationException: TypeInitialization_Type, SkiaSharp.SKImageInfo"
        ],
        "codeSnippets": [
          {
            "language": "xml",
            "code": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk.BlazorWebAssembly\u0022\u003E\n\t\u003CPropertyGroup\u003E\n\t\t\u003CTargetFramework\u003Enet10.0\u003C/TargetFramework\u003E\n\t\t\u003CNullable\u003Eenable\u003C/Nullable\u003E\n\t\t\u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\n\t\t\u003COverrideHtmlAssetPlaceholders\u003Etrue\u003C/OverrideHtmlAssetPlaceholders\u003E\n\t\u003C/PropertyGroup\u003E\n\t\u003CItemGroup\u003E\n\t\t\u003CPackageReference Include=\u0022Microsoft.AspNetCore.Components.WebAssembly\u0022 Version=\u002210.0.0\u0022 /\u003E\n\t\t\u003CPackageReference Include=\u0022Microsoft.AspNetCore.Components.WebAssembly.DevServer\u0022 Version=\u002210.0.0\u0022 PrivateAssets=\u0022all\u0022 /\u003E\n\t\t\u003CPackageReference Include=\u0022SkiaSharp.Views.Blazor\u0022 Version=\u00223.119.2-preview.1\u0022 /\u003E\n\t\u003C/ItemGroup\u003E\n\u003C/Project\u003E",
            "context": "Project file that reproduces the issue. Same result with release build."
          },
          {
            "language": "csharp",
            "code": "@using SkiaSharp\n@using SkiaSharp.Views.Blazor\n\n\u003CSKCanvasView OnPaintSurface=\u0022OnPaintSurface\u0022 IgnorePixelScaling=\u0022true\u0022 /\u003E\n\n@code {\n    private void OnPaintSurface(SKPaintSurfaceEventArgs args)\n    {\n        var canvas = args.Surface.Canvas;\n        canvas.Clear(SkiaSharp.SKColors.White);\n        using var paint = new SkiaSharp.SKPaint\n        {\n            Color = SkiaSharp.SKColors.Black,\n            IsAntialias = true,\n            Style = SkiaSharp.SKPaintStyle.Fill\n        };\n        using var font = new SkiaSharp.SKFont { Size = 24 };\n        var coord = new SkiaSharp.SKPoint(args.Info.Width / 2, (args.Info.Height \u002B font.Size) / 2);\n        canvas.DrawText(\u0022SkiaSharp\u0022, coord, font, paint);\n    }\n}",
            "context": "Razor component that triggers the TypeInitializationException when rendered."
          }
        ],
        "environmentDetails": "Windows 11 Pro, VS 2026, .NET 10, Edge/Chrome browsers. Also reproduced on macOS with Rider (SkiaSharp 3.119.1) and Linux production deployment."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.119.2-preview.1",
          "3.119.1",
          "3.118.0-preview.2.3",
          "2.88.9",
          "2.88.0"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Issue affects all tested SkiaSharp versions (including 2.88.x legacy) when targeting .NET 10 WASM. The problem is not version-specific to SkiaSharp \u2014 it\u0027s a .NET 10 WASM toolchain compatibility issue. Still relevant as .NET 10 is the current target.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.90,
        "reason": "This is a real compatibility bug affecting .NET 10 WASM. The NativeAssets.WebAssembly package needs to be updated to support .NET 10\u0027s WASM build pipeline. Investigation is needed to determine whether the Emscripten version, MSBuild targets, or NativeFileReference mechanism changed in .NET 10.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.70,
        "reason": "Partial workaround exists (dotnet workload restore) and the root cause is understood at a high level. A response acknowledging the .NET 10 compatibility gap and providing interim guidance would be useful.",
        "draft": "Thanks for the detailed reproduction \u2014 the project file and component code make this straightforward to verify.\n\nThis appears to be a .NET 10 WASM toolchain compatibility issue rather than a SkiaSharp-specific regression, which explains why rolling back SkiaSharp versions doesn\u0027t help. The \u0060TypeInitializationException\u0060 on \u0060SKImageInfo\u0060 is caused by \u0060libSkiaSharp\u0060 not being statically linked into \u0060dotnet.wasm\u0060 during the build \u2014 the .NET 10 WASM build pipeline likely changed how \u0060NativeFileReference\u0060 items are processed.\n\nOne user reported that \u0060dotnet workload restore\u0060 resolved it, though results have been mixed. If you haven\u0027t tried that yet, it\u0027s worth a shot \u2014 it ensures the WASM workload and Emscripten toolchain are properly installed for .NET 10.\n\nWe\u0027ll investigate what changed in the .NET 10 WASM build pipeline and update the \u0060NativeAssets.WebAssembly\u0060 package accordingly."
      },
      "analysisNotes": {
        "summary": "SkiaSharp completely fails to initialize in Blazor WASM on .NET 10, throwing TypeInitializationException (wrapping DllNotFoundException) on SKImageInfo. This affects all SkiaSharp versions tested, indicating a .NET 10 WASM toolchain change broke the static linking of native WASM assets.",
        "keySignals": [
          {
            "text": "ManagedError: TypeInitialization_Type, SkiaSharp.SKImageInfo",
            "source": "body",
            "interpretation": "TypeInitializationException in SKImageInfo\u0027s static constructor, which performs P/Invoke to libSkiaSharp. On WASM this means the native library was not statically linked into dotnet.wasm.",
            "supportedFields": [
              "type",
              "bugSignals.severity",
              "bugSignals.hasCrash"
            ]
          },
          {
            "text": "DllNotFoundException: libSkiaSharp at SkiaSharp.SKPath..ctor()",
            "source": "comment 3",
            "interpretation": "Confirms the TypeInitializationException is caused by libSkiaSharp not being found \u2014 the static linking into dotnet.wasm failed during build.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals"
            ]
          },
          {
            "text": "it seems more related to .net 10 WASM projects",
            "source": "comment 2",
            "interpretation": "Reporter explicitly identifies .NET 10 as the variable, not SkiaSharp version. This is key for classification \u2014 it\u0027s a platform compatibility issue.",
            "supportedFields": [
              "platforms",
              "regression",
              "versionAnalysis"
            ]
          },
          {
            "text": "I tried rolling back to several older versions (including 2.88.9 and 2.88.0) without luck",
            "source": "comment 5",
            "interpretation": "Confirms the issue is not SkiaSharp-version-specific. The problem is in the .NET 10 WASM toolchain\u0027s handling of NativeFileReference static linking.",
            "supportedFields": [
              "regression",
              "versionAnalysis"
            ]
          },
          {
            "text": "Restoring the .NET 10 wasm workload helped me. dotnet workload restore",
            "source": "comment 6",
            "interpretation": "Suggests the WASM workload installation state matters \u2014 possibly a missing or mismatched Emscripten toolchain. But this workaround is inconsistent.",
            "supportedFields": [
              "bugSignals.hasWorkaround",
              "resolutionAnalysis"
            ]
          },
          {
            "text": "dotnet workload restore didn\u0027t have any effect for me - still seeing the same issue on MacOS",
            "source": "comment 8",
            "interpretation": "Workaround is unreliable, suggesting deeper compatibility issue beyond just workload installation.",
            "supportedFields": [
              "bugSignals.severity",
              "bugSignals.hasWorkaround"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Complete failure to initialize SkiaSharp in a supported scenario (Blazor WASM). TypeInitializationException/DllNotFoundException is a clear crash, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "feature-request",
                "whyRejected": "Blazor WASM is already a supported platform \u2014 this is a regression in that support on .NET 10, not a request for new functionality."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views.Blazor",
            "expandedReason": "The issue manifests through SkiaSharp.Views.Blazor\u0027s SKCanvasView component. The root cause is in how Views.Blazor and NativeAssets.WebAssembly integrate with the .NET 10 WASM build pipeline. The area/SkiaSharp.Views.Blazor label is already applied.",
            "alternatives": [
              {
                "value": "libSkiaSharp.native",
                "whyRejected": "While the native library is involved, the issue is specifically about WASM static linking managed by the Blazor/WebAssembly packages, not the native binary itself."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "WASM",
            "expandedReason": "Exclusively a WebAssembly issue. The WASM static linking pipeline (NativeFileReference \u2192 Emscripten \u2192 dotnet.wasm) is the failure point."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Complete inability to use SkiaSharp on .NET 10 WASM. No reliable workaround \u2014 dotnet workload restore works for some but not all. Multiple users affected.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": ".NET 10 is still in preview, and .NET 9 WASM still works. While it\u0027s a blocker for .NET 10 adoption, it\u0027s not a data-loss or security issue."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause needs engineering investigation: what changed in .NET 10\u0027s WASM build pipeline that breaks NativeFileReference static linking for SkiaSharp\u0027s .a files. May require updating NativeAssets.WebAssembly MSBuild targets or rebuilding the .a files with a newer Emscripten version.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "This needs active investigation, not just backlog tracking. .NET 10 GA is approaching."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed that WASM uses static linking via NativeFileReference, not dynamic P/Invoke. NativeAssets.WebAssembly is auto-included by SkiaSharp.Views.Blazor. This explains why DllNotFoundException means the .a file wasn\u0027t linked into dotnet.wasm.",
            "usedFor": [
              "area",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Confirmed WASM static linking pattern and threading variants (st/mt). No existing heuristic for .NET 10 WASM breakage.",
            "usedFor": [
              "area",
              "resolutionAnalysis"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult API XML docs or rendering backend docs \u2014 this is a build/linking issue, not an API usage or rendering problem.",
        "uncertainties": [
          "Exact change in .NET 10 WASM toolchain that breaks static linking is unknown \u2014 could be Emscripten version bump, NativeFileReference MSBuild target changes, or workload packaging changes",
          "Whether the \u0027dotnet workload restore\u0027 workaround depends on specific SDK versions or OS \u2014 it worked for one Windows user but not a macOS user",
          "Whether the original reporter (NetRushJacob) tried the workload restore workaround",
          "Whether the os/Windows-Universal-UWP label is correctly applied \u2014 this appears to be a WASM issue, not UWP"
        ],
        "assumptions": [
          "Assumed the TypeInitializationException wraps a DllNotFoundException based on comment 3\u0027s explicit DllNotFoundException and the known pattern for SKImageInfo static constructor failures",
          "Assumed this is not a SkiaSharp code regression since rolling back to 2.88.x versions doesn\u0027t fix it"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The .NET 10 WASM toolchain (Emscripten/MSBuild targets) changed how NativeFileReference items are processed during the WASM build. The SkiaSharp.NativeAssets.WebAssembly package\u0027s .a files are not being linked into dotnet.wasm, causing DllNotFoundException at runtime. This could be due to an Emscripten version mismatch, changed MSBuild property names, or a new workload dependency requirement.",
        "researchDone": [
          "Reviewed documentation/packages.md for WASM static linking architecture",
          "Reviewed references/skia-patterns.md for WASM-specific quirks",
          "Searched for duplicate/similar issues \u2014 found #2411 (similar Blazor WASM issue on .NET 7) and #3015 (WASI WASM DllNotFoundException)",
          "Analyzed all 8 comments for diagnostic clues and workaround effectiveness",
          "Checked that the issue affects multiple SkiaSharp versions confirming it\u0027s a platform issue"
        ],
        "proposals": [
          {
            "title": "Update NativeAssets.WebAssembly for .NET 10 Emscripten",
            "description": "Rebuild the libSkiaSharp.a static library against the Emscripten version bundled with .NET 10\u0027s WASM workload, and update the MSBuild targets in NativeAssets.WebAssembly to match any .NET 10 build pipeline changes.",
            "steps": [
              "Identify the Emscripten version used by .NET 10\u0027s WASM workload",
              "Rebuild libSkiaSharp.a with the matching Emscripten version and flags",
              "Update the NativeAssets.WebAssembly .targets file for any .NET 10 MSBuild changes",
              "Add net10.0 to the package\u0027s supported TFMs",
              "Test with a .NET 10 Blazor WASM project"
            ],
            "pros": [
              "Addresses root cause",
              "Ensures long-term .NET 10 compatibility",
              "Benefits all WASM users"
            ],
            "cons": [
              "Requires understanding .NET 10\u0027s WASM build pipeline changes",
              "May need to ship multiple Emscripten-versioned .a files"
            ],
            "confidence": 0.80,
            "effort": "medium"
          },
          {
            "title": "Workaround: dotnet workload restore",
            "description": "Advise users to run \u0027dotnet workload restore\u0027 to ensure the .NET 10 WASM workload is properly installed. This has worked for at least one user and may resolve cases where the workload is missing or partially installed.",
            "steps": [
              "Run \u0027dotnet workload restore\u0027 in the project directory",
              "Optionally restart the IDE",
              "Clean and rebuild the project",
              "If still failing, try \u0027dotnet workload install wasm-tools\u0027"
            ],
            "pros": [
              "No SkiaSharp code changes needed",
              "Immediate action users can try",
              "Addresses workload installation issues"
            ],
            "cons": [
              "Does not work for all users (failed for Webreaper on macOS)",
              "Doesn\u0027t address the underlying compatibility gap",
              "May only work when the issue is a missing workload, not an incompatible one"
            ],
            "confidence": 0.45,
            "effort": "low"
          },
          {
            "title": "Target .NET 9 instead of .NET 10",
            "description": "As a temporary workaround, users can target net9.0 instead of net10.0 while .NET 10 support is being developed. SkiaSharp Blazor WASM works on .NET 9.",
            "steps": [
              "Change TargetFramework from net10.0 to net9.0 in the project file",
              "Update Microsoft.AspNetCore.Components.WebAssembly to 9.x version",
              "Rebuild and verify SkiaSharp works"
            ],
            "pros": [
              "Immediate workaround that reliably works",
              "No SkiaSharp changes needed"
            ],
            "cons": [
              "Users lose .NET 10 features",
              "Not viable for projects that require .NET 10",
              "Temporary \u2014 doesn\u0027t solve the long-term issue"
            ],
            "confidence": 0.85,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Update NativeAssets.WebAssembly for .NET 10 Emscripten",
        "recommendedReason": "This is the only proposal that addresses the root cause. .NET 10 GA is approaching, and SkiaSharp needs to support it. The workarounds are either unreliable (workload restore) or temporary (targeting .NET 9)."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3422"
    },
    {
      "schemaVersion": "1.0",
      "number": 3421,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-24T12:00:00Z",
      "summary": "Skottie Animation.Create returns null for .lottie files because they are ZIP-compressed, not plain JSON",
      "type": {
        "value": "bug",
        "confidence": 0.70,
        "reason": "While the root cause is a format mismatch (.lottie is ZIP, Skottie expects JSON), the silent null return with no error or exception constitutes unreliable behavior. The existing labels also classify this as type/bug. Could alternatively be classified as question or feature-request."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.90,
        "reason": "The Skottie Animation class is part of the SkiaSharp binding ecosystem. The existing label area/SkiaSharp confirms this."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.85,
          "reason": "Reporter specifies Windows 11 with Visual Studio. The existing label os/Windows-Classic confirms. However, this issue is likely cross-platform since it relates to file format parsing, not platform-specific behavior."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.90,
          "reason": "Silent null return with no exception or error message is an unexpected behavior / reliability concern. Matches existing tenet/reliability label."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "partial",
        "hasScreenshot": true,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net8.0"
        ],
        "severity": "medium",
        "severityReason": "The API silently returns null instead of parsing the file. No crash occurs, but the user has no indication of what went wrong. A workaround exists (extract the JSON from the .lottie ZIP archive first), but the user does not know this."
      },
      "reproEvidence": {
        "screenshots": [
          {
            "url": "https://github.com/user-attachments/assets/9ca27c18-536b-4403-a41d-44e907329001",
            "context": "Screenshot shown alongside the lottie file reference from LottieFiles \u2014 appears to be a preview of the animation being loaded",
            "source": "description"
          },
          {
            "url": "https://github.com/user-attachments/assets/0fe1691c-82ee-462a-a110-f53b0682833f",
            "context": "Shown under \u0027Relevant Screenshots\u0027 section \u2014 appears to show the null result or debugger output",
            "source": "description"
          }
        ],
        "stepsToReproduce": [
          "Download a .lottie file from LottieFiles (e.g., https://app.lottiefiles.com/animation/5b206184-3c40-4a29-a6c4-0f62df06e4a8)",
          "Call SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute) where sourceFileAbsolute points to the .lottie file",
          "Observe that the returned animation is null"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);",
            "context": "The call that returns null when given a .lottie file path"
          }
        ],
        "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), Windows 11 Desktop"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Reporter is using 3.116.0 which is a current modern SkiaSharp 3.x release. The underlying issue (Skottie parses JSON, not ZIP-compressed .lottie files) has never been supported, so this is relevant to all versions.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.75,
        "reason": "The core question is whether SkiaSharp/Skottie should support .lottie files (ZIP-compressed Lottie bundles) natively, or if this is expected behavior that should be better documented. At minimum, the silent failure should be addressed with better error messaging or documentation. Needs maintainer decision on scope.",
        "requiresHumanReview": true,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.85,
        "reason": "The root cause is identifiable: .lottie files are ZIP archives, Skottie expects JSON. A helpful response explaining the format difference and workaround is appropriate.",
        "draft": "Thanks for the detailed report and screenshots.\n\nThe \u0060.lottie\u0060 file format is actually a ZIP-compressed archive that bundles the Lottie JSON animation along with any assets (images, fonts). Skia\u0027s Skottie parser expects the raw Lottie JSON data directly, so when it receives the ZIP binary data, it fails to parse and returns null.\n\nAs a workaround, you can extract the JSON from the \u0060.lottie\u0060 file before passing it to \u0060Animation.Create\u0060:\n\n\u0060\u0060\u0060csharp\nusing var archive = System.IO.Compression.ZipFile.OpenRead(sourceFileAbsolute);\nvar entry = archive.Entries.First(e =\u003E e.Name.EndsWith(\u0022.json\u0022) \u0026\u0026 e.Name != \u0022manifest.json\u0022);\nusing var stream = entry.Open();\nvar animation = Animation.Create(stream);\n\u0060\u0060\u0060\n\nAlternatively, you can download the animation in \u0060.json\u0060 format directly from LottieFiles instead of \u0060.lottie\u0060.\n\nThat said, the silent null return without any indication of what went wrong is something we should look at improving. Would it help to know which specific \u0060.lottie\u0060 file you\u0027re working with so we can verify the workaround works for your case?"
      },
      "analysisNotes": {
        "summary": "The user is passing a .lottie file (ZIP-compressed archive format) to Skottie\u0027s Animation.Create(), which expects plain JSON Lottie data. The Skia JSON parser receives binary ZIP data, fails silently, and returns null. This is technically expected behavior given the format mismatch, but the silent failure is a reliability concern.",
        "keySignals": [
          {
            "text": "Loading .lottie file results in null SkiaSharp.Skottie.Animation",
            "source": "title",
            "interpretation": "The .lottie extension is the critical signal \u2014 .lottie files are ZIP-compressed bundles (introduced by LottieFiles), distinct from .json Lottie files that Skottie supports.",
            "supportedFields": [
              "type",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "text": "No exception is thrown, so it fails silently",
            "source": "body",
            "interpretation": "Silent null return is a reliability concern. The API should ideally indicate why parsing failed.",
            "supportedFields": [
              "tenets",
              "bugSignals.severity"
            ]
          },
          {
            "text": "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);",
            "source": "body",
            "interpretation": "Using the file path overload of Create, which reads the file as raw data and passes to the JSON parser. A ZIP file will fail JSON parsing.",
            "supportedFields": [
              "area",
              "resolutionAnalysis"
            ]
          },
          {
            "text": "https://app.lottiefiles.com/animation/5b206184-3c40-4a29-a6c4-0f62df06e4a8",
            "source": "body",
            "interpretation": "LottieFiles is a popular source. Downloads can be in .lottie (ZIP) or .json format. User likely chose the .lottie download option.",
            "supportedFields": [
              "resolutionAnalysis"
            ]
          },
          {
            "text": "Last Known Good Version: Other (Please indicate in the description)",
            "source": "body",
            "interpretation": "User didn\u0027t indicate a prior working version, suggesting this may never have worked for .lottie files. This is consistent with it being a format that was never supported.",
            "supportedFields": [
              "regression"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Classified as bug primarily because of the silent failure behavior \u2014 a null return with no error or exception when given an unsupported file format is unreliable. The existing labels also mark this as type/bug. However, the underlying cause is a format mismatch (.lottie vs .json), which makes this a borderline case.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "The user is not asking how to do something \u2014 they expect Create to work and it doesn\u0027t. The report structure is a bug report."
              },
              {
                "value": "feature-request",
                "whyRejected": "Adding native .lottie support could be a feature request, but the reporter isn\u0027t requesting a new feature \u2014 they expect existing behavior to work."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "The Skottie Animation class is part of the SkiaSharp binding ecosystem. While it\u0027s technically in the SkiaSharp.Skottie package, the area labels use area/SkiaSharp for core API issues. The existing label confirms this classification."
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "Reporter explicitly states Windows 11 and Visual Studio. The existing label os/Windows-Classic confirms. However, this issue is almost certainly cross-platform since JSON parsing failure would occur on any OS.",
            "alternatives": [
              {
                "value": "null (cross-platform)",
                "whyRejected": "Respecting the reporter\u0027s stated platform and existing label, even though the issue is likely platform-independent."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "reliability",
            "expandedReason": "Silent null return with no exception or error constitutes unexpected behavior. The user has no way to diagnose why loading failed. Matches existing tenet/reliability label."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "The API returns null silently rather than crashing. A workaround exists (extract JSON from the ZIP archive, or download .json instead of .lottie). Classified medium because there IS a workaround even though the user doesn\u0027t know about it.",
            "alternatives": [
              {
                "value": "low",
                "whyRejected": "Silent failure without diagnostic info elevates this above cosmetic/minor."
              },
              {
                "value": "high",
                "whyRejected": "No crash, no data loss. There are straightforward workarounds once the format difference is understood."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Needs maintainer decision: should SkiaSharp detect .lottie ZIP format and either decompress automatically or throw an informative error? The immediate value is the response explaining the format difference, but the longer-term question requires engineering input.",
            "alternatives": [
              {
                "value": "close-with-docs",
                "whyRejected": "While the immediate issue can be resolved with an explanation, the silent failure behavior may warrant a code change (better error message or .lottie support)."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "binding/SkiaSharp.Skottie/Animation.cs",
            "relevance": "Confirmed that Animation.Create(path) reads file into SKData and passes to skottie_animation_make_from_data, which expects JSON bytes. ZIP binary data would fail JSON parsing.",
            "usedFor": [
              "type",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "tests/Tests/Skottie/AnimationTest.cs",
            "relevance": "Confirmed that all test files are .json format (LottieLogo1.json, LottieLogo1_bom.json). No .lottie test files exist, confirming the format was never tested/supported.",
            "usedFor": [
              "type",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for any Skottie-specific patterns or known traps. None found for .lottie format specifically.",
            "usedFor": [
              "analysisNotes"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult documentation/packages.md (no native loading or deployment issue), or .docs/ (no how-to question about drawing).",
        "uncertainties": [
          "Whether the upstream Skia Skottie library has any support for .lottie (ZIP-compressed) format, or if this would need to be handled in the C# wrapper layer",
          "Whether the specific .lottie file from LottieFiles has a standard ZIP structure with a manifest.json and animation JSON, or uses a different layout",
          "Whether LottieFiles recently changed their default download format from .json to .lottie, which could cause a wave of similar reports"
        ],
        "assumptions": [
          "Assumed the .lottie file follows the standard dotLottie format (ZIP archive containing animation JSON and optional assets), based on the LottieFiles source URL",
          "Assumed the target framework is net8.0 since the user is on SkiaSharp 3.116.0 and using Visual Studio on Windows, though this was not explicitly stated"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The user downloaded a .lottie file (ZIP-compressed dotLottie format) instead of a plain .json Lottie animation. Skia\u0027s Skottie parser expects JSON data and silently fails when given ZIP binary data, returning null with no error indication.",
        "researchDone": [
          "Examined Animation.cs source \u2014 confirmed Create(path) reads raw bytes and passes to native skottie_animation_make_from_data which expects JSON",
          "Examined AnimationTest.cs \u2014 all test files are .json format, no .lottie test coverage exists",
          "Searched GitHub issues \u2014 found #2166 (similar silent null for BOM issue, now fixed), confirming pattern of Skottie silently failing on unparseable data",
          "Reviewed LottieFiles distribution formats \u2014 .lottie is their ZIP-based format; .json is also available as a download option"
        ],
        "proposals": [
          {
            "title": "Respond with format explanation and workaround",
            "description": "Explain the .lottie vs .json difference to the user and provide a code workaround to extract JSON from the ZIP archive, or suggest downloading in .json format instead.",
            "steps": [
              "Post response explaining .lottie is ZIP-compressed, Skottie expects JSON",
              "Provide code snippet to extract JSON from .lottie ZIP archive using System.IO.Compression",
              "Suggest downloading .json format from LottieFiles as simpler alternative"
            ],
            "pros": [
              "Immediately unblocks the user",
              "No code changes required",
              "Educational for other users who find this issue"
            ],
            "cons": [
              "Doesn\u0027t address the silent failure behavior",
              "Users may continue to hit this as .lottie becomes more common"
            ],
            "confidence": 0.90,
            "effort": "low"
          },
          {
            "title": "Add .lottie format detection with informative error",
            "description": "In Animation.TryCreate, detect ZIP magic bytes (PK header: 0x50 0x4B) at the start of the data and throw an informative exception or log a message indicating the .lottie format needs to be decompressed first.",
            "steps": [
              "Add ZIP magic bytes check in TryCreate(SKData) before passing to native parser",
              "Return false from TryCreate with a debug/trace message indicating ZIP format detected",
              "Optionally throw NotSupportedException from Create() with message explaining .lottie format",
              "Add test with a .lottie (or synthetic ZIP) file to verify the detection"
            ],
            "pros": [
              "Users get a clear error message instead of silent null",
              "Minimal code change",
              "Doesn\u0027t break existing behavior for .json files"
            ],
            "cons": [
              "Still doesn\u0027t support .lottie natively",
              "Detecting ZIP by magic bytes is a heuristic"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Add native .lottie (dotLottie) support",
            "description": "Add a new overload or auto-detection in Animation.Create that handles .lottie ZIP archives by extracting the animation JSON from the archive before passing to the Skottie parser.",
            "steps": [
              "Detect ZIP format via PK magic bytes in TryCreate(SKData)",
              "If ZIP detected, use System.IO.Compression.ZipArchive to extract the animation JSON",
              "Parse the manifest.json to find the main animation entry",
              "Extract the animation JSON and pass to the existing parser",
              "Add Animation.CreateFromDotLottie() overload for explicit .lottie loading",
              "Add test coverage with sample .lottie files"
            ],
            "pros": [
              "Seamless experience for users",
              ".lottie format is increasingly common",
              "Full compatibility with LottieFiles ecosystem"
            ],
            "cons": [
              "Adds dependency on System.IO.Compression",
              "Needs to handle .lottie format variations",
              "Asset loading (embedded images) may need additional work",
              "Larger scope change"
            ],
            "confidence": 0.65,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Respond with format explanation and workaround",
        "recommendedReason": "Immediately unblocks the user with zero risk. The maintainer can then decide whether to invest in .lottie format detection (proposal 2) or full support (proposal 3) as a follow-up."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3421"
    },
    {
      "schemaVersion": "1.0",
      "number": 3420,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-08T15:00:00Z",
      "summary": "libSkiaSharp.so built with 4KB page size blocks Android 16\u002B targeting; fix shipped in 3.118.0",
      "type": {
        "value": "bug",
        "confidence": 0.88,
        "reason": "The native library is built with incorrect ELF alignment (4KB instead of 16KB), which prevents apps from running on Android 16\u002B and being accepted by Google Play. This is broken behavior in the build output, not a feature request."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.97,
        "reason": "Issue is entirely about the native binary libSkiaSharp.so and its ELF segment alignment. This is a native build configuration issue, not a managed API issue."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Android",
          "confidence": 0.99,
          "reason": "Issue explicitly concerns Android 16\u002B 16KB page size requirement for native .so libraries. Only affects Android platform."
        }
      ],
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.95,
          "reason": "This is a forward-compatibility issue \u2014 existing binaries are incompatible with the new Android 16\u002B page size requirement. The existing label tenet/compatibility confirms this classification."
        }
      ],
      "partner": {
        "value": "maui",
        "confidence": 0.70,
        "reason": "Reporter is using .NET MAUI 9.0 and references a MAUI discussion (dotnet/maui#30428). However, the underlying issue is in the native binary, not MAUI-specific."
      },
      "regression": null,
      "fixStatus": {
        "likelyFixed": true,
        "confidence": 0.85,
        "reason": "Issue #3025 reported the same 16KB alignment problem and was closed as fixed in milestone 3.118.0. The fix involved adding the -Wl,-z,max-page-size=16384 linker flag. The reporter\u0027s 2.88.6 version is unsupported and won\u0027t receive the fix, but SkiaSharp 3.118.0\u002B should have correct alignment. The reporter also selected 3.116.0 as \u0027current\u0027 \u2014 unclear if they actually tested on 3.118.0\u002B.",
        "fixedInVersion": "3.118.0",
        "verificationStatus": "unverified"
      },
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net9.0-android"
        ],
        "severity": "high",
        "severityReason": "Apps using affected SkiaSharp versions cannot target Android 16\u002B or pass Google Play validation. This is a blocking issue for any app shipping to Google Play with the deadline approaching, though upgrading to 3.118.0\u002B is the workaround."
      },
      "reproEvidence": {
        "attachments": [
          {
            "url": "https://github.com/user-attachments/files/23669684/16KB_PageSize_Report.txt",
            "filename": "16KB_PageSize_Report.txt",
            "type": "log-file",
            "source": "description"
          },
          {
            "url": "https://github.com/user-attachments/files/23547442/Android16_PageSize_Issue.pdf",
            "filename": "Android16_PageSize_Issue.pdf",
            "type": "other",
            "source": "description"
          }
        ],
        "relatedIssues": [
          3025
        ],
        "stepsToReproduce": [
          "Create a .NET MAUI Android app targeting Android 16.",
          "Build AAB using current SkiaSharp (v2.88.6) / MAUI workload.",
          "Run page size check on .so files.",
          "libSkiaSharp.so shows 4 KB page size."
        ],
        "environmentDetails": "SkiaSharp.NativeAssets.Android v2.88.6, .NET MAUI 9.0, Android 16\u002B target, Visual Studio (Windows). Also reports version 3.116.0 as \u0027Current\u0027."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "2.88.6",
          "2.88.9",
          "3.116.0"
        ],
        "era": "maui-transition",
        "currentRelevance": "unlikely",
        "reason": "The primary version reported (2.88.6) is in the unsupported 2.x series. The fix was shipped in 3.118.0 as part of milestone closure. Reporter also selected 3.116.0 as \u0027current version\u0027 but the fix is in 3.118.0\u002B. Users on 3.118.0\u002B should not experience this issue.",
        "migrationPath": "Upgrade to SkiaSharp 3.118.0 or later which includes 16KB page alignment for Android native libraries."
      },
      "actionability": {
        "suggestedAction": "close-as-fixed",
        "confidence": 0.78,
        "reason": "This is effectively a duplicate of #3025 which was fixed in 3.118.0. The maintainer already asked if the reporter tried the 3.x series. However, confidence is not higher because: (1) the reporter listed 3.116.0 as their \u0027current\u0027 version which predates the fix, and (2) it\u0027s unverified whether 3.118.0\u002B actually resolves this. The reporter hasn\u0027t confirmed testing with 3.118.0\u002B.",
        "requiresHumanReview": true,
        "closeable": true,
        "closeReason": "Fixed in SkiaSharp 3.118.0 via 16KB page alignment linker flags. See #3025.",
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.80,
        "reason": "The fix for 16KB page alignment was shipped in 3.118.0. The reporter needs to upgrade from both 2.88.6 and 3.116.0 to 3.118.0\u002B. A clear response pointing to the fix and the related issue would be helpful.",
        "draft": "Thanks for the detailed report and the attached page size analysis \u2014 that\u0027s useful context.\n\nThis was addressed in SkiaSharp 3.118.0, where the Android native libraries were rebuilt with 16KB page alignment (\u0060-Wl,-z,max-page-size=16384\u0060). The original tracking issue was #3025.\n\nBoth versions you mentioned (2.88.6 and 3.116.0) predate that fix. Upgrading to SkiaSharp 3.118.0 or later should resolve the alignment warnings and allow targeting Android 16\u002B.\n\nThe 2.88.x series is no longer actively maintained, so the fix won\u0027t be backported there. Would you be able to test with the latest 3.x release and confirm the alignment is correct?"
      },
      "analysisNotes": {
        "summary": "Reporter describes libSkiaSharp.so having 4KB page alignment, which blocks Android 16\u002B targeting. This is the same issue as #3025, which was fixed in SkiaSharp 3.118.0 by adding the -Wl,-z,max-page-size=16384 linker flag. The reporter is on versions (2.88.6 and 3.116.0) that predate the fix.",
        "keySignals": [
          {
            "text": "libSkiaSharp.so included in SkiaSharp.NativeAssets.Android v2.88.6 has a 4 KB page size",
            "source": "body",
            "interpretation": "Confirms the native binary lacks 16KB alignment. This is the core issue \u2014 a linker configuration problem in the native build.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity"
            ]
          },
          {
            "text": "Google Play now requires all 64-bit native libraries to use 16 KB memory page size starting with Android 16\u002B",
            "source": "body",
            "interpretation": "External compliance requirement making this a blocking issue for app distribution. Drives high severity classification.",
            "supportedFields": [
              "bugSignals.severity",
              "tenets"
            ]
          },
          {
            "text": "Version of SkiaSharp: 3.116.0 (Current), Last Known Good: 2.88.9 (Previous)",
            "source": "body",
            "interpretation": "Reporter selected both 2.88.6 in description and 3.116.0 in the version field. Both predate the 3.118.0 fix. The \u0027last known good\u0027 of 2.88.9 doesn\u0027t apply here \u2014 there was no version where 16KB was supported before the fix.",
            "supportedFields": [
              "versionAnalysis",
              "fixStatus"
            ]
          },
          {
            "text": "Have you tried the 3.x series of SkiaSharp? The 2.x series is not really supported",
            "source": "comment 3",
            "interpretation": "Maintainer mattleibow\u0027s comment suggests the fix exists in 3.x and 2.x won\u0027t be fixed. This supports close-as-fixed for 3.118.0\u002B.",
            "supportedFields": [
              "fixStatus",
              "actionability"
            ]
          },
          {
            "text": "Issue #3025 closed in milestone 3.118.0 \u2014 same 16KB alignment problem",
            "source": "labels",
            "interpretation": "The predecessor issue was tracked and resolved. Fix involved -Wl,-z,max-page-size=16384 linker flag per grendello\u0027s comment on #3025.",
            "supportedFields": [
              "fixStatus",
              "actionability"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The native library is built with incorrect ELF alignment, making it incompatible with Android 16\u002B requirements. This is a defect in the build output \u2014 the binary should have been built with 16KB alignment. The existing label type/bug also confirms this classification.",
            "alternatives": [
              {
                "value": "feature-request",
                "whyRejected": "While #3025 was originally labeled feature-request, this is actually a defect \u2014 the binary doesn\u0027t meet platform requirements. Google mandates 16KB alignment, making the current output non-compliant."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "The issue is entirely about the native binary\u0027s ELF page alignment. This is a native build configuration issue, not related to managed C# code or any specific view/API surface. Matches existing label area/libSkiaSharp.native."
          },
          {
            "field": "platforms",
            "chosen": "Android",
            "expandedReason": "16KB page size is an Android-specific requirement from Google. No other platform has this constraint. Matches existing label os/Android."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "This is a forward-compatibility issue with new Android platform requirements. The binary was previously fine but now doesn\u0027t meet the evolving platform standard. Matches existing label tenet/compatibility."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Apps cannot target Android 16\u002B or pass Google Play validation with the affected binaries. This is a blocking issue for distribution, though it doesn\u0027t cause crashes or data loss (critical). The workaround is to upgrade to 3.118.0\u002B.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "While blocking for Play Store submission, the fix exists (upgrade to 3.118.0\u002B). It doesn\u0027t cause crashes, data loss, or security issues in currently running apps."
              },
              {
                "value": "medium",
                "whyRejected": "The Google Play deadline makes this more urgent than medium \u2014 apps that can\u0027t be updated will be rejected."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "The fix shipped in 3.118.0 via #3025. The reporter needs to upgrade. However, requiring human review because the reporter hasn\u0027t confirmed testing with 3.118.0\u002B and may have version confusion (listed both 2.88.6 and 3.116.0).",
            "alternatives": [
              {
                "value": "close-as-duplicate",
                "whyRejected": "While functionally a duplicate of #3025, this issue specifically reports on versions 2.88.6 and 3.116.0 which weren\u0027t part of the original report. Close-as-fixed is more accurate since the fix exists."
              },
              {
                "value": "request-info",
                "whyRejected": "The maintainer already asked for clarification (comment 3). Could use this action, but close-as-fixed with a pointer to #3025 and the upgrade path is more helpful."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed NativeAssets.Android is auto-included and contains platform-specific native binaries. Relevant context for understanding the packaging.",
            "usedFor": [
              "area"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked Android section for related quirks. No existing pattern for 16KB alignment, but confirmed architecture matrix (x86, x64, arm, arm64) ships in Android package.",
            "usedFor": [
              "area",
              "platforms"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Field definitions and allowed values for all classification fields.",
            "usedFor": [
              "type",
              "area",
              "platforms",
              "tenets",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated output format and structure against provided examples.",
            "usedFor": [
              "type",
              "bugSignals",
              "analysisNotes"
            ]
          }
        ],
        "docsNotConsulted": "No rendering backend or API documentation needed \u2014 this is purely a native build configuration issue, not related to drawing APIs, GPU backends, or managed code patterns.",
        "uncertainties": [
          "Whether the reporter actually tested with 3.116.0 or only 2.88.6 \u2014 the version fields are contradictory (description says 2.88.6, form field says 3.116.0)",
          "Whether the reporter has tried 3.118.0\u002B which contains the fix \u2014 no response to mattleibow\u0027s comment yet",
          "Whether the fix in 3.118.0 fully resolves the issue or if there are edge cases with HarfBuzzSharp alignment as well (mentioned in #3025 comments)"
        ],
        "assumptions": [
          "Assumed the 3.118.0 fix (from #3025 milestone) addresses this issue since it was the same 16KB alignment problem with the same linker flag solution",
          "Assumed reporter\u0027s mention of 2.88.9 as \u0027last known good\u0027 is incorrect \u2014 no version had 16KB alignment before the fix, so this is likely form template confusion"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "libSkiaSharp.so was built without 16KB page alignment (-Wl,-z,max-page-size=16384 linker flag), which was fixed in 3.118.0. The reporter is using versions that predate the fix.",
        "researchDone": [
          "Searched GitHub issues for \u002716KB page size Android\u0027 \u2014 found #3025 as the predecessor issue",
          "Read all comments on #3025 including grendello\u0027s explanation of the -Wl,-z,max-page-size=16384 linker flag",
          "Confirmed #3025 was closed in milestone 3.118.0",
          "Checked #3420 comments \u2014 maintainer already asked reporter to try 3.x series",
          "Reviewed packages.md for NativeAssets.Android packaging details",
          "Reviewed skia-patterns.md for Android-specific quirks"
        ],
        "proposals": [
          {
            "title": "Upgrade to SkiaSharp 3.118.0\u002B",
            "description": "The 16KB page alignment fix was shipped in SkiaSharp 3.118.0. Upgrading resolves the issue without any code changes.",
            "steps": [
              "Update SkiaSharp NuGet package to 3.118.0 or later in the project file",
              "Update HarfBuzzSharp to the latest version as well (also needed 16KB alignment per #3025)",
              "Rebuild the AAB and verify with page size check tool that libSkiaSharp.so shows 16KB alignment",
              "Test on Android 16\u002B emulator or device"
            ],
            "pros": [
              "Directly addresses the root cause",
              "No code changes needed beyond version bump",
              "Includes all other fixes and improvements since 2.88.6/3.116.0"
            ],
            "cons": [
              "Requires migration from 2.88.x to 3.x if reporter is on 2.88.6 (breaking API changes)",
              "May introduce other behavioral changes from the version jump"
            ],
            "confidence": 0.90,
            "effort": "low"
          },
          {
            "title": "Close as duplicate of #3025",
            "description": "This issue describes the exact same problem as #3025. Close with a pointer to the fix and upgrade instructions.",
            "steps": [
              "Comment with link to #3025 and the 3.118.0 fix",
              "Ask reporter to confirm the fix works with 3.118.0\u002B",
              "Close as duplicate if confirmed"
            ],
            "pros": [
              "Reduces issue noise",
              "Clear pointer to the canonical issue"
            ],
            "cons": [
              "Reporter may feel dismissed if they have version-specific concerns",
              "Doesn\u0027t address the 2.88.x situation explicitly"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Backport 16KB alignment to 2.88.x",
            "description": "Apply the -Wl,-z,max-page-size=16384 linker flag to the 2.88.x build and release a patch.",
            "steps": [
              "Add -Wl,-z,max-page-size=16384 to the Android native build configuration in the 2.88.x branch",
              "Rebuild libSkiaSharp.so for all Android architectures",
              "Release as 2.88.10 or similar patch",
              "Verify 16KB alignment with readelf"
            ],
            "pros": [
              "Helps users who can\u0027t migrate to 3.x immediately",
              "Minimal risk \u2014 only changes linker alignment, no code changes"
            ],
            "cons": [
              "2.88.x is not actively maintained per maintainer comment",
              "Build environment for 2.88.x may be difficult to set up with current tooling",
              "Sets precedent for maintaining an unsupported branch"
            ],
            "confidence": 0.50,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Upgrade to SkiaSharp 3.118.0\u002B",
        "recommendedReason": "The fix already exists and is the official resolution. The 2.x series is unsupported, and the maintainer has already directed the reporter toward 3.x. This is the lowest effort path to compliance."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3420"
    },
    {
      "schemaVersion": "1.0",
      "number": 3402,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-24T12:00:00Z",
      "summary": "Request for compressed indexed color bitmap support (1bpp, 2bpp, 4bpp) for retro game graphics",
      "type": {
        "value": "feature-request",
        "confidence": 0.97,
        "reason": "Issue uses the [FEATURE] prefix and feature request template. Requests new capability (compressed indexed color formats) that does not exist in SkiaSharp or upstream Skia."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.90,
        "reason": "The request targets core bitmap/pixel format support in SkiaSharp, not views or platform-specific rendering. SKBitmap and SKColorType are in the core SkiaSharp package."
      },
      "backends": null,
      "platforms": null,
      "tenets": [
        {
          "value": "performance",
          "confidence": 0.85,
          "reason": "The request explicitly focuses on minimizing memory usage by operating on compressed pixel formats without expanding them, citing GiB-scale memory savings."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": null,
      "versionAnalysis": null,
      "actionability": {
        "suggestedAction": "keep-open",
        "confidence": 0.80,
        "reason": "This is a valid feature request but requires significant upstream Skia support that does not exist. Skia removed kIndex_8_SkColorType years ago and has no indexed color types. The request is well-structured and legitimate but unlikely to be implemented without upstream changes.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.80,
        "reason": "The request involves fundamental pixel format support that upstream Skia removed. A technical explanation of the constraints plus workaround suggestions would be helpful.",
        "draft": "Thanks for the detailed feature request and the memory calculations \u2014 that helps understand the scale of what you\u0027re working with.\n\nThis is unfortunately constrained by upstream Skia, which removed indexed color type support (\u0060kIndex_8_SkColorType\u0060) several years ago. SkiaSharp\u0027s \u0060SKColorType\u0060 enum maps directly to Skia\u0027s supported pixel formats, and there are no 1bpp, 2bpp, or 4bpp indexed color types available in the underlying engine. Adding these would require changes to Skia itself, which is outside SkiaSharp\u0027s scope.\n\nFor your NES/SNES tile-based graphics system, a practical approach would be to store your tile data in your own compact binary format (the 4bpp format you described), then expand tiles to \u0060SKColorType.Rgba8888\u0060 only when you need to render them to an \u0060SKBitmap\u0060 or \u0060SKCanvas\u0060. Since NES/SNES screens are typically 256\u00D7240 or 512\u00D7448, the expanded render target would only be ~440 KB to ~920 KB per frame, which is very manageable. The bulk storage stays in your compact format.\n\nAlternatively, \u0060SKColorType.Alpha8\u0060 (1 byte per pixel) could serve as a palette index buffer that you convert at render time."
      },
      "analysisNotes": {
        "summary": "Feature request for compressed indexed color bitmap support (1bpp, 2bpp, 4bpp) driven by a retro game graphics use case in Avalonia UI. Upstream Skia does not support indexed color types \u2014 they were removed years ago \u2014 so this cannot be implemented in SkiaSharp without fundamental upstream changes.",
        "keySignals": [
          {
            "text": "[FEATURE] Drawing to and from compressed indexed color bitmaps",
            "source": "title",
            "interpretation": "Explicitly tagged as a feature request, requesting new pixel format capabilities.",
            "supportedFields": [
              "type"
            ]
          },
          {
            "text": "Please support drawing to and from compressed 1bpp 2bpp and 4bpp indexed color graphics",
            "source": "body",
            "interpretation": "Requests specific sub-byte indexed color formats that do not exist in Skia or SkiaSharp.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "8 * 8 * 32 * 30 * 65536 pixels which in 4bpp color would be 1.87 GiB",
            "source": "body",
            "interpretation": "Memory optimization is a key driver \u2014 user wants to avoid 15 GiB at 32bpp. Performance/memory tenet applies.",
            "supportedFields": [
              "tenets"
            ]
          },
          {
            "text": "Pixel operations should work on multiple pixels at a time with these formats without expanding them in memory",
            "source": "body",
            "interpretation": "Requests native operations on packed pixel formats \u2014 this would require fundamental changes to Skia\u0027s rendering pipeline.",
            "supportedFields": [
              "type",
              "actionability"
            ]
          },
          {
            "text": "I am using avalonia ui which uses this and I wanted to make a nes/snes graphics system",
            "source": "body",
            "interpretation": "Use case is retro game tile graphics in Avalonia UI, not general-purpose bitmap manipulation.",
            "supportedFields": [
              "area"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "feature-request",
            "expandedReason": "The issue uses the [FEATURE] template, requests new capability that doesn\u0027t exist (indexed color formats), and describes no broken behavior. This is a request for entirely new functionality.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "Enhancement implies improving existing functionality. There is no existing indexed color support to enhance \u2014 Skia removed it entirely."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "The request targets core pixel format and bitmap operations (SKColorType, SKBitmap). These live in the core SkiaSharp package, not in any Views or platform-specific package."
          },
          {
            "field": "tenets",
            "chosen": "performance",
            "expandedReason": "The user explicitly calculates memory savings (1.87 GiB vs 15 GiB) and requests that operations work without expanding compressed formats. Memory efficiency is the primary motivation."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "The request is legitimate and well-structured, but implementation is blocked by upstream Skia lacking indexed color support. It should stay open as a tracked feature request but is unlikely to be actionable without Skia changes.",
            "alternatives": [
              {
                "value": "close-with-docs",
                "whyRejected": "While we can suggest workarounds, the feature request itself is valid and worth tracking."
              },
              {
                "value": "convert-to-discussion",
                "whyRejected": "The request is specific enough to be a feature request, not a general discussion topic."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "binding/SkiaSharp/Definitions.cs",
            "relevance": "Confirmed SKColorType enum has no indexed or sub-byte color types. Only direct color formats (Alpha8, Rgb565, Rgba8888, etc.) are supported.",
            "usedFor": [
              "type",
              "area",
              "actionability"
            ]
          },
          {
            "path": "binding/SkiaSharp/SKBitmap.cs",
            "relevance": "Found legacy Index8 reference in UnsupportedColorTypeMessage constant, confirming indexed color support was once considered but is no longer available.",
            "usedFor": [
              "type",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "No platform-specific docs, native loading docs, or rendering backend docs consulted \u2014 the request is about core pixel format support, not platform/backend specific.",
        "uncertainties": [
          "Whether the user would accept a workaround using custom binary storage with render-time expansion to standard SKColorType formats",
          "Whether upstream Skia has any plans to reintroduce indexed color support",
          "The exact Avalonia UI integration requirements that might constrain workaround approaches"
        ],
        "assumptions": [
          "Assumed the user is on a modern SkiaSharp 3.x version since no version was mentioned and the issue was filed in November 2025"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The user wants to build a NES/SNES tile-based graphics system storing large amounts of pixel data in compact indexed color formats (1-4bpp), operating on them without expansion, and rendering via SkiaSharp in Avalonia UI. Upstream Skia removed indexed color support years ago, so native support in SkiaSharp is not feasible.",
        "researchDone": [
          "Checked SKColorType enum in binding/SkiaSharp/Definitions.cs \u2014 no indexed color types available",
          "Found legacy Index8 reference in SKBitmap.cs indicating this was once partially supported but removed",
          "Verified upstream Skia removed kIndex_8_SkColorType \u2014 modern Skia has no indexed color formats",
          "Reviewed user\u0027s memory calculations and NES/SNES tile system requirements"
        ],
        "proposals": [
          {
            "title": "Custom compact storage with render-time expansion",
            "description": "Store tile data in a custom 4bpp binary format. When rendering, expand only the visible tiles into an SKBitmap with SKColorType.Rgba8888. NES/SNES screens are small (256x240), so the render target is under 1 MB.",
            "steps": [
              "Define a custom binary format for 4bpp indexed tile data with palette tables",
              "Implement a tile expander that converts 4bpp tiles to Rgba8888 pixels using a palette lookup",
              "Use SKBitmap.InstallPixels() or SKImage.FromPixels() to wrap the expanded pixel data for rendering",
              "Only expand tiles that are visible on screen, keeping the bulk data in compact format"
            ],
            "pros": [
              "Works today with current SkiaSharp \u2014 no upstream changes needed",
              "Bulk storage stays compact as requested",
              "NES/SNES screen resolution makes the expanded render buffer trivially small"
            ],
            "cons": [
              "Requires user to implement the tile expansion/palette lookup logic",
              "Cannot use SkiaSharp drawing operations directly on the compact format",
              "Extra CPU cost for palette expansion at render time"
            ],
            "confidence": 0.85,
            "effort": "medium"
          },
          {
            "title": "Use Alpha8 as palette index buffer",
            "description": "Use SKColorType.Alpha8 (1 byte per pixel) as a palette index buffer. Store palette-indexed pixel data where each byte is an index into a color table, then apply the palette via a custom SKColorFilter or shader at render time.",
            "steps": [
              "Create an SKBitmap with SKColorType.Alpha8",
              "Write palette indices (0-255) as the pixel values",
              "Create an SKShader or use SKColorFilter.CreateTable() to map alpha values to palette colors at render time",
              "Render the Alpha8 bitmap through the color mapping pipeline"
            ],
            "pros": [
              "Uses existing SkiaSharp APIs \u2014 no custom pixel format code needed",
              "Palette changes are instant (just swap the color filter)",
              "1 byte per pixel is reasonable for 8bpp indexed color"
            ],
            "cons": [
              "Only supports 8bpp (256 colors), not 1bpp, 2bpp, or 4bpp",
              "Somewhat hackish use of Alpha8 \u2014 not its intended purpose",
              "Still 8x more memory than true 1bpp format"
            ],
            "confidence": 0.65,
            "effort": "low"
          },
          {
            "title": "Implement indexed color as a standalone C# library",
            "description": "Create a separate .NET library that implements indexed color bitmap operations (1bpp, 2bpp, 4bpp) with palette support, and provides conversion to SkiaSharp types for rendering. This keeps the compressed format handling in managed code while using SkiaSharp only for final rendering.",
            "steps": [
              "Create a NuGet package with IndexedBitmap\u003CT\u003E supporting 1/2/4/8 bpp formats",
              "Implement bitwise pixel read/write operations for packed formats",
              "Add palette class with color lookup tables",
              "Provide ToSKBitmap() and ToSKImage() conversion methods",
              "Implement tile-based operations (blit, copy regions) on packed formats"
            ],
            "pros": [
              "Full control over the indexed color format implementation",
              "Can be optimized with SIMD for batch pixel operations",
              "Reusable library for any retro graphics project",
              "No dependency on upstream Skia changes"
            ],
            "cons": [
              "Significant development effort",
              "Not integrated into SkiaSharp\u0027s drawing pipeline",
              "User would need to maintain or find such a library"
            ],
            "confidence": 0.75,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Custom compact storage with render-time expansion",
        "recommendedReason": "Most practical approach that works today. NES/SNES tile systems inherently work with small visible windows into large tile maps, so only expanding visible tiles keeps memory low while leveraging SkiaSharp for all rendering."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3402"
    },
    {
      "schemaVersion": "1.0",
      "number": 3400,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-25T12:00:00Z",
      "summary": "SKDocument.CreateXps() renders \u003Cimage\u003E elements from SVG at incorrect (smaller) size, while CreatePdf() renders correctly",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Reporter describes broken rendering behavior: same SKPicture produces correct images in PDF but incorrectly scaled images (~30-40% of expected size) in XPS. Clear expected vs actual behavior described."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.90,
        "reason": "The issue is in SKDocument.CreateXps() which is in the core SkiaSharp API. However the root cause is likely in Skia upstream XPS device implementation, not in the C# binding layer."
      },
      "backends": [
        {
          "value": "XPS",
          "confidence": 0.95,
          "reason": "Bug occurs specifically in XPS output. The reporter explicitly states XPS renders images incorrectly while PDF renders them correctly."
        },
        {
          "value": "PDF",
          "confidence": 0.85,
          "reason": "PDF is the comparison format that renders correctly. Included because the issue is about XPS vs PDF rendering discrepancy."
        }
      ],
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.92,
          "reason": "Reporter specifies Windows 10/11, .NET 9.0, Visual Studio. XPS is a Windows-specific document format."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.90,
          "reason": "Incorrect rendering output constitutes unexpected behavior. Images render at wrong dimensions."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.70,
        "reason": "Reporter states Last Known Good Version 2.88.9 and current broken version is 3.116.0. However, the version gap is very large (2.88.9 to 3.x is a major version jump with Skia upstream updates), so the regression may be in upstream Skia rather than SkiaSharp itself.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net9.0"
        ],
        "severity": "medium",
        "severityReason": "Incorrect rendering output (images 30-40% of expected size in XPS) impacts label printing workflows that require XPS for Windows print pipeline. No crash, but produces unusable output. User can use PDF as alternative output format."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Load an SVG document containing \u003Cimage\u003E elements with Base64-encoded images",
          "Parse the SVG using SKSvg.Load() from the Svg.Skia library",
          "Generate XPS using SKDocument.CreateXps() with canvas.Scale(72/96) applied",
          "Generate PDF using SKDocument.CreatePdf() with the same SVG and same scaling",
          "Compare the image dimensions in XPS vs PDF output - XPS images are ~30-40% of correct size"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "using SkiaSharp;\nusing Svg.Skia;\nusing System.IO;\nusing System.Text;\n\nvar svgContent = File.ReadAllText(\u0022sample.svg\u0022);\nusing var ms = new MemoryStream(Encoding.UTF8.GetBytes(svgContent));\nvar skSvg = new SKSvg();\nvar picture = skSvg.Load(ms);\nvar bounds = picture.CullRect;\n\nconst float DPI = 72f;\nconst float SVG_DPI = 96f;\nconst float contentScale = DPI / SVG_DPI;\n\nvar pageWidth = bounds.Width * contentScale;\nvar pageHeight = bounds.Height * contentScale;\n\nusing (var xpsStream = File.OpenWrite(\u0022output.xps\u0022))\n{\n    using var document = SKDocument.CreateXps(xpsStream);\n    using var canvas = document.BeginPage(pageWidth, pageHeight);\n    canvas.Clear(SKColors.White);\n    canvas.Scale(contentScale);\n    canvas.DrawPicture(picture);\n    document.EndPage();\n    document.Close();\n}",
            "context": "Full reproduction code showing XPS generation with DPI-based scaling. Same code with CreatePdf works correctly."
          },
          {
            "language": "xml",
            "code": "\u003Csvg width=\u002270mm\u0022 height=\u002250mm\u0022 viewBox=\u00220 0 265 189\u0022 xmlns=\u0022http://www.w3.org/2000/svg\u0022\u003E\n  \u003Cimage href=\u0022data:image/jpeg;base64,...\u0022 x=\u002210.388\u0022 y=\u002222.387\u0022 width=\u002239.99997292\u0022 height=\u002220.00001292\u0022 preserveAspectRatio=\u0022xMidYMid meet\u0022/\u003E\n\u003C/svg\u003E",
            "context": "Sample SVG structure showing the \u003Cimage\u003E element that gets incorrectly scaled in XPS output."
          }
        ],
        "environmentDetails": "SkiaSharp 3.119.1 (also reported on 3.116.0), Svg.Skia 3.2.1, Windows 10/11, .NET 9.0, Visual Studio (Windows)"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.119.1",
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Reporter tested on both 3.116.0 and 3.119.1 (latest). The XPS backend is still present in current builds. The issue is likely in Skia upstream XPS device implementation.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.85,
        "reason": "Genuine rendering bug in the XPS backend. Investigation should focus on whether Skia XPS device applies additional DPI scaling to raster images causing double-scaling. Root cause is likely in upstream Skia SkXPSDevice, not in the SkiaSharp C# binding.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "XPS backend renders \u003Cimage\u003E elements from SVG at approximately 30-40% of their expected size, while PDF and raster output from the same SKPicture are correct. This is a rendering correctness bug likely rooted in how Skia XPS device handles DPI-dependent image scaling differently from the PDF device. The issue is a regression from 2.88.9 to 3.x, coinciding with significant Skia upstream updates.",
        "keySignals": [
          {
            "text": "Images are significantly smaller (approximately 30-40% of correct size)",
            "source": "body",
            "interpretation": "Quantifiable rendering error suggesting a DPI scaling factor is being applied incorrectly.",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "This issue only affects \u003Cimage\u003E elements within SVG. Other elements: Text, barcodes, shapes render correctly in both PDF and XPS",
            "source": "body",
            "interpretation": "Only raster images are affected, not vector elements. Points to DPI-based resolution handling specific to raster image embedding in XPS.",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          },
          {
            "text": "The same SKPicture object produces correct output with CreatePdf() and CreateImage()",
            "source": "body",
            "interpretation": "Bug is isolated to XPS backend. The SKPicture and SVG parsing are correct.",
            "supportedFields": [
              "backends",
              "area"
            ]
          },
          {
            "text": "Last Known Good Version: 2.88.9, Current: 3.116.0",
            "source": "body",
            "interpretation": "Regression across a major version boundary. SkiaSharp 3.x uses a significantly updated Skia upstream.",
            "supportedFields": [
              "regression"
            ]
          },
          {
            "text": "This severely impacts label printing applications that require XPS output for Windows print pipeline",
            "source": "body",
            "interpretation": "Business impact - XPS is used for Windows print spooling.",
            "supportedFields": [
              "bugSignals.severity"
            ]
          },
          {
            "text": "contentScale = DPI / SVG_DPI = 72/96 = 0.75",
            "source": "body",
            "interpretation": "User applies a 0.75 scaling factor. If XPS backend also internally applies DPI conversion for images, this could cause double-scaling.",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Reporter describes broken rendering: same input produces correct output in PDF but incorrect output in XPS. Clear expected vs actual behavior with quantifiable difference.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Reporter is not asking how to use XPS - they know how and it produces wrong output."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "SKDocument.CreateXps() is in the core SkiaSharp binding. While the root cause is likely in Skia upstream SkXPSDevice, the area classification maps to the C# API surface.",
            "alternatives": [
              {
                "value": "libSkiaSharp.native",
                "whyRejected": "Not a loading/P-Invoke issue. It is a rendering logic issue better tracked under SkiaSharp area."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "XPS, PDF",
            "expandedReason": "XPS is the broken backend. PDF is included because the issue is specifically about the discrepancy between XPS and PDF rendering."
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "XPS is a Windows-only format. Reporter confirms Windows 10/11 with Visual Studio."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "No crash or data loss, but produces unusable XPS output for label printing. User can use PDF as workaround for non-print scenarios. Medium because not a crash, partial workaround exists via PDF, but output is wrong.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "A workaround exists (PDF output). Not a crash or data loss."
              },
              {
                "value": "low",
                "whyRejected": "Producing images at wrong size makes XPS output unusable for printing - not cosmetic."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Real rendering bug that needs engineering investigation into Skia XPS device image DPI scaling behavior."
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for known XPS platform quirks or common traps. No XPS-specific patterns documented.",
            "usedFor": [
              "bugSignals"
            ]
          },
          {
            "path": "binding/SkiaSharp/SKDocument.cs",
            "relevance": "Confirmed CreateXps defaults to 72 DPI (DefaultRasterDpi), same as CreatePdf. C# wrapper correctly passes DPI through to native call.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Schema reference for field definitions and allowed values.",
            "usedFor": [
              "type",
              "area",
              "backends",
              "platforms",
              "tenets",
              "bugSignals",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult documentation/packages.md (no deployment/loading issue), .docs (no API misuse suspected), or mslearn (not a MAUI/Blazor/WPF issue).",
        "uncertainties": [
          "The ~30-40% size reduction does not cleanly map to a known DPI ratio - could be 72/96 * some other factor. Reproducing with a known SVG would clarify the exact scaling factor.",
          "Whether this is an upstream Skia XPS device bug vs a SkiaSharp DPI parameter issue - needs native code investigation.",
          "Whether the issue occurs without Svg.Skia (with a manually constructed SKPicture containing DrawImage calls) - would isolate whether Svg.Skia image handling contributes.",
          "Whether explicitly passing 96 DPI to CreateXps() (matching XPS native DPI) would resolve the issue as a workaround."
        ],
        "assumptions": [
          "Assumed the reporter observation of 30-40% size reduction is approximate - exact measurement would help identify the scaling factor.",
          "Assumed the bug is not in Svg.Skia SVG parsing since the reporter states PDF output from the same SKPicture is correct."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "Skia XPS device (SkXPSDevice) handles raster image DPI resolution differently from the PDF device. When embedded images from SVG \u003Cimage\u003E elements are recorded into an SKPicture and then played back through the XPS device, the device applies DPI-based scaling to raster content that effectively double-scales images. Vector elements (text, shapes) are resolution-independent and unaffected.",
        "researchDone": [
          "Examined SKDocument.CreateXps() C# wrapper - correctly passes DPI to native sk_document_create_xps_from_stream",
          "Confirmed DefaultRasterDpi is 72.0f for both XPS and PDF",
          "Searched for existing XPS issues - found #422 (file lock), #463 (null on .NET Core), #1291 (null on Linux), but none about scaling",
          "Analyzed the DPI math: XPS uses 96 DPI, user applies 72/96=0.75 scale, compound scaling possible"
        ],
        "proposals": [
          {
            "title": "Try CreateXps with 96 DPI parameter",
            "description": "Pass 96 DPI to CreateXps() instead of using the default 72 DPI. Since XPS natively uses 96 DPI, this may prevent the XPS device from applying additional DPI-based image scaling.",
            "steps": [
              "Change CreateXps() call to: SKDocument.CreateXps(xpsStream, 96f)",
              "Adjust the contentScale calculation if needed to account for the higher DPI",
              "Compare image dimensions in the output with the PDF result"
            ],
            "pros": [
              "Simple configuration change - no code modification needed",
              "Addresses the likely root cause (DPI mismatch between SkiaSharp default and XPS native DPI)"
            ],
            "cons": [
              "May affect page dimensions and require recalculating the scaling factor",
              "May not be the complete fix if the scaling issue is more complex"
            ],
            "confidence": 0.60,
            "effort": "low"
          },
          {
            "title": "Pre-rasterize images before XPS rendering",
            "description": "Instead of relying on the XPS device to handle raster images from SKPicture playback, flatten the SVG content to a raster image first, then draw that image onto the XPS canvas.",
            "steps": [
              "Create an SKSurface at the target resolution",
              "Draw the SKPicture onto the surface to produce an SKImage",
              "Begin XPS page and draw the pre-rasterized SKImage at exact page dimensions"
            ],
            "pros": [
              "Completely avoids the XPS image scaling bug",
              "Produces pixel-identical output to PDF at a given resolution"
            ],
            "cons": [
              "Loses vector quality for text and shapes in XPS output",
              "Output file size increases significantly",
              "Not suitable for high-resolution printing where vector quality matters"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Investigate and fix Skia XPS device image scaling",
            "description": "Debug the native Skia XPS device (SkXPSDevice) to find where raster images get additional DPI-based scaling during SKPicture playback. Fix the scaling logic to match the PDF device behavior.",
            "steps": [
              "Create a minimal reproduction without Svg.Skia (pure SkiaSharp DrawImage into SKPicture, then replay to XPS)",
              "Build libSkiaSharp with debug symbols on Windows",
              "Trace the image drawing path through SkXPSDevice::drawImage and related methods",
              "Compare with SkPDFDevice::drawImage to identify where the scaling diverges",
              "Apply fix in the Skia fork and rebuild"
            ],
            "pros": [
              "Fixes the root cause for all users",
              "Preserves vector quality in XPS output"
            ],
            "cons": [
              "High effort - requires native Skia debugging on Windows",
              "Risk of unintended side effects in XPS device",
              "Fix would be in the Skia fork, requiring ongoing maintenance"
            ],
            "confidence": 0.70,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Try CreateXps with 96 DPI parameter",
        "recommendedReason": "Lowest effort and can be tested immediately by the reporter. If it resolves the issue, it confirms the DPI mismatch hypothesis and informs whether the fix should be in SkiaSharp (change default DPI for XPS) or upstream Skia."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3400"
    },
    {
      "schemaVersion": "1.0",
      "number": 3398,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-25T12:00:00Z",
      "summary": "Intermittent crash in SKCanvas.DrawPath during Mapsui rendering in Avalonia desktop app on Windows 11",
      "type": {
        "value": "bug",
        "confidence": 0.75,
        "reason": "Reporter describes a hard crash with stack trace in sk_canvas_draw_path. However, the crash appears to originate from a threading violation in the third-party Mapsui library, not from a SkiaSharp defect."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.85,
        "reason": "The crash occurs in the core SkiaSharp API (SKCanvas.DrawPath / sk_canvas_draw_path), not in Views or other subpackages."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.90,
          "reason": "Reporter explicitly states Windows 11, running Avalonia desktop (which uses Win32 APIs). Already labeled os/Windows-Classic."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Hard process crash (unhandled exception terminating the process). Already labeled tenet/reliability."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": false,
        "confidence": 0.60,
        "reason": "Reporter selected \u00272.88.9\u0027 as last known good version and \u00273.116.0\u0027 as current, but then commented the actual DLL version is 2.88.8.0. The version information is contradictory and unreliable. The intermittent threading crash pattern could exist in any version.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": true,
        "reproQuality": "steps-only",
        "hasScreenshot": true,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net9.0"
        ],
        "severity": "medium",
        "severityReason": "Hard crash but intermittent, and strong evidence points to a threading violation in the third-party Mapsui library rather than a SkiaSharp defect. The crash is triggered by concurrent access to SkiaSharp objects from Mapsui\u0027s rendering and query threads."
      },
      "reproEvidence": {
        "screenshots": [
          {
            "url": "https://github.com/user-attachments/assets/cf361924-61d3-4773-9689-b4c36b927b71",
            "context": "Shown inline in description alongside text about crash when drawing graphics",
            "source": "description"
          },
          {
            "url": "https://github.com/user-attachments/assets/40e7de45-62b9-42bf-9c05-7073203d9258",
            "context": "Shown inline in description alongside text about crash when drawing graphics",
            "source": "description"
          }
        ],
        "stepsToReproduce": [
          "Create an Avalonia desktop application using Mapsui for map rendering (Avalonia 11.3.7, SkiaSharp 2.88.8.0)",
          "Subscribe to the PointerMoved event on the map control",
          "In the PointerMoved handler, call MapInfo\u0027s GetMapInfo() query method",
          "Interact with the map by moving the pointer \u2014 crash occurs intermittently but frequently"
        ],
        "codeSnippets": [
          {
            "language": "text",
            "code": "Application: AeroSpirit.Desktop.exe\nCoreCLR Version: 9.0.725.31616\n.NET Version: 9.0.7\nDescription: The process was terminated due to an unhandled exception.\nStack:\n   at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr)\n   at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr)\n   at SkiaSharp.SKCanvas.DrawPath(SkiaSharp.SKPath, SkiaSharp.SKPaint)\n   at Mapsui.Rendering.Skia.Extensions.SkCanvasExtensions.DrawPath(SKCanvas, CacheTracker\u003CSKPath\u003E, CacheTracker)\n   at Mapsui.Rendering.Skia.LineStringRenderer.Draw(SKCanvas, Viewport, VectorStyle, IFeature, LineString, Single, RenderService, Int32)\n   at Mapsui.Rendering.Skia.VectorStyleRenderer.",
            "context": "Stack trace from comment 3 showing crash in sk_canvas_draw_path called through Mapsui rendering pipeline"
          }
        ],
        "environmentDetails": "Windows 11, .NET 9.0.7, Avalonia 11.3.7, SkiaSharp DLL version 2.88.8.0 (form says 3.116.0 but comment corrects to 2.88.8), Visual Studio (Windows)"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9",
          "2.88.8"
        ],
        "era": "maui-transition",
        "currentRelevance": "unknown",
        "reason": "Reporter selected 3.116.0 in the form but corrected to 2.88.8.0 in a comment. The 2.88.x series is the maui-transition era. The crash pattern (threading violation from Mapsui) would likely occur in any SkiaSharp version.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "request-info",
        "confidence": 0.80,
        "reason": "The stack trace shows the crash originates from Mapsui\u0027s rendering pipeline calling SkiaSharp, with the intermittent nature strongly suggesting a threading violation. A community member also flagged this as likely a Mapsui issue. However, we should confirm with the reporter and suggest they file upstream with Mapsui before closing.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "missingInfo": [
          "sample-project",
          "stack-trace"
        ],
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "request-info",
        "confidence": 0.80,
        "reason": "Need to guide the reporter toward Mapsui as the likely source while being respectful. Also need to clarify the version confusion and request a minimal reproduction.",
        "draft": "Thanks for the stack trace in your follow-up comment \u2014 that\u0027s really helpful for narrowing this down.\n\nLooking at the stack, the crash is inside \u0060Mapsui.Rendering.Skia.LineStringRenderer.Draw\u0060 \u2192 \u0060SKCanvas.DrawPath\u0060. The intermittent nature (\u0022occasionally, it does not necessarily appear, but it appears frequently\u0022) combined with the fact that you\u0027re calling \u0060GetMapInfo()\u0060 inside \u0060PointerMoved\u0060 suggests this may be a concurrency issue \u2014 Mapsui\u0027s rendering and your query call may be accessing the same SkiaSharp objects (SKCanvas, SKPath, SKPaint) simultaneously. SkiaSharp objects are not thread-safe and concurrent access causes exactly this kind of intermittent crash.\n\nA couple of things that would help clarify:\n\n1. **Version**: You selected 3.116.0 in the form but mentioned 2.88.8.0 in a comment \u2014 could you confirm which version you\u0027re using? (\u0060dotnet list package\u0060 in your project would show the exact NuGet version.)\n\n2. **Mapsui issue**: This crash pattern is very likely a threading bug in Mapsui rather than in SkiaSharp itself. Would you be able to report this to the [Mapsui project](https://github.com/Mapsui/Mapsui/issues) as well? They would be best positioned to add the necessary synchronization.\n\nAs an immediate workaround, you could try debouncing or throttling your \u0060GetMapInfo()\u0060 calls in \u0060PointerMoved\u0060, or dispatching them off the rendering thread."
      },
      "analysisNotes": {
        "summary": "Intermittent crash in SKCanvas.DrawPath when Mapsui renders map features during concurrent GetMapInfo() queries triggered by PointerMoved. The crash pattern and stack trace strongly suggest a threading violation in Mapsui, not a SkiaSharp defect. SkiaSharp objects are not thread-safe and concurrent access causes exactly this type of intermittent native crash.",
        "keySignals": [
          {
            "text": "always collapse when drawing graphics, Occasionally, it does not necessarily appear, but it appears frequently",
            "source": "body",
            "interpretation": "Intermittent nature is a classic sign of a race condition / threading violation rather than a deterministic bug",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "The crash indeed occurred during the process of using MapInfo\u0027s query GetMapInfo(). It was retrieving MapInfo in the PointerMoved event.",
            "source": "body",
            "interpretation": "GetMapInfo() in PointerMoved likely triggers concurrent access to SkiaSharp objects while Mapsui is rendering, causing a threading violation",
            "supportedFields": [
              "type",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "text": "at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr) ... at Mapsui.Rendering.Skia.LineStringRenderer.Draw",
            "source": "comment 3",
            "interpretation": "Stack trace shows the crash path is entirely through Mapsui\u0027s rendering pipeline calling into SkiaSharp. No SkiaSharp-internal bug is evident.",
            "supportedFields": [
              "area",
              "actionability"
            ]
          },
          {
            "text": "Looks more like a Mapsui issue? There\u0027s doesn\u0027t look like there\u0027s anything here that suggests that SkiaSharp is at fault...",
            "source": "comment 4",
            "interpretation": "Community member independently identified this as likely a Mapsui issue, corroborating the threading violation hypothesis",
            "supportedFields": [
              "actionability"
            ]
          },
          {
            "text": "the SkiaSharp.dll version is 2.88.8.0",
            "source": "comment 2",
            "interpretation": "Contradicts the form selection of 3.116.0. Actual version is 2.88.8.0, making the regression claim unreliable.",
            "supportedFields": [
              "versionAnalysis",
              "regression"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The reporter describes a crash (process termination) with a stack trace. Even though the root cause is likely in Mapsui, the crash manifests in SkiaSharp\u0027s native code, so classifying as bug is appropriate for tracking. The confidence is lower (0.75) because this is likely an upstream issue, not a SkiaSharp defect.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "This is a real crash with a stack trace, not a how-to question. Even if the root cause is usage, the symptom is broken behavior."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "The crash occurs in the core SKCanvas.DrawPath API (sk_canvas_draw_path P/Invoke). This is the core SkiaSharp library, not Views, HarfBuzz, or native loading.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views",
                "whyRejected": "While Avalonia uses SkiaSharp for rendering, the crash is in the core SKCanvas API, not in any View control. Avalonia manages its own Skia surface."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash is typically high/critical, but this is downgraded to medium because: (1) it\u0027s intermittent, (2) it\u0027s almost certainly caused by threading misuse in Mapsui rather than a SkiaSharp defect, and (3) a workaround exists (avoiding concurrent GetMapInfo calls).",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Would be appropriate if this were a SkiaSharp defect, but the evidence strongly points to upstream misuse."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "Before closing, we should confirm the version confusion and gently redirect the reporter to Mapsui. Asking for a minimal reproduction without Mapsui would confirm whether SkiaSharp is at fault.",
            "alternatives": [
              {
                "value": "convert-to-discussion",
                "whyRejected": "There is a real crash occurring, which merits a proper issue response rather than just a discussion redirect."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "The stack trace is clear enough that investigation would just confirm the threading hypothesis. Better to request info and redirect upstream."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Confirmed the \u0027AccessViolationException / hard crash\u0027 pattern: threading violation (sharing SKCanvas/SKPaint between threads) is a documented common cause of intermittent native crashes.",
            "usedFor": [
              "type",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "path": "references/research-by-type.md",
            "relevance": "Followed bug research checklist: mapped stack trace to SkiaSharp source, checked for similar issues, identified API misuse vs actual defect.",
            "usedFor": [
              "area",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "No native loading diagnostics needed \u2014 this is a threading crash, not a loading issue. No packages.md consultation needed. No API XML docs needed since DrawPath is a well-known API.",
        "uncertainties": [
          "Cannot view the screenshots in the issue body \u2014 they may contain additional diagnostic information (error dialogs, stack traces)",
          "Exact SkiaSharp version is uncertain: form says 3.116.0, comment says 2.88.8.0",
          "Whether the crash can be reproduced without Mapsui (with just concurrent SKCanvas.DrawPath calls) is unknown",
          "Whether Mapsui has documented thread-safety requirements for GetMapInfo() is unknown"
        ],
        "assumptions": [
          "Assumed the crash is a threading violation based on the intermittent nature and the concurrent GetMapInfo/PointerMoved pattern. A disposed-object scenario is also possible but less likely given the intermittent behavior.",
          "Assumed SkiaSharp DLL version 2.88.8.0 (from comment) is more accurate than the 3.116.0 form selection, as the reporter likely checked the actual file.",
          "Assumed .NET 9.0 based on the stack trace showing \u0027CoreCLR Version: 9.0.725.31616\u0027"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "Mapsui is accessing SkiaSharp objects (SKCanvas, SKPath, SKPaint) concurrently from its rendering thread and the UI thread handling GetMapInfo() in PointerMoved. SkiaSharp objects are not thread-safe, and this concurrent access causes an intermittent native crash in sk_canvas_draw_path.",
        "researchDone": [
          "Analyzed stack trace: crash path is Mapsui.Rendering.Skia.LineStringRenderer \u2192 SKCanvas.DrawPath \u2192 sk_canvas_draw_path",
          "Checked skia-patterns.md for common crash patterns \u2014 matches threading violation pattern exactly",
          "Searched for similar Mapsui/Avalonia crash issues \u2014 no duplicates found in SkiaSharp",
          "Reviewed SkiaSharp threading rules: SKCanvas, SKPaint, SKPath must not be shared between threads"
        ],
        "proposals": [
          {
            "title": "Redirect to Mapsui project",
            "description": "Guide the reporter to file this issue with the Mapsui project, as the threading violation is in their rendering code.",
            "steps": [
              "Respond to the issue explaining the threading violation hypothesis",
              "Link to Mapsui\u0027s GitHub issues page",
              "Suggest the reporter include the stack trace and the PointerMoved/GetMapInfo concurrent access pattern in the upstream report",
              "Close the SkiaSharp issue as external/not-a-bug after the reporter confirms"
            ],
            "pros": [
              "Directs the fix to the right project",
              "Mapsui team understands their threading model best"
            ],
            "cons": [
              "Reporter may feel dismissed",
              "If Mapsui doesn\u0027t fix it, the user is stuck"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Suggest workaround: throttle GetMapInfo calls",
            "description": "Advise the reporter to debounce or throttle GetMapInfo() calls in PointerMoved to reduce concurrent access.",
            "steps": [
              "In the PointerMoved handler, add a debounce timer (e.g., 100ms) before calling GetMapInfo()",
              "Alternatively, use a lock or SemaphoreSlim to ensure GetMapInfo is not called while rendering is in progress",
              "Test to confirm crash frequency is reduced or eliminated"
            ],
            "pros": [
              "Immediate fix the user can apply",
              "No upstream changes needed"
            ],
            "cons": [
              "Treats the symptom not the root cause",
              "May reduce map interactivity/responsiveness"
            ],
            "confidence": 0.70,
            "effort": "low"
          },
          {
            "title": "Request minimal reproduction without Mapsui",
            "description": "Ask the reporter to reproduce the crash with plain SkiaSharp code (concurrent DrawPath calls without Mapsui) to confirm whether SkiaSharp itself has a bug.",
            "steps": [
              "Ask the reporter to create a minimal Avalonia app that calls DrawPath concurrently from two threads",
              "If it crashes, there may be a SkiaSharp issue (e.g., missing null checks before native calls)",
              "If it doesn\u0027t crash, confirm this is a Mapsui-specific concurrency bug"
            ],
            "pros": [
              "Definitively identifies whether SkiaSharp has a bug",
              "Provides a clear repro for any SkiaSharp-side fix"
            ],
            "cons": [
              "Asks the reporter to do significant work",
              "Unlikely to reveal a SkiaSharp bug based on current evidence"
            ],
            "confidence": 0.60,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Redirect to Mapsui project",
        "recommendedReason": "The stack trace clearly shows Mapsui\u0027s rendering pipeline as the call site, and the intermittent crash pattern matches a threading violation. The most effective resolution is for Mapsui to add proper synchronization around their SkiaSharp calls. A workaround suggestion should be included in the response to help the reporter immediately."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3398"
    },
    {
      "schemaVersion": "1.0",
      "number": 3396,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-10-27T12:00:00Z",
      "summary": "User cannot get SkiaSharp working on Unity WebGL \u2014 DllNotFoundException for libSkiaSharp in browser console",
      "type": {
        "value": "question",
        "confidence": 0.70,
        "reason": "Despite the [FEATURE] prefix, the issue body is primarily asking \u0027has anyone got this working?\u0027 and \u0027is there something to change here?\u0027 \u2014 these are support questions. The desired solution is a sample project, which is more about guidance than requesting new functionality."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.85,
        "reason": "The core problem is DllNotFoundException for libSkiaSharp on WebAssembly. This is a native loading/linking issue, not a managed API or views issue. The user is placing .a files manually and getting a native library resolution failure."
      },
      "backends": null,
      "platforms": [
        {
          "value": "WASM",
          "confidence": 0.95,
          "reason": "Issue is explicitly about Unity WebGL which compiles to WebAssembly via Emscripten. The browser console error confirms this is a WASM runtime issue."
        }
      ],
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.80,
          "reason": "The user wants cross-platform compatibility (Windows \u002B Android \u002B WebGL) and is hitting a platform gap where Unity WebGL is not officially supported by SkiaSharp."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": {
        "stepsToReproduce": [
          "Download managed SkiaSharp NuGet plus NativeAssets.Windows, NativeAssets.Android, and NativeAssets.WebAssembly packages",
          "Create a Unity project targeting WebGL",
          "Place libSkiaSharp.a static library files in Unity project",
          "Build and run for WebGL target",
          "Observe DllNotFoundException for libSkiaSharp in browser console"
        ],
        "environmentDetails": "Unity 2021.2 and 2022.3 tested. Windows and Android builds work. WebGL build fails at runtime with DllNotFoundException."
      },
      "versionAnalysis": null,
      "actionability": {
        "suggestedAction": "close-with-docs",
        "confidence": 0.75,
        "reason": "Unity WebGL is not officially supported by SkiaSharp. The technical reason is that SkiaSharp\u0027s WASM native assets use MSBuild NativeFileReference for static linking into dotnet.wasm, which is a .NET/Blazor/Uno-specific mechanism that Unity\u0027s build pipeline does not use. This can be answered with documentation.",
        "requiresHumanReview": true,
        "closeable": true,
        "closeReason": "Unity WebGL is not officially supported. SkiaSharp\u0027s WASM support relies on .NET\u0027s MSBuild static linking pipeline (NativeFileReference), which Unity does not use.",
        "duplicateOf": null,
        "missingInfo": [
          "version-number"
        ],
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.80,
        "reason": "Can provide a clear technical explanation of why Unity WebGL doesn\u0027t work and what the limitations are, plus point to related issue #921 for broader Unity discussion.",
        "draft": "Thanks for the detailed writeup of what you\u0027ve tried \u2014 that helps clarify the situation.\n\nSkiaSharp\u0027s WebAssembly support is designed specifically for the .NET WebAssembly runtime (used by Blazor and Uno Platform). It works through MSBuild\u0027s \u0060NativeFileReference\u0060 mechanism, which statically links the \u0060.a\u0060 files into the \u0060dotnet.wasm\u0060 binary at build time. Unity WebGL uses its own Emscripten build pipeline that doesn\u0027t go through MSBuild, so simply placing the \u0060.a\u0060 files in the project won\u0027t link them \u2014 they never get compiled into the final WebAssembly binary, which is why you see the \u0060DllNotFoundException\u0060.\n\nUnity WebGL isn\u0027t officially supported at this time. The fundamental challenge is that Unity\u0027s IL2CPP/Emscripten toolchain would need custom integration to statically link libSkiaSharp and resolve the P/Invoke calls. Issue #921 has some broader discussion about SkiaSharp and Unity.\n\nFor cross-platform vector graphics in Unity specifically (Standalone \u002B Android \u002B WebGL), you may want to look into Unity-native solutions like the Vector Graphics package or third-party Unity SVG renderers that are designed for Unity\u0027s build pipeline."
      },
      "analysisNotes": {
        "summary": "User is attempting to use SkiaSharp with Unity WebGL and getting DllNotFoundException. Unity WebGL is not officially supported \u2014 SkiaSharp\u0027s WASM support uses .NET-specific MSBuild static linking (NativeFileReference) that Unity\u0027s Emscripten pipeline does not support. This is a question about an unsupported platform configuration, not a bug.",
        "keySignals": [
          {
            "text": "DLLNotFound libSkiaSharp",
            "source": "body",
            "interpretation": "The native library is not being resolved at runtime. On WASM, this means the static library was never linked into the WebAssembly binary \u2014 Unity\u0027s build pipeline doesn\u0027t process .a files the same way MSBuild does.",
            "supportedFields": [
              "area",
              "platforms"
            ]
          },
          {
            "text": "I have tried placing all the different libSkiaSharp.a files in Unity",
            "source": "body",
            "interpretation": "User is manually placing static libraries, but Unity WebGL needs specific Emscripten linker integration, not just file placement. The .a files must be linked at compile time.",
            "supportedFields": [
              "type",
              "actionability"
            ]
          },
          {
            "text": "Has anyone got this working on Unity for WebGL?",
            "source": "body",
            "interpretation": "This is a support/how-to question, not a feature proposal. The user doesn\u0027t know if it\u0027s possible and is seeking guidance.",
            "supportedFields": [
              "type"
            ]
          },
          {
            "text": "I have downloaded the managed SkiaSharp nuget and the Native.Windows and Native.Android and Native.WebAssemebly nugets",
            "source": "body",
            "interpretation": "User is using the NuGet packages designed for .NET, not Unity-specific integration. These packages rely on MSBuild for deployment.",
            "supportedFields": [
              "area"
            ]
          },
          {
            "text": "[FEATURE] prefix and type/feature-request label",
            "source": "labels",
            "interpretation": "Filed as feature request, but the body reads as a question. The auto-triage bot also classified this as feature request. The ambiguity is real \u2014 there\u0027s a question (how to make it work) and an implicit feature request (please support Unity WebGL).",
            "supportedFields": [
              "type"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "question",
            "expandedReason": "The body is primarily asking \u0027has anyone got this working?\u0027 and \u0027is there something to change here?\u0027 \u2014 these are support questions. While there\u0027s an implicit feature request for Unity WebGL support, the user\u0027s immediate need is understanding why it doesn\u0027t work and whether it can be made to work.",
            "alternatives": [
              {
                "value": "feature-request",
                "whyRejected": "The [FEATURE] prefix and existing label suggest this, and there is an implicit request for official Unity WebGL support. However, the core of the body is asking for help, not proposing a new feature. The \u0027solution\u0027 requested is a sample project (guidance), not a code change."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "DllNotFoundException is a native library loading issue. The problem is specifically about how the native .a files are (not) linked into the WebAssembly binary. This is a native assets deployment/linking problem.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views.Uno",
                "whyRejected": "The existing label suggests this, but Uno is not involved \u2014 the user is using Unity, not Uno Platform. The label was likely applied because WASM was mentioned."
              },
              {
                "value": "SkiaSharp",
                "whyRejected": "Too broad \u2014 the issue is specifically about native library loading, not the managed API."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "WASM",
            "expandedReason": "Unity WebGL compiles to WebAssembly via Emscripten. The runtime error occurs in the browser, confirming this is a WASM platform issue."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "The user wants SkiaSharp to work across Windows, Android, and WebGL. The issue is about cross-platform compatibility \u2014 SkiaSharp works on the first two but not on Unity\u0027s WebGL target."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The answer is clear: Unity WebGL is not officially supported because SkiaSharp\u0027s WASM support relies on .NET MSBuild\u0027s NativeFileReference for static linking. This can be documented and explained. However, human review is recommended since closing a question from a frustrated user requires empathetic framing.",
            "alternatives": [
              {
                "value": "convert-to-discussion",
                "whyRejected": "Could be appropriate for a broader \u0027Unity support\u0027 discussion, but issue #921 already exists for that. Closing with a clear explanation and pointer to #921 is more helpful."
              },
              {
                "value": "keep-open",
                "whyRejected": "There\u0027s no actionable work for the SkiaSharp team here \u2014 Unity WebGL support would require Unity-specific build integration that\u0027s outside SkiaSharp\u0027s scope."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed that WASM uses static linking via NativeFileReference, and that Unity WebGL is mentioned as \u0027not officially supported\u0027 with a note about manual configuration requirements.",
            "usedFor": [
              "area",
              "actionability",
              "type"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Confirmed Unity WebGL is not officially supported and that Unity doesn\u0027t use MSBuild. The WASM section clarifies static linking vs P/Invoke distinction.",
            "usedFor": [
              "area",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "No API docs or rendering backend docs consulted \u2014 issue is about platform support/deployment, not about specific SkiaSharp API usage or rendering pipeline.",
        "uncertainties": [
          "Whether it\u0027s technically possible to manually configure Unity\u0027s Emscripten pipeline to link libSkiaSharp.a \u2014 the Unity docs link provided by the user suggests it might be possible with correct linker flags, but this hasn\u0027t been tested.",
          "Whether the user tried Unity 6000.x (referenced in the Unity docs link) or only older versions \u2014 the Emscripten integration may have improved.",
          "Whether issue #921 has any community-contributed solutions for Unity WebGL specifically."
        ],
        "assumptions": [
          "Assumed the user is placing the .a files without configuring Unity\u0027s Emscripten linker flags, since no linker configuration is mentioned."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The user is trying to use SkiaSharp\u0027s .NET-targeted WASM native assets in Unity WebGL, but Unity\u0027s build pipeline doesn\u0027t use MSBuild\u0027s NativeFileReference mechanism. The .a files are being placed in the project but never linked into the final WebAssembly binary by Unity\u0027s Emscripten toolchain.",
        "researchDone": [
          "Checked documentation/packages.md for WASM deployment details \u2014 confirmed static linking via NativeFileReference",
          "Checked references/skia-patterns.md for Unity WebGL notes \u2014 confirmed not officially supported",
          "Searched for similar Unity issues \u2014 found #921 (SkiaSharp with Unity, open since 2019) and #3016 (Unity Editor DLL issues)",
          "Reviewed Unity docs link provided by user about Emscripten native plugins"
        ],
        "proposals": [
          {
            "title": "Manual Emscripten linker integration in Unity",
            "description": "Attempt to configure Unity\u0027s Emscripten build pipeline to statically link libSkiaSharp.a using Unity\u0027s native plugin system for WebGL.",
            "steps": [
              "Place libSkiaSharp.a from the WebAssembly NativeAssets package in Assets/Plugins/WebGL/",
              "Configure the .a file\u0027s import settings in Unity to target WebGL platform",
              "Add an .jslib or linker flag file to pass the correct Emscripten flags (-s EXPORTED_FUNCTIONS, etc.)",
              "Ensure all Skia C API symbols are exported in the Emscripten configuration",
              "Test if Unity\u0027s IL2CPP runtime can resolve DllImport(\u0027libSkiaSharp\u0027) to the statically linked symbols"
            ],
            "pros": [
              "Would enable SkiaSharp on Unity WebGL without changes to SkiaSharp itself"
            ],
            "cons": [
              "Completely untested and unsupported path",
              "IL2CPP\u0027s P/Invoke resolution may not support static linking the same way .NET WASM does",
              "Likely requires significant Emscripten/Unity expertise",
              "May break with Unity version updates"
            ],
            "confidence": 0.25,
            "effort": "high"
          },
          {
            "title": "Use Blazor/Uno for web target instead of Unity WebGL",
            "description": "If the goal is cross-platform vector art including web browsers, consider using .NET MAUI with Blazor Hybrid or Uno Platform for the web target, where SkiaSharp WASM is fully supported.",
            "steps": [
              "Keep Unity for Standalone and Android targets",
              "Create a separate Blazor or Uno Platform project for the web target",
              "Use SkiaSharp.Views.Blazor or SkiaSharp.Views.Uno.WinUI which auto-include the WASM native assets",
              "Share drawing logic in a common library between Unity and .NET projects"
            ],
            "pros": [
              "Fully supported and tested WASM path",
              "SkiaSharp.Views.Blazor handles all static linking automatically",
              "Active community and documentation"
            ],
            "cons": [
              "Requires maintaining two separate project types",
              "Not a single Unity project for all platforms",
              "Different rendering surface setup for web vs native"
            ],
            "confidence": 0.85,
            "effort": "medium"
          },
          {
            "title": "Use Unity-native vector graphics solutions",
            "description": "For cross-platform vector art within Unity (including WebGL), use Unity\u0027s own Vector Graphics package or third-party Unity SVG renderers that are designed for Unity\u0027s build pipeline.",
            "steps": [
              "Evaluate Unity\u0027s Vector Graphics package (com.unity.vectorgraphics) for SVG support",
              "Consider third-party assets like \u0027SVG Importer\u0027 from the Unity Asset Store",
              "Implement vector rendering using Unity\u0027s own 2D rendering pipeline",
              "Test across Standalone, Android, and WebGL targets"
            ],
            "pros": [
              "Works natively across all Unity platforms including WebGL",
              "No native plugin integration required",
              "Supported by Unity\u0027s build pipeline"
            ],
            "cons": [
              "Different API from SkiaSharp \u2014 migration effort required",
              "May not have all of Skia\u0027s advanced drawing features",
              "Third-party assets may have licensing costs"
            ],
            "confidence": 0.80,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Use Blazor/Uno for web target instead of Unity WebGL",
        "recommendedReason": "This is the only fully supported path for SkiaSharp on the web. While it requires a separate project for the web target, the drawing logic can be shared. If a single-codebase Unity solution is required, the Unity-native vector graphics approach is more practical than attempting unsupported Emscripten integration."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3396"
    },
    {
      "schemaVersion": "1.0",
      "number": 3393,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-10-23T00:00:00Z",
      "summary": "All P/Invoke wrappers missing GC.KeepAlive calls, allowing premature GC of managed objects during native execution",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "The issue describes a real race condition between GC and native code execution. Objects passed to P/Invoke calls can be collected mid-call because the runtime cannot see into native code. This is a well-documented .NET correctness bug (Chris Brumme blog), not a feature request."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.95,
        "reason": "The bug is in the core C# binding layer (binding/SkiaSharp/*.cs) where P/Invoke calls are made. All public wrapper methods across the entire SkiaSharp binding surface are affected."
      },
      "backends": null,
      "platforms": null,
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Premature GC during P/Invoke is a race condition that leads to use-after-free crashes, AccessViolationExceptions, and data corruption \u2014 all reliability concerns. The issue is explicitly about preventing crashes from GC/finalizer races."
        }
      ],
      "partner": {
        "value": "unoplatform",
        "confidence": 0.80,
        "reason": "The issue directly references unoplatform/uno#21660 as a real-world Skia-related example of this bug manifesting in the Uno Platform."
      },
      "regression": {
        "isRegression": false,
        "confidence": 0.90,
        "reason": "This is a latent correctness bug that has existed since SkiaSharp\u0027s inception. It is not a regression from a specific version \u2014 it is a systemic omission. The \u0027Last Known Good Version\u0027 field says \u0027Other\u0027, confirming no prior version was correct."
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Callers can add GC.KeepAlive(obj) after every SkiaSharp API call that passes managed objects, but this is impractical at scale and the responsibility should be on the library, not the consumer.",
        "targetFrameworks": [
          "net8.0-android"
        ],
        "severity": "high",
        "severityReason": "This is a systemic correctness issue affecting every public P/Invoke wrapper method across the entire SkiaSharp API surface. While crashes are intermittent (race condition), they are unrecoverable when they occur. The scope is massive \u2014 only ~14 GC.KeepAlive calls exist vs ~700\u002B SkiaApi P/Invoke call sites across 50\u002B files."
      },
      "reproEvidence": {
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "var canvas = \u2026\nvar picture = \u2026\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point.",
            "context": "Demonstrates the pattern where picture can be GC\u0027d during the DrawPicture P/Invoke call because nothing references it after the Handle is extracted."
          },
          {
            "language": "csharp",
            "code": "partial class SKCanvas {\n\tpublic void DrawPicture (SKPicture picture, SKPaint paint = null)\n\t{\n\t\tif (picture == null)\n\t\t\tthrow new ArgumentNullException (nameof (picture));\n\t\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n\t\tGC.KeepAlive (picture);\n\t\tGC.KeepAlive (paint);\n\t}\n}",
            "context": "Proposed fix pattern showing GC.KeepAlive calls after each P/Invoke invocation."
          }
        ],
        "repoLinks": [
          {
            "url": "https://github.com/mono/SkiaSharp/blob/34c5ed8272b9e0a138089d2e0a18f34f5592653f/binding/SkiaSharp/SKCanvas.cs#L533-L538",
            "description": "The specific unprotected SKCanvas.DrawPicture P/Invoke call site."
          },
          {
            "url": "https://github.com/unoplatform/uno/pull/21660",
            "description": "Uno Platform PR that encountered this issue in practice with Skia-based rendering."
          },
          {
            "url": "https://github.com/dotnet/java-interop/issues/719",
            "description": "Same class of bug in dotnet/java-interop, demonstrating this is a well-known pattern."
          }
        ],
        "stepsToReproduce": [
          "Create an SKCanvas and an SKPicture (or any SKObject-derived parameter)",
          "Call canvas.DrawPicture(picture) where picture is not referenced after the call",
          "Under GC pressure, the runtime may collect picture while native Skia code is still using the handle",
          "This causes use-after-free, AccessViolationException, or silent data corruption"
        ],
        "environmentDetails": "SkiaSharp 3.116.0, affects all platforms (reported as Android \u002B All). The issue is in managed code and is platform-independent."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "This is a systemic omission in the C# binding layer that has never been addressed. Current codebase shows only ~14 GC.KeepAlive calls across 6 files, while there are ~700\u002B SkiaApi P/Invoke call sites across 50\u002B files. The issue is relevant to all SkiaSharp versions.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.90,
        "reason": "This is a legitimate, well-documented .NET correctness issue. The reporter (jonpryor) is a highly experienced .NET/Xamarin developer who authored java-interop. The fix approach is clear (add GC.KeepAlive after P/Invoke calls) but the scope is enormous (~700\u002B call sites). Engineering needs to decide whether to do a manual audit, modify the code generator, or use a Roslyn analyzer.",
        "requiresHumanReview": false,
        "closeable": false
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "Issue #3393 reports a systemic correctness bug: SkiaSharp\u0027s P/Invoke wrapper methods do not call GC.KeepAlive on managed object parameters, allowing the GC to collect them while native Skia code is still operating on their handles. This is a well-documented .NET pattern (Chris Brumme\u0027s blog) and has manifested in practice (Uno Platform PR #21660). The fix is clear but the scope is massive.",
        "keySignals": [
          {
            "text": "once execution hits SkiaApi.sk_canvas_draw_picture(), nothing ensures that picture is kept alive. (Or canvas, for that matter!)",
            "source": "body",
            "interpretation": "Confirms the specific race condition: after Handle extraction, the GC can collect the managed object while native code is executing. This is the core bug.",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "This should be done for all public methods that invoke P/Invoke methods",
            "source": "body",
            "interpretation": "The reporter explicitly states this is a systemic issue affecting all P/Invoke wrappers, not just DrawPicture. This dramatically increases the scope and severity.",
            "supportedFields": [
              "bugSignals.severity",
              "actionability"
            ]
          },
          {
            "text": "unoplatform/uno#21660 is a Skia-related example of this",
            "source": "body",
            "interpretation": "Real-world manifestation in the Uno Platform confirms this is not theoretical \u2014 the bug causes actual crashes in production.",
            "supportedFields": [
              "type",
              "partner",
              "bugSignals"
            ]
          },
          {
            "text": "Context: Chris Brumme\u0027s blog post on Lifetime, GC.KeepAlive, handle recycling",
            "source": "body",
            "interpretation": "Well-established .NET correctness pattern documented by a CLR team member. This is not a new or controversial finding.",
            "supportedFields": [
              "type"
            ]
          },
          {
            "text": "Platform / Operating System: Android, All",
            "source": "body",
            "interpretation": "While reported from Android context (via Uno), the issue affects all platforms since it\u0027s in the managed C# layer.",
            "supportedFields": [
              "platforms"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "This is a correctness bug \u2014 a race condition between the GC and native code execution. The issue is not asking for a new feature; it\u0027s reporting that existing code is missing required safety guarantees (GC.KeepAlive) that prevent use-after-free during P/Invoke calls.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "While adding GC.KeepAlive could be seen as an enhancement, the absence of it is a correctness defect. The current behavior can cause crashes, making this a bug."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "The affected code is in binding/SkiaSharp/*.cs \u2014 the core C# wrapper layer. All P/Invoke call sites across all wrapper classes are affected. This is not specific to Views, HarfBuzz, or any sub-package."
          },
          {
            "field": "tenets",
            "chosen": "reliability",
            "expandedReason": "The bug causes race conditions leading to use-after-free, AccessViolationException, and potential data corruption. These are classic reliability issues \u2014 crashes under GC pressure."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "The scope is enormous (~700\u002B unprotected P/Invoke call sites across 50\u002B files), and when the race is lost, the result is an unrecoverable crash or memory corruption. However, it requires GC pressure timing to trigger, so it\u0027s high rather than critical.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "While the consequences are severe, the bug requires specific GC timing to trigger. It\u0027s not a guaranteed crash on every call."
              },
              {
                "value": "medium",
                "whyRejected": "The systemic scope (all P/Invoke methods) and unrecoverable nature of the crashes warrant high severity."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The fix approach is conceptually clear (add GC.KeepAlive after P/Invoke calls) but requires architectural decision: manual audit of 700\u002B call sites, code generator modification, or Roslyn analyzer. Engineering needs to evaluate the best approach."
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for related patterns around AccessViolationException and premature disposal. The \u0027Premature Disposal\u0027 section describes a related but distinct pattern (same-instance returns).",
            "usedFor": [
              "type",
              "bugSignals"
            ]
          },
          {
            "path": "binding/SkiaSharp/SKCanvas.cs",
            "relevance": "Verified the specific code referenced in the issue (lines 533-538). Confirmed no GC.KeepAlive calls exist in DrawPicture or other Canvas methods.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          }
        ],
        "docsNotConsulted": "No native loading diagnostics (packages.md) needed \u2014 this is a managed code correctness issue, not a deployment/loading problem. No backend-specific docs needed \u2014 the bug is in the C# layer before any backend is involved.",
        "uncertainties": [
          "Whether the code generator (pwsh ./utils/generate.ps1) can be modified to automatically emit GC.KeepAlive calls, or if manual editing is required",
          "Whether GC.KeepAlive(this) should be added to instance methods, or if that responsibility stays with the caller",
          "The exact count of affected methods \u2014 grep shows ~700\u002B SkiaApi call sites but some may be in static methods or handle struct parameters that don\u0027t need protection",
          "Whether any existing GC.KeepAlive calls (14 found) were added intentionally or coincidentally"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "SkiaSharp\u0027s P/Invoke wrapper methods extract IntPtr handles from managed SKObject instances and pass them to native code, but do not prevent the GC from collecting those managed objects during the native call. This creates a race condition: the GC can finalize and dispose the managed object (closing the native handle) while Skia is still using it, causing use-after-free crashes.",
        "researchDone": [
          "Verified the specific code at SKCanvas.cs:533-538 \u2014 confirmed no GC.KeepAlive present",
          "Counted GC.KeepAlive usage across binding/SkiaSharp/ \u2014 only ~14 calls in 6 files",
          "Counted SkiaApi P/Invoke call sites \u2014 ~700\u002B across 50\u002B files",
          "Checked for duplicate issues \u2014 no prior issues found for GC.KeepAlive/P/Invoke lifetime",
          "Reviewed references/skia-patterns.md for related known patterns"
        ],
        "proposals": [
          {
            "title": "Systematic manual audit with GC.KeepAlive insertion",
            "description": "Audit every public method in binding/SkiaSharp/ that calls SkiaApi.* and add GC.KeepAlive for all reference-type parameters (SKObject-derived) after the P/Invoke call. Include GC.KeepAlive(this) for instance methods.",
            "steps": [
              "Identify all public methods in binding/SkiaSharp/*.cs that call SkiaApi.* methods",
              "For each method, identify reference-type parameters (SKObject-derived types)",
              "Add GC.KeepAlive(param) for each reference-type parameter after the P/Invoke call",
              "Add GC.KeepAlive(this) for instance methods that access Handle",
              "Run full test suite to ensure no regressions"
            ],
            "pros": [
              "Most thorough \u2014 covers every call site with human review",
              "Can handle edge cases (nullable params, conditional logic) correctly",
              "Allows adding GC.KeepAlive(this) selectively based on context"
            ],
            "cons": [
              "Extremely labor-intensive (~700\u002B call sites in 50\u002B files)",
              "Error-prone \u2014 easy to miss call sites or parameters",
              "New methods added later could lack GC.KeepAlive without enforcement"
            ],
            "confidence": 0.85,
            "effort": "high"
          },
          {
            "title": "Roslyn analyzer to enforce GC.KeepAlive after P/Invoke",
            "description": "Create a custom Roslyn analyzer that detects SkiaApi.* P/Invoke calls and verifies that all reference-type parameters have corresponding GC.KeepAlive calls. Combine with a bulk code fix to address existing violations.",
            "steps": [
              "Create a Roslyn DiagnosticAnalyzer that identifies SkiaApi.* call sites",
              "Analyze parameter sources to detect SKObject-derived types",
              "Report diagnostic if GC.KeepAlive is missing for any reference-type parameter",
              "Implement a CodeFixProvider to automatically insert GC.KeepAlive calls",
              "Run the code fix across the entire binding/SkiaSharp/ directory",
              "Add the analyzer to the build to prevent future regressions"
            ],
            "pros": [
              "Automated \u2014 catches all existing and future violations",
              "Enforced at build time \u2014 new code cannot miss GC.KeepAlive",
              "Code fix handles bulk application"
            ],
            "cons": [
              "Significant upfront development effort for the analyzer",
              "May produce false positives for struct parameters or static methods",
              "Analyzer maintenance burden"
            ],
            "confidence": 0.80,
            "effort": "high"
          },
          {
            "title": "Modify code generator to emit GC.KeepAlive",
            "description": "If the P/Invoke declarations or wrapper methods are generated (via pwsh ./utils/generate.ps1), modify the generator to automatically emit GC.KeepAlive calls for all reference-type parameters after P/Invoke invocations.",
            "steps": [
              "Investigate whether generate.ps1 generates the wrapper methods or just the P/Invoke declarations",
              "If wrappers are generated, modify the template to include GC.KeepAlive for reference-type params",
              "If wrappers are hand-written, this approach may not apply \u2014 fall back to manual audit",
              "Regenerate and verify output",
              "Run full test suite"
            ],
            "pros": [
              "Systematic \u2014 all generated code gets GC.KeepAlive automatically",
              "Future-proof \u2014 new generated methods will include it",
              "Lower ongoing maintenance than manual approach"
            ],
            "cons": [
              "May not cover hand-written wrapper methods (only generated ones)",
              "Requires understanding the generator\u0027s template system",
              "Generator may not have enough type information to distinguish reference vs value types"
            ],
            "confidence": 0.65,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Roslyn analyzer to enforce GC.KeepAlive after P/Invoke",
        "recommendedReason": "While the manual audit is most thorough for initial fix, the Roslyn analyzer provides both the initial bulk fix (via CodeFixProvider) and ongoing enforcement at build time. This prevents the problem from recurring as new methods are added. The analyzer \u002B code fix approach addresses both the immediate issue and the systemic risk."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3393"
    },
    {
      "schemaVersion": "1.0",
      "number": 3386,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-25T12:00:00Z",
      "summary": "DllNotFoundException in Azure Container Apps with .NET Aspire \u2014 NoDependencies binary not deployed, fontconfig variant loaded instead",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "DllNotFoundException crash with stack trace in production container deployment. Reporter describes broken behavior \u2014 images fail to generate with TypeInitializationException."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.97,
        "reason": "DllNotFoundException loading libSkiaSharp native library. The issue is entirely about native binary deployment/resolution, not managed API behavior."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Linux",
          "confidence": 0.98,
          "reason": "Explicitly stated: Azure Container App running Linux. Error shows Linux-specific paths (/usr/share/dotnet/, /app/) and .so loading."
        }
      ],
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.85,
          "reason": "Reporter states last known good version was 2.88.9, suggesting the deployment model that worked in 2.x broke when upgrading to 3.116.0 with Aspire containerization."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.70,
        "reason": "Reporter claims 2.88.9 worked but 3.116.0 does not. However, the deployment method (.NET Aspire) may not have existed with 2.88.9, so the regression may be in the deployment tooling rather than SkiaSharp itself. The native packaging model changed significantly between 2.x and 3.x.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": true,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Switch from NoDependencies to NativeAssets.Linux, use a custom Docker image (ghcr.io/avantipoint/aspnet-skia) with fontconfig and other native deps pre-installed, set ContainerBaseImage in csproj. Also add System.Memory.Data as direct PackageReference to prevent trimming.",
        "targetFrameworks": [
          "net9.0"
        ],
        "severity": "high",
        "severityReason": "Application crashes on startup in production container environment. Workaround requires building and hosting a custom container base image, which is a significant operational burden."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a WebAPI project using .NET Aspire targeting net9.0",
          "Add PackageReference for SkiaSharp and SkiaSharp.NativeAssets.Linux.NoDependencies",
          "Use SKBitmap.Decode() or any SkiaSharp API that triggers native library loading",
          "Deploy to Azure Container Apps via .NET Aspire container deployment",
          "Observe DllNotFoundException with fontconfig dependency error on first SkiaSharp API call"
        ],
        "codeSnippets": [
          {
            "language": "xml",
            "code": "\u003CPackageReference Include=\u0022SkiaSharp\u0022 /\u003E\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022 /\u003E",
            "context": "Package references in the project file \u2014 user has NoDependencies referenced but gets fontconfig errors, indicating wrong binary deployed"
          },
          {
            "language": "xml",
            "code": "\u003CPropertyGroup\u003E\n  \u003COutputType\u003EExe\u003C/OutputType\u003E\n  \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\n  \u003CContainerBaseImage\u003Eghcr.io/avantipoint/aspnet-skia:9.0\u003C/ContainerBaseImage\u003E\n\u003C/PropertyGroup\u003E",
            "context": "Workaround: custom container base image with native dependencies pre-installed"
          }
        ],
        "repoLinks": [
          {
            "url": "https://github.com/AvantiPoint/aspnet-skia",
            "description": "Custom Docker image repo created by reporter as a workaround \u2014 based on mcr.microsoft.com/dotnet/aspnet with SkiaSharp native dependencies installed"
          }
        ],
        "environmentDetails": "SkiaSharp 3.116.0, .NET 9.0.10, Azure Container Apps deployed via .NET Aspire, Linux container (Ubuntu Noble base), Visual Studio (Windows) for development"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Issue is with SkiaSharp 3.116.0 and .NET Aspire container deployment. The native package deployment mechanism is unchanged in current versions, so the same issue would occur with any 3.x version deployed via Aspire.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "keep-open",
        "confidence": 0.80,
        "reason": "This is a real deployment issue where .NET Aspire\u0027s container deployment doesn\u0027t correctly deploy the NoDependencies native binary. The reporter found a workaround but the root cause (wrong binary being deployed in Aspire containers) likely affects other users. The issue may need investigation into whether Aspire\u0027s container publishing resolves NativeAssets correctly, or if documentation/guidance should be improved.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.82,
        "reason": "Reporter already found a workaround. A response can validate the diagnosis (wrong binary deployed), confirm the NoDependencies package should never need fontconfig, and suggest an alternative simpler workaround.",
        "draft": "Thanks for the detailed error output and for sharing your workaround \u2014 that\u0027s genuinely useful for others hitting this.\n\nThe fontconfig error with \u0060NoDependencies\u0060 confirms this: the \u0060NoDependencies\u0060 binary has zero external dependencies (only libc/libm/libpthread/libdl), so the fact that fontconfig is even mentioned means the deployed binary is *not* from the \u0060NoDependencies\u0060 package. It appears .NET Aspire\u0027s container publishing is deploying the wrong \u0060libSkiaSharp.so\u0060 variant.\n\nYour approach of switching to \u0060NativeAssets.Linux\u0060 with a custom base image is solid. A potentially simpler alternative would be to keep \u0060NoDependencies\u0060 but verify what\u0027s actually deployed by running \u0060ldd\u0060 on the \u0060libSkiaSharp.so\u0060 in your container\u0027s publish output \u2014 that would confirm which variant ended up deployed and whether there\u0027s a transitive \u0060NativeAssets.Linux\u0060 reference overriding your \u0060NoDependencies\u0060 reference.\n\nWould you be able to check if there\u0027s a transitive \u0060SkiaSharp.NativeAssets.Linux\u0060 coming in from another dependency? \u0060dotnet nuget why SkiaSharp.NativeAssets.Linux\u0060 in your project directory would reveal that."
      },
      "analysisNotes": {
        "summary": "Classic \u0027wrong binary deployed\u0027 pattern: user references NoDependencies but gets fontconfig dependency errors, proving the NoDependencies binary was not the one loaded. .NET Aspire\u0027s container deployment mechanism is likely deploying the fontconfig-dependent NativeAssets.Linux variant instead. Reporter found a workaround using a custom Docker image with native deps installed.",
        "keySignals": [
          {
            "text": "libfontconfig.so.1: cannot open shared object file: No such file or directory",
            "source": "stack-trace",
            "interpretation": "First error line in DllNotFoundException. NoDependencies has zero external deps, so fontconfig error proves the loaded binary is NOT from the NoDependencies package \u2014 a different libSkiaSharp.so variant was deployed.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity"
            ]
          },
          {
            "text": "\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022 /\u003E",
            "source": "body",
            "interpretation": "User explicitly references NoDependencies, yet gets dependency errors. This is the \u0027wrong binary\u0027 pattern documented in skia-patterns.md.",
            "supportedFields": [
              "area",
              "bugSignals"
            ]
          },
          {
            "text": "We are deploying a set of WebAPIs using .NET Aspire. This creates a Linux based Container App.",
            "source": "body",
            "interpretation": ".NET Aspire container deployment is the deployment mechanism. Aspire controls how native assets are resolved and deployed to the container, which is likely the root cause.",
            "supportedFields": [
              "platforms",
              "actionability"
            ]
          },
          {
            "text": "switched to SkiaSharp.NativeAssets.Linux ... created the following repo AvantiPoint/aspnet-skia",
            "source": "comment 2",
            "interpretation": "Reporter found a workaround: use NativeAssets.Linux (which requires fontconfig) with a custom Docker image that has the native dependencies installed. Confirms the issue is deployment-related.",
            "supportedFields": [
              "bugSignals.hasWorkaround"
            ]
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9",
            "source": "body",
            "interpretation": "Possible regression, but may reflect changed deployment model between 2.x and 3.x rather than a SkiaSharp defect.",
            "supportedFields": [
              "regression",
              "tenets"
            ]
          },
          {
            "text": "System.Memory.Data was not found ... trimming is enabled",
            "source": "comment 2",
            "interpretation": "Secondary issue: Aspire container publishing with trimming strips transitive assemblies. Separate from the native loading issue but compounds the deployment problem.",
            "supportedFields": [
              "bugSignals"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Application crashes with DllNotFoundException in a production deployment scenario. The user followed the documented approach (adding NoDependencies as PackageReference) but the wrong binary was deployed. This is broken behavior in the deployment pipeline.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Not a how-to question \u2014 user correctly added the package but the deployment tooling failed to resolve it properly."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "The issue is entirely about native library loading and deployment. The managed API works fine \u2014 the problem is that the correct native binary isn\u0027t reaching the container.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "Core managed API is not involved. The crash occurs before any managed SkiaSharp code runs, during P/Invoke resolution."
              },
              {
                "value": "Build",
                "whyRejected": "Build succeeds. The issue is in deployment/packaging, specifically how Aspire resolves native assets for container publishing."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Linux",
            "expandedReason": "Explicitly stated as Linux-based Azure Container App. The error shows Linux-specific paths and .so loading. NativeAssets.Linux packages are Linux-specific."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "Reporter indicates 2.88.9 worked but 3.116.0 does not. Even if the root cause is Aspire\u0027s handling of the new 3.x packaging model, this is a compatibility concern for users upgrading from 2.x to 3.x."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Application crashes on first SkiaSharp API call in production. Workaround exists but requires building and maintaining a custom Docker image, which is a significant operational burden. Not critical because it\u0027s not a security issue or data loss, and a workaround exists.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "Workaround exists (custom Docker image with NativeAssets.Linux). Not security or data-loss related."
              },
              {
                "value": "medium",
                "whyRejected": "The workaround is operationally heavy (custom Docker images). This effectively blocks Aspire-based deployments with the documented NoDependencies approach."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "The root cause \u2014 Aspire deploying the wrong native binary variant \u2014 likely affects all Aspire users of SkiaSharp on Linux. Even though the reporter found a workaround, this needs investigation into whether the fix belongs in SkiaSharp\u0027s packaging (e.g., stronger RID resolution) or in Aspire/SDK tooling, and whether documentation should be updated with Aspire-specific guidance.",
            "alternatives": [
              {
                "value": "close-with-docs",
                "whyRejected": "While the workaround is documented in the comments, the root cause (wrong binary deployed by Aspire) hasn\u0027t been investigated. Closing would lose the signal that Aspire container deployment doesn\u0027t work correctly with NoDependencies."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "The pattern is well-understood (wrong binary deployed) and a workaround exists. Investigation would be into Aspire\u0027s behavior, which may be outside SkiaSharp\u0027s control."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed NoDependencies has zero external deps, Linux package selection guidance, container deployment checklist, and native loading troubleshooting. The \u0027Wrong Binary Deployed\u0027 section directly describes this exact pattern.",
            "usedFor": [
              "area",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "The \u0027Wrong Binary Pattern\u0027 heuristic confirms: fontconfig error with NoDependencies PROVES a different binary was loaded. Issue #3386 is already documented as a known pattern in this file.",
            "usedFor": [
              "type",
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/research-by-type.md",
            "relevance": "Bug research checklist guided investigation into deployment patterns and workaround proposals.",
            "usedFor": [
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/response-guidelines.md",
            "relevance": "Guided tone and structure of the suggested response draft \u2014 acknowledge \u2192 analyze \u2192 ask pattern.",
            "usedFor": [
              "suggestedResponse"
            ]
          }
        ],
        "docsNotConsulted": "No GPU/backend docs needed \u2014 this is a native loading issue, not a rendering issue. No API XML docs needed \u2014 the crash occurs before any managed API usage.",
        "uncertainties": [
          "Whether the root cause is in .NET Aspire\u0027s container publishing, in the .NET SDK\u0027s native asset resolution for containers, or in a transitive NativeAssets.Linux reference overriding NoDependencies",
          "Whether the 2.88.9 \u0027last known good\u0027 used the same deployment mechanism (Aspire) or a different one",
          "Whether this affects all Aspire container deployments or only Azure Container Apps specifically"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s PackageReference for NoDependencies is in the executable project (not a library), since the reporter is clearly experienced and the project is an ASP.NET WebAPI",
          "Assumed no transitive NativeAssets.Linux reference, since the reporter didn\u0027t mention one \u2014 but this hasn\u0027t been confirmed"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": ".NET Aspire\u0027s container deployment pipeline is not correctly resolving the NoDependencies variant of libSkiaSharp.so. Instead, it deploys the fontconfig-dependent variant from NativeAssets.Linux (possibly via a transitive reference or incorrect RID resolution), causing DllNotFoundException when fontconfig is not available in the minimal container image.",
        "researchDone": [
          "Reviewed documentation/packages.md \u2014 Container Deployment section, Linux Package Selection Guide, and Troubleshooting: Native Loading",
          "Reviewed references/skia-patterns.md \u2014 \u0027Wrong Binary Pattern\u0027 heuristic and Issue Lessons for #3386",
          "Checked for similar/duplicate issues on GitHub \u2014 no other issues found for this specific Aspire\u002BNoDependencies pattern",
          "Analyzed the reporter\u0027s workaround in comment 2 \u2014 confirmed the approach of switching to NativeAssets.Linux with custom Docker image"
        ],
        "proposals": [
          {
            "title": "Use NativeAssets.Linux with custom container image",
            "description": "The reporter\u0027s own workaround: switch from NoDependencies to NativeAssets.Linux and use a custom Docker base image that has fontconfig and other native dependencies pre-installed.",
            "steps": [
              "Replace SkiaSharp.NativeAssets.Linux.NoDependencies with SkiaSharp.NativeAssets.Linux in PackageReferences",
              "Use a container base image with fontconfig installed (e.g., ghcr.io/avantipoint/aspnet-skia:9.0 or build your own from mcr.microsoft.com/dotnet/aspnet with apt-get install libfontconfig1)",
              "Set \u003CContainerBaseImage\u003E in the csproj to the custom image",
              "Add System.Memory.Data as direct PackageReference if trimming strips it"
            ],
            "pros": [
              "Confirmed working by the reporter",
              "Full fontconfig support enables system font enumeration",
              "Well-understood approach for containerized .NET apps"
            ],
            "cons": [
              "Requires building and maintaining a custom Docker image",
              "Adds operational complexity for container image updates",
              "Doesn\u0027t solve the root cause \u2014 NoDependencies should work"
            ],
            "confidence": 0.92,
            "effort": "medium"
          },
          {
            "title": "Investigate and fix NoDependencies deployment with Aspire",
            "description": "Investigate why Aspire\u0027s container publishing doesn\u0027t deploy the NoDependencies binary. Check for transitive NativeAssets.Linux references, verify RID resolution in container publish, and potentially add Aspire-specific documentation or packaging workarounds.",
            "steps": [
              "Run \u0060dotnet nuget why SkiaSharp.NativeAssets.Linux\u0060 to check for transitive references",
              "Run \u0060ldd\u0060 on the deployed libSkiaSharp.so to confirm which variant is in the container",
              "If transitive reference exists, add explicit exclusion or use Directory.Build.props to enforce NoDependencies",
              "If no transitive reference, investigate Aspire\u0027s container publishing RID resolution for native assets",
              "File an issue against dotnet/aspire if the bug is in their tooling"
            ],
            "pros": [
              "Addresses the root cause",
              "Benefits all Aspire\u002BSkiaSharp users",
              "No custom Docker image needed"
            ],
            "cons": [
              "May require changes in Aspire/SDK tooling outside SkiaSharp\u0027s control",
              "Investigation effort needed to pinpoint exact cause",
              "Fix timeline depends on external team if the bug is in Aspire"
            ],
            "confidence": 0.65,
            "effort": "high"
          },
          {
            "title": "Install fontconfig in the default container image",
            "description": "Keep the default Aspire container image but add a Dockerfile layer to install fontconfig. This accepts the wrong binary being deployed and ensures its dependency is met.",
            "steps": [
              "Create a Dockerfile FROM mcr.microsoft.com/dotnet/aspnet:9.0",
              "Add RUN apt-get update \u0026\u0026 apt-get install -y libfontconfig1 \u0026\u0026 rm -rf /var/lib/apt/lists/*",
              "Set \u003CContainerBaseImage\u003E to the custom image, or configure Aspire to use a custom Dockerfile"
            ],
            "pros": [
              "Simple \u2014 just one apt-get install",
              "No package changes needed",
              "Fontconfig enables system font enumeration as a bonus"
            ],
            "cons": [
              "Doesn\u0027t fix the root cause \u2014 NoDependencies should work without fontconfig",
              "Increases container image size",
              "Still requires custom Docker image"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Add Aspire deployment guidance to SkiaSharp documentation",
            "description": "Document the known issue with .NET Aspire container deployment and the recommended workarounds in packages.md, making it discoverable for other users hitting the same problem.",
            "steps": [
              "Add an \u0027Aspire / Azure Container Apps\u0027 section to documentation/packages.md under Container Deployment",
              "Document the wrong-binary pattern specific to Aspire",
              "Include both workarounds (custom image with fontconfig, and NativeAssets.Linux with custom image)",
              "Add a note about trimming and System.Memory.Data"
            ],
            "pros": [
              "Immediately helps other users hitting this issue",
              "Low effort, no code changes",
              "Can be done in parallel with investigating the root cause"
            ],
            "cons": [
              "Doesn\u0027t fix the underlying problem",
              "Documentation can go stale if Aspire fixes the issue"
            ],
            "confidence": 0.90,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Add Aspire deployment guidance to SkiaSharp documentation",
        "recommendedReason": "Immediate impact for the lowest effort. The reporter has already found and shared a working solution \u2014 documenting it officially helps other Aspire users. The root cause investigation (proposal 2) should happen in parallel but may depend on the Aspire team."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3386"
    },
    {
      "schemaVersion": "1.0",
      "number": 3385,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-10-15T02:00:00Z",
      "summary": "Feature request: add SKColorType.Gray16 for 16-bit grayscale PNG support",
      "type": {
        "value": "feature-request",
        "confidence": 0.98,
        "reason": "Issue uses the feature request template and explicitly asks to \u0027add SkColorType.Gray16\u0027. No broken behavior reported \u2014 this capability does not exist."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.95,
        "reason": "SKColorType is a core SkiaSharp enum defined in binding/SkiaSharp/Definitions.cs. This is a core API surface request."
      },
      "backends": null,
      "platforms": null,
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.75,
          "reason": "Request relates to supporting a standard image format (16-bit grayscale PNG) that other imaging libraries handle."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": null,
      "versionAnalysis": null,
      "actionability": {
        "suggestedAction": "keep-open",
        "confidence": 0.85,
        "reason": "Valid feature request, but blocked by upstream Skia which has no kGray_16_SkColorType. The request is understandable \u2014 16-bit grayscale PNGs are used in medical imaging, scientific data, and photography. However, implementation requires upstream Skia support first.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.90,
        "reason": "Can provide a clear technical explanation of why this isn\u0027t currently possible and suggest workarounds.",
        "draft": "Thanks for the feature request. You\u0027re right that there\u0027s no \u0060SKColorType.Gray16\u0060 \u2014 as noted in the comments, upstream Skia itself doesn\u0027t have a 16-bit grayscale color type (\u0060kGray_16_SkColorType\u0060 doesn\u0027t exist in Skia\u0027s \u0060SkColorType\u0060 enum).\n\nSince SkiaSharp wraps Skia\u0027s API surface, adding \u0060Gray16\u0060 would require upstream support first.\n\nAs a potential workaround for reading 16-bit grayscale PNGs, you could:\n1. Decode the PNG using a library that supports 16-bit gray (e.g., \u0060System.Drawing\u0060, \u0060ImageSharp\u0060, or \u0060libpng\u0060 directly)\n2. Convert the pixel data to a format SkiaSharp supports (e.g., \u0060Rgba16161616\u0060 or \u0060RgbaF16\u0060) by replicating the gray value across RGB channels\n3. Create an \u0060SKImage\u0060 from the converted pixel data\n\nThis adds a conversion step but lets you work with 16-bit data in SkiaSharp today."
      },
      "analysisNotes": {
        "summary": "User requests adding SKColorType.Gray16 for 16-bit grayscale PNG support. This is a feature request for functionality that does not exist in upstream Skia \u2014 confirmed by checking SkColorType.h which only defines kGray_8_SkColorType. A community member also confirmed no upstream support.",
        "keySignals": [
          {
            "text": "i want to use 16bit grayscale pngs but it looks like it doesnt exist in skiasharp",
            "source": "body",
            "interpretation": "User wants to work with 16-bit grayscale PNGs and found the capability missing. This is a new feature request, not a bug.",
            "supportedFields": [
              "type"
            ]
          },
          {
            "text": "add SkColorType.Gray16",
            "source": "body",
            "interpretation": "Explicit request for a new enum value in the core SKColorType. This targets the SkiaSharp core API surface.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "There\u0027s no Gray16 support upstream: https://api.skia.org/SkColorType_8h.html",
            "source": "comment 2",
            "interpretation": "Community member confirmed the fundamental blocker \u2014 upstream Skia doesn\u0027t have this color type. This means SkiaSharp cannot add it without custom implementation or upstream changes.",
            "supportedFields": [
              "actionability"
            ]
          },
          {
            "text": "[FEATURE] prefix in title and type/feature-request label",
            "source": "labels",
            "interpretation": "Issue already correctly labeled as feature request by automation.",
            "supportedFields": [
              "type"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "feature-request",
            "expandedReason": "The issue uses the feature request template, asks to \u0027add\u0027 a new enum value, and describes functionality that does not currently exist. There is no broken behavior \u2014 this is a request for new capability.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "Enhancement implies improving existing functionality. Gray16 is entirely new \u2014 there\u0027s no existing grayscale 16-bit support to improve."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "SKColorType is defined in the core SkiaSharp binding (Definitions.cs). This isn\u0027t about views, platform-specific rendering, or native loading \u2014 it\u0027s about the core color type enumeration.",
            "alternatives": [
              {
                "value": "libSkiaSharp.native",
                "whyRejected": "While implementation would touch native code, the request is about the C# API surface. The native layer is an implementation detail."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a valid feature request representing a real use case (16-bit grayscale imagery). However, it\u0027s blocked by upstream Skia\u0027s lack of Gray16 support. Keeping it open acknowledges the need while tracking the upstream dependency.",
            "alternatives": [
              {
                "value": "close-with-docs",
                "whyRejected": "While workarounds exist, this is a legitimate gap. Closing might dismiss a valid need that could be addressed if upstream adds support."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "No investigation needed \u2014 the blocker is clear: upstream Skia doesn\u0027t support this color type."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "externals/skia/include/core/SkColorType.h",
            "relevance": "Confirmed that upstream Skia has no kGray_16_SkColorType \u2014 only kGray_8_SkColorType exists. The full enum was reviewed to verify no 16-bit grayscale variant exists.",
            "usedFor": [
              "type",
              "actionability"
            ]
          },
          {
            "path": "binding/SkiaSharp/Definitions.cs",
            "relevance": "Reviewed the public SKColorType enum to confirm Gray8 exists (value 9) but no Gray16. Also confirmed the full set of color types SkiaSharp exposes.",
            "usedFor": [
              "area",
              "actionability"
            ]
          },
          {
            "path": "binding/SkiaSharp/EnumMappings.cs",
            "relevance": "Checked the native-to-managed enum mapping to understand how color types are bridged between C API and C#.",
            "usedFor": [
              "area"
            ]
          }
        ],
        "docsNotConsulted": "No platform-specific docs, packages.md, or native loading diagnostics consulted \u2014 this is a cross-platform API surface request unrelated to deployment or platform quirks.",
        "uncertainties": [
          "Whether Skia has plans to add a 16-bit grayscale color type in the future",
          "Whether the user\u0027s use case (16-bit grayscale PNGs) could be adequately served by existing higher-bit-depth color types like Rgba16161616 with a conversion step",
          "Whether there\u0027s demand from other users for this specific feature"
        ],
        "assumptions": [
          "Assumed the user wants to both read and render 16-bit grayscale data, not just decode it"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "User needs to work with 16-bit grayscale PNGs in SkiaSharp. The fundamental limitation is that upstream Skia only supports 8-bit grayscale (kGray_8_SkColorType). Any solution must either work around this limitation or wait for upstream support.",
        "researchDone": [
          "Checked upstream Skia SkColorType.h \u2014 confirmed no Gray16 variant exists",
          "Reviewed SkiaSharp SKColorType enum in Definitions.cs \u2014 Gray8 is present at value 9, no Gray16",
          "Checked EnumMappings.cs for native enum bridging pattern",
          "Reviewed comment from community member confirming no upstream support",
          "Checked available high-bit-depth color types: Rgba16161616, RgbaF16, Alpha16 exist and could serve as conversion targets"
        ],
        "proposals": [
          {
            "title": "Workaround: convert Gray16 to Rgba16161616",
            "description": "Decode 16-bit grayscale PNGs externally and convert pixel data to SKColorType.Rgba16161616 by replicating the gray value across R, G, B channels with full alpha.",
            "steps": [
              "Decode the 16-bit grayscale PNG using an external library (e.g., ImageSharp, System.Drawing, or raw libpng P/Invoke)",
              "Allocate a buffer for Rgba16161616 format (8 bytes per pixel: 4x uint16)",
              "For each gray16 pixel value, write (gray, gray, gray, 0xFFFF) into the RGBA buffer",
              "Create SKImageInfo with SKColorType.Rgba16161616 and create SKImage/SKBitmap from the converted data"
            ],
            "pros": [
              "Works today with current SkiaSharp",
              "Preserves full 16-bit precision",
              "No upstream changes required"
            ],
            "cons": [
              "Requires external PNG decoding library",
              "4x memory usage (8 bytes vs 2 bytes per pixel)",
              "Extra conversion step adds complexity and processing time"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Workaround: convert Gray16 to RgbaF16",
            "description": "Convert 16-bit grayscale data to half-float RGBA format, which SkiaSharp supports natively.",
            "steps": [
              "Decode 16-bit grayscale PNG externally",
              "Convert each uint16 gray value to half-float (gray/65535.0)",
              "Write as (grayF16, grayF16, grayF16, 1.0F16) into RgbaF16 buffer",
              "Create SKImage with SKColorType.RgbaF16"
            ],
            "pros": [
              "Works today, no SkiaSharp changes needed",
              "Half-float provides good precision for grayscale data",
              "Compatible with GPU rendering paths"
            ],
            "cons": [
              "Slight precision loss in float16 conversion for some values",
              "8 bytes per pixel (same memory overhead as Rgba16161616)",
              "Requires half-float conversion logic"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Request upstream Skia Gray16 support",
            "description": "File a feature request with the Skia project to add kGray_16_SkColorType, then expose it in SkiaSharp once available.",
            "steps": [
              "File a feature request at https://issues.skia.org/ requesting kGray_16_SkColorType",
              "Reference use cases: medical imaging (DICOM), scientific data, photography RAW processing",
              "If accepted and implemented upstream, add Gray16 to SkiaSharp\u0027s SKColorType enum",
              "Add C API mapping, enum mapping, and tests"
            ],
            "pros": [
              "Proper native-level support with optimal memory layout (2 bytes per pixel)",
              "Would benefit the entire Skia ecosystem",
              "Correct long-term solution"
            ],
            "cons": [
              "Requires upstream approval \u2014 no guarantee of acceptance",
              "Timeline is unpredictable",
              "Medical/scientific imaging may not be a Skia priority"
            ],
            "confidence": 0.40,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Workaround: convert Gray16 to Rgba16161616",
        "recommendedReason": "Provides a working solution today with full 16-bit precision, requires no SkiaSharp or Skia changes, and uses the existing Rgba16161616 color type. The 4x memory overhead is acceptable for most use cases."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3385"
    },
    {
      "schemaVersion": "1.0",
      "number": 3379,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-10-07T12:00:00Z",
      "summary": "OpenTK.GLWpfControl 3.3.0 dependency lacks strong-naming, blocking strong-named WPF apps on .NET Framework",
      "type": {
        "value": "bug",
        "confidence": 0.92,
        "reason": "Runtime FileLoadException when loading an unsigned dependency from a strong-named application. This is broken behavior, not a feature request \u2014 the library cannot be used at all in strong-named projects."
      },
      "area": {
        "value": "SkiaSharp.Views",
        "confidence": 0.97,
        "reason": "The issue is in SkiaSharp.Views.WPF\u0027s csproj PackageReference to OpenTK.GLWpfControl 3.3.0 for .NET Framework targets."
      },
      "backends": [
        {
          "value": "OpenGL",
          "confidence": 0.85,
          "reason": "OpenTK.GLWpfControl is the OpenGL WPF integration control used by SKGLElement. The dependency only exists for the GL rendering backend."
        }
      ],
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.97,
          "reason": "WPF is a Windows-Classic technology, and the issue is specific to the .NET Framework 4.x target where OpenTK.GLWpfControl 3.3.0 is referenced."
        }
      ],
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.95,
          "reason": "Strong-naming is a .NET Framework compatibility requirement. The unsigned dependency breaks compatibility with any strong-named consuming application."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.75,
        "reason": "Reporter states \u0027Last Known Good Version\u0027 is 2.88.9, implying this worked previously. The OpenTK.GLWpfControl dependency was likely different or absent in 2.x. However, the exact mechanism of the regression (new dependency vs changed version) isn\u0027t fully confirmed.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net48"
        ],
        "severity": "medium",
        "severityReason": "FileLoadException prevents app from loading at all for strong-named projects on .NET Framework. However, the impact is limited to the specific scenario of strong-named .NET Framework WPF apps using SKGLElement. Most users on modern .NET are unaffected. The fix is known and trivial (version bump)."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a .NET Framework 4.8 WPF application with strong-naming enabled (SignAssembly=true)",
          "Add a PackageReference to SkiaSharp.Views.WPF 3.119.1 (or 3.116.0)",
          "Run the application \u2014 FileLoadException is thrown because GLWpfControl 3.3.0 is not strong-named"
        ],
        "codeSnippets": [
          {
            "language": "xml",
            "code": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EWinExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet48\u003C/TargetFramework\u003E\n    \u003CSignAssembly\u003Etrue\u003C/SignAssembly\u003E\n    \u003CAssemblyOriginatorKeyFile\u003EMyStrongNameKey.snk\u003C/AssemblyOriginatorKeyFile\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp.Views.WPF\u0022 Version=\u00223.119.1\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E",
            "context": "Example strong-named WPF project that triggers the FileLoadException"
          }
        ],
        "environmentDetails": "Windows, Visual Studio, .NET Framework 4.8, SkiaSharp 3.116.0 / 3.119.1"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "3.119.1",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "The csproj on the main branch still references OpenTK.GLWpfControl 3.3.0 for net4x targets. This issue is current and unresolved.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.90,
        "reason": "The fix is straightforward (bump OpenTK.GLWpfControl from 3.3.0 to 3.3.1 for net4x targets), but it needs a maintainer to verify there are no breaking changes between 3.3.0 and 3.3.1 and to make the change.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.85,
        "reason": "The root cause is clear and the fix is well-defined. A response acknowledging the issue and confirming the path forward would be helpful.",
        "draft": "Thanks for the clear report and for identifying the exact version where strong-naming was added to GLWpfControl \u2014 that makes this straightforward to address.\n\nYou\u0027re right that the \u0060OpenTK.GLWpfControl\u0060 3.3.0 reference for .NET Framework targets is missing a strong name, and 3.3.1 added it. The fix would be bumping that dependency version in the SkiaSharp.Views.WPF project file.\n\nIn the meantime, if you\u0027re not using \u0060SKGLElement\u0060 (the OpenGL-backed WPF control), you could use \u0060SKElement\u0060 instead, which doesn\u0027t depend on OpenTK at all and uses the software rasterizer."
      },
      "analysisNotes": {
        "summary": "OpenTK.GLWpfControl 3.3.0 is not strong-named, causing FileLoadException in strong-named .NET Framework WPF applications. The fix is a simple version bump to 3.3.1\u002B which added strong-naming. Verified the csproj still has version 3.3.0 on the current main branch.",
        "keySignals": [
          {
            "text": "In version 3.3.0, the GLWpfControl assembly is not strong-named",
            "source": "body",
            "interpretation": "Root cause identified by the reporter \u2014 the dependency version lacks strong-naming",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          },
          {
            "text": "Strong-naming was added in OpenTK.GLWpfControl 3.3.1",
            "source": "body",
            "interpretation": "Reporter has already identified the fix \u2014 bump to 3.3.1",
            "supportedFields": [
              "actionability",
              "resolutionAnalysis"
            ]
          },
          {
            "text": "System.IO.FileLoadException: \u0027Could not load file or assembly \u0027GLWpfControl, Version=3.3.0.0, Culture=neutral, PublicKeyToken=null\u0027 ... A strongly-named assembly is required. (Exception from HRESULT: 0x80131044)\u0027",
            "source": "body",
            "interpretation": "Runtime crash with clear error message confirming the strong-naming mismatch",
            "supportedFields": [
              "type",
              "bugSignals.hasCrash",
              "bugSignals.severity"
            ]
          },
          {
            "text": "PackageReference Include=\u0022OpenTK.GLWpfControl\u0022 Version=\u00223.3.0\u0022",
            "source": "body",
            "interpretation": "Reporter pinpointed the exact line in the csproj causing the issue. Verified: still present on main branch.",
            "supportedFields": [
              "area",
              "actionability"
            ]
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9",
            "source": "body",
            "interpretation": "Regression from 2.x to 3.x, likely because OpenTK.GLWpfControl was added or changed in the 3.x rewrite",
            "supportedFields": [
              "regression"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The application crashes at runtime with FileLoadException. This is broken behavior \u2014 a dependency version choice by SkiaSharp prevents usage in strong-named applications. While it could be framed as an enhancement request, the runtime crash makes it a bug.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "Could argue this is \u0027improve dependency version\u0027, but the FileLoadException crash makes it a defect, not an improvement."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views",
            "expandedReason": "The issue is in the SkiaSharp.Views.WPF csproj, specifically the PackageReference to OpenTK.GLWpfControl for .NET Framework targets."
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "WPF is a Windows-Classic technology. The issue is specific to .NET Framework 4.x targets where OpenTK.GLWpfControl 3.3.0 is referenced."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "Strong-naming is a .NET Framework compatibility concern. The unsigned dependency breaks the strong-naming chain required by consuming applications."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Severity is medium: the crash is total for affected users (strong-named net4x WPF apps), but the affected population is narrow (only net48 \u002B strong-naming \u002B SKGLElement users). The fix is known and trivial.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "While the crash is total for affected users, the scope is narrow (net48 \u002B strong-naming only) and a workaround exists (use SKElement instead)."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The fix is clear (bump version), but a maintainer needs to verify no breaking changes exist between OpenTK.GLWpfControl 3.3.0 and 3.3.1 before making the change."
          }
        ],
        "docsConsulted": [
          {
            "path": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "relevance": "Confirmed OpenTK.GLWpfControl 3.3.0 is still referenced on main branch for net4x targets (line 15). Also confirmed OpenTK 3.3.1 is already used (line 14), so only GLWpfControl needs the bump.",
            "usedFor": [
              "area",
              "bugSignals",
              "resolutionAnalysis"
            ]
          }
        ],
        "docsNotConsulted": "No need to check native loading docs (packages.md) \u2014 this is a managed assembly strong-naming issue, not a native loading issue. No rendering/backend docs needed \u2014 the issue is purely about assembly signing, not rendering behavior.",
        "uncertainties": [
          "Whether OpenTK.GLWpfControl 3.3.1 introduces any breaking API changes vs 3.3.0",
          "Whether the reporter could use SKElement (raster) instead of SKGLElement (OpenGL) as a workaround",
          "Whether SkiaSharp 2.88.9 truly worked because it didn\u0027t use OpenTK.GLWpfControl or because the version was different"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "SkiaSharp.Views.WPF references OpenTK.GLWpfControl 3.3.0 for .NET Framework targets, which is not strong-named. This causes FileLoadException in any consuming application that enables strong-naming. OpenTK.GLWpfControl 3.3.1 added strong-naming and would resolve the issue.",
        "researchDone": [
          "Verified SkiaSharp.Views.WPF.csproj on current main branch still references OpenTK.GLWpfControl 3.3.0 for net4x targets",
          "Confirmed OpenTK (not GLWpfControl) is already at 3.3.1 \u2014 only the GLWpfControl package needs bumping",
          "Searched for duplicate issues \u2014 no existing issues about strong-naming or GLWpfControl",
          "Checked issue comments \u2014 only automated triage bot comment, no maintainer response"
        ],
        "proposals": [
          {
            "title": "Bump OpenTK.GLWpfControl to 3.3.1 for net4x targets",
            "description": "Update the PackageReference from 3.3.0 to 3.3.1 in the SkiaSharp.Views.WPF.csproj for .NET Framework targets. This is the direct fix requested by the reporter.",
            "steps": [
              "Open source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
              "Change line 15: OpenTK.GLWpfControl Version from 3.3.0 to 3.3.1",
              "Build and test SkiaSharp.Views.WPF for net48 target",
              "Verify SKGLElement still works correctly with the updated dependency"
            ],
            "pros": [
              "Directly addresses the root cause",
              "Minimal change \u2014 single version number bump",
              "3.3.1 is a patch release, likely backward compatible",
              "OpenTK (non-GLWpfControl) is already at 3.3.1, so this aligns versions"
            ],
            "cons": [
              "Need to verify no breaking changes between 3.3.0 and 3.3.1",
              "Requires a new SkiaSharp release for users to get the fix"
            ],
            "confidence": 0.95,
            "effort": "low"
          },
          {
            "title": "User workaround: Use SKElement instead of SKGLElement",
            "description": "Users who don\u0027t specifically need OpenGL rendering can switch from SKGLElement to SKElement, which uses the software rasterizer and has no OpenTK dependency.",
            "steps": [
              "Replace SKGLElement with SKElement in XAML",
              "Replace OnPaintSurface handler with equivalent SKElement handler",
              "Remove any OpenGL-specific configuration"
            ],
            "pros": [
              "Immediate workaround \u2014 no SkiaSharp release needed",
              "Eliminates the OpenTK dependency entirely",
              "SKElement is simpler and sufficient for most WPF use cases"
            ],
            "cons": [
              "Loses hardware-accelerated OpenGL rendering",
              "Not viable if the user specifically needs GPU rendering",
              "Doesn\u0027t fix the underlying issue for other users"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Bump to latest OpenTK.GLWpfControl 3.x",
            "description": "Instead of bumping to exactly 3.3.1, update to the latest available 3.x version to pick up all fixes and improvements.",
            "steps": [
              "Check the latest 3.x release of OpenTK.GLWpfControl on NuGet",
              "Update the PackageReference to that version",
              "Build, test, and verify compatibility"
            ],
            "pros": [
              "Gets all bug fixes and improvements, not just strong-naming",
              "Reduces the chance of needing another bump soon"
            ],
            "cons": [
              "Larger version jump increases risk of breaking changes",
              "Need more thorough testing to verify compatibility"
            ],
            "confidence": 0.80,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Bump OpenTK.GLWpfControl to 3.3.1 for net4x targets",
        "recommendedReason": "Most conservative fix \u2014 single patch version bump that directly addresses the reported issue. Since OpenTK (non-GLWpfControl) is already at 3.3.1, this aligns the version and the change is minimal risk."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3379"
    },
    {
      "schemaVersion": "1.0",
      "number": 3378,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-07-22T12:00:00Z",
      "summary": "Memory leak in ToHarfBuzzBlob() \u2014 SKStreamAsset not disposed in the non-memory-mapped code path",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Reporter identifies a code path in ToHarfBuzzBlob() where SKStreamAsset is never disposed, causing a memory leak. Code inspection confirms the else branch at BlobExtensions.cs:30 frees the copied buffer but never disposes the source SKStreamAsset."
      },
      "area": {
        "value": "SkiaSharp.HarfBuzz",
        "confidence": 0.95,
        "reason": "The bug is in BlobExtensions.ToHarfBuzzBlob() in the SkiaSharp.HarfBuzz package, and is triggered through SKShaper\u0027s constructor."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Android",
          "confidence": 0.85,
          "reason": "Reporter says \u0027First observed bug on Android\u0027. The bug is cross-platform in code, but Android was the first observation point."
        },
        {
          "value": "Windows-Classic",
          "confidence": 0.75,
          "reason": "Reporter says \u0027seems to be a problem also on Windows\u0027 and selected Windows as platform. Lower confidence because phrased tentatively."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.90,
          "reason": "Memory leak that grows with each SKShaper construction/disposal cycle. Over time this degrades application reliability and can lead to OOM."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "partial",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "severity": "medium",
        "severityReason": "Memory leak \u2014 not a crash, but will degrade reliability over time, especially on memory-constrained devices like Android. Severity is medium because the leak occurs per SKShaper construction, so apps creating/disposing shapers frequently (e.g., text rendering engines) will be impacted."
      },
      "reproEvidence": {
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "public TextSegmentShaper(SKTypeface typeface, SKPaint fromPaint)\n{\n    Paint = new SKPaint() { ... };\n    Shaper = new SKShaper(typeface);\n}\n\nprotected virtual void Dispose(bool disposing)\n{\n    if (!disposedValue)\n    {\n        Paint?.Dispose();\n        Shaper?.Dispose();\n        Paint = null;\n        Shaper = null;\n        disposedValue = true;\n    }\n}",
            "context": "User\u0027s wrapper class that creates and disposes SKShaper. Even with proper disposal, SKStreamAsset leaks inside SKShaper constructor via ToHarfBuzzBlob()."
          }
        ],
        "stepsToReproduce": [
          "Create a new SKShaper(typeface) \u2014 internally calls Typeface.OpenStream().ToHarfBuzzBlob()",
          "If the SKStreamAsset returned by OpenStream() does not have a memory-mapped base (GetMemoryBase() returns IntPtr.Zero), the else branch in ToHarfBuzzBlob copies the data but never disposes the original SKStreamAsset",
          "Dispose the SKShaper \u2014 the internal HarfBuzz Blob and Buffer are disposed, but the leaked SKStreamAsset remains unreleased",
          "Repeat to observe growing memory usage"
        ],
        "environmentDetails": "SkiaSharp 3.116.0, Visual Studio Windows, first observed on Android, also reproduced on Windows"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "The code in BlobExtensions.cs and SKShaper.cs has not changed in recent versions. The else branch leak has been present since the method was introduced. Still applicable to latest."
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.90,
        "reason": "Code review confirms the leak exists in the else branch of ToHarfBuzzBlob(). The fix is straightforward \u2014 add asset.Dispose() in the else branch after reading. Needs engineering to implement and test.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.85,
        "reason": "The root cause can be confirmed from code inspection and a helpful response acknowledging the finding is appropriate.",
        "draft": "Thanks for the detailed report and for pinpointing the likely root cause \u2014 that\u0027s a really helpful lead.\n\nLooking at \u0060BlobExtensions.ToHarfBuzzBlob()\u0060, I can confirm the issue: when \u0060GetMemoryBase()\u0060 returns \u0060IntPtr.Zero\u0060 (the \u0060else\u0060 branch), the method copies the stream data into a new allocation and sets up a release callback for that allocation, but the original \u0060SKStreamAsset\u0060 is never disposed. In contrast, the \u0060if\u0060 branch correctly captures the asset in the Blob\u0027s release callback via \u0060() =\u003E asset.Dispose()\u0060.\n\nThis means every \u0060new SKShaper(typeface)\u0060 call leaks one \u0060SKStreamAsset\u0060 when the typeface stream isn\u0027t memory-mapped \u2014 which explains the growing memory usage you\u0027re seeing.\n\nWe\u0027ll look into getting a fix in for this. The fix would be adding \u0060asset.Dispose()\u0060 in the else branch after the data has been read."
      },
      "analysisNotes": {
        "summary": "Confirmed memory leak in BlobExtensions.ToHarfBuzzBlob(). The else branch (non-memory-mapped path) copies data from SKStreamAsset but never disposes it. The if branch correctly defers disposal via the Blob\u0027s release callback. Every SKShaper construction leaks one SKStreamAsset when the typeface stream isn\u0027t memory-mapped.",
        "keySignals": [
          {
            "text": "I think the bug is in ToHarfBuzzBlob() extension - it doesn\u0027t dispose SKStreamAsset in all paths",
            "source": "body",
            "interpretation": "Reporter correctly identified the root cause method and the asymmetric disposal pattern between the two branches.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "It seems that this code leaks SKStreamAssets even if properly disposed",
            "source": "body",
            "interpretation": "Reporter\u0027s wrapper class disposes SKShaper correctly, but the leak is internal to the SKShaper/BlobExtensions code path.",
            "supportedFields": [
              "type",
              "bugSignals.reproQuality"
            ]
          },
          {
            "text": "First observed bug on Android, but seems to be a problem also on Windows",
            "source": "body",
            "interpretation": "Cross-platform issue, first noticed on memory-constrained Android. The bug is in managed C# code so it affects all platforms.",
            "supportedFields": [
              "platforms"
            ]
          },
          {
            "text": "blob = new Blob(ptr, size, MemoryMode.ReadOnly, () =\u003E Marshal.FreeCoTaskMem(ptr));",
            "source": "BlobExtensions.cs:30",
            "interpretation": "The else branch release callback only frees the copied buffer, never disposes the source SKStreamAsset. Compare with line 24 where the if branch callback calls asset.Dispose().",
            "supportedFields": [
              "type",
              "bugSignals"
            ]
          },
          {
            "text": "using (var blob = Typeface.OpenStream(out index).ToHarfBuzzBlob())",
            "source": "SKShaper.cs:20",
            "interpretation": "The SKStreamAsset from OpenStream() is passed directly to ToHarfBuzzBlob() without any independent using/disposal. If ToHarfBuzzBlob doesn\u0027t dispose it, nobody does.",
            "supportedFields": [
              "area",
              "bugSignals"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Code inspection confirms a resource leak where SKStreamAsset is not disposed in one of two code paths. This is broken behavior \u2014 resources should be released on disposal.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "This is not an improvement request \u2014 it\u0027s a genuine resource management defect where Dispose() fails to release all owned resources."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.HarfBuzz",
            "expandedReason": "The bug is in BlobExtensions.cs and manifests through SKShaper.cs, both in the SkiaSharp.HarfBuzz package. The existing label area/SkiaSharp is less specific \u2014 this is squarely in the HarfBuzz integration layer.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "While SKStreamAsset is a core SkiaSharp type, the leak is in SkiaSharp.HarfBuzz\u0027s BlobExtensions, not in the core library."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Memory leak that grows with each SKShaper construction. Not a crash, but on mobile devices (Android) with constrained memory, repeated text shaping operations could eventually cause OOM. Severity is medium because a workaround exists (minimizing SKShaper recreations) and the per-instance leak size is bounded.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "No crash or data loss. The leak is per-SKShaper-construction, not per-frame, so the growth rate is typically manageable."
              },
              {
                "value": "low",
                "whyRejected": "On mobile platforms with tight memory budgets, resource leaks are more than cosmetic \u2014 they can cause OOM kills over time."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause is identified and the fix appears straightforward (dispose asset in the else branch), but it needs engineering to implement, test, and verify there are no ownership/lifetime complications with the Blob callback."
          }
        ],
        "docsConsulted": [
          {
            "path": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "relevance": "Contains the bug \u2014 confirmed the else branch does not dispose SKStreamAsset while the if branch does.",
            "usedFor": [
              "type",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "relevance": "Shows how ToHarfBuzzBlob is called \u2014 the SKStreamAsset from OpenStream() has no independent disposal path outside of ToHarfBuzzBlob.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          }
        ],
        "docsNotConsulted": "No need to consult packages.md (not a deployment/loading issue), skia-patterns.md (not a platform quirk), or rendering docs (not a backend-specific issue).",
        "uncertainties": [
          "Whether the title \u0027SKShader\u0027 is a typo for \u0027SKShaper\u0027 \u2014 the body exclusively discusses SKShaper/ToHarfBuzzBlob, not SKShader",
          "How often the else branch (non-memory-mapped) is actually taken vs the if branch \u2014 this affects real-world impact",
          "Whether there are other callers of ToHarfBuzzBlob() beyond SKShaper that also leak"
        ],
        "assumptions": [
          "Assumed the title \u0027SKShader\u0027 is a typo for \u0027SKShaper\u0027 based on the body content exclusively discussing SKShaper and ToHarfBuzzBlob"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "BlobExtensions.ToHarfBuzzBlob() has asymmetric disposal: the memory-mapped path (if branch) correctly disposes the SKStreamAsset via the Blob\u0027s release callback, but the copy path (else branch) only frees the copied memory allocation and never disposes the source SKStreamAsset. This causes a native memory leak for every SKShaper construction when the typeface stream isn\u0027t memory-mapped.",
        "researchDone": [
          "Inspected BlobExtensions.ToHarfBuzzBlob() \u2014 confirmed else branch lacks asset.Dispose()",
          "Inspected SKShaper constructor \u2014 confirmed OpenStream() result has no independent disposal",
          "Searched GitHub issues for duplicates of SKStreamAsset memory leak \u2014 none found",
          "Checked if branch disposal pattern to confirm correct behavior as reference"
        ],
        "proposals": [
          {
            "title": "Dispose SKStreamAsset in else branch after reading",
            "description": "Add asset.Dispose() in the else branch of ToHarfBuzzBlob() after reading the data, since the data has been fully copied and the asset is no longer needed.",
            "steps": [
              "In BlobExtensions.cs, add asset.Dispose() after the asset.Read() call in the else branch (after line 29)",
              "Run existing SKShaper tests to verify no regression",
              "Add a test that creates/disposes multiple SKShapers and verifies no leaked handles"
            ],
            "pros": [
              "Minimal one-line fix",
              "Mirrors the if-branch pattern where asset lifetime is managed",
              "No API or behavioral changes"
            ],
            "cons": [
              "Need to verify no other code holds a reference to the asset after ToHarfBuzzBlob returns"
            ],
            "confidence": 0.90,
            "effort": "low"
          },
          {
            "title": "Use using statement for asset in SKShaper constructor",
            "description": "Wrap the OpenStream() call in SKShaper.cs with a using statement so the SKStreamAsset is always disposed after the blob is created, regardless of which branch ToHarfBuzzBlob takes.",
            "steps": [
              "In SKShaper.cs, change line 20 to: using var stream = Typeface.OpenStream(out index);",
              "Then: using var blob = stream.ToHarfBuzzBlob();",
              "Remove the disposal responsibility from BlobExtensions (but keep the if-branch callback for the memory-mapped case where Blob needs the asset alive)",
              "Run tests"
            ],
            "pros": [
              "Disposal responsibility is clear at the call site",
              "Works regardless of which ToHarfBuzzBlob branch executes"
            ],
            "cons": [
              "Conflicts with the if-branch pattern where Blob\u0027s release callback owns the asset lifetime \u2014 would cause double-dispose in the memory-mapped case",
              "Requires reworking the if-branch callback to not dispose the asset"
            ],
            "confidence": 0.60,
            "effort": "medium"
          },
          {
            "title": "Always dispose asset in Blob release callback",
            "description": "Modify the else branch to include asset disposal in the Blob\u0027s release callback alongside FreeCoTaskMem, making both branches consistently dispose the asset via the Blob\u0027s lifecycle.",
            "steps": [
              "Change else branch callback to: () =\u003E { Marshal.FreeCoTaskMem(ptr); asset.Dispose(); }",
              "This ensures the asset lives as long as the Blob in both branches",
              "Run tests to verify"
            ],
            "pros": [
              "Both branches have symmetric disposal patterns",
              "Asset lifetime is tied to Blob lifetime in both cases",
              "Simple change"
            ],
            "cons": [
              "Asset stays alive longer than necessary in the else branch (data was already copied)",
              "Slightly more memory held until Blob is GC\u0027d/disposed"
            ],
            "confidence": 0.85,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Dispose SKStreamAsset in else branch after reading",
        "recommendedReason": "Simplest fix \u2014 the data has already been fully copied into the allocated buffer, so the SKStreamAsset is no longer needed. Disposing it immediately after Read() is the most memory-efficient approach and requires only a single line change."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3378"
    },
    {
      "schemaVersion": "1.0",
      "number": 3375,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-24T12:00:00Z",
      "summary": "SkiaSharp 3.116\u002B crashes with stack overflow on Windows x86 (.NET 8/9), works on x64 and with v2.88.9",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Two reporters describe hard crashes (app termination, stack overflow) when using SkiaSharp 3.116\u002B on x86. Second reporter provides a stack trace showing stack overflow at sk_bitmap_get_pixel_color P/Invoke."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.85,
        "reason": "The stack overflow occurs at the P/Invoke boundary (SkiaApi.sk_bitmap_get_pixel_color). The crash is architecture-specific (x86 only) and version-specific (3.x only), pointing to a native calling convention or native binary loading issue rather than a managed code bug."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.95,
          "reason": "Both reporters are on Windows. Original reporter uses Windows 11 Pro ARM, second reporter uses Windows with .NET 8.0. The existing label os/Windows-Classic is already applied."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Hard crash (stack overflow, process termination) with no recovery. Existing label tenet/reliability already applied."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.92,
        "reason": "Original reporter explicitly states 2.88.9 works and 3.116.0 crashes. Second reporter confirms x86\u002Bnet472 works but x86\u002Bnet8.0 with v3.x crashes. The P/Invoke layer was significantly reworked in SkiaSharp 3.x.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": true,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Original reporter: copy DLLs from subdirectory to application root directory. Both reporters: use x64 instead of x86. Original reporter: downgrade to SkiaSharp 2.88.9.",
        "targetFrameworks": [
          "net9.0",
          "net8.0",
          "netstandard2.0"
        ],
        "severity": "high",
        "severityReason": "Hard crash (stack overflow / process termination) on a supported platform (Windows x86). Workarounds exist (use x64 or downgrade) but are not viable for all scenarios, particularly applications that must target x86 for legacy compatibility."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a .NET 8.0 or 9.0 application targeting x86 on Windows",
          "Add SkiaSharp 3.116.0 or newer as a dependency",
          "Call any SkiaSharp API that invokes a native P/Invoke (e.g. SKBitmap.GetPixel)",
          "Observe stack overflow crash \u2014 the process is terminated with no exception or dump"
        ],
        "codeSnippets": [
          {
            "language": "text",
            "code": "powershell.exe : The active test run was aborted. Reason: Test host process crashed : Stack overflow.\n   at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color(IntPtr, Int32, Int32)\n   [...]\n   at System.RuntimeMethodHandle.InvokeMethod(System.Object, Void**, System.Signature, Boolean)\n   at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(System.Object, IntPtr*)\n   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(...)",
            "context": "Stack trace from second reporter (TomPMoleman) showing stack overflow originating at SkiaSharp P/Invoke boundary on x86 \u002B .NET 8.0"
          }
        ],
        "environmentDetails": "Reporter 1: Windows 11 Pro ARM CPU (23H2 build 22631), .NET 9.0, Avalonia UI 11.3.6, SkiaSharp 3.116.0. Reporter 2: Windows, .NET 8.0, NUnit tests, netstandard2.0 library, x86 target."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "The bug was reported against SkiaSharp 3.116.0 (current release line). The second reporter confirmed it still occurs with .NET 8.0. No fix has been mentioned in the thread. x86 support is still part of the NativeAssets.Win32 package matrix.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.90,
        "reason": "This is a confirmed regression with a stack trace pointing to a P/Invoke calling convention or stack corruption issue on x86. Two independent reporters confirm the same pattern. Needs engineering investigation of the x86 native binary and P/Invoke signatures in SkiaSharp 3.x.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "missingInfo": [
          "sample-project"
        ],
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "request-info",
        "confidence": 0.80,
        "reason": "The stack trace from the second reporter is very helpful, but a minimal reproduction project would help isolate whether this is a calling convention issue, a native binary loading issue, or something specific to the DLL-from-subdirectory loading scenario.",
        "draft": "Thanks for the detailed report, and @TomPMoleman thanks for confirming with the stack trace \u2014 that\u0027s very useful. The stack overflow at \u0060sk_bitmap_get_pixel_color\u0060 on x86 with .NET 8/9 looks like it could be a calling convention mismatch in the P/Invoke layer that was reworked for SkiaSharp 3.x.\n\nThe x86-only nature of this is a strong signal \u2014 on x64, calling convention differences are largely irrelevant (everything uses the same convention), but on x86, a cdecl/stdcall mismatch can corrupt the stack and cause exactly this kind of overflow.\n\nWould either of you be able to share a minimal reproduction project? Even a simple console app that calls one SkiaSharp API and crashes on x86 would be enough to investigate. That would help us pin down whether this is a general x86 P/Invoke issue or specific to certain loading scenarios."
      },
      "analysisNotes": {
        "summary": "Two independent reporters confirm SkiaSharp 3.116\u002B crashes on Windows x86 with a stack overflow at the P/Invoke boundary. The crash does not occur on x64, and rolling back to 2.88.9 resolves it. The stack trace points to sk_bitmap_get_pixel_color, suggesting a possible calling convention mismatch introduced in the SkiaSharp 3.x P/Invoke rework.",
        "keySignals": [
          {
            "text": "when we compile the application for x86 then we are getting app crash (no event log, no dump)",
            "source": "body",
            "interpretation": "Hard crash specific to x86 architecture, no managed exception \u2014 indicates native-level issue",
            "supportedFields": [
              "type",
              "bugSignals.severity",
              "platforms"
            ]
          },
          {
            "text": "When we rollback the SkiaSharp nuget to version 2.88.9 then DLLs loading from subdirectory also work as expected (x64, x86)",
            "source": "body",
            "interpretation": "Confirms regression from v2.88.9 to v3.116.0. Something changed in the native layer or P/Invoke signatures.",
            "supportedFields": [
              "type",
              "regression"
            ]
          },
          {
            "text": "when we copy the DLLs from subdirectory to application root directory then the app crash is gone",
            "source": "body",
            "interpretation": "On x86, DLL loading from subdirectory fails but works from root. Could indicate native DLL search path issue specific to x86.",
            "supportedFields": [
              "area",
              "bugSignals"
            ]
          },
          {
            "text": "Stack overflow. at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color(IntPtr, Int32, Int32)",
            "source": "comment 2",
            "interpretation": "Stack overflow at P/Invoke entry point. On x86, this pattern is consistent with a calling convention mismatch causing infinite recursion or stack corruption.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity"
            ]
          },
          {
            "text": "x86 \u002B net472: working, x64 \u002B net472: working, x86 \u002B Net8.0: ISSUE, x64 \u002B Net8.0: working",
            "source": "comment 2",
            "interpretation": "Matrix confirms the issue is specifically x86 \u002B modern .NET (8.0\u002B). net472 x86 works, suggesting the .NET runtime\u0027s P/Invoke handling changed or SkiaSharp\u0027s declarations changed.",
            "supportedFields": [
              "type",
              "platforms",
              "regression"
            ]
          },
          {
            "text": "Microsoft Windows 11 Pro (ARM CPU)",
            "source": "body",
            "interpretation": "Original reporter is on ARM Windows running x86 emulation, which adds another variable \u2014 x86 emulation on ARM may have different P/Invoke behavior.",
            "supportedFields": [
              "platforms"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Two reporters describe hard crashes (stack overflow, process termination) when calling SkiaSharp APIs on x86. This is clearly broken behavior, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Not asking how to do something \u2014 reporting a crash that prevents usage entirely."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "The stack overflow occurs at the P/Invoke boundary (SkiaApi.sk_bitmap_get_pixel_color), which is the interface between the managed SkiaSharp assembly and the native libSkiaSharp binary. The architecture-specific nature (x86 only) and the DLL loading path dependency point to a native binary or P/Invoke declaration issue rather than managed code.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "While SkiaSharp managed code contains the P/Invoke declarations, the root cause is likely in the native binary\u0027s calling convention or the x86-specific binary itself."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "Both reporters are on Windows using classic .NET (not WinUI/UWP). The original reporter uses Avalonia (not a MAUI/WinUI app). Already labeled os/Windows-Classic."
          },
          {
            "field": "tenets",
            "chosen": "reliability",
            "expandedReason": "Hard crash with no recovery \u2014 the process is terminated. This is the definition of a reliability issue."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Hard crash that terminates the process on a supported platform configuration (Windows x86). Workarounds exist (use x64 or downgrade) but are not viable for applications that must target x86. Not critical because workarounds exist for most users.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "Workarounds exist (x64, downgrade to 2.88.9). x86 is a diminishing use case. Not data loss or security."
              },
              {
                "value": "medium",
                "whyRejected": "A hard crash that prevents any SkiaSharp usage on a supported architecture is more severe than medium."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Confirmed regression with stack trace, two independent reporters. Needs engineering investigation into the x86 P/Invoke declarations and native binary in SkiaSharp 3.x. Cannot be closed without a fix or definitive root cause.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "While a repro project would help, the stack trace from the second reporter already provides strong diagnostic signal. The issue is real and confirmed."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Checked NativeAssets.Win32 package details \u2014 confirms x86 is a supported architecture in the Win32 native package. The DLL-from-subdirectory loading issue could relate to native asset deployment paths.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked common traps section. \u0027AccessViolationException / hard crash\u0027 pattern mentions memory management bugs, but this is a stack overflow which is more consistent with calling convention issues. Also noted Windows ARM64 \u002B VC\u002B\u002B Redistributable quirk, relevant since original reporter is on ARM Windows.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Field definitions and allowed values for all classification fields.",
            "usedFor": [
              "type",
              "area",
              "platforms",
              "tenets",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated JSON output format and confidence scoring.",
            "usedFor": [
              "type",
              "area",
              "bugSignals",
              "actionability"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult rendering backend docs or WASM docs \u2014 no GPU/backend or WASM signals in this issue. Did not consult API XML docs \u2014 the issue is at the native/P/Invoke level, not API misuse.",
        "uncertainties": [
          "Is the stack overflow caused by a calling convention mismatch (cdecl vs stdcall) on x86, or by infinite recursion in native code?",
          "Does the original reporter\u0027s ARM Windows \u002B x86 emulation scenario add a unique dimension, or is it the same root cause as the second reporter\u0027s native x86?",
          "Is the DLL-from-subdirectory loading issue related to the stack overflow, or are these two separate x86 bugs?",
          "Does this affect all SkiaSharp 3.x P/Invoke calls on x86, or only specific functions like sk_bitmap_get_pixel_color?"
        ],
        "assumptions": [
          "Assumed the second reporter\u0027s stack trace (sk_bitmap_get_pixel_color stack overflow) is representative of the same root cause as the original reporter\u0027s crash, despite different reproduction scenarios.",
          "Assumed x86 is still a supported target for SkiaSharp 3.x based on NativeAssets.Win32 including x86 binaries."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "SkiaSharp 3.x introduced a P/Invoke calling convention change or native binary issue that causes stack corruption on x86. On x64 Windows, there is only one calling convention so mismatches are harmless. On x86, cdecl/stdcall mismatches cause the caller or callee to incorrectly manage the stack, leading to stack overflow. The DLL subdirectory loading issue may be a separate but related native resolution problem.",
        "researchDone": [
          "Analyzed stack trace from second reporter \u2014 stack overflow at SkiaApi.sk_bitmap_get_pixel_color P/Invoke boundary",
          "Reviewed packages.md \u2014 confirmed x86 is in NativeAssets.Win32 supported architecture matrix",
          "Reviewed skia-patterns.md \u2014 checked Windows platform quirks and common crash patterns",
          "Searched for similar x86 crash issues \u2014 no exact duplicates found",
          "Analyzed the version regression: 2.88.9 works, 3.116.0 crashes \u2014 SkiaSharp 3.x reworked P/Invoke layer significantly"
        ],
        "proposals": [
          {
            "title": "Investigate x86 P/Invoke calling conventions",
            "description": "Audit the P/Invoke declarations in SkiaSharp 3.x for x86 calling convention correctness. On x86, CallingConvention.Cdecl is typically correct for C APIs, but if the native library was built with stdcall or if the managed declarations are wrong, this would cause stack corruption.",
            "steps": [
              "Build a minimal x86 console app that calls sk_bitmap_get_pixel_color and confirm the stack overflow",
              "Compare P/Invoke declarations between SkiaSharp 2.88.9 and 3.116.0 for calling convention changes",
              "Check the native x86 libSkiaSharp.dll export table (dumpbin /exports) to verify calling convention",
              "If mismatch found, fix the generated P/Invoke declarations or native build configuration",
              "Run existing test suite with x86 target to verify fix"
            ],
            "pros": [
              "Addresses root cause directly",
              "Would fix all x86 P/Invoke calls, not just sk_bitmap_get_pixel_color",
              "Low risk \u2014 calling convention is a build/declaration setting"
            ],
            "cons": [
              "Requires access to x86 build environment to reproduce and verify",
              "If the issue is in generated code, may need to update the code generator"
            ],
            "confidence": 0.75,
            "effort": "medium"
          },
          {
            "title": "Verify x86 native binary integrity",
            "description": "Check whether the x86 native binary in NativeAssets.Win32 is correctly built and exported. The stack overflow could indicate a corrupt or misconfigured x86 binary rather than a calling convention issue.",
            "steps": [
              "Extract libSkiaSharp.dll (x86) from the NativeAssets.Win32 NuGet package",
              "Run dumpbin /exports and dumpbin /headers to verify architecture and exports",
              "Compare with the x64 binary to look for anomalies",
              "If binary is corrupt, rebuild with corrected build configuration"
            ],
            "pros": [
              "Quick diagnostic step",
              "Could identify build infrastructure issue"
            ],
            "cons": [
              "May not reveal the issue if the binary itself is correct but loading context matters",
              "Doesn\u0027t explain why DLL subdirectory loading changes behavior"
            ],
            "confidence": 0.60,
            "effort": "low"
          },
          {
            "title": "Investigate .NET x86 P/Invoke changes in .NET 8\u002B",
            "description": "Since the second reporter confirms x86\u002Bnet472 works but x86\u002Bnet8.0 crashes, investigate whether .NET 8\u0027s P/Invoke marshalling changes on x86 affect SkiaSharp. .NET 8 introduced source-generated P/Invoke which may have different x86 behavior.",
            "steps": [
              "Check if SkiaSharp 3.x uses LibraryImport (source-generated) vs DllImport for x86",
              "Test with DllImport fallback on x86 to see if crash disappears",
              "Review .NET 8 breaking changes related to x86 P/Invoke marshalling",
              "If LibraryImport is the cause, add x86-specific DllImport fallback or report to .NET runtime team"
            ],
            "pros": [
              "Could explain the net472-works / net8.0-crashes pattern",
              "LibraryImport x86 issues may be a known .NET runtime bug"
            ],
            "cons": [
              "May not be the cause \u2014 could be SkiaSharp-side changes, not .NET runtime changes",
              "Workaround (DllImport fallback) would reduce performance"
            ],
            "confidence": 0.65,
            "effort": "medium"
          }
        ],
        "recommendedProposal": "Investigate x86 P/Invoke calling conventions",
        "recommendedReason": "The stack overflow at the P/Invoke boundary is the strongest signal. On x86, calling convention mismatches are the most common cause of stack corruption. SkiaSharp 3.x reworked the P/Invoke layer, making this the most likely regression vector. This investigation would also cover the other proposals\u0027 hypotheses."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3375"
    },
    {
      "schemaVersion": "1.0",
      "number": 3372,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-09-20T12:00:00Z",
      "summary": "Upgrade SkiaSharp.Views.WinUI to use Microsoft.WindowsAppSDK.WinUI 1.8 instead of the full metapackage",
      "type": {
        "value": "feature-request",
        "confidence": 0.97,
        "reason": "Filed via feature request template. Requests a new dependency configuration that doesn\u0027t exist today \u2014 switching from the Microsoft.WindowsAppSDK metapackage to the split Microsoft.WindowsAppSDK.WinUI package introduced in 1.8."
      },
      "area": {
        "value": "SkiaSharp.Views",
        "confidence": 0.95,
        "reason": "Directly about the SkiaSharp.Views.WinUI package and its csproj dependency on Microsoft.WindowsAppSDK. The change lives in source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-WinUI",
          "confidence": 0.97,
          "reason": "Explicitly about the WinUI 3 / WinAppSDK dependency in SkiaSharp.Views.WinUI."
        }
      ],
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.8,
          "reason": "Changing the minimum WinAppSDK dependency from 1.4 to 1.8 affects compatibility \u2014 consumers on older WinAppSDK versions would need to upgrade. Discussion in comments highlights this tradeoff."
        }
      ],
      "partner": {
        "value": "maui",
        "confidence": 0.75,
        "reason": "Reporter (dotMorten) explicitly states MAUI\u0027s upgrade to WinAppSDK 1.8 for RC2 depends on SkiaSharp making this change first, as MAUI transitively depends on SkiaSharp.Views.WinUI."
      },
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": {
        "stepsToReproduce": [
          "Observe that SkiaSharp.Views.WinUI.csproj references Microsoft.WindowsAppSDK 1.4.230913002 (the full metapackage)",
          "Any project referencing SkiaSharp.Views.WinUI is forced to pull in the entire WinAppSDK metapackage transitively",
          "With WinAppSDK 1.8, Microsoft split the SDK into granular packages (e.g. Microsoft.WindowsAppSDK.WinUI) allowing consumers to take only what they need"
        ],
        "environmentDetails": "WinAppSDK 1.8\u002B, WinUI 3, .NET MAUI context"
      },
      "versionAnalysis": {
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "This is about the current SkiaSharp 3.x codebase. The Microsoft.WindowsAppSDK 1.4.230913002 metapackage dependency is still present in the main branch csproj."
      },
      "actionability": {
        "suggestedAction": "keep-open",
        "confidence": 0.85,
        "reason": "Valid feature request with ecosystem implications. Requires maintainer decision on whether the minimum WinAppSDK version bump from 1.4 to 1.8 is acceptable. Active discussion between dotMorten and jeromelaban (Uno Platform) shows the tradeoffs are real.",
        "requiresHumanReview": true,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "Feature request to change the WinAppSDK dependency in SkiaSharp.Views.WinUI from the full Microsoft.WindowsAppSDK metapackage (1.4) to the granular Microsoft.WindowsAppSDK.WinUI package (1.8). This reduces transitive dependency bloat for the entire downstream ecosystem including .NET MAUI. Active community debate on the compatibility vs dependency-reduction tradeoff.",
        "keySignals": [
          {
            "text": "upgrade the WinUI package to reference Microsoft.WindowsAppSDK.WinUI 1.8, so that it no longer relies on the Microsoft.WindowsAppSDK metapackage",
            "source": "body",
            "interpretation": "Core request: switch from metapackage to granular WinUI-only package. This is a dependency management improvement, not a functional change.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "force you and any other library that depends on Skia (like .NET MAUI) to pull in the entire metapackage",
            "source": "body",
            "interpretation": "The metapackage dependency is viral \u2014 it cascades through the dependency graph, forcing all consumers to take the full WinAppSDK. This explains why the request has ecosystem-wide impact.",
            "supportedFields": [
              "partner",
              "tenets"
            ]
          },
          {
            "text": "This kind of change has always strings attached, as it requires all consumers to upgrade to the latest.",
            "source": "comment 2",
            "interpretation": "jeromelaban (Uno Platform contributor) raises valid concern: bumping minimum WinAppSDK from 1.4 to 1.8 forces all consumers to upgrade. This is the key tradeoff the maintainer needs to evaluate.",
            "supportedFields": [
              "tenets",
              "actionability"
            ]
          },
          {
            "text": "1.8 upgrade is planned for RC2, but it can\u0027t be done right without this.",
            "source": "comment 5",
            "interpretation": "dotMorten indicates MAUI\u0027s planned 1.8 upgrade for .NET 10 RC2 is blocked on SkiaSharp making this change first, since SkiaSharp is lower in the dependency stack.",
            "supportedFields": [
              "partner",
              "actionability"
            ]
          },
          {
            "text": "PackageReference Include=\u0022Microsoft.WindowsAppSDK\u0022 Version=\u00221.4.230913002\u0022",
            "source": "codebase research",
            "interpretation": "Confirmed the current dependency in source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj is the full metapackage at version 1.4.",
            "supportedFields": [
              "area"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "feature-request",
            "expandedReason": "Filed via the feature request template with [FEATURE] prefix. Requests a dependency configuration that doesn\u0027t exist today in SkiaSharp. While the end effect is improving existing functionality, the mechanism (switching to a new split package) constitutes a new capability in the packaging.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "Could be considered an improvement to existing functionality, but the feature-request label was already applied and the change introduces a new package dependency rather than improving an existing API."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views",
            "expandedReason": "The change is specifically in the SkiaSharp.Views.WinUI project. The csproj file that needs modification is source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj."
          },
          {
            "field": "platforms",
            "chosen": "Windows-WinUI",
            "expandedReason": "Exclusively about the WinUI 3 platform and WinAppSDK dependency. No other platforms are affected."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "Bumping the minimum WinAppSDK version from 1.4 to 1.8 is a compatibility decision. Consumers on WinAppSDK 1.4-1.7 would need to upgrade. jeromelaban explicitly raised this concern.",
            "alternatives": [
              {
                "value": "performance",
                "whyRejected": "While reducing dependency size could be framed as a build/restore performance improvement, the primary concern is compatibility and dependency management."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "maui",
            "expandedReason": "dotMorten explicitly states .NET MAUI depends on SkiaSharp and that MAUI\u0027s planned 1.8 upgrade for RC2 is blocked on this change. The MAUI team needs SkiaSharp to move first in the dependency stack."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a valid, well-argued feature request with active discussion. It requires a maintainer decision balancing reduced dependency footprint against minimum version bump. Neither close nor investigation is appropriate \u2014 it needs a product decision.",
            "alternatives": [
              {
                "value": "needs-investigation",
                "whyRejected": "The change itself is well-understood (swap one PackageReference). The decision is about policy/tradeoffs, not technical investigation."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj",
            "relevance": "Confirmed current dependency is Microsoft.WindowsAppSDK 1.4.230913002 (full metapackage). This is the exact file that would need to change.",
            "usedFor": [
              "area",
              "resolutionAnalysis"
            ]
          }
        ],
        "docsNotConsulted": "No rendering/backend docs needed \u2014 this is purely a packaging/dependency issue. No native loading diagnostics needed \u2014 no DllNotFoundException. No Skia patterns reference needed \u2014 no platform quirks involved.",
        "uncertainties": [
          "Whether WinAppSDK 1.8 split packages are fully stable and supported for library authors (vs app developers)",
          "Whether there are any API surface differences between the metapackage and the split WinUI package that SkiaSharp.Views.WinUI relies on",
          "Whether the native WinUI C\u002B\u002B/WinRT projection (native/winui/) also has dependencies that would need updating",
          "The exact impact on Uno Platform consumers who also reference SkiaSharp.Views.WinUI"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "SkiaSharp.Views.WinUI currently depends on the full Microsoft.WindowsAppSDK 1.4 metapackage, but only needs the WinUI subset. With WinAppSDK 1.8 splitting packages, the dependency can be narrowed to just Microsoft.WindowsAppSDK.WinUI, reducing transitive dependency bloat for the entire downstream ecosystem.",
        "researchDone": [
          "Examined source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj \u2014 confirmed Microsoft.WindowsAppSDK 1.4.230913002 metapackage reference",
          "Searched for all WindowsAppSDK references across the repository \u2014 samples also reference 1.4.x",
          "Reviewed issue discussion between dotMorten and jeromelaban for ecosystem context",
          "Checked for duplicate or related issues \u2014 none found"
        ],
        "proposals": [
          {
            "title": "Switch to Microsoft.WindowsAppSDK.WinUI 1.8",
            "description": "Replace the Microsoft.WindowsAppSDK metapackage reference with Microsoft.WindowsAppSDK.WinUI 1.8 in the SkiaSharp.Views.WinUI csproj. This is the exact change the reporter requests.",
            "steps": [
              "In source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj, replace \u003CPackageReference Include=\u0022Microsoft.WindowsAppSDK\u0022 Version=\u00221.4.230913002\u0022 /\u003E with \u003CPackageReference Include=\u0022Microsoft.WindowsAppSDK.WinUI\u0022 Version=\u00221.8.x\u0022 /\u003E",
              "Update native/winui project references if they also depend on the metapackage",
              "Update sample projects to use consistent WinAppSDK version",
              "Build and test on Windows to verify no missing APIs",
              "Verify native WinUI projection still works with the split package"
            ],
            "pros": [
              "Eliminates forced metapackage dependency for all downstream consumers",
              "Unblocks MAUI and other ecosystem libraries to cleanly adopt WinAppSDK 1.8",
              "Reduces NuGet restore size and build complexity for consumers"
            ],
            "cons": [
              "Forces minimum WinAppSDK 1.8 for all SkiaSharp.Views.WinUI consumers",
              "May break consumers still on WinAppSDK 1.4-1.7",
              "Needs validation that the split WinUI package provides all needed APIs"
            ],
            "confidence": 0.85,
            "effort": "medium"
          },
          {
            "title": "Use conditional PackageReference with version range",
            "description": "Use MSBuild conditions to reference the split WinUI package when available (1.8\u002B) but fall back to the metapackage for older versions. This preserves backward compatibility.",
            "steps": [
              "Add version detection logic in the csproj or a targets file",
              "Reference Microsoft.WindowsAppSDK.WinUI when 1.8\u002B is resolved, else Microsoft.WindowsAppSDK",
              "Test both code paths",
              "Document the behavior change"
            ],
            "pros": [
              "Maintains backward compatibility with WinAppSDK \u003C 1.8",
              "Allows gradual migration"
            ],
            "cons": [
              "Adds build complexity",
              "Difficult to implement cleanly with NuGet \u2014 package references are static",
              "May not actually be feasible with NuGet\u0027s resolution model"
            ],
            "confidence": 0.35,
            "effort": "high"
          },
          {
            "title": "Wait for next major SkiaSharp release to bump minimum",
            "description": "Keep the current metapackage reference for now and make the switch as part of the next major SkiaSharp release where breaking dependency changes are expected.",
            "steps": [
              "Track this issue for the next major version milestone",
              "Make the dependency switch alongside other breaking changes",
              "Communicate the minimum WinAppSDK version bump in release notes"
            ],
            "pros": [
              "No compatibility impact on current consumers",
              "Aligns with semver expectations \u2014 major versions can change dependencies",
              "Gives ecosystem time to adopt WinAppSDK 1.8 naturally"
            ],
            "cons": [
              "Delays the ecosystem benefit",
              "May block MAUI .NET 10 RC2 timeline if SkiaSharp doesn\u0027t move first",
              "WinAppSDK 1.4 is already quite old"
            ],
            "confidence": 0.7,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Switch to Microsoft.WindowsAppSDK.WinUI 1.8",
        "recommendedReason": "The direct switch is the cleanest approach and addresses the reporter\u0027s request fully. WinAppSDK 1.4 is old enough that requiring 1.8 is reasonable, especially given the MAUI .NET 10 timeline. The conditional approach is impractical with NuGet, and waiting delays ecosystem-wide benefits."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3372"
    },
    {
      "schemaVersion": "1.0",
      "number": 3365,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-07-25T12:00:00Z",
      "summary": "libSkiaSharp.dll has hard link-time dependency on d3d12.dll causing crashes on Windows 10 systems without DX12",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Reporter describes hard crashes on 0.1% of 1 million installations due to d3d12.dll link-time dependency. This is a clear defect \u2014 the native binary should dynamically load DX12, not statically link it."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.95,
        "reason": "The issue is a link-time dependency in the native libSkiaSharp.dll binary on d3d12.dll. This is a native build configuration issue, not a managed code problem."
      },
      "backends": [
        {
          "value": "Direct3D",
          "confidence": 0.92,
          "reason": "The d3d12.dll dependency was introduced to support Direct3D 12 rendering in Skia. The issue is that this backend\u0027s dependency is statically linked rather than dynamically loaded."
        }
      ],
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.95,
          "reason": "Reporter explicitly states this is a Win32 legacy app on Windows 10. Labels include os/Windows-Classic."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Hard crashes on systems without DX12 support. Reporter quantifies impact at 0.1% of 1M installations."
        },
        {
          "value": "compatibility",
          "confidence": 0.85,
          "reason": "Regression from 2.x to 3.x breaks backward compatibility with Windows 10 systems that lack DX12 drivers."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.90,
        "reason": "Reporter states last known good version is 2.88.9 and the issue appeared in 3.116.0. Issue #3267 pinpoints the regression to 3.119.0-preview.1.2 when D3D12 support was added.",
        "workedInVersion": "2.88.9",
        "brokeInVersion": "3.116.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "net8.0-windows"
        ],
        "severity": "critical",
        "severityReason": "Hard crash at DLL load time with no workaround. Affects 0.1% of a 1 million user base (~1000 users). The crash occurs before any SkiaSharp API is called, making it impossible to catch or work around in managed code."
      },
      "reproEvidence": {
        "relatedIssues": [
          3267
        ],
        "stepsToReproduce": [
          "Install SkiaSharp 3.116.0 (or later) in a Win32 application",
          "Deploy to a Windows 10 system that does not have d3d12.dll (systems without DX12 support or missing Windows updates)",
          "Launch the application \u2014 it crashes on native library load due to missing d3d12.dll dependency"
        ],
        "codeSnippets": [
          {
            "language": "csharp",
            "code": "// From related issue #3267 - minimal repro\nusing SkiaSharp;\nnamespace SkiaSharpCrashTest\n{\n   internal class Program\n   {\n      static void Main(string[] args)\n      {\n         Console.WriteLine(\u0022Before\u0022);\n         var fontMgr = SKFontManager.Default;\n         Console.WriteLine(\u0022After\u0022);\n      }\n   }\n}",
            "context": "Minimal reproduction from related issue #3267 \u2014 any code that triggers libSkiaSharp.dll loading will crash on systems without d3d12.dll."
          }
        ],
        "environmentDetails": "Windows 10 (not fully updated, lacking DX12 support). SkiaSharp 3.116.0. Legacy Win32 application. Sample of ~1 million installations with 0.1% crash rate."
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "2.88.9"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "Issue is reported on current version 3.116.0 and the D3D12 dependency is still present in the latest builds. The root cause (static linking of d3d12.dll) has not been addressed.",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.85,
        "reason": "While this is related to #3267, it provides additional data (0.1% of 1M installations on Windows 10 vs Win7). The core issue \u2014 that d3d12.dll should be dynamically loaded rather than statically linked \u2014 needs engineering investigation in the Skia build configuration. This is not a simple duplicate since it demonstrates the issue affects modern Windows 10 systems, not just legacy Win7.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.80,
        "reason": "The issue is well-understood and related to #3267. A response acknowledging the problem and linking it to the existing tracking issue would be appropriate.",
        "draft": "Thanks for the detailed report and the deployment scale data \u2014 knowing this affects ~0.1% of 1M installations on Windows 10 specifically is valuable context.\n\nThis is the same root cause as #3267: \u0060libSkiaSharp.dll\u0060 has a static (link-time) dependency on \u0060d3d12.dll\u0060 since D3D12 rendering support was added in SkiaSharp 3.x. On systems where \u0060d3d12.dll\u0060 isn\u0027t present \u2014 whether Win7 or Windows 10 without the necessary updates \u2014 the DLL fails to load entirely.\n\nThe fix would need to happen at the Skia build level, changing the D3D12 dependency from a static import to a runtime \u0060LoadLibrary\u0060/\u0060GetProcAddress\u0060 pattern so Skia can gracefully fall back when D3D12 isn\u0027t available.\n\nI\u0027m linking this to #3267 as the canonical tracking issue since the resolution would be the same. Your data about Windows 10 impact is a helpful addition to that issue."
      },
      "analysisNotes": {
        "summary": "This is a bug where libSkiaSharp.dll has a hard link-time dependency on d3d12.dll introduced when D3D12 rendering support was added in SkiaSharp 3.x. Systems without DX12 (certain Windows 10 configurations and Windows 7) crash on DLL load. This is closely related to #3267 which reports the identical root cause on Windows 7.",
        "keySignals": [
          {
            "text": "There is a hard dependency on DX12 in the latest versions of SkiaSharp",
            "source": "body",
            "interpretation": "Reporter identifies the root cause as a static/link-time dependency on d3d12.dll rather than a dynamic/runtime load. This points to a native build configuration issue.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity"
            ]
          },
          {
            "text": "out of a sample of 1 million installations around 0.1% are crashing because their systems don\u0027t have DX12",
            "source": "body",
            "interpretation": "Quantified real-world impact: ~1000 affected users. This elevates severity to critical \u2014 it\u0027s a hard crash affecting a measurable production user base.",
            "supportedFields": [
              "bugSignals.severity",
              "actionability"
            ]
          },
          {
            "text": "porting one of our legacy Win32 apps to use SkiaSharp",
            "source": "body",
            "interpretation": "Confirms Windows-Classic platform (Win32/WPF/WinForms), not WinUI or UWP.",
            "supportedFields": [
              "platforms"
            ]
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9",
            "source": "body",
            "interpretation": "Confirms this is a regression from the 2.x to 3.x transition, when D3D12 support was added to the Skia build.",
            "supportedFields": [
              "regression"
            ]
          },
          {
            "text": "While this is in reference to Windows 7, all of our crashes occur on Windows 10",
            "source": "comment 3",
            "interpretation": "Reporter distinguishes their issue from #3267 by noting it affects Windows 10, not just Win7. Same root cause but broader impact than originally thought.",
            "supportedFields": [
              "platforms",
              "actionability"
            ]
          },
          {
            "text": "the common theme is that they\u0027re on systems that don\u0027t support DX12... and the resolution would be the same. So this is still a duplicate.",
            "source": "comment 4",
            "interpretation": "Community member confirms same root cause as #3267. While technically a duplicate, #3365 adds valuable scale data.",
            "supportedFields": [
              "actionability"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The issue describes a hard crash caused by a static dependency on d3d12.dll in the native binary. This is clearly broken behavior \u2014 the library should gracefully handle missing DX12 support rather than failing to load entirely."
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "The issue is in the native binary build configuration \u2014 d3d12.dll is a link-time import in libSkiaSharp.dll. This is a native build/linking issue, not a managed code or views issue.",
            "alternatives": [
              {
                "value": "SkiaSharp",
                "whyRejected": "The core managed library is not the problem \u2014 it\u0027s the native binary\u0027s link-time dependency."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "Direct3D",
            "expandedReason": "The d3d12.dll dependency exists because Skia added Direct3D 12 rendering backend support. The fix involves making this backend\u0027s dependency optional at the native level."
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "Reporter explicitly describes a legacy Win32 app on Windows 10. The os/Windows-Classic label was already applied by the automated triage."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "critical",
            "expandedReason": "Hard crash at DLL load time with no managed-code workaround. Quantified impact of ~1000 affected users (0.1% of 1M). The crash prevents any SkiaSharp functionality from being used, and there is no way to catch or handle it in application code.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "The inability to work around the crash in managed code and the quantified production impact elevate this beyond \u0027high\u0027 to \u0027critical\u0027."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "While closely related to #3267, the fix requires engineering work in the Skia build configuration to change d3d12.dll from a static import to a dynamic load. This hasn\u0027t been addressed yet and the issue remains open.",
            "alternatives": [
              {
                "value": "close-as-duplicate",
                "whyRejected": "While the root cause is identical to #3267, this issue adds significant value with real-world scale data (1M installations, 0.1% affected on Win10). A community member suggested closing as duplicate, but the additional context is worth preserving."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked Windows platform quirks section. No specific guidance on d3d12.dll dependency, but confirmed this is a native binary issue pattern.",
            "usedFor": [
              "area",
              "platforms"
            ]
          },
          {
            "path": "references/triage-schema.json",
            "relevance": "Field definitions and allowed values for all classification fields.",
            "usedFor": [
              "type",
              "area",
              "backends",
              "platforms",
              "tenets",
              "bugSignals"
            ]
          },
          {
            "path": "references/triage-examples.md",
            "relevance": "Calibrated JSON output format and confidence scoring.",
            "usedFor": [
              "type",
              "bugSignals",
              "actionability"
            ]
          },
          {
            "path": "references/response-guidelines.md",
            "relevance": "Tone and structure guidance for the suggested response draft.",
            "usedFor": [
              "suggestedResponse"
            ]
          }
        ],
        "docsNotConsulted": "Did not consult documentation/packages.md since this is not a deployment/NativeAssets selection issue \u2014 the correct binary is deployed, it just has an unwanted static dependency. Did not consult API docs since no specific SkiaSharp API is involved.",
        "uncertainties": [
          "Exact Windows 10 build numbers affected \u2014 likely systems missing specific Windows Updates that provide d3d12.dll",
          "Whether the Skia upstream has already addressed this with delayed/dynamic loading of D3D12, or if this requires a SkiaSharp-specific build change",
          "Whether the version discrepancy matters \u2014 reporter says 3.116.0 but #3267 pinpoints 3.119.0-preview.1.2 as the introduction point"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s version 3.116.0 is correct and that D3D12 support may have been added earlier than the 3.119.0-preview.1.2 noted in #3267, or the reporter may be imprecise about when the issue was introduced",
          "Assumed targetFramework is net8.0-windows based on \u0027legacy Win32 app\u0027 and modern SkiaSharp 3.x usage, though reporter did not explicitly state this"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The Skia build configuration statically imports d3d12.dll, causing the Windows loader to fail when that DLL is absent. The fix requires changing the D3D12 dependency from a load-time import to a runtime dynamic load (LoadLibrary/GetProcAddress pattern), allowing Skia to gracefully fall back to software rendering or other backends when D3D12 is unavailable.",
        "researchDone": [
          "Read issue #3267 \u2014 same root cause (d3d12.dll dependency), reported on Win7 with version 3.119.0-preview.1.2",
          "Checked issue comments \u2014 community member confirms same root cause, reporter adds Win10 impact data",
          "Reviewed skia-patterns.md for Windows-specific quirks and native loading heuristics",
          "Checked labels on both issues to confirm triage alignment"
        ],
        "proposals": [
          {
            "title": "Dynamic-load d3d12.dll in Skia build",
            "description": "Modify the Skia GN build to use delayed/dynamic loading of d3d12.dll instead of static imports. This is the proper fix \u2014 Skia should probe for DX12 availability at runtime and fall back gracefully.",
            "steps": [
              "Investigate Skia\u0027s GN build configuration for D3D12 linking (likely in skia/BUILD.gn or a Windows-specific .gni file)",
              "Change d3d12.lib from a direct link dependency to a delay-loaded DLL (/DELAYLOAD:d3d12.dll linker flag) or use LoadLibrary/GetProcAddress",
              "Ensure Skia\u0027s D3D12 backend initialization checks for DLL availability before attempting to use it",
              "Rebuild native libraries and test on a system without d3d12.dll to verify graceful fallback",
              "Run full test suite on systems with and without DX12"
            ],
            "pros": [
              "Addresses root cause \u2014 systems without DX12 will work with software rendering",
              "No breaking changes to the API surface",
              "Matches expected behavior described by reporter"
            ],
            "cons": [
              "Requires changes in the Skia build system which SkiaSharp maintains as a fork",
              "May need to be re-applied when updating the Skia upstream version",
              "Needs testing across multiple Windows versions"
            ],
            "confidence": 0.85,
            "effort": "medium"
          },
          {
            "title": "Disable D3D12 backend in SkiaSharp build",
            "description": "Turn off D3D12 backend entirely in the SkiaSharp Skia fork build, removing the d3d12.dll dependency. Users who need D3D12 can use GrContext with explicit D3D12 setup.",
            "steps": [
              "Set skia_use_direct3d=false (or equivalent) in the GN build args for Windows",
              "Rebuild native libraries",
              "Verify d3d12.dll is no longer in the import table (use dumpbin /imports)",
              "Test all existing functionality still works with software/OpenGL rendering"
            ],
            "pros": [
              "Simple build configuration change",
              "Eliminates the dependency entirely",
              "Low risk of breaking other functionality"
            ],
            "cons": [
              "Removes D3D12 rendering capability for all users",
              "May reduce rendering performance on systems where D3D12 was providing acceleration",
              "Would need to be re-evaluated when D3D12 support is desired"
            ],
            "confidence": 0.80,
            "effort": "low"
          },
          {
            "title": "Ship separate NativeAssets packages with and without D3D12",
            "description": "Provide two Windows native asset variants \u2014 one with D3D12 support and one without \u2014 allowing users to choose based on their target environment.",
            "steps": [
              "Create a new build configuration that excludes D3D12",
              "Publish as SkiaSharp.NativeAssets.Win32.NoDX12 or similar",
              "Document the package selection guidance in packages.md",
              "Default NativeAssets.Win32 could remain with D3D12 as delayed-load"
            ],
            "pros": [
              "Users targeting older Windows can opt out of DX12",
              "Users targeting modern Windows keep DX12 acceleration",
              "No functionality loss for either group"
            ],
            "cons": [
              "Increases package maintenance burden",
              "More confusing package selection for users",
              "Does not fix the root cause \u2014 the default package still crashes"
            ],
            "confidence": 0.60,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Dynamic-load d3d12.dll in Skia build",
        "recommendedReason": "This is the proper fix that addresses the root cause without removing functionality. Delay-loading or dynamic loading of d3d12.dll lets the library probe for DX12 at runtime and fall back gracefully, which is exactly what the reporter expects. It preserves D3D12 acceleration where available while being safe on systems without it."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3365"
    },
    {
      "schemaVersion": "1.0",
      "number": 3357,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2025-09-05T00:00:00Z",
      "summary": "Maintainer request to migrate XML API docs from docs folder into inline C# triple-slash comments",
      "type": {
        "value": "documentation",
        "confidence": 0.95,
        "reason": "The issue explicitly requests migrating API documentation from external XML files into inline C# source code comments. This is a documentation restructuring task."
      },
      "area": {
        "value": "Docs",
        "confidence": 0.98,
        "reason": "The issue is entirely about documentation migration. It already has the area/Docs label applied by the maintainer."
      },
      "backends": null,
      "platforms": null,
      "tenets": null,
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": null,
      "versionAnalysis": null,
      "actionability": {
        "suggestedAction": "keep-open",
        "confidence": 0.95,
        "reason": "This is an active work item created by the maintainer (mattleibow) and assigned to Copilot bot. It represents an ongoing documentation migration task with a defined checklist and guide.",
        "requiresHumanReview": false,
        "closeable": false,
        "closeReason": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "Maintainer-created work item to migrate XML API documentation from the docs/ folder into inline C# triple-slash comments in the source code. This is a structured documentation task with a guide, checklist, and clear rules (one type per commit, migrate all members).",
        "keySignals": [
          {
            "text": "Can you help migrate my docs from the docs folder into the c# source.",
            "source": "body",
            "interpretation": "This is a documentation migration request, not a bug or feature. The maintainer wants to move API docs from external XML files to inline code comments.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "There is a guide here: ~/API.Docs.Migration.Guide.md",
            "source": "body",
            "interpretation": "A structured migration guide already exists, indicating this is a well-planned documentation task with established procedures.",
            "supportedFields": [
              "type",
              "actionability"
            ]
          },
          {
            "text": "This is the checklist of APIs to migrate: ~/API.Docs.Migration.Checklist.md",
            "source": "body",
            "interpretation": "A checklist exists tracking which APIs need migration, confirming this is a multi-step ongoing task.",
            "supportedFields": [
              "actionability"
            ]
          },
          {
            "text": "Each type should be migrated and commited separately.",
            "source": "body",
            "interpretation": "Clear process constraint: one type per commit for review purposes. This shapes how the work should be executed.",
            "supportedFields": [
              "actionability"
            ]
          },
          {
            "text": "area/Docs label applied by maintainer",
            "source": "labels",
            "interpretation": "Maintainer explicitly categorized this as a documentation issue.",
            "supportedFields": [
              "area"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "documentation",
            "expandedReason": "The issue is entirely about migrating API documentation from one format/location to another. There is no broken behavior, no feature request, and no question being asked. It is a documentation restructuring task.",
            "alternatives": [
              {
                "value": "enhancement",
                "whyRejected": "While moving docs inline could be seen as an improvement, the core activity is documentation work, not improving API functionality."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "Docs",
            "expandedReason": "The issue is about API documentation migration. The maintainer applied the area/Docs label. The work involves moving content from docs/ XML files into C# source files as triple-slash comments."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is an active, maintainer-created work item with a defined checklist. It is assigned to Copilot bot for execution. The task is ongoing and should remain open until the full checklist is completed.",
            "alternatives": [
              {
                "value": "needs-investigation",
                "whyRejected": "No investigation needed \u2014 the task is clearly defined with a guide and checklist."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/research-by-type.md",
            "relevance": "Checked documentation-type research guidance to confirm approach for docs issues.",
            "usedFor": [
              "type",
              "actionability"
            ]
          },
          {
            "path": "references/labels.md",
            "relevance": "Confirmed area/Docs is the correct label for documentation issues and type/documentation is the correct classification.",
            "usedFor": [
              "type",
              "area"
            ]
          }
        ],
        "docsNotConsulted": "No need to check packages.md, skia-patterns.md, or API XML docs since this is a documentation process issue, not a technical/API problem.",
        "uncertainties": [
          "The referenced files (API.Docs.Migration.Guide.md and API.Docs.Migration.Checklist.md) are at ~/path which may be relative \u2014 unclear how many types remain to migrate.",
          "Unclear whether any types have already been migrated or if this is the initial request."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The maintainer wants to consolidate API documentation by moving it from external XML files in the docs/ folder into inline triple-slash XML comments in the C# source code, following a defined guide and checklist.",
        "researchDone": [
          "Reviewed issue body for migration rules and constraints",
          "Checked labels and assignee for context on issue status",
          "Reviewed triage schema documentation type guidance"
        ],
        "proposals": [
          {
            "title": "Execute migration per checklist",
            "description": "Follow the API.Docs.Migration.Guide.md and work through the API.Docs.Migration.Checklist.md, migrating one type at a time with separate commits.",
            "steps": [
              "Read API.Docs.Migration.Guide.md for migration procedures",
              "Read API.Docs.Migration.Checklist.md for the list of types to migrate",
              "For each type: copy XML docs from docs/ into inline triple-slash comments in the C# source",
              "Commit each type separately with a descriptive commit message",
              "Mark each checklist item as complete"
            ],
            "pros": [
              "Follows maintainer\u0027s exact instructions",
              "One commit per type enables granular review",
              "Checklist provides clear tracking"
            ],
            "cons": [
              "Large number of commits if many types remain",
              "Manual process is time-consuming"
            ],
            "confidence": 0.95,
            "effort": "high"
          },
          {
            "title": "Automated migration script",
            "description": "Create a script to parse the docs/ XML files and inject triple-slash comments into the corresponding C# source files, then manually review and commit per type.",
            "steps": [
              "Parse docs/ XML structure to map types to C# files",
              "Generate triple-slash comments from XML content",
              "Insert into source files at correct positions",
              "Review each type\u0027s changes manually",
              "Commit per type as required"
            ],
            "pros": [
              "Faster for large numbers of types",
              "Consistent formatting"
            ],
            "cons": [
              "Script may need edge case handling",
              "Still requires manual review and per-type commits",
              "Maintainer specifically asked agents not to build/test"
            ],
            "confidence": 0.70,
            "effort": "medium"
          },
          {
            "title": "Prioritized partial migration",
            "description": "Migrate only the most commonly used types first, leaving less-used types for later.",
            "steps": [
              "Identify high-usage types from the checklist",
              "Migrate those first following the guide",
              "Commit each separately",
              "Continue with remaining types in priority order"
            ],
            "pros": [
              "Gets most-impactful docs migrated first",
              "Reduces initial scope"
            ],
            "cons": [
              "Maintainer explicitly said to go through each item \u2014 partial migration may not align with intent",
              "Prioritization adds overhead"
            ],
            "confidence": 0.50,
            "effort": "high"
          }
        ],
        "recommendedProposal": "Execute migration per checklist",
        "recommendedReason": "The maintainer provided explicit instructions: follow the guide, use the checklist, migrate one type at a time with separate commits, and do not skip any type or member. The straightforward execution approach best matches these requirements."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3357"
    },
    {
      "schemaVersion": "1.0",
      "number": 3346,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T21:13:00Z",
      "summary": "MAUI app crashes on Windows ARM64 when published as MSIX; installing VC\u002B\u002B Redistributable resolves it",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Reporter describes a crash in published builds on ARM64 Windows. Debug/Release builds work; only published executable crashes. This is broken behavior, not a usage question."
      },
      "area": {
        "value": "libSkiaSharp.native",
        "confidence": 0.82,
        "reason": "The crash is resolved by installing VC\u002B\u002B Redistributable, indicating the native binary (libSkiaSharp.dll or ANGLE libraries) has a dynamic dependency on the C\u002B\u002B runtime that isn\u0027t satisfied in a fresh ARM64 Windows deployment."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.95,
          "reason": "Reporter explicitly states Windows ARM64, tested on Windows 10 and 11. The MAUI WinUI target is Windows-specific."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Application crashes immediately on launch in published builds \u2014 a fundamental reliability failure."
        }
      ],
      "partner": {
        "value": "maui",
        "confidence": 0.75,
        "reason": "The repro project is a .NET MAUI app using SkiaSharp.Views.Maui.Controls. The MSIX packaging and ANGLE rendering surface are MAUI/WinUI concerns that may contribute to the issue."
      },
      "regression": null,
      "fixStatus": {
        "likelyFixed": false,
        "confidence": 0.55,
        "reason": "Maintainer mattleibow asked about GPU rendering and mentioned \u0027trying to release a fix for that\u0027, suggesting a related fix is in progress. However, the repro uses SKCanvasView (CPU rendering), so the GPU fix may not fully address this issue. The VC\u002B\u002B Redistributable dependency suggests a native build configuration issue that may require separate attention."
      },
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": false,
        "reproQuality": "complete",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Install Microsoft Visual C\u002B\u002B Redistributable on the target ARM64 Windows machine before running the published app.",
        "targetFrameworks": [
          "net9.0-windows10.0.19041.0"
        ],
        "severity": "medium",
        "severityReason": "Crash on published builds is severe, but a workaround exists (installing VC\u002B\u002B Redistributable). The issue is specific to ARM64 Windows published deployments, which is a narrower audience."
      },
      "reproEvidence": {
        "repoLinks": [
          {
            "url": "https://github.com/riccardomartins/ArmDemoTryout",
            "description": ".NET MAUI app demonstrating the ARM64 Windows crash. Uses SkiaSharp.Views.Maui.Controls 3.119.0 and Svg.Skia 3.0.6 with MSIX packaging."
          }
        ],
        "relatedIssues": [
          3155,
          136
        ],
        "stepsToReproduce": [
          "Clone https://github.com/riccardomartins/ArmDemoTryout",
          "Open in Visual Studio on a Windows ARM64 machine",
          "Build and run in Debug or Release mode \u2014 works fine",
          "Publish the app as MSIX for Windows ARM64",
          "Run the published executable on a fresh ARM64 Windows machine without VC\u002B\u002B Redistributable installed",
          "App starts and crashes immediately"
        ],
        "codeSnippets": [
          {
            "language": "xml",
            "code": "\u003CPackageReference Include=\u0022SkiaSharp.Views.Maui.Controls\u0022 Version=\u00223.119.0\u0022 /\u003E\n\u003CPackageReference Include=\u0022Svg.Skia\u0022 Version=\u00223.0.6\u0022 /\u003E",
            "context": "Project dependencies from the repro csproj. Uses MAUI with MSIX packaging (WindowsPackageType=MSIX)."
          }
        ],
        "environmentDetails": "Windows 10 and 11 ARM64, Visual Studio (Windows), SkiaSharp 3.116.0 (reported) / 3.119.0 (in csproj), .NET 9, MSIX packaging"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "3.116.0",
          "3.119.0"
        ],
        "era": "modern",
        "currentRelevance": "likely",
        "reason": "The issue is reported against 3.116.0 but the repro project references 3.119.0, indicating it persists across recent versions. The VC\u002B\u002B Redistributable dependency on ARM64 is a build configuration issue that likely still exists in the latest builds."
      },
      "actionability": {
        "suggestedAction": "needs-investigation",
        "confidence": 0.85,
        "reason": "The VC\u002B\u002B Redistributable dependency on ARM64 Windows suggests the native library is not statically linking the C\u002B\u002B runtime for ARM64 builds. This was fixed for x86/x64 in issue #136 (v1.68.0) but may not have been applied to ARM64. Additionally, the ANGLE libraries from NativeAssets.WinUI may also contribute. The maintainer\u0027s in-progress GPU fix may partially address this, but the CPU rendering repro suggests it\u0027s a broader native linking issue.",
        "requiresHumanReview": false,
        "closeable": false
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.75,
        "reason": "The reporter\u0027s VC\u002B\u002B Redistributable finding is a strong diagnostic signal. The maintainer already asked about GPU rendering but hasn\u0027t addressed the VC\u002B\u002B dependency question. A response acknowledging the finding and explaining the situation would be helpful.",
        "draft": "Thanks for tracking that down \u2014 the VC\u002B\u002B Redistributable dependency is a really useful finding.\n\nTo answer your question: ideally, no, you shouldn\u0027t need to install the VC\u002B\u002B Redistributable separately. The native libraries should either statically link the C\u002B\u002B runtime or the MSIX package should include it.\n\nThis looks like it could be specific to the ARM64 build of the native libraries \u2014 the x64 builds have had static C\u002B\u002B runtime linking since v1.68.0, but the ARM64 build may not have the same configuration.\n\nA couple of things that would help narrow this down:\n- Are you using \u0060SKCanvasView\u0060 (CPU) or \u0060SKGLView\u0060 (GPU) in your app? (Looking at the repro code, it appears to be SKCanvasView.)\n- When you say \u0022crash immediately\u0022 \u2014 is there an exception in the Event Viewer or a crash dump? That would help pinpoint whether it\u0027s \u0060libSkiaSharp.dll\u0060 or one of the ANGLE libraries (\u0060libEGL.dll\u0060/\u0060libGLESv2.dll\u0060) that needs the runtime."
      },
      "analysisNotes": {
        "summary": "A .NET MAUI app using SkiaSharp crashes on Windows ARM64 when published as MSIX, but works in Debug/Release modes. The reporter discovered that installing VC\u002B\u002B Redistributable resolves the crash, indicating the native binaries have a dynamic dependency on the C\u002B\u002B runtime not satisfied on fresh ARM64 deployments. The maintainer asked about GPU rendering and mentioned a fix in progress, but the repro uses CPU rendering (SKCanvasView).",
        "keySignals": [
          {
            "text": "installing Microsoft Visual C\u002B\u002B Redistributable that app works correctly in a fresh arm64 windows",
            "source": "comment 2",
            "interpretation": "The native binary (libSkiaSharp.dll or ANGLE libraries) dynamically links to the C\u002B\u002B runtime rather than statically linking it. This is the root cause of the crash on fresh ARM64 systems.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity",
              "bugSignals.hasWorkaround"
            ]
          },
          {
            "text": "runs correctly in Debug and Release modes on Windows ARM64, but when creating a Publish build for Windows ARM64, the app starts but crashes immediately",
            "source": "body",
            "interpretation": "Debug/Release work because Visual Studio installs VC\u002B\u002B runtime. Published MSIX on a fresh system lacks it. The difference is deployment context, not code.",
            "supportedFields": [
              "type",
              "bugSignals.hasCrash",
              "platforms"
            ]
          },
          {
            "text": "Were you using the GPU rendering? If so, I am trying to release a fix for that.",
            "source": "comment 3",
            "interpretation": "Maintainer is aware of a related ARM64 GPU issue and has a fix in progress. However, the repro uses SKCanvasView (CPU), so the GPU fix may not fully resolve this.",
            "supportedFields": [
              "fixStatus"
            ]
          },
          {
            "text": "SKPaintSurfaceEventArgs in MainPage.xaml.cs",
            "source": "repro code",
            "interpretation": "The repro uses SKCanvasView (CPU rendering via SKPaintSurfaceEventArgs), not SKGLView. This means the GPU fix mattleibow mentioned may not address this issue.",
            "supportedFields": [
              "backends",
              "fixStatus"
            ]
          },
          {
            "text": "WindowsPackageType=MSIX and SkiaSharp.Views.Maui.Controls with WinUI target",
            "source": "repro csproj",
            "interpretation": "MAUI WinUI apps use ANGLE libraries (libEGL.dll, libGLESv2.dll from NativeAssets.WinUI) for the rendering surface. These ANGLE binaries may also require VC\u002B\u002B runtime.",
            "supportedFields": [
              "area",
              "partner"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "The app crashes immediately on published builds on ARM64 Windows. This is clearly broken behavior \u2014 published apps should work without manual VC\u002B\u002B runtime installation."
          },
          {
            "field": "area",
            "chosen": "libSkiaSharp.native",
            "expandedReason": "The crash is resolved by installing VC\u002B\u002B Redistributable, which points to the native binary build configuration. Either libSkiaSharp.dll ARM64 or the ANGLE libraries are dynamically linking the C\u002B\u002B runtime instead of statically linking it.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views.Maui",
                "whyRejected": "While the repro uses MAUI, the root cause is in the native binary packaging, not the managed MAUI view layer."
              },
              {
                "value": "Build",
                "whyRejected": "Build area would suggest a build system issue, but this is specifically about native library linking configuration for ARM64."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "Reported on Windows ARM64 (Windows 10 and 11). The os/Windows-Classic label is the correct match for Win32-based deployments."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "The crash is severe (app won\u0027t start), but the workaround is simple (install VC\u002B\u002B Redistributable) and the affected audience is narrow (ARM64 Windows published deployments only).",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "A workaround exists (VC\u002B\u002B Redistributable installation), which lowers severity from high to medium."
              },
              {
                "value": "low",
                "whyRejected": "An app crash preventing all functionality is more than cosmetic/minor, even with a workaround."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The VC\u002B\u002B Redistributable dependency on ARM64 needs investigation. Is it libSkiaSharp.dll or the ANGLE libraries? Was static linking intentionally omitted for ARM64? Is the maintainer\u0027s in-progress GPU fix sufficient? These questions need engineering investigation.",
            "alternatives": [
              {
                "value": "close-as-fixed",
                "whyRejected": "No fix has been released. The maintainer mentioned a fix in progress but hasn\u0027t confirmed it addresses this specific issue."
              },
              {
                "value": "request-info",
                "whyRejected": "The reporter provided a full repro project and identified the root cause (VC\u002B\u002B Redistributable). The reporter hasn\u0027t responded to the GPU rendering question, but there\u0027s enough info to investigate."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "maui",
            "expandedReason": "The repro is a MAUI app and the MSIX packaging is MAUI/WinUI-specific. The ANGLE libraries from NativeAssets.WinUI are part of the MAUI/WinUI rendering pipeline and may contribute to the VC\u002B\u002B dependency."
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed NativeAssets.Win32 is auto-included for Windows targets and NativeAssets.WinUI contains ANGLE libraries (libEGL.dll, libGLESv2.dll). Publishing modes section confirmed self-contained and MSIX packaging behavior.",
            "usedFor": [
              "area",
              "bugSignals"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Contains direct entry: \u0027ARM64 \u002B VC\u002B\u002B Redistributable \u2014 Published apps on ARM64 Windows may need VC\u002B\u002B Redistributable installed. Self-contained publish doesn\u0027t always include it.\u0027 This confirms it\u0027s a known pattern.",
            "usedFor": [
              "type",
              "area",
              "bugSignals"
            ]
          }
        ],
        "docsNotConsulted": "Did not check rendering/GPU documentation since the repro uses CPU rendering (SKCanvasView). Did not check Linux or container docs as this is a Windows-specific issue.",
        "uncertainties": [
          "Whether the crash is in libSkiaSharp.dll or the ANGLE libraries (libEGL.dll/libGLESv2.dll) from NativeAssets.WinUI \u2014 both could require VC\u002B\u002B runtime",
          "Whether the maintainer\u0027s in-progress GPU fix also addresses the VC\u002B\u002B runtime linking for CPU rendering scenarios",
          "The reporter says version 3.116.0 but the repro csproj shows 3.119.0 \u2014 unclear if the version discrepancy matters",
          "Whether the reporter responded to the GPU rendering question (no further comments after mattleibow\u0027s question \u2014 possible abandoned thread)"
        ],
        "assumptions": [
          "Assumed the SKCanvasView usage in the repro code represents the reporter\u0027s actual usage pattern, making this a CPU rendering issue not a GPU one",
          "Assumed the ARM64 native build configuration is the root cause since the same app works in Debug/Release (where VC\u002B\u002B runtime is available from VS)"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The ARM64 Windows build of libSkiaSharp.dll (or the ANGLE libraries from NativeAssets.WinUI) dynamically links the C\u002B\u002B runtime instead of statically linking it. When deployed via MSIX to a fresh ARM64 system, the C\u002B\u002B runtime isn\u0027t present, causing an immediate crash. Debug/Release from VS works because VS installs the VC\u002B\u002B runtime.",
        "researchDone": [
          "Reviewed repro project csproj \u2014 MAUI app with MSIX packaging, SkiaSharp.Views.Maui.Controls 3.119.0, Svg.Skia 3.0.6",
          "Reviewed repro MainPage.xaml.cs \u2014 uses SKCanvasView (CPU rendering via SKPaintSurfaceEventArgs), not GPU",
          "Checked issue #136 \u2014 static linking of C\u002B\u002B runtime was implemented in v1.68.0, but may not cover ARM64",
          "Checked issue #3155 \u2014 related ARM64 Windows issue with GRGlInterface.Create() returning null (GPU/OpenGL specific)",
          "Reviewed skia-patterns.md \u2014 documents ARM64 \u002B VC\u002B\u002B Redistributable as a known pattern",
          "Reviewed packages.md \u2014 confirmed NativeAssets.WinUI contains ANGLE libraries that could also need VC\u002B\u002B runtime"
        ],
        "proposals": [
          {
            "title": "Statically link C\u002B\u002B runtime for ARM64 Windows builds",
            "description": "Update the native build configuration to statically link the C\u002B\u002B runtime (/MT instead of /MD) for the ARM64 Windows target, matching what was done for x86/x64 in issue #136.",
            "steps": [
              "Check current ARM64 Windows build flags in the Skia build configuration (GN args)",
              "Verify if /MT (static CRT) or /MD (dynamic CRT) is used for ARM64",
              "If /MD, switch to /MT for ARM64 builds",
              "Rebuild native binaries and verify the published MSIX works without VC\u002B\u002B Redistributable"
            ],
            "pros": [
              "Eliminates the root cause",
              "Consistent with x86/x64 builds",
              "No user action required"
            ],
            "cons": [
              "Slightly larger native binary",
              "Need to verify ANGLE libraries don\u0027t also need the same fix"
            ],
            "confidence": 0.80,
            "effort": "medium"
          },
          {
            "title": "Include VC\u002B\u002B Redistributable in MSIX package",
            "description": "Configure the MSIX packaging to include the VC\u002B\u002B Redistributable merge modules or declare a dependency on the VC\u002B\u002B runtime framework package.",
            "steps": [
              "Add VC\u002B\u002B runtime dependency to the MSIX manifest",
              "Or include the VC\u002B\u002B merge modules in the MSIX package",
              "Document the approach for MAUI developers targeting ARM64 Windows"
            ],
            "pros": [
              "Doesn\u0027t require rebuilding native libraries",
              "Standard MSIX packaging approach"
            ],
            "cons": [
              "Pushes the fix to app developers rather than the library",
              "May not work for non-MSIX deployment scenarios",
              "Increases package size"
            ],
            "confidence": 0.60,
            "effort": "low"
          },
          {
            "title": "Workaround: Install VC\u002B\u002B Redistributable as prerequisite",
            "description": "Document that ARM64 Windows deployments require the VC\u002B\u002B Redistributable, and recommend including it in deployment scripts or installation prerequisites.",
            "steps": [
              "Document the ARM64 VC\u002B\u002B Redistributable requirement in the SkiaSharp deployment guide",
              "Add a note to the NativeAssets.Win32 package description",
              "Optionally add a runtime check that provides a helpful error message instead of a crash"
            ],
            "pros": [
              "Immediate solution for affected users",
              "No code changes needed"
            ],
            "cons": [
              "Doesn\u0027t fix the underlying issue",
              "Poor user experience",
              "Easy to miss in deployment planning"
            ],
            "confidence": 0.90,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Statically link C\u002B\u002B runtime for ARM64 Windows builds",
        "recommendedReason": "This is the proper fix that eliminates the dependency for all users. It\u0027s consistent with how x86/x64 builds were fixed in issue #136 and ensures ARM64 published apps work without additional prerequisites."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3346"
    },
    {
      "schemaVersion": "1.0",
      "number": 2511,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T21:30:00Z",
      "summary": "AccessViolationException in NonAlertableWin32Lock during finalizer when closing WinForms app",
      "type": {
        "value": "bug",
        "confidence": 0.95,
        "reason": "Stack trace shows AccessViolationException crash during object finalization \u2014 clearly broken behavior, not a usage question."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.90,
        "reason": "Crash is in HandleDictionary/PlatformLock infrastructure used by the core SkiaSharp library, not in a view-specific or platform-specific package."
      },
      "backends": null,
      "platforms": [
        {
          "value": "Windows-Classic",
          "confidence": 0.90,
          "reason": "Reporter says \u0027winform program\u0027 and the crash is in Win32 CRITICAL_SECTION, which is Windows-only. WinForms = Windows Classic."
        }
      ],
      "tenets": [
        {
          "value": "reliability",
          "confidence": 0.95,
          "reason": "Uncatchable crash (AccessViolationException) during process shutdown is a reliability issue."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.80,
        "reason": "The NonAlertableWin32Lock was introduced in v2.88.0 via PR #1817 to fix deadlocks (#1383). Issue #2194 confirms this crash started in v2.88.0 (worked in v2.80.4-preview.9). The crash cannot occur in older versions that used ReaderWriterLockSlim.",
        "workedInVersion": "2.80.4",
        "brokeInVersion": "2.88.0"
      },
      "fixStatus": null,
      "bugSignals": {
        "hasCrash": true,
        "hasStackTrace": true,
        "reproQuality": "steps-only",
        "hasScreenshot": false,
        "hasWorkaround": true,
        "workaroundSummary": "Explicitly dispose all SkiaSharp objects (using statements) instead of relying on the finalizer. This avoids the finalizer code path entirely.",
        "targetFrameworks": [
          "net48"
        ],
        "severity": "medium",
        "severityReason": "Crash during process shutdown \u2014 the application has already completed its work. Workaround exists (explicit disposal). Does not cause data loss or affect runtime operation."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Create a WinForms application using SkiaSharp on Windows",
          "Use SkiaSharp objects without explicitly disposing them (let GC/finalizer handle cleanup)",
          "Close the application"
        ],
        "codeSnippets": [
          {
            "language": "text",
            "code": "System.AccessViolationException: An attempt was made to read or write protected memory. This usually indicates that other memory is corrupted.\n   at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterCriticalSection(IntPtr lpCriticalSection)\n   at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterWriteLock()\n   at SkiaSharp.HandleDictionary.DeregisterHandle(IntPtr handle, SKObject instance)\n   at SkiaSharp.SKObject.DeregisterHandle(IntPtr handle, SKObject instance)\n   at SkiaSharp.SKObject.set_Handle(IntPtr value)\n   at SkiaSharp.SKNativeObject.Dispose(Boolean disposing)\n   at SkiaSharp.SKNativeObject.Finalize()",
            "context": "Full stack trace from the crash on application exit"
          }
        ],
        "relatedIssues": [
          2194,
          1817,
          1383,
          2181
        ],
        "environmentDetails": "Windows, WinForms application. No specific SkiaSharp version or .NET version mentioned by reporter."
      },
      "versionAnalysis": {
        "era": "maui-transition",
        "currentRelevance": "likely",
        "reason": "The NonAlertableWin32Lock code with the same finalizer pattern still exists in the current codebase (3.x). The race condition between lock finalization and SKNativeObject finalization has not been structurally addressed \u2014 the Enter() null check guards against _cs being zero but not against freed memory (dangling pointer during GC shutdown).",
        "migrationPath": null
      },
      "actionability": {
        "suggestedAction": "close-as-duplicate",
        "confidence": 0.85,
        "reason": "Identical stack trace and same root cause as #2194, which was filed first and milestoned to v2.88.1. Issue #2511 provides no additional information beyond #2194. The issue is already closed and locked.",
        "requiresHumanReview": false,
        "closeable": true,
        "closeReason": "Duplicate of #2194 \u2014 same AccessViolationException in NonAlertableWin32Lock.EnterCriticalSection during finalization.",
        "duplicateOf": 2194,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "Reporter experiences AccessViolationException when closing a WinForms application. The stack trace is identical to #2194 \u2014 a race condition in the NonAlertableWin32Lock\u0027s Win32 CRITICAL_SECTION during GC finalization at process shutdown. The lock object can be finalized (freeing the critical section memory) before all SKNativeObject finalizers complete, causing a use-after-free crash.",
        "keySignals": [
          {
            "text": "System.AccessViolationException at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterCriticalSection(IntPtr lpCriticalSection)",
            "source": "body",
            "interpretation": "Crash inside Win32 EnterCriticalSection P/Invoke \u2014 the CRITICAL_SECTION memory has been freed or corrupted. This is the same signature as #2194.",
            "supportedFields": [
              "type",
              "area",
              "bugSignals.severity",
              "actionability"
            ]
          },
          {
            "text": "at SkiaSharp.SKNativeObject.Finalize()",
            "source": "body",
            "interpretation": "Crash occurs on the finalizer thread during GC cleanup, not during normal application operation. This is a process-shutdown race condition, not a runtime bug.",
            "supportedFields": [
              "type",
              "bugSignals.severity"
            ]
          },
          {
            "text": "When I close my winform program, this error will be reported",
            "source": "body",
            "interpretation": "Triggers on application exit. WinForms = Windows Classic platform. The crash only affects shutdown, not runtime operation.",
            "supportedFields": [
              "platforms",
              "bugSignals.severity"
            ]
          },
          {
            "text": "HandleDictionary.DeregisterHandle \u2192 SKObject.set_Handle \u2192 SKNativeObject.Dispose(Boolean) \u2192 SKNativeObject.Finalize()",
            "source": "body",
            "interpretation": "The disposal path during finalization tries to acquire the HandleDictionary lock, but the lock\u0027s underlying CRITICAL_SECTION has already been freed by the NonAlertableWin32Lock\u0027s own finalizer.",
            "supportedFields": [
              "area",
              "type"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "Despite the [BUG] prefix being empty, the content clearly describes a crash (AccessViolationException) with a full stack trace. This is broken behavior in SkiaSharp\u0027s internal memory management during finalization.",
            "alternatives": [
              {
                "value": "question",
                "whyRejected": "Reporter asks \u0027what is the problem?\u0027 but provides a definitive crash trace \u2014 this is a bug report with a question framing, not a how-to question."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "The crash is in HandleDictionary and PlatformLock, which are core SkiaSharp infrastructure classes. Not specific to any view, platform binding, or HarfBuzz component.",
            "alternatives": [
              {
                "value": "SkiaSharp.Views",
                "whyRejected": "While the reporter uses WinForms (which implies Views), the crash is in core object lifecycle management, not in any view-specific code."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "Windows-Classic",
            "expandedReason": "Reporter says \u0027winform program\u0027 and the crash is in Win32 CRITICAL_SECTION P/Invoke, which only exists on Windows. WinForms maps to Windows-Classic (not WinUI)."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "While an AccessViolationException is normally critical, this only occurs during process shutdown when the GC finalizer runs. The application has already completed its work. Users can work around it by explicitly disposing SkiaSharp objects. No data loss or runtime impact.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "Crash is only at shutdown, not during operation. No data loss. Workaround exists (explicit disposal)."
              },
              {
                "value": "high",
                "whyRejected": "Workaround exists and the crash doesn\u0027t affect application functionality \u2014 only the exit path."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "Issue #2194 was filed earlier (Aug 2022 vs Jun 2023) with the identical stack trace, more detail (version info, repro code), and was milestoned to v2.88.1 by mattleibow. Issue #2511 adds no new information. Already closed and locked."
          }
        ],
        "docsConsulted": [
          {
            "path": "binding/SkiaSharp/PlatformLock.cs",
            "relevance": "Confirmed the NonAlertableWin32Lock uses a finalizer to free the CRITICAL_SECTION. The Enter() method has an _cs != IntPtr.Zero guard, but this doesn\u0027t protect against freed-but-non-zero memory during GC shutdown race.",
            "usedFor": [
              "type",
              "bugSignals",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "binding/SkiaSharp/HandleDictionary.cs",
            "relevance": "Confirmed instancesLock is a static readonly field initialized via PlatformLock.Create(). During process shutdown, GC can finalize the lock object even though it\u0027s referenced by a static field.",
            "usedFor": [
              "area",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked AccessViolationException pattern \u2014 documented as memory management bug. This case is a GC finalization ordering issue, not a typical use-after-dispose.",
            "usedFor": [
              "type",
              "bugSignals"
            ]
          }
        ],
        "docsNotConsulted": "No native loading diagnostics needed \u2014 this is a managed-side locking issue, not a DllNotFoundException. No backend or platform-specific docs needed.",
        "uncertainties": [
          "No SkiaSharp version specified by the reporter \u2014 regression version range inferred from #2194",
          "No .NET version specified \u2014 could be .NET Framework 4.x or .NET Core/5\u002B, which have different GC finalization behaviors",
          "Whether the issue is still present in SkiaSharp 3.x \u2014 the code pattern exists but .NET runtime GC behavior may have changed",
          "Whether the issue was actually addressed in v2.88.1 as milestoned on #2194"
        ],
        "assumptions": [
          "Assumed the reporter is on a 2.88.x version since the NonAlertableWin32Lock was introduced in 2.88.0",
          "Assumed WinForms implies .NET Framework 4.x (Windows Classic) based on the era, though modern WinForms on .NET 6\u002B is also possible"
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "During process shutdown, the .NET GC finalizer thread can finalize the NonAlertableWin32Lock (freeing the CRITICAL_SECTION memory) before all SKNativeObject finalizers complete. When a remaining SKNativeObject.Finalize() calls DeregisterHandle, it tries to enter the already-freed CRITICAL_SECTION, causing an AccessViolationException. This is a classic GC finalization ordering problem \u2014 static field references don\u0027t prevent finalization during shutdown.",
        "researchDone": [
          "Read PlatformLock.cs \u2014 confirmed NonAlertableWin32Lock has a finalizer that calls DeleteCriticalSection and FreeHGlobal",
          "Read HandleDictionary.cs \u2014 confirmed instancesLock is a static readonly field (doesn\u0027t prevent GC finalization at shutdown)",
          "Searched GitHub for identical issues \u2014 found #2194 with same stack trace, milestoned to v2.88.1",
          "Checked PR #1817 \u2014 introduced the NonAlertableWin32Lock to fix alertable lock deadlocks (#1383)",
          "Reviewed .NET GC documentation \u2014 during AppDomain unload/process exit, even rooted objects can be finalized"
        ],
        "proposals": [
          {
            "title": "Suppress finalization of HandleDictionary lock",
            "description": "Call GC.SuppressFinalize on the NonAlertableWin32Lock instance after creation, and intentionally leak the CRITICAL_SECTION at process shutdown. The OS reclaims all process memory on exit anyway.",
            "steps": [
              "In HandleDictionary, after creating instancesLock, call GC.SuppressFinalize(instancesLock)",
              "Alternatively, remove the ~NonAlertableWin32Lock() finalizer entirely and let the OS clean up on process exit",
              "Run tests to verify no functional regression"
            ],
            "pros": [
              "Eliminates the race condition entirely",
              "No risk of behavior change during normal operation",
              "OS always reclaims memory on process exit \u2014 no actual leak"
            ],
            "cons": [
              "Technically \u0027leaks\u0027 the CRITICAL_SECTION if the lock is created multiple times (unlikely given it\u0027s a static field)",
              "If SkiaSharp is ever used in a plugin/AppDomain unload scenario, the leak could accumulate"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Guard DeregisterHandle against finalized lock",
            "description": "Wrap the lock acquisition in DeregisterHandle with a try-catch for AccessViolationException during finalization, or add an IsFinalized/IsDisposed flag to the lock.",
            "steps": [
              "Add a volatile bool _disposed flag to NonAlertableWin32Lock, set in the finalizer",
              "In Enter(), check _disposed before calling EnterCriticalSection",
              "In HandleDictionary.DeregisterHandle, skip lock acquisition if the lock is disposed (only when called from finalizer)"
            ],
            "pros": [
              "Handles the race condition gracefully",
              "No memory leak concerns"
            ],
            "cons": [
              "Still has a tiny race window between checking _disposed and entering the critical section",
              "Skipping the lock in the finalizer could theoretically cause dictionary corruption (benign at shutdown)"
            ],
            "confidence": 0.70,
            "effort": "medium"
          },
          {
            "title": "User workaround: explicit disposal",
            "description": "Users should explicitly dispose all SkiaSharp objects using \u0027using\u0027 statements instead of relying on GC finalization. This avoids the finalizer code path entirely.",
            "steps": [
              "Wrap all SkiaSharp objects in \u0027using\u0027 statements or call Dispose() explicitly",
              "Ensure disposal happens before the form closes (e.g., in FormClosing event)",
              "Verify no AccessViolationException on exit"
            ],
            "pros": [
              "Works immediately, no SkiaSharp update needed",
              "Best practice for IDisposable objects anyway",
              "Avoids all finalizer-related issues"
            ],
            "cons": [
              "Requires code changes by the user",
              "Some objects may be hard to track (e.g., cached objects, objects in third-party libraries like QuestPDF)",
              "Doesn\u0027t fix the underlying issue in SkiaSharp"
            ],
            "confidence": 0.90,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Suppress finalization of HandleDictionary lock",
        "recommendedReason": "Simplest fix with highest confidence. The CRITICAL_SECTION is a singleton static field that lives for the process lifetime \u2014 suppressing finalization is safe and eliminates the race condition. The OS reclaims all process memory on exit."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2511"
    },
    {
      "schemaVersion": "1.0",
      "number": 2383,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T21:04:00Z",
      "summary": "User asks if SkiaSharp supports a 24-bit (3 bytes/pixel, no alpha) color type equivalent to Format24bppRgb",
      "type": {
        "value": "question",
        "confidence": 0.95,
        "reason": "Title starts with \u0027Does skia supports...\u0027 and body describes a requirement, not broken behavior."
      },
      "area": {
        "value": "SkiaSharp",
        "confidence": 0.90,
        "reason": "Core pixel format / color type API question \u2014 SKColorType and SKImageInfo are in the SkiaSharp core package."
      },
      "backends": null,
      "platforms": null,
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.80,
          "reason": "User is migrating from System.Drawing and needs a compatible pixel format for interop."
        }
      ],
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": null,
      "versionAnalysis": null,
      "actionability": {
        "suggestedAction": "close-with-docs",
        "confidence": 0.88,
        "reason": "The question has a clear answer: Skia does not support 24bpp natively, but Rgb888x (32bpp, alpha ignored) or manual pixel conversion can serve the same purpose.",
        "requiresHumanReview": false,
        "closeable": true,
        "closeReason": "Answered \u2014 Skia has no 24bpp format; use Rgb888x or convert 24bpp data to 32bpp before loading.",
        "abandoned": true,
        "abandonedReason": "Issue opened 2023-02-13, zero comments, reporter never followed up."
      },
      "suggestedResponse": {
        "responseType": "answer",
        "confidence": 0.90,
        "reason": "Direct technical answer with code example addresses all three of the user\u0027s requirements.",
        "draft": "Thanks for the question \u2014 this is a common one when migrating from System.Drawing.\n\nSkia (and SkiaSharp) doesn\u0027t have a native 24-bit (3 bytes per pixel) color type. The closest is \u0060SKColorType.Rgb888x\u0060, which uses 4 bytes per pixel with the fourth byte unused (no alpha). This satisfies your \u00228 bits per channel, no alpha\u0022 requirement, but the stride will be \u0060width * 4\u0060, not \u0060width * 3\u0060.\n\nIf your source data is truly packed 24bpp RGB, you\u0027d need to expand it to 32bpp before loading into an \u0060SKBitmap\u0060. Something like:\n\n\u0060\u0060\u0060csharp\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nusing var bitmap = new SKBitmap(info);\n\n// Copy 24bpp source into 32bpp destination\nvar src = sourcePixelSpan; // your 24bpp data\nvar dst = bitmap.GetPixels();\nfor (int i = 0, j = 0; i \u003C src.Length; i \u002B= 3, j \u002B= 4)\n{\n    Marshal.WriteByte(dst \u002B j, src[i]);       // R\n    Marshal.WriteByte(dst \u002B j \u002B 1, src[i\u002B1]); // G\n    Marshal.WriteByte(dst \u002B j \u002B 2, src[i\u002B2]); // B\n    Marshal.WriteByte(dst \u002B j \u002B 3, 0xFF);     // X (unused)\n}\n\u0060\u0060\u0060\n\nAlternatively, if your source is a file (JPEG, PNG, BMP), \u0060SKBitmap.Decode()\u0060 handles the format conversion automatically \u2014 no manual pixel wrangling needed.\n\nHope that helps!"
      },
      "analysisNotes": {
        "summary": "User is migrating from System.Drawing and needs a SkiaSharp equivalent of Format24bppRgb (3 bytes per pixel, RGB, no alpha). Skia has no 24bpp color type \u2014 Rgb888x is 32bpp with unused 4th byte. The answer is straightforward: either use Rgb888x with manual pixel expansion, or let SKBitmap.Decode() handle format conversion.",
        "keySignals": [
          {
            "text": "Does skia supports a 24-bit color type like System.Drawing.Imaging.PixelFormat.Format24bppRgb",
            "source": "title",
            "interpretation": "User is asking a capability question, not reporting broken behavior. They are coming from System.Drawing and looking for a compatible pixel format.",
            "supportedFields": [
              "type",
              "area",
              "tenets"
            ]
          },
          {
            "text": "use 8 bits for each colors, no alpha, necessary to specify width, height and stride",
            "source": "body",
            "interpretation": "Three specific requirements: 8bpc, no alpha, stride control. Rgb888x satisfies the first two; InstallPixels/SKImageInfo provides stride control.",
            "supportedFields": [
              "type",
              "resolutionAnalysis"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "question",
            "expandedReason": "Title is phrased as a question (\u0027Does skia supports...\u0027), body lists requirements, and no broken behavior or error is described. This is a how-to/capability inquiry.",
            "alternatives": [
              {
                "value": "feature-request",
                "whyRejected": "Not requesting a new feature \u2014 asking how to achieve something. Rgb888x already partially addresses the need."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp",
            "expandedReason": "SKColorType, SKImageInfo, and SKBitmap pixel operations are all in the core SkiaSharp package."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "User explicitly references System.Drawing.Imaging.PixelFormat.Format24bppRgb, indicating a migration/interop scenario where format compatibility matters."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The question has a definitive answer. No 24bpp type exists in Skia, but Rgb888x \u002B pixel expansion achieves the same result. Issue is also 3 years old with zero follow-up.",
            "alternatives": [
              {
                "value": "convert-to-discussion",
                "whyRejected": "While it\u0027s a question, it\u0027s old and answered. Converting adds unnecessary noise to Discussions."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "binding/SkiaSharp/Definitions.cs",
            "relevance": "Confirmed SKColorType enum values. Verified Rgb888x is 4 bytes per pixel (not 3). No 24bpp type exists.",
            "usedFor": [
              "type",
              "resolutionAnalysis"
            ]
          },
          {
            "path": "binding/SkiaSharp/SKBitmap.cs",
            "relevance": "Confirmed InstallPixels API supports custom stride via SKImageInfo, addressing the user\u0027s third requirement.",
            "usedFor": [
              "resolutionAnalysis"
            ]
          }
        ],
        "docsNotConsulted": "No platform-specific docs, backend docs, or native loading docs consulted \u2014 issue is purely about pixel format API with no platform or deployment context.",
        "uncertainties": [
          "Unclear exactly what the user\u0027s source data format is \u2014 raw byte array from System.Drawing, a file, or something else.",
          "Unknown whether performance of per-pixel expansion is acceptable for the user\u0027s use case."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "User has 24bpp RGB image data (likely from System.Drawing or interop) and wants to load it into an SKBitmap. Skia has no 24bpp color type, so the data needs conversion to a 32bpp format.",
        "researchDone": [
          "Checked SKColorType enum \u2014 confirmed no 24bpp type exists; Rgb888x is 32bpp with ignored 4th byte",
          "Checked SKBitmap.InstallPixels \u2014 supports custom stride via SKImageInfo for raw pixel data",
          "Checked SKBitmap.Decode \u2014 handles format conversion automatically for encoded images (JPEG, PNG, BMP)",
          "Verified Rgb888x bytes-per-pixel is 4 in Definitions.cs"
        ],
        "proposals": [
          {
            "title": "Use Rgb888x with manual 24\u219232 pixel expansion",
            "description": "Expand each 3-byte RGB pixel to 4 bytes (RGBx) and load with SKColorType.Rgb888x. This is the closest to the user\u0027s System.Drawing format.",
            "steps": [
              "Allocate new byte array of width * height * 4",
              "Copy each 3-byte pixel to 4 bytes, padding with 0xFF",
              "Create SKImageInfo with SKColorType.Rgb888x and SKAlphaType.Opaque",
              "Use SKBitmap.InstallPixels or create bitmap from info and copy to GetPixels()"
            ],
            "pros": [
              "Closest equivalent to Format24bppRgb semantics",
              "Alpha channel is properly ignored",
              "Full control over stride"
            ],
            "cons": [
              "Requires manual pixel expansion loop \u2014 ~33% memory overhead",
              "Slightly more code than other approaches"
            ],
            "confidence": 0.90,
            "effort": "low"
          },
          {
            "title": "Use Rgba8888 with alpha set to 0xFF",
            "description": "Convert 24bpp data to standard RGBA 32bpp with alpha = 255 (fully opaque). Wider compatibility since Rgba8888 is the most commonly used type.",
            "steps": [
              "Allocate byte array of width * height * 4",
              "For each pixel: copy R, G, B bytes and append 0xFF for alpha",
              "Create SKImageInfo with SKColorType.Rgba8888, SKAlphaType.Opaque",
              "Load into SKBitmap via InstallPixels"
            ],
            "pros": [
              "Most widely compatible SKColorType \u2014 works everywhere",
              "Interops well with other SkiaSharp APIs"
            ],
            "cons": [
              "Same ~33% memory overhead as Rgb888x approach",
              "Semantically \u0027has alpha\u0027 even though it\u0027s always opaque"
            ],
            "confidence": 0.85,
            "effort": "low"
          },
          {
            "title": "Decode from encoded image format",
            "description": "If the source is a file or stream (JPEG, PNG, BMP), use SKBitmap.Decode() which handles all pixel format conversion automatically.",
            "steps": [
              "If source is a file: SKBitmap.Decode(filename)",
              "If source is a stream: SKBitmap.Decode(stream)",
              "If source is byte[]: SKBitmap.Decode(data)",
              "Optionally specify target SKImageInfo to control output format"
            ],
            "pros": [
              "Zero manual pixel manipulation",
              "Handles BMP, JPEG, PNG, WebP, and other formats automatically",
              "Simplest code path"
            ],
            "cons": [
              "Only works if source is an encoded image, not raw pixel data",
              "Less control over exact pixel layout"
            ],
            "confidence": 0.80,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Use Rgb888x with manual 24\u219232 pixel expansion",
        "recommendedReason": "Most directly answers the user\u0027s question about a 24bpp equivalent. Rgb888x is semantically identical to Format24bppRgb (RGB, no alpha) with the only difference being 4 bytes per pixel instead of 3. If the source turns out to be an encoded file, Decode() is even simpler."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2383"
    },
    {
      "schemaVersion": "1.0",
      "number": 1898,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T20:54:00Z",
      "summary": "SkiaSharp.Views.Forms 2.88.0-preview.179 NuGet package missing DLLs for netcoreapp3.1 target framework",
      "type": {
        "value": "bug",
        "confidence": 0.88,
        "reason": "Reporter identifies that DLL files are missing from a published NuGet package \u2014 a packaging defect, not a usage question."
      },
      "area": {
        "value": "SkiaSharp.Views.Forms",
        "confidence": 0.95,
        "reason": "Issue explicitly names SkiaSharp.Views.Forms package and links to its NuGet listing."
      },
      "backends": null,
      "platforms": null,
      "tenets": [
        {
          "value": "compatibility",
          "confidence": 0.90,
          "reason": "Missing target framework support is a cross-version compatibility issue \u2014 netcoreapp3.1 was advertised as added but the DLLs are absent."
        }
      ],
      "partner": null,
      "regression": {
        "isRegression": true,
        "confidence": 0.80,
        "reason": "Reporter states netcoreapp3.1 support was added in preview.127 but is missing in preview.179, suggesting it regressed between preview versions.",
        "workedInVersion": "2.88.0-preview.127",
        "brokeInVersion": "2.88.0-preview.179"
      },
      "fixStatus": {
        "likelyFixed": true,
        "confidence": 0.85,
        "reason": "SkiaSharp.Views.Forms is now an obsolete package replaced by SkiaSharp.Views.Maui.Controls. The 2.88.0 preview series was superseded by stable releases and then 3.x. .NET Core 3.1 reached end-of-life in December 2022.",
        "verificationStatus": "inconclusive"
      },
      "bugSignals": {
        "hasCrash": false,
        "hasStackTrace": false,
        "reproQuality": "complete",
        "hasScreenshot": false,
        "hasWorkaround": false,
        "workaroundSummary": null,
        "targetFrameworks": [
          "netcoreapp3.1"
        ],
        "severity": "medium",
        "severityReason": "Missing DLLs prevent using the package for a specific target framework, but this is a preview package and the target framework is now EOL."
      },
      "reproEvidence": {
        "stepsToReproduce": [
          "Install SkiaSharp.Views.Forms version 2.88.0-preview.179",
          "Open the package in NuGet Package Explorer",
          "Inspect the netcoreapp3.1 directory \u2014 it is empty (no DLL files)"
        ],
        "environmentDetails": "NuGet Package Explorer inspecting SkiaSharp.Views.Forms 2.88.0-preview.179"
      },
      "versionAnalysis": {
        "mentionedVersions": [
          "2.88.0-preview.127",
          "2.88.0-preview.179"
        ],
        "era": "maui-transition",
        "currentRelevance": "unlikely",
        "reason": "Both mentioned versions are preview builds from the 2.88.0 series (late 2021). SkiaSharp has since shipped 2.88.x stable and moved to 3.x. .NET Core 3.1 reached end-of-life in December 2022. SkiaSharp.Views.Forms is now obsolete, replaced by SkiaSharp.Views.Maui.Controls.",
        "migrationPath": "Upgrade to SkiaSharp 3.x with SkiaSharp.Views.Maui.Controls targeting net8.0\u002B."
      },
      "actionability": {
        "suggestedAction": "close-as-fixed",
        "confidence": 0.82,
        "reason": "The issue concerns a preview version of an obsolete package targeting an EOL framework. SkiaSharp.Views.Forms is replaced by Views.Maui.Controls. No one is blocked by this anymore.",
        "requiresHumanReview": false,
        "closeable": true,
        "closeReason": "Obsolete package/framework: SkiaSharp.Views.Forms is replaced by Views.Maui.Controls, and .NET Core 3.1 is EOL.",
        "abandoned": true,
        "abandonedReason": "No comments in 4\u002B years. Reporter never followed up. No maintainer engagement."
      },
      "suggestedResponse": {
        "responseType": "close-message",
        "confidence": 0.82,
        "reason": "Issue is about an obsolete preview package targeting an EOL framework. A brief explanation with migration guidance is appropriate.",
        "draft": "Thanks for flagging this packaging gap back in the 2.88 preview days \u2014 the 5 upvotes suggest others ran into it too.\n\nSince then, a lot has changed: .NET Core 3.1 reached end-of-life in December 2022, and \u0060SkiaSharp.Views.Forms\u0060 has been replaced by \u0060SkiaSharp.Views.Maui.Controls\u0060 in the 3.x series. The 2.88 preview packaging issues are no longer applicable.\n\nIf you\u0027re still working with SkiaSharp, the recommended path is upgrading to SkiaSharp 3.x targeting \u0060net8.0\u0060\u002B with \u0060SkiaSharp.Views.Maui.Controls\u0060.\n\nClosing this as superseded \u2014 but if anyone is still seeing a similar packaging gap in the current packages, please open a new issue and we\u0027ll look into it."
      },
      "analysisNotes": {
        "summary": "A 4-year-old report that SkiaSharp.Views.Forms 2.88.0-preview.179 shipped with an empty netcoreapp3.1 directory. The package, the framework, and the preview series are all obsolete. This is a clear close candidate.",
        "keySignals": [
          {
            "text": "Support for netcore 3.1 was added in 2.88.0-preview.127 version",
            "source": "body",
            "interpretation": "Establishes that netcoreapp3.1 support was intentionally added but subsequently lost \u2014 indicates a packaging regression between preview builds.",
            "supportedFields": [
              "type",
              "regression"
            ]
          },
          {
            "text": "netcoreapp3.1 directory is empty in Nuget Package Explorer",
            "source": "body",
            "interpretation": "Clear evidence of a packaging defect \u2014 the TFM folder exists but contains no assemblies.",
            "supportedFields": [
              "type",
              "bugSignals.reproQuality"
            ]
          },
          {
            "text": "2.88.0-preview.179 version of Views.Forms",
            "source": "body",
            "interpretation": "Pins this to a specific preview release in the MAUI-transition era. Both the package and the framework are now obsolete.",
            "supportedFields": [
              "area",
              "versionAnalysis"
            ]
          },
          {
            "text": "0 comments, created 2021-12-22",
            "source": "metadata",
            "interpretation": "No engagement from reporter or maintainers in over 4 years. Strongly suggests the issue is no longer impacting anyone.",
            "supportedFields": [
              "actionability"
            ]
          },
          {
            "text": "5 thumbs-up reactions",
            "source": "metadata",
            "interpretation": "Others encountered the same preview packaging gap at the time, adding legitimacy to the original report, but no one followed up.",
            "supportedFields": [
              "bugSignals.severity"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "bug",
            "expandedReason": "An empty TFM directory in a NuGet package is a packaging defect. The reporter demonstrates that the support was added in a prior preview and then lost \u2014 this is broken build/packaging behavior, not a feature request or question.",
            "alternatives": [
              {
                "value": "feature-request",
                "whyRejected": "netcoreapp3.1 support was explicitly added in preview.127 \u2014 this is a regression, not a new feature ask."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "SkiaSharp.Views.Forms",
            "expandedReason": "The issue names this specific package and links to its NuGet listing. No ambiguity."
          },
          {
            "field": "tenets",
            "chosen": "compatibility",
            "expandedReason": "Missing target framework support is fundamentally a compatibility issue \u2014 the package claims to support netcoreapp3.1 (the folder exists) but provides no usable binaries."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Missing DLLs completely blocks usage on netcoreapp3.1 (could argue \u0027high\u0027), but this is a preview package and the framework is now EOL, reducing practical severity.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Would be high if the framework and package were still current, but both are obsolete."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "The specific preview version, the package (Views.Forms), and the framework (netcoreapp3.1) are all end-of-life or obsolete. The issue is superseded by the 3.x release series.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "No one is using 2.88.0-preview.179 with netcoreapp3.1 in 2026. Keeping it open adds noise."
              },
              {
                "value": "close-with-docs",
                "whyRejected": "No specific doc addresses this \u2014 it\u0027s simply obsolete."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "documentation/packages.md",
            "relevance": "Confirmed SkiaSharp.Views.Forms is listed under Obsolete Packages with replacement SkiaSharp.Views.Maui.Controls. Also confirmed the current package matrix targets net8.0\u002B.",
            "usedFor": [
              "area",
              "versionAnalysis",
              "fixStatus",
              "actionability"
            ]
          },
          {
            "path": "references/skia-patterns.md",
            "relevance": "Checked for any known NuGet packaging patterns \u2014 none specific to this issue.",
            "usedFor": [
              "type"
            ]
          }
        ],
        "docsNotConsulted": "No API docs or rendering docs consulted \u2014 this is a pure packaging issue, not a runtime or API behavior problem.",
        "uncertainties": [
          "Whether the empty netcoreapp3.1 folder was intentional (build system dropped it) or accidental (regression in CI) \u2014 impossible to determine 4 years later.",
          "Whether any 2.88.0 stable release ever included netcoreapp3.1 support for Views.Forms."
        ]
      },
      "resolutionAnalysis": {
        "hypothesis": "The 2.88.0-preview.179 NuGet build pipeline for SkiaSharp.Views.Forms accidentally produced an empty netcoreapp3.1 folder, likely a build configuration regression between preview.127 and preview.179. The issue is entirely moot now since both the package and the framework are obsolete.",
        "researchDone": [
          "Checked packages.md \u2014 SkiaSharp.Views.Forms is listed under Obsolete Packages, replaced by Views.Maui.Controls",
          "Searched GitHub issues for duplicates \u2014 none found",
          "Checked issue age and engagement \u2014 4\u002B years old with zero comments",
          "Verified .NET Core 3.1 EOL status (December 2022)"
        ],
        "proposals": [
          {
            "title": "Close as superseded",
            "description": "Close the issue with an explanation that the package, framework, and preview series are all obsolete. Point to the upgrade path.",
            "steps": [
              "Post a courteous close comment acknowledging the original report and the upvotes",
              "Explain that Views.Forms is replaced by Views.Maui.Controls",
              "Note that .NET Core 3.1 is EOL",
              "Close the issue"
            ],
            "pros": [
              "Reduces open issue count",
              "Clear and respectful",
              "Provides migration guidance"
            ],
            "cons": [
              "Does not fix the historical defect (no one needs it fixed)"
            ],
            "confidence": 0.90,
            "effort": "low"
          },
          {
            "title": "Upgrade to SkiaSharp 3.x with MAUI",
            "description": "For any reporter still affected, the resolution is migrating from Xamarin.Forms plus netcoreapp3.1 to .NET MAUI plus net8.0 with SkiaSharp 3.x.",
            "steps": [
              "Update project to target net8.0 or later",
              "Replace Xamarin.Forms with .NET MAUI",
              "Replace SkiaSharp.Views.Forms with SkiaSharp.Views.Maui.Controls",
              "Update SkiaSharp to 3.x"
            ],
            "pros": [
              "Modern supported stack",
              "Active development and support"
            ],
            "cons": [
              "Requires significant migration effort",
              "May not be feasible for legacy projects"
            ],
            "confidence": 0.85,
            "effort": "high"
          },
          {
            "title": "Pin to 2.88.0-preview.127 (historical workaround)",
            "description": "If someone in 2021 needed an immediate workaround, they could pin to the last preview that included netcoreapp3.1 DLLs.",
            "steps": [
              "Downgrade SkiaSharp.Views.Forms to 2.88.0-preview.127",
              "Verify netcoreapp3.1 DLLs are present"
            ],
            "pros": [
              "Immediate workaround at the time"
            ],
            "cons": [
              "Uses an older preview with other potential issues",
              "Completely irrelevant in 2026"
            ],
            "confidence": 0.70,
            "effort": "low"
          }
        ],
        "recommendedProposal": "Close as superseded",
        "recommendedReason": "The issue is about a 4-year-old preview of an obsolete package targeting an EOL framework. No one is blocked by this, and the entire ecosystem has moved on. A respectful close with migration guidance is the right call."
      },
      "url": "https://github.com/mono/SkiaSharp/issues/1898"
    },
    {
      "schemaVersion": "1.0",
      "number": 1773,
      "repo": "mono/SkiaSharp",
      "analyzedAt": "2026-02-09T21:34:00Z",
      "summary": "Accidental empty issue immediately closed by the author \u2014 no content or actionable information",
      "type": {
        "value": "question",
        "confidence": 0.50,
        "reason": "No content to classify. Title \u0027TO DELETE PLEASE\u0027 and empty body indicate accidental issue creation. \u0027question\u0027 is the closest fit but confidence is low since this is not a genuine issue of any type."
      },
      "area": null,
      "backends": null,
      "platforms": null,
      "tenets": null,
      "partner": null,
      "regression": null,
      "fixStatus": null,
      "bugSignals": null,
      "reproEvidence": null,
      "versionAnalysis": null,
      "actionability": {
        "suggestedAction": "close-as-fixed",
        "confidence": 0.95,
        "reason": "Issue was already closed by the author within 26 minutes of opening. Empty body, no comments, no labels. No action required \u2014 correctly closed as accidental.",
        "requiresHumanReview": false,
        "closeable": true,
        "closeReason": "Accidental issue, already closed by the author.",
        "duplicateOf": null,
        "abandoned": false,
        "abandonedReason": null
      },
      "suggestedResponse": null,
      "analysisNotes": {
        "summary": "This is an accidental issue with no content. The title \u0027TO DELETE PLEASE\u0027 and empty body indicate the author created it by mistake and closed it themselves within 26 minutes. There is nothing to investigate, fix, or respond to.",
        "keySignals": [
          {
            "text": "TO DELETE PLEASE",
            "source": "title",
            "interpretation": "Author explicitly asking for the issue to be deleted, indicating accidental creation.",
            "supportedFields": [
              "type",
              "actionability.suggestedAction"
            ]
          },
          {
            "text": "Empty body with zero comments",
            "source": "body",
            "interpretation": "No technical content, no description, no reproduction steps \u2014 confirms accidental creation.",
            "supportedFields": [
              "type",
              "area"
            ]
          },
          {
            "text": "Closed 26 minutes after opening",
            "source": "body",
            "interpretation": "Author self-closed almost immediately, confirming this was not intentional.",
            "supportedFields": [
              "actionability.suggestedAction"
            ]
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "question",
            "expandedReason": "There is no \u0027invalid\u0027 or \u0027noise\u0027 type in the schema. \u0027question\u0027 is the least committal classification for an issue with zero content. Confidence is set low (0.50) to reflect that this doesn\u0027t genuinely fit any category.",
            "alternatives": [
              {
                "value": "bug",
                "whyRejected": "No broken behavior described."
              },
              {
                "value": "feature-request",
                "whyRejected": "No feature requested."
              },
              {
                "value": "documentation",
                "whyRejected": "No docs gap identified."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "Issue is already closed and requires no action. \u0027close-as-fixed\u0027 is the closest available option since the issue\u0027s lifecycle is complete \u2014 the author resolved it themselves by closing.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "Issue is already closed and the author clearly doesn\u0027t intend to follow up."
              },
              {
                "value": "convert-to-discussion",
                "whyRejected": "No discussion content exists."
              }
            ]
          }
        ],
        "docsConsulted": [
          {
            "path": "references/triage-schema.json",
            "relevance": "Checked available type enum values to find the best fit for a contentless issue.",
            "usedFor": [
              "type"
            ]
          }
        ],
        "docsNotConsulted": "No technical docs consulted \u2014 the issue contains zero technical content. No packages.md, skia-patterns.md, or API docs were relevant.",
        "uncertainties": [
          "The true intent behind opening this issue is unknown \u2014 it may have been a test, an accident, or the author may have meant to write content but changed their mind."
        ]
      },
      "resolutionAnalysis": null,
      "url": "https://github.com/mono/SkiaSharp/issues/1773"
    }
  ]
}