{
  "generatedAt": "2026-02-12T00:49:16.8626346Z",
  "totalCount": 46,
  "summary": {
    "needsInvestigation": 18,
    "closeable": 13,
    "quickWins": 11,
    "needsHumanReview": 7,
    "regressions": 13
  },
  "byType": [
    {
      "label": "type/bug",
      "count": 32
    },
    {
      "label": "type/question",
      "count": 6
    },
    {
      "label": "type/feature-request",
      "count": 5
    },
    {
      "label": "type/documentation",
      "count": 2
    },
    {
      "label": "type/enhancement",
      "count": 1
    }
  ],
  "byArea": [
    {
      "label": "area/SkiaSharp",
      "count": 18
    },
    {
      "label": "area/libSkiaSharp.native",
      "count": 8
    },
    {
      "label": "area/SkiaSharp.Views",
      "count": 7
    },
    {
      "label": "area/SkiaSharp.Views.Maui",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.HarfBuzz",
      "count": 2
    },
    {
      "label": "area/Docs",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.Views.Blazor",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.Views.Forms",
      "count": 2
    },
    {
      "label": "area/HarfBuzzSharp",
      "count": 1
    },
    {
      "label": "area/Build",
      "count": 1
    },
    {
      "label": "area/SkiaSharp.Views.Uno",
      "count": 1
    }
  ],
  "byAction": [
    {
      "label": "needs-investigation",
      "count": 18
    },
    {
      "label": "keep-open",
      "count": 10
    },
    {
      "label": "close-with-docs",
      "count": 7
    },
    {
      "label": "close-as-duplicate",
      "count": 4
    },
    {
      "label": "close-as-fixed",
      "count": 3
    },
    {
      "label": "request-info",
      "count": 3
    },
    {
      "label": "convert-to-discussion",
      "count": 1
    }
  ],
  "bySeverity": [
    {
      "label": "medium",
      "count": 16
    },
    {
      "label": "high",
      "count": 11
    },
    {
      "label": "low",
      "count": 4
    },
    {
      "label": "critical",
      "count": 1
    }
  ],
  "issues": [
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3509,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/bug"
        ],
        "state": "open"
      },
      "summary": "Incomplete bug report \u2014 images not appearing on screen, but no actual code, repro steps, or error details provided (template placeholders only)",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.5
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.45
        },
        "platforms": [
          {
            "value": "os/macOS",
            "confidence": 0.65
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "none",
          "severity": "low",
          "severityReason": "No actual details provided \u2014 the issue body contains only the default template placeholders with no real code, no expected/actual behavior, and no error information. Cannot assess real severity.",
          "hasWorkaround": false
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/user/repo/tree/bug-123",
              "description": "Template placeholder URL \u2014 not a real repro project"
            }
          ],
          "codeSnippets": [
            {
              "code": "// some C# code here",
              "language": "cs",
              "context": "Template placeholder \u2014 no real code provided"
            }
          ],
          "environmentDetails": "IDE: Visual Studio (Windows), Platform: macOS, SkiaSharp 3.116.0, Last Known Good: 2.88.9"
        },
        "versionAnalysis": {
          "reason": "Reporter selected 3.116.0 as current and 2.88.9 as last known good, suggesting a possible regression across a major version boundary (v2 \u2192 v3). However, no details were provided to confirm whether the issue is real or if this was just default template selection.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "unknown"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.3,
          "reason": "Reporter selected 2.88.9 as last known good version, which could indicate regression from v2 to v3. However, the entire report is template placeholders, so this selection may not reflect actual testing."
        }
      },
      "analysis": {
        "summary": "This issue contains only the default bug template with placeholder text \u2014 no actual code, no expected or actual behavior, no screenshots, no logs. The title mentions images not appearing but provides zero actionable information. Cannot determine root cause or even confirm a real bug exists.",
        "keySignals": [
          {
            "text": "My images are not appearing in the screen",
            "source": "title",
            "interpretation": "Vague description of visual output issue \u2014 could be rendering, loading, drawing, or display problem"
          },
          {
            "text": "// some C# code here",
            "source": "body",
            "interpretation": "Code section contains the template placeholder, not actual code \u2014 reporter did not fill in the template"
          },
          {
            "text": "Expected Behavior: _No response_",
            "source": "body",
            "interpretation": "No expected behavior described \u2014 cannot determine what the reporter expects to happen"
          },
          {
            "text": "Actual Behavior: _No response_",
            "source": "body",
            "interpretation": "No actual behavior described \u2014 cannot determine what is actually happening"
          },
          {
            "text": "Version: 3.116.0, Last Known Good: 2.88.9",
            "source": "body",
            "interpretation": "Version fields were filled in, suggesting possible v2-to-v3 migration issue, but could also be default selections"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter used the bug template and the title says \u0027[BUG]\u0027. While the content is empty, they claim something is not working (\u0027images not appearing\u0027). Keeping type/bug but with very low confidence since there is no actual evidence of broken behavior.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "The reporter chose the bug template and claims something is broken, not asking how to do something. However, with so little info, this could easily be a usage question."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "No specific component mentioned. \u0027Images not appearing\u0027 is too vague to narrow down \u2014 could be core SkiaSharp, Views, or MAUI. Defaulting to the broadest area.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "No mention of SKCanvasView, views, or any UI framework."
              },
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "No mention of MAUI, .NET MAUI, or any MAUI-specific types."
              }
            ]
          },
          {
            "field": "platforms[0]",
            "chosen": "os/macOS",
            "expandedReason": "Reporter selected \u0027macOS\u0027 as platform. However, they also say IDE is \u0027Visual Studio (Windows)\u0027 which is contradictory \u2014 they may be developing on Windows targeting macOS, or this may be a template selection error.",
            "alternatives": [
              {
                "value": "os/Windows-Classic",
                "whyRejected": "IDE says Visual Studio Windows but platform says macOS \u2014 trusting the explicit platform selection over IDE choice."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "low",
            "expandedReason": "Cannot assess severity without any actual details. No crash, no stack trace, no repro, no description of the problem beyond the title. Defaulting to low until more information is available."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "The issue is entirely template placeholders. We need actual code, expected behavior, actual behavior, and ideally a sample project before any investigation can begin."
          },
          {
            "field": "platforms",
            "chosen": "os/macOS",
            "expandedReason": "Reporter selected macOS as the platform in the bug template. The IDE field says Visual Studio (Windows), which is contradictory \u2014 trusting the explicit platform selection over the IDE choice.",
            "alternatives": [
              {
                "value": "os/Windows-Classic",
                "whyRejected": "IDE says Visual Studio Windows but the explicit platform selection says macOS \u2014 prioritizing the direct platform field."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "Reporter selected 2.88.9 as last known good version, but the entire report is template placeholders with no actual details. This selection may not reflect real testing, so regression cannot be confirmed."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unknown",
            "expandedReason": "Reporter selected 3.116.0 and 2.88.9, but no details confirm whether a real issue exists. The version selections may be default template values rather than reflecting actual testing.",
            "alternatives": [
              {
                "value": "likely",
                "whyRejected": "Without any actual issue details, we cannot determine if this affects current versions or is even a real bug."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether this is a real bug report or an accidental submission of the empty template",
          "What kind of images \u2014 SKImage, SKBitmap, or UI framework image controls",
          "Whether the issue is in core SkiaSharp drawing, views rendering, or a platform-specific display problem",
          "Whether the v2.88.9 \u0027last known good\u0027 reflects actual testing or default selection",
          "Whether the macOS platform selection is accurate given the Windows IDE selection"
        ],
        "assumptions": [
          "Assumed this is an intentional (not accidental) submission based on title containing a specific complaint",
          "Assumed macOS is the target platform despite contradictory IDE selection"
        ],
        "resolution": {
          "hypothesis": "The reporter has code that should display images using SkiaSharp but nothing appears on screen. Without any details, the most common causes are: incorrect drawing coordinates, missing invalidation/refresh of the canvas view, image loading failures returning null, or v2-to-v3 API migration issues.",
          "proposals": [
            {
              "title": "Request complete bug report",
              "description": "Ask the reporter to fill in the template with actual code, expected behavior, actual behavior, and ideally a minimal repro project. This is a prerequisite for any investigation.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "Check for v2-to-v3 migration issues",
              "description": "If the reporter confirms this worked in v2.88.9, investigate common v3 migration pitfalls like API changes, namespace changes, or rendering pipeline differences.",
              "confidence": 0.4,
              "effort": "medium"
            },
            {
              "title": "Provide common image rendering checklist",
              "description": "Share a checklist of common reasons images don\u0027t appear: null image from loading, drawing at wrong coordinates, canvas not invalidated, view not sized correctly.",
              "confidence": 0.5,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Request complete bug report",
          "recommendedReason": "Cannot investigate without any actual information. The template is completely empty."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.92,
          "reason": "The issue body contains only template placeholders \u2014 no real code, no expected/actual behavior, no logs, no screenshots. Investigation is impossible without more details.",
          "requiresHumanReview": false,
          "missingInfo": [
            "reproduction-steps",
            "expected-behavior",
            "actual-behavior",
            "sample-project"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp and os/macOS labels",
            "reason": "Matches classification \u2014 generic SkiaSharp area and macOS platform",
            "confidence": 0.5,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "os/macOS"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Request the reporter to fill in the bug template with actual details",
            "reason": "Issue body contains only placeholder text \u2014 need real code and behavior description to investigate",
            "confidence": 0.9,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for opening this issue.\n\nIt looks like the bug template still has the placeholder text in the Code, Expected Behavior, and Actual Behavior sections. Without actual code or a description of what\u0027s happening, it\u0027s hard to investigate further.\n\nWould you be able to update the issue with:\n- The code you\u0027re using to load and display the images (even a short snippet helps)\n- What you expect to see vs. what actually happens\n\nIf you have a small repro project, that would be ideal \u2014 but even a code snippet and description of the behavior would help narrow this down.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3509-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3509"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3472,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "HarfBuzzSharp Blob.FromStream uses a pinned managed array pointer that becomes invalid after the fixed block exits, causing potential GC-related crashes",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/HarfBuzzSharp",
          "confidence": 0.95
        },
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "high",
          "severityReason": "Memory safety bug: the fixed block exits before the Blob is used, so GC can relocate the managed byte array causing use-after-move crashes. No workaround exists short of avoiding FromStream entirely.",
          "hasWorkaround": false
        },
        "reproEvidence": {
          "codeSnippets": [
            {
              "code": "public static unsafe Blob FromStream (Stream stream)\n{\n\tusing var ms = new MemoryStream ();\n\tstream.CopyTo (ms);\n\tvar data = ms.ToArray ();\n\n\tfixed (byte* dataPtr = data) {\n\t\treturn new Blob ((IntPtr)dataPtr, data.Length, MemoryMode.ReadOnly, () =\u003E ms.Dispose ());\n\t}\n}",
              "language": "csharp",
              "context": "Current buggy implementation in binding/HarfBuzzSharp/Blob.cs"
            },
            {
              "code": "public static unsafe Blob FromStream (Stream stream)\n{\n\tvar length = (int)(stream.Length - stream.Position);\n\n\tvar dataPtr = Marshal.AllocCoTaskMem (length);\n\n\tusing var ums = new UnmanagedMemoryStream ((byte*)dataPtr, length, length, FileAccess.ReadWrite);\n\tstream.CopyTo (ums);\n\n\treturn new Blob (dataPtr, length, MemoryMode.ReadOnly, () =\u003E Marshal.FreeCoTaskMem (dataPtr));\n}",
              "language": "csharp",
              "context": "Reporter\u0027s proposed fix using unmanaged memory allocation"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), affects all platforms"
        },
        "versionAnalysis": {
          "reason": "The buggy code pattern exists in the current source (binding/HarfBuzzSharp/Blob.cs lines 71-82). The issue was found by code inspection, not runtime testing, and the code has not changed.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.8,
          "reason": "The reporter lists 2.88.9 as \u0027Last Known Good Version\u0027 but this appears to be a latent bug present since the method was written \u2014 the fixed block has always exited before the Blob could be used. It likely manifests non-deterministically depending on GC timing."
        }
      },
      "analysis": {
        "summary": "Real memory safety bug in HarfBuzzSharp\u0027s Blob.FromStream. The fixed statement pins a managed byte array only for the duration of the block, but the resulting Blob holds the pointer beyond that scope. After the fixed block exits, the GC is free to relocate the managed array, leaving the Blob with a dangling pointer.",
        "keySignals": [
          {
            "text": "If GC runs after the blob is created, the managed array memory might be moved resulting in a crash",
            "source": "body",
            "interpretation": "Reporter correctly identifies the root cause: the fixed block scope is too narrow"
          },
          {
            "text": "fixed (byte* dataPtr = data) { return new Blob((IntPtr)dataPtr, ...); }",
            "source": "body",
            "interpretation": "The fixed block exits immediately after Blob construction, unpinning the managed array while the Blob still holds the pointer"
          },
          {
            "text": "Should copy via an UnmanagedMemoryStream",
            "source": "body",
            "interpretation": "Reporter provides a concrete fix using Marshal.AllocCoTaskMem for GC-safe unmanaged memory"
          },
          {
            "text": "TODO: check to see if we can avoid the second copy (the ToArray)",
            "source": "body",
            "interpretation": "Existing TODO comment in the code acknowledges the implementation is suboptimal"
          },
          {
            "text": "This should also improve performance since it removes the redundant copy",
            "source": "comment 2",
            "interpretation": "The proposed fix also eliminates an unnecessary buffer copy \u2014 stream \u2192 MemoryStream \u2192 byte[] becomes stream \u2192 unmanaged buffer"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a real memory safety defect found by code inspection. The fixed keyword only pins memory within its block scope, but the Blob outlives that scope. This is not a feature request or enhancement \u2014 it\u0027s broken code that can crash.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "While the fix also improves performance, the core issue is a use-after-unpin memory safety bug, not an optimization request."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/HarfBuzzSharp",
            "expandedReason": "The bug is in HarfBuzzSharp.Blob.FromStream (binding/HarfBuzzSharp/Blob.cs), not in the SkiaSharp core library. The existing label area/SkiaSharp is incorrect.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The Blob class is in the HarfBuzzSharp namespace and assembly, not SkiaSharp."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Memory safety bug with potential for hard crashes. No workaround other than avoiding the API entirely. The crash is non-deterministic (depends on GC timing), making it difficult to diagnose in production."
          },
          {
            "field": "platforms",
            "chosen": "null",
            "expandedReason": "The reporter selected \u0027All\u0027 for platform. The bug is in managed C# code and affects all platforms equally since GC behavior is a .NET runtime concern, not platform-specific."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The memory safety bug is clearly identified by code inspection with a concrete fix proposal. Needs brief investigation to check for similar fixed-block patterns elsewhere before applying the fix.",
            "alternatives": [
              {
                "value": "close-wontfix",
                "whyRejected": "This is a real memory safety defect with a dangling pointer \u2014 it must be fixed, not dismissed."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Memory safety bug where GC can relocate a managed array while a Blob still holds a raw pointer to it, causing potential hard crashes that are non-deterministic and difficult to diagnose."
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "The buggy fixed-block pattern appears to have been present since the method was originally written. The reporter listed 2.88.9 as last known good, but this is likely a latent bug that manifests non-deterministically depending on GC timing."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The buggy code pattern still exists in the current source at binding/HarfBuzzSharp/Blob.cs. The issue was found by code inspection and the code has not been modified.",
            "alternatives": [
              {
                "value": "outdated",
                "whyRejected": "The vulnerable code path is unchanged in the latest version."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether this has been observed as an actual crash in production, or only identified by code inspection",
          "Whether SkiaSharp\u0027s SKData or other classes have similar fixed-block scope issues"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s version selection of 2.88.9 as \u0027Last Known Good\u0027 is likely a form field default rather than evidence of a regression, since the buggy pattern appears to have been present since the method was written"
        ],
        "resolution": {
          "hypothesis": "The fixed block in Blob.FromStream exits immediately after constructing the Blob, unpinning the managed byte array. The Blob holds a raw pointer to what was pinned memory, but after unpinning, the GC can relocate the array, leaving a dangling pointer. The fix is to use unmanaged memory that the GC cannot move.",
          "proposals": [
            {
              "title": "Use Marshal.AllocCoTaskMem with UnmanagedMemoryStream",
              "description": "Allocate unmanaged memory, copy stream data directly into it via UnmanagedMemoryStream, and pass the unmanaged pointer to Blob with a release delegate that calls Marshal.FreeCoTaskMem. This is the reporter\u0027s proposed fix. It eliminates the GC safety issue and removes one redundant buffer copy (stream \u2192 MemoryStream \u2192 ToArray becomes stream \u2192 unmanaged buffer).",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Use GCHandle.Alloc to pin the managed array",
              "description": "Instead of fixed, use GCHandle.Alloc(data, GCHandleType.Pinned) to pin the managed array for the lifetime of the Blob. Free the GCHandle in the release delegate. This is simpler but keeps the redundant copy and long-lived GC pinning can fragment the managed heap.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Use NativeMemory.Alloc (modern .NET)",
              "description": "Use System.Runtime.InteropServices.NativeMemory.Alloc instead of Marshal.AllocCoTaskMem for a more modern API. Functionally equivalent but uses the newer .NET API surface. May require conditional compilation for older target frameworks.",
              "confidence": 0.75,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Use Marshal.AllocCoTaskMem with UnmanagedMemoryStream",
          "recommendedReason": "Directly addresses the root cause, eliminates the redundant copy, uses well-established APIs available on all target frameworks, and matches the reporter\u0027s well-reasoned proposal."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The bug is clearly identified by code inspection with a concrete fix proposal. Needs brief investigation to check for similar patterns elsewhere (e.g., SkiaSharp\u0027s SKData) before applying the fix."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Correct area label from SkiaSharp to HarfBuzzSharp and remove incorrect Windows-Classic platform label",
            "reason": "Bug is in HarfBuzzSharp.Blob, not SkiaSharp core. Platform is All, not Windows-specific.",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [
                "area/HarfBuzzSharp"
              ],
              "labelsToRemove": [
                "area/SkiaSharp",
                "os/Windows-Classic"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug report and confirm the analysis is correct",
            "reason": "Reporter provided excellent analysis with a concrete fix. Acknowledging and confirming encourages high-quality reports.",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the thorough analysis \u2014 you\u0027re right that the \u0060fixed\u0060 block scope is too narrow here. Once the block exits, the managed array is unpinned and the GC is free to relocate it, leaving the \u0060Blob\u0060 with a dangling pointer.\n\nYour proposed fix using \u0060Marshal.AllocCoTaskMem\u0060 with \u0060UnmanagedMemoryStream\u0060 looks correct and also has the nice side effect of eliminating the redundant \u0060ToArray()\u0060 copy.\n\nWe should also check whether similar patterns exist elsewhere in the codebase before applying the fix.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3472-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3472"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3440,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-10T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp.Views.Maui",
          "os/Windows-WinUI",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "MAUI app crashes on certain Windows 11 systems with COMException in PropertySetExtensions WinRT activation during ANGLE surface creation",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.9
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.92
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-WinUI",
            "confidence": 0.97
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.97
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "steps-only",
          "severity": "high",
          "severityReason": "Application crash with no known workaround during view initialization. Occurs on certain deployed systems, blocking production use on affected machines. The crash is unrecoverable \u2014 once the static initializer fails, all subsequent calls also fail.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "net8.0-windows",
            "net9.0-windows"
          ]
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a MAUI app with LiveCharts2 that uses SkiaSharp 3.119.1 for chart rendering",
            "Deploy the app to a Windows 11 system (reported: Lenovo 83C4, Windows 11 10.0.26100.7462)",
            "Launch the app \u2014 crashes when AngleSwapChainPanel loads and attempts to create the ANGLE render surface"
          ],
          "codeSnippets": [
            {
              "code": "\u003CliveCharts:CartesianChart x:Name=\u0022Graph\u0022\n                                   AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022\n                                   AbsoluteLayout.LayoutFlags=\u0022PositionProportional,SizeProportional\u0022\n                                   ZoomMode=\u0022None\u0022\n                                   EasingFunction=\u0022{x:Null}\u0022\n                                   ... /\u003E",
              "language": "xml",
              "context": "XAML markup for the LiveCharts2 CartesianChart that triggers the crash via SkiaSharp rendering"
            },
            {
              "code": "System.Runtime.InteropServices.COMException: Element not found.\n  at void Marshal.ThrowExceptionForHR(int errorCode)() in Marshal.cs:line 856\n  at new BaseActivationFactory(string typeNamespace, string typeFullName)()\n  at static PropertySetExtensions()()\n\nSystem.TypeInitializationException: The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception.\n  at IObjectReference PropertySetExtensions.get__objRef_global__SkiaSharp_Views_WinUI_Native_IPropertySetExtensionsStatics()()\n  at void PropertySetExtensions.AddSingle(PropertySet propertySet, string key, float value)()\n  at void GlesContext.CreateSurface(SwapChainPanel panel, Size? renderSurfaceSize, float? resolutionScale)()\n  at void AngleSwapChainPanel.EnsureRenderSurface()()\n  at void AngleSwapChainPanel.OnLoaded(object sender, RoutedEventArgs e)()\n  at int RoutedEventHandler.Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e)()",
              "language": "text",
              "context": "Full stack trace showing COMException during WinRT activation of PropertySetExtensions"
            }
          ],
          "environmentDetails": "Windows 11 (10.0.26100.7462), Lenovo 83C4, SkiaSharp 3.119.1, MAUI app with LiveCharts2. Tried with HA (Hardware Acceleration) enabled and disabled \u2014 same result."
        },
        "versionAnalysis": {
          "reason": "Version 3.119.1 is a current stable release. The WinRT activation issue with PropertySetExtensions has been reported across multiple 3.x versions, indicating a persistent architectural issue not yet resolved.",
          "mentionedVersions": [
            "3.119.1"
          ],
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "MAUI app with LiveCharts2 crashes on certain Windows 11 systems during ANGLE render surface creation. The WinRT activation factory for SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails with COMException \u0027Element not found\u0027, a recurring pattern seen across multiple issues.",
        "keySignals": [
          {
            "text": "System.Runtime.InteropServices.COMException: Element not found.",
            "source": "stack-trace",
            "interpretation": "WinRT activation factory cannot locate the SkiaSharp.Views.WinUI.Native component DLL or its class registration. This occurs before any GPU interaction."
          },
          {
            "text": "The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception",
            "source": "stack-trace",
            "interpretation": "Static constructor failure in the WinRT projection class. Once this fails, it is permanently broken for the process lifetime."
          },
          {
            "text": "crashes on certain systems",
            "source": "body",
            "interpretation": "Environment-dependent failure \u2014 suggests deployment or system configuration issue (WinRT component registration, packaging mode, Windows App SDK runtime) rather than a universal code bug."
          },
          {
            "text": "tried both with HA enabled and disabled but the result is the same",
            "source": "body",
            "interpretation": "Hardware acceleration toggle does not affect the crash, confirming the issue is in WinRT component activation (before any GPU interaction), not in the rendering pipeline itself."
          },
          {
            "text": "MAUI app with LiveCharts2 that uses SkiaSharp 3.119.1",
            "source": "body",
            "interpretation": "Third-party library (LiveCharts2) uses SkiaSharp for rendering. User may not have direct control over which SkiaSharp view type (SKGLView vs SKCanvasView) is used."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The issue reports a crash with a full stack trace during normal rendering initialization. The app terminates with COMException/TypeInitializationException \u2014 clearly broken behavior, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they are reporting a crash."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Maui",
            "expandedReason": "The crash occurs in SkiaSharp.Views.WinUI components (PropertySetExtensions, GlesContext, AngleSwapChainPanel) used through a MAUI app. The reporter\u0027s context is MAUI and the existing label correctly scopes this.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "SkiaSharp.Views.Maui is more specific \u2014 the crash is in MAUI-deployed WinUI views."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "The crash path goes through AngleSwapChainPanel \u2192 GlesContext.CreateSurface, which is the ANGLE OpenGL ES backend. ANGLE translates OpenGL ES to Direct3D on Windows. PropertySetExtensions is only needed for GLES surface setup."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-WinUI",
            "expandedReason": "Explicitly Windows 11, WinUI 3 stack. The crash is in SkiaSharp.Views.WinUI.Native.PropertySetExtensions, a C\u002B\u002B/WinRT component specific to the WinUI rendering path."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Application crash during rendering initialization. The COMException causes a TypeInitializationException that terminates rendering entirely with no recovery path."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Crash with no known workaround for users who need GPU-accelerated rendering via SKGLView. The crash is unrecoverable and happens during initialization. It only affects \u0027certain systems\u0027 so it\u0027s not universal \u2014 hence high rather than critical.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "The crash is environment-specific, not universal. Apps using SKCanvasView are unaffected."
              },
              {
                "value": "medium",
                "whyRejected": "No confirmed workaround for affected users, and the crash prevents all rendering."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "This is part of a recurring pattern of WinRT activation failures for PropertySetExtensions. The root cause \u2014 the C\u002B\u002B/WinRT component failing to activate on certain system configurations \u2014 needs engineering investigation to find a robust solution, potentially replacing the WinRT component with managed code.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "While more info would help (packaged vs unpackaged, DLL presence), the stack trace and environment details are sufficient to classify and begin investigation."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "The reporter is using a .NET MAUI app with LiveCharts2 for chart rendering. The crash occurs in SkiaSharp.Views.WinUI components invoked through the MAUI rendering pipeline.",
            "alternatives": [
              {
                "value": "null",
                "whyRejected": "The reporter explicitly describes a MAUI application and the crash path goes through MAUI-deployed WinUI views."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Version 3.119.1 is a current stable release. The WinRT activation issue with PropertySetExtensions is a persistent architectural problem reported across multiple 3.x versions and not yet resolved.",
            "alternatives": [
              {
                "value": "outdated",
                "whyRejected": "The underlying WinRT component activation architecture has not changed in recent releases."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the app is deployed as packaged (MSIX) or unpackaged \u2014 this significantly affects WinRT component discovery",
          "Whether SkiaSharp.Views.WinUI.Native.dll is present in the app output directory on the failing systems",
          "Whether the failing systems have Windows App SDK runtime installed or if the app is self-contained",
          "Which specific system configuration differences cause the failure on \u0027certain systems\u0027 but not others"
        ],
        "assumptions": [
          "Assumed the app uses SKGLView (via LiveCharts2) since the crash path is through AngleSwapChainPanel, the GPU-accelerated OpenGL ES view",
          "Assumed target framework is net8.0-windows or net9.0-windows based on SkiaSharp 3.119.1 being a modern version"
        ],
        "resolution": {
          "hypothesis": "The WinRT activation factory for SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails because the C\u002B\u002B/WinRT component DLL cannot be discovered by the WinRT activation system on certain Windows configurations. The \u0027Element not found\u0027 COMException suggests the activation catalog entry exists but the backing DLL or class cannot be located, likely due to deployment mode or Windows App SDK runtime state.",
          "proposals": [
            {
              "title": "Replace WinRT PropertySetExtensions with managed alternative",
              "description": "Eliminate the dependency on the C\u002B\u002B/WinRT component by implementing PropertySet manipulation in managed code using WinRT interop APIs directly. This removes the activation factory requirement entirely and fixes this class of issues across all deployment modes.",
              "confidence": 0.7,
              "effort": "high"
            },
            {
              "title": "Add try-catch fallback around PropertySetExtensions in GlesContext.CreateSurface",
              "description": "Wrap PropertySetExtensions calls with try-catch(COMException) and skip the optional resolution scale/surface size properties on failure, allowing ANGLE surface creation to proceed with defaults.",
              "confidence": 0.6,
              "effort": "medium"
            },
            {
              "title": "Use SKCanvasView instead of SKGLView as workaround",
              "description": "Configure LiveCharts2 to use SKCanvasView (CPU rendering) instead of SKGLView, bypassing the entire AngleSwapChainPanel/GlesContext/PropertySetExtensions code path. Workaround for end users, not a fix in SkiaSharp itself.",
              "confidence": 0.8,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Replace WinRT PropertySetExtensions with managed alternative",
          "recommendedReason": "This is the root-cause fix that eliminates the entire class of WinRT activation failures. The C\u002B\u002B/WinRT component exists solely to add typed values to a PropertySet, which should be achievable in managed code. While higher effort, it permanently solves the recurring deployment and activation issues."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "This is a recurring WinRT activation failure pattern affecting multiple users across versions. The root cause needs engineering investigation \u2014 specifically whether PropertySetExtensions can be replaced with managed code to eliminate the C\u002B\u002B/WinRT dependency."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add backend/OpenGL and partner/maui labels to existing labels",
            "reason": "The crash is in the ANGLE OpenGL ES path and the reporter uses MAUI \u2014 these labels are missing from the current set",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis response with diagnostic questions and workaround suggestion",
            "reason": "Provide useful context from related issues and suggest diagnostic steps to narrow down the deployment configuration causing the failure",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the detailed stack trace \u2014 that\u0027s very helpful for diagnosing this.\n\nThis is a known issue pattern where the WinRT activation factory for \u0060SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0060 fails on certain Windows configurations. The \u0060COMException: Element not found\u0060 during \u0060BaseActivationFactory\u0060 construction suggests the WinRT component DLL either isn\u0027t deployed alongside the app or can\u0027t be found by the WinRT activation system on that particular machine.\n\nA couple of questions that would help narrow this down:\n\n1. Is the app deployed as packaged (MSIX) or unpackaged (\u0060WindowsPackageType=None\u0060)?\n2. Can you confirm whether \u0060SkiaSharp.Views.WinUI.Native.dll\u0060 exists in the app\u0027s output directory on the failing system?\n\nAs a potential workaround, if LiveCharts2 supports it, using \u0060SKCanvasView\u0060 instead of \u0060SKGLView\u0060 would bypass the ANGLE/OpenGL path entirely \u2014 though with CPU rendering instead of GPU-accelerated.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3440-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3440"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3437,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability",
          "backend/SVG"
        ],
        "state": "open"
      },
      "summary": "SKSvgCanvas produces \u003Ctext\u003E elements with missing text values and x/y attributes when used concurrently in parallel tasks on Windows \u2014 regression from 2.88.9",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "backends": [
          {
            "value": "backend/SVG",
            "confidence": 0.98
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "severity": "high",
          "severityReason": "Data corruption in SVG output with no simple workaround besides removing parallelism. Regression from 2.x.",
          "hasWorkaround": true,
          "workaroundSummary": "Avoid parallel usage of SKSvgCanvas \u2014 serialize SVG generation to a single thread, or downgrade to SkiaSharp 2.88.9.",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/jankurianski/skiasharp-svg-text-missing-bug",
              "description": "Full reproduction project demonstrating parallel SKSvgCanvas text corruption on Windows"
            }
          ],
          "stepsToReproduce": [
            "Create multiple parallel tasks using Task.Run()",
            "In each task, create an independent SKSvgCanvas writing to a MemoryStream",
            "Draw multiple text elements using canvas.DrawText()",
            "Dispose canvas to flush SVG output",
            "Inspect resulting SVG \u2014 \u003Ctext\u003E elements will have empty x/y attributes and missing text content"
          ],
          "codeSnippets": [
            {
              "code": "await Task.WhenAll(\n    Enumerable.Range(0, 5)\n    .Select(i =\u003E Task.Run(() =\u003E drawSvgFunc(i)))\n    ).ConfigureAwait(false);",
              "language": "csharp",
              "context": "Parallel SVG generation triggering the bug \u2014 each task creates its own independent SKSvgCanvas"
            }
          ],
          "environmentDetails": "Windows 11, Visual Studio Code, SkiaSharp 3.116.0 / 3.119.1 / 3.119.2-preview.1. Linux (Ubuntu 22.04.2 LTS via WSL) is unaffected."
        },
        "versionAnalysis": {
          "reason": "Bug affects all SkiaSharp 3.x versions tested including the latest preview. Confirmed working in 2.88.9.",
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "3.119.2-preview.1",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.92,
          "reason": "Reporter explicitly states 2.88.9 does not have the bug and all 3.x versions do. This aligns with the major Skia engine upgrade between 2.x and 3.x.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "Thread-safety bug in the SVG canvas backend on Windows. Independent SKSvgCanvas instances used in parallel tasks produce corrupted \u003Ctext\u003E elements with missing content and attributes. This is a regression from 2.88.9, suggesting the Skia 3.x SVG module introduced shared mutable global state.",
        "keySignals": [
          {
            "text": "text elements will sometimes have their text value and x/y attribute values removed",
            "source": "body",
            "interpretation": "Data corruption in SVG output \u2014 not a crash but silent data loss"
          },
          {
            "text": "The more text elements being drawn and the more threads running the same task, the more likely the problem is to occur",
            "source": "body",
            "interpretation": "Classic race condition symptom \u2014 probability increases with concurrency"
          },
          {
            "text": "This affects all SkiaSharp 3.x versions on Windows. Linux is unaffected.",
            "source": "body",
            "interpretation": "Windows-specific thread-safety issue, possibly related to platform-specific string formatting or locale handling"
          },
          {
            "text": "This is a regression from SkiaSharp 2.88.9 which does not have the bug.",
            "source": "body",
            "interpretation": "Regression tied to the Skia engine upgrade from 2.x to 3.x"
          },
          {
            "text": "I tested the bug on Ubuntu 22.04.2 LTS (using WSL) and the bug does not occur there",
            "source": "comment 1",
            "interpretation": "Reporter confirmed Linux is unaffected even with 100 elements and 50 parallel tasks \u2014 strongly platform-specific"
          },
          {
            "text": "GitHub repository with full source code to reproduce",
            "source": "body",
            "interpretation": "Complete reproduction project available \u2014 high-quality bug report"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Clear broken behavior: SVG output data corruption where text elements lose their content and attributes. The reporter provides expected vs actual output showing the defect.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to use threading \u2014 reporting data corruption in independent canvas instances."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKSvgCanvas is part of the core SkiaSharp API surface (binding/SkiaSharp/). While it targets SVG output, the code path goes through the main SkiaSharp library.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the root cause is likely in native Skia SVG code, the entry point is through the managed SkiaSharp API."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/SVG",
            "expandedReason": "The bug is specific to SKSvgCanvas \u2014 the SVG rendering backend. Standard raster canvas drawing is not affected."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Reporter confirmed the bug only occurs on Windows 11. Ubuntu 22.04 via WSL is unaffected even with significantly more parallelism."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Silent data corruption in output \u2014 text elements lose their content without any error or warning. The only workaround is to serialize work or downgrade to 2.x. This is a regression affecting all 3.x versions."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Well-documented regression with a complete repro project. Needs native-level debugging to identify the shared global state in Skia\u0027s SVG module causing the Windows-specific race condition.",
            "alternatives": [
              {
                "value": "close-wontfix",
                "whyRejected": "The bug has a high-quality reproduction and is a clear regression from 2.88.9 \u2014 it warrants investigation."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "tenet/reliability: Silent data corruption in SVG output with missing text values. tenet/compatibility: This is a regression from 2.88.9 to all 3.x versions, indicating a cross-version compatibility break."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter explicitly confirms 2.88.9 does not have the bug and all 3.x versions do. This aligns with the major Skia engine upgrade between 2.x and 3.x that likely changed SVG serialization internals."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Bug affects all SkiaSharp 3.x versions tested (3.116.0, 3.119.1, 3.119.2-preview.1) including the latest preview, confirming it remains unresolved.",
            "alternatives": [
              {
                "value": "outdated",
                "whyRejected": "The latest preview (3.119.2-preview.1) still exhibits the bug, so the issue is current."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the root cause is in Skia\u0027s C\u002B\u002B SVG module or in the C API/P/Invoke layer \u2014 needs native debugging",
          "Whether the issue affects other SVG element types beyond \u003Ctext\u003E or if it\u0027s specific to text rendering",
          "Whether Windows-specific locale or string formatting functions used in SVG serialization are the source of the race condition",
          "The exact shared mutable state causing the race \u2014 could be global buffers, static formatters, or locale-dependent number-to-string conversion"
        ],
        "assumptions": [
          "Assumed net8.0-windows target framework since reporter uses Windows 11 with VS Code but doesn\u0027t specify exact TFM",
          "Assumed the race condition is in native Skia code rather than the managed wrapper since each thread creates fully independent managed objects"
        ],
        "resolution": {
          "hypothesis": "The Skia 3.x SVG serialization module likely uses shared global state (possibly a string formatting buffer or locale-dependent number conversion function) that is not thread-safe on Windows. Linux uses different formatting functions (e.g., POSIX locale-independent formatting) that happen to be thread-safe, explaining the platform difference.",
          "proposals": [
            {
              "title": "Add thread-safety documentation for SKSvgCanvas",
              "description": "Document that Skia is not thread-safe and SKSvgCanvas instances should not be used concurrently, even if they are independent instances. This is the quickest mitigation but doesn\u0027t fix the underlying defect.",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Investigate and fix shared state in Skia SVG module",
              "description": "Debug the native Skia SVG serialization to identify the shared mutable state causing the race condition on Windows. This likely involves SkSVGDevice or related classes. May require an upstream Skia fix or a SkiaSharp-specific patch in the fork.",
              "confidence": 0.65,
              "effort": "high"
            },
            {
              "title": "Add per-thread locking around SVG canvas operations",
              "description": "Add a global lock in the managed SKSvgCanvas wrapper to serialize access to the SVG backend. This would fix the corruption but eliminate parallelism benefits for SVG generation.",
              "confidence": 0.8,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Investigate and fix shared state in Skia SVG module",
          "recommendedReason": "The root cause fix is the right long-term solution. Each independent canvas instance should be fully thread-safe. The regression from 2.x suggests a specific change that can be identified and fixed."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Well-documented regression with complete repro project. Needs native-level debugging to identify the shared global state in Skia\u0027s SVG module causing the Windows-specific race condition."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add tenet/compatibility label to reflect this is a 2.x to 3.x regression",
            "reason": "The regression from 2.88.9 to 3.x is a key signal \u2014 compatibility tenet captures this",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the high-quality report and confirm investigation is needed",
            "reason": "Reporter provided excellent reproduction material and cross-platform testing. Acknowledge the regression and signal that native-level investigation is the next step.",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the thorough report and the cross-platform testing \u2014 confirming Linux is unaffected is really helpful for narrowing this down.\n\nThis looks like a thread-safety issue in Skia\u0027s SVG serialization that\u0027s specific to Windows. Even though each task creates its own independent SKSvgCanvas, there may be shared global state in the native SVG module (possibly related to Windows string formatting or number-to-string conversion) that isn\u0027t safe to access concurrently.\n\nThe regression from 2.88.9 is a strong signal \u2014 the Skia engine was upgraded significantly between 2.x and 3.x, which likely changed how SVG text serialization works internally.\n\nThis needs investigation at the native Skia level to identify the shared state. In the meantime, serializing SVG generation to a single thread would be the safest workaround.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3437-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3437"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3435,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "DllNotFoundException for libSkiaSharp in Blazor WASM after upgrading from .NET 9 to .NET 10 \u2014 duplicate of #3422",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.9
        },
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.92
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.88
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "none",
          "severity": "high",
          "severityReason": "Complete failure to load libSkiaSharp in Blazor WASM on .NET 10. SkiaSharp is entirely unusable in this scenario. Multiple users affected across #3422.",
          "hasWorkaround": true,
          "workaroundSummary": "Downgrade to .NET 9 which works with SkiaSharp 3.116.1. Also, \u0027dotnet workload restore\u0027 may help per #3422 comments, though results are inconsistent.",
          "targetFrameworks": [
            "net10.0"
          ]
        },
        "reproEvidence": {
          "relatedIssues": [
            3422
          ],
          "environmentDetails": "Blazor WASM targeting .NET 10. Tried SkiaSharp 3.116.1 and 3.119.2-preview.1. Previously worked on .NET 9 with 3.116.1."
        },
        "versionAnalysis": {
          "reason": "Issue affects all SkiaSharp versions on .NET 10 WASM. The root cause is a .NET 10 WASM toolchain change, not a SkiaSharp version-specific regression. Confirmed by #3422 where even 2.88.x versions fail.",
          "mentionedVersions": [
            "3.116.1",
            "3.119.2-preview.1"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "SkiaSharp Blazor WASM worked on .NET 9 but fails on .NET 10. The regression is in the .NET platform\u0027s WASM toolchain, not in SkiaSharp itself \u2014 rolling back SkiaSharp versions does not fix it.",
          "workedInVersion": "3.116.1",
          "brokeInVersion": "3.116.1"
        }
      },
      "analysis": {
        "summary": "Duplicate of #3422. DllNotFoundException for libSkiaSharp in Blazor WASM on .NET 10. The .NET 10 WASM toolchain changed how native static linking works, breaking SkiaSharp\u0027s NativeAssets.WebAssembly integration. All SkiaSharp versions are affected.",
        "keySignals": [
          {
            "text": "System.DllNotFoundException: libSkiaSharp",
            "source": "title",
            "interpretation": "Native library not found \u2014 on WASM this means the .a file was not statically linked into dotnet.wasm during build."
          },
          {
            "text": "Started getting this runtime error after upgrading Blazor app from .Net 9 to .Net 10",
            "source": "body",
            "interpretation": "Clearly identifies .NET 10 upgrade as the trigger, matching #3422 pattern exactly."
          },
          {
            "text": ".Net 9 app worked with 3.116.1",
            "source": "body",
            "interpretation": "Confirms this is a .NET 10 regression, not a SkiaSharp version issue."
          },
          {
            "text": "Platform: Blazor, WASM",
            "source": "body",
            "interpretation": "This is a WASM issue, not Windows-Classic as currently labeled."
          },
          {
            "text": "Duplicate of https://github.com/mono/SkiaSharp/issues/3422",
            "source": "comment 2",
            "interpretation": "Community member identifies this as a duplicate of the canonical .NET 10 Blazor WASM issue."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "DllNotFoundException is a clear runtime crash. The reporter describes something that previously worked (Blazor WASM with .NET 9) now failing after upgrading to .NET 10. This is broken behavior, not a usage question.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they are reporting a crash that occurred after a .NET version upgrade."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Blazor",
            "expandedReason": "The issue is in a Blazor WASM app using SkiaSharp. The root cause is the WASM static linking pipeline managed by SkiaSharp.Views.Blazor and NativeAssets.WebAssembly packages. The current label area/libSkiaSharp.native is less specific \u2014 the native binary itself is fine, it\u0027s the WASM linking integration that\u0027s broken.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the native library fails to load, the root cause is in the WASM static linking pipeline, not the native binary itself. area/SkiaSharp.Views.Blazor better captures where the fix needs to happen."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM",
            "expandedReason": "Reporter explicitly states platform is \u0027Blazor, WASM\u0027. The current os/Windows-Classic label is incorrect \u2014 the issue is about WebAssembly execution in the browser, not Windows desktop. Windows is merely the development machine OS."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "tenet/reliability: DllNotFoundException causes complete failure. tenet/compatibility: This is a cross-version compatibility issue \u2014 SkiaSharp doesn\u0027t work with .NET 10\u0027s WASM toolchain."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Complete inability to use SkiaSharp in Blazor WASM on .NET 10. Workaround is to stay on .NET 9, which is viable but limits adoption.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": ".NET 10 is still in preview and users can stay on .NET 9. Not a data-loss or security issue."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "A community member identified this as a duplicate of #3422, which tracks the exact same issue (DllNotFoundException/TypeInitializationException for SkiaSharp in Blazor WASM on .NET 10). The symptoms, platform, and root cause are identical. #3422 has more detailed reproduction and community discussion."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "SkiaSharp Blazor WASM worked on .NET 9 but fails on .NET 10. The regression is in the .NET WASM toolchain, not SkiaSharp itself \u2014 rolling back SkiaSharp versions does not fix it."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Issue affects all SkiaSharp versions on .NET 10 WASM. The root cause is a .NET 10 toolchain change, not version-specific, as confirmed by #3422 where even 2.88.x versions fail.",
            "alternatives": [
              {
                "value": "outdated",
                "whyRejected": "The issue is not version-specific \u2014 it affects current and older versions equally on .NET 10."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the reporter tried \u0027dotnet workload restore\u0027 as suggested in #3422",
          "Whether the reporter\u0027s development environment is Windows or another OS \u2014 they selected \u0027Blazor, WASM\u0027 as platform but the previous triage labeled it Windows-Classic"
        ],
        "assumptions": [
          "Assumed this is the same root cause as #3422 based on identical symptoms (DllNotFoundException: libSkiaSharp in Blazor WASM on .NET 10) and the community duplicate identification",
          "Assumed the reporter\u0027s platform selection of \u0027Blazor, WASM\u0027 is accurate and os/Windows-Classic was a triage error"
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.9,
          "reason": "Identical symptoms to #3422: DllNotFoundException for libSkiaSharp in Blazor WASM on .NET 10. Community member confirms duplicate. #3422 is the canonical issue with more detail and discussion."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Fix platform and area labels: replace incorrect Windows-Classic with WASM, replace libSkiaSharp.native with Views.Blazor, add compatibility tenet",
            "reason": "Current labels have incorrect platform (Windows-Classic instead of WASM) and less specific area. This is a Blazor WASM issue, not a Windows desktop issue.",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "os/WASM",
                "area/SkiaSharp.Views.Blazor",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "os/Windows-Classic",
                "area/libSkiaSharp.native"
              ]
            }
          },
          {
            "id": "dup-1",
            "type": "link-duplicate",
            "risk": "medium",
            "description": "Mark as duplicate of #3422",
            "reason": "Identical issue: DllNotFoundException for libSkiaSharp in Blazor WASM on .NET 10. Confirmed by community member and matching symptoms.",
            "confidence": 0.9,
            "payload": {
              "duplicateOf": 3422,
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Notify reporter of duplicate and suggest workaround",
            "reason": "Let reporter know this is tracked in #3422 and provide interim guidance",
            "confidence": 0.88,
            "dependsOn": "dup-1",
            "payload": {
              "commentType": "duplicate-notice",
              "draftBody": "Thanks for reporting this. This is the same .NET 10 Blazor WASM compatibility issue tracked in #3422 \u2014 the \u0060DllNotFoundException\u0060 happens because the .NET 10 WASM toolchain changed how native libraries are statically linked, which affects all SkiaSharp versions.\n\nAs an interim workaround, some users have had success running \u0060dotnet workload restore\u0060 to ensure the WASM workload is properly installed for .NET 10. If that doesn\u0027t help, staying on .NET 9 is a reliable fallback until this is resolved.\n\nClosing in favor of #3422 where the investigation is being tracked.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3435-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as duplicate of #3422",
            "reason": "Duplicate of #3422 \u2014 same root cause and symptoms",
            "confidence": 0.9,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3435"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3430,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/WASM",
          "area/SkiaSharp.Views.Uno",
          "os/Windows-WinUI",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "NullReferenceException in SKXamlCanvas.Skia when canvas resizes because FreeBitmap destroys the bitmap that CreateBitmap just allocated",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.Views.Uno",
          "confidence": 0.97
        },
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.85
          },
          {
            "value": "os/Windows-WinUI",
            "confidence": 0.85
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": {
          "value": "partner/unoplatform",
          "confidence": 0.95
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "severity": "medium",
          "severityReason": "NRE crash when canvas resizes, but only affects the Uno Skia variant and requires a size change to trigger. No workaround provided, but the trigger condition is specific.",
          "hasWorkaround": false
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/blob/fbd27f7ec2e2ad8bd0f0f0484dd467c5d8395ae1/source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs#L72",
              "description": "Line 72 where bitmap.PixelBuffer throws NRE because bitmap was set to null by FreeBitmap"
            }
          ],
          "stepsToReproduce": [
            "Use SKXamlCanvas in an Uno Platform Skia-based app",
            "Trigger a canvas size change (e.g. window resize)",
            "DoInvalidate is called, which calls CreateBitmap",
            "CreateBitmap calls FreeBitmap at line 87 (size changed), then creates new bitmap at line 91",
            "CreateBitmap calls FreeBitmap again at line 106 (pixels null), which sets bitmap=null",
            "Back in DoInvalidate, line 72 accesses bitmap.PixelBuffer \u2014 NRE"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), Uno Platform Skia targets"
        },
        "versionAnalysis": {
          "reason": "The bug is in current source code (SKXamlCanvas.Skia.cs). The reporter lists 2.88.9 as the last known good version, but the Skia-specific variant of SKXamlCanvas may not have existed in that version, making the regression claim uncertain.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.55,
          "reason": "Reporter selected 2.88.9 as last good version from a form dropdown, but the SKXamlCanvas.Skia.cs file (Uno Skia variant) likely did not exist in 2.88.9. This may be a latent bug rather than a regression."
        }
      },
      "analysis": {
        "summary": "The reporter identified a real race condition in SKXamlCanvas.Skia.cs where CreateBitmap calls FreeBitmap twice during a size change, destroying the WriteableBitmap before DoInvalidate can use it. The code path is clear from reading the source.",
        "keySignals": [
          {
            "text": "FreeBitmap method may have reset bitmap field to null",
            "source": "body",
            "interpretation": "Reporter correctly identified the root cause: FreeBitmap nulls the bitmap field, and it is accessed after that"
          },
          {
            "text": "This line of code may throw NRE if the canvas changed its size",
            "source": "body",
            "interpretation": "The trigger is a canvas size change, which causes CreateBitmap to call FreeBitmap twice \u2014 once for size mismatch (line 87) and once for pixels mismatch (line 106)"
          },
          {
            "text": "Link to SKXamlCanvas.Skia.cs line 72",
            "source": "body",
            "interpretation": "Points to bitmap.PixelBuffer.AsStream() where NRE occurs because bitmap is null after the double-FreeBitmap sequence"
          },
          {
            "text": "Version: 3.116.0, Last Known Good: 2.88.9",
            "source": "body",
            "interpretation": "May be a latent bug rather than a regression since the Skia variant of this file is relatively new"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter describes a NullReferenceException caused by a logic error in resource management code. The bitmap field is set to null by FreeBitmap and then accessed without a null check. This is clearly broken behavior.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "This is not an improvement request \u2014 it\u0027s a crash caused by a logic error."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Uno",
            "expandedReason": "The bug is in SKXamlCanvas.Skia.cs, which is part of the SkiaSharp.Views.Uno.WinUI.Skia project. This is specific to the Uno Platform Skia rendering path.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "The more specific area/SkiaSharp.Views.Uno label exists and the bug is Uno-specific."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "NRE crash with no workaround, but the trigger is specific (canvas resize on Uno Skia targets). Not critical because it doesn\u0027t cause data loss and only affects one platform variant."
          },
          {
            "field": "partner",
            "chosen": "partner/unoplatform",
            "expandedReason": "The bug is in the Uno Platform-specific view layer (SKXamlCanvas.Skia.cs). The reporter MartinZikmund is a well-known Uno Platform contributor. The fix may need coordination with Uno Platform."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The bug report identifies a clear logic error (double FreeBitmap) confirmed by source code inspection. The fix approach is known but needs verification with tests across all Uno Skia targets and size-change scenarios.",
            "alternatives": [
              {
                "value": "ready-to-fix",
                "whyRejected": "While the root cause is clear, the fix needs careful testing to ensure the bitmap lifecycle is correct across all resize scenarios."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM, os/Windows-WinUI",
            "expandedReason": "The bug is in SKXamlCanvas.Skia.cs which targets all Uno Platform Skia backends. Reporter selected All platforms, and the code path affects both WASM and WinUI desktop Skia targets."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "NullReferenceException crash during canvas resize is a reliability issue \u2014 the application crashes during normal window resizing operations with no workaround."
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "The SKXamlCanvas.Skia.cs file is relatively new and likely did not exist in 2.88.9. The reporter\u0027s last-known-good selection appears to be a form default rather than a tested version, making this a latent bug."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The bug is in current source code at a specific line (SKXamlCanvas.Skia.cs:72), confirmed by source inspection and not yet fixed."
          }
        ],
        "uncertainties": [
          "Whether this bug also exists in the non-Skia variants of SKXamlCanvas (UWP/WinUI native paths)",
          "Whether the 2.88.9 last-known-good version claim is accurate or just a form default selection",
          "Whether there are other callers or code paths that can trigger the same double-FreeBitmap issue"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s code analysis is correct based on source code inspection confirming the double-FreeBitmap path",
          "Assumed \u0027All\u0027 platforms means all Uno Skia targets (WASM, WinUI desktop), not all SkiaSharp platforms"
        ],
        "resolution": {
          "hypothesis": "CreateBitmap calls FreeBitmap at line 106 to free the old pixel buffer, but this also nulls the bitmap that was just created at line 91. The second FreeBitmap destroys the bitmap unnecessarily because it conflates pixel buffer management with bitmap management.",
          "proposals": [
            {
              "title": "Add null check before accessing bitmap in DoInvalidate",
              "description": "Guard line 72 with \u0060if (bitmap != null)\u0060 before accessing bitmap.PixelBuffer. Simple defensive fix that prevents the NRE, but doesn\u0027t address the underlying logic issue where CreateBitmap returns with bitmap=null.",
              "confidence": 0.7,
              "effort": "low"
            },
            {
              "title": "Separate pixel buffer freeing from bitmap freeing in CreateBitmap",
              "description": "Split FreeBitmap into two concerns: one that frees pixels/handle only, and one that frees the bitmap. The second FreeBitmap call at line 106 only needs to free the pixel buffer, not the bitmap. This addresses the root cause by ensuring the bitmap created at line 91 survives the pixel reallocation.",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Restructure CreateBitmap to handle bitmap and pixels independently",
              "description": "Refactor CreateBitmap so that bitmap creation and pixel buffer allocation are managed separately with their own lifecycle. The bitmap should only be recreated when its dimensions change, and pixels should be reallocated independently. This is the cleanest fix but involves more refactoring.",
              "confidence": 0.85,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Separate pixel buffer freeing from bitmap freeing in CreateBitmap",
          "recommendedReason": "Addresses the root cause directly with minimal code change. The second FreeBitmap call only needs to free the GCHandle and pixel array, not the WriteableBitmap."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The bug report identifies a real logic error confirmed by source code inspection. The fix approach is clear but should be verified with a test to ensure the bitmap lifecycle is correct across all size-change scenarios."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add partner/unoplatform label \u2014 existing labels are already correct",
            "reason": "The bug is in the Uno Platform-specific view layer and the reporter is an Uno Platform contributor",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "partner/unoplatform"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis confirming the bug and describing the root cause",
            "reason": "Acknowledge the well-analyzed report and confirm the double-FreeBitmap root cause",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the clear analysis and the direct pointer to the problematic line.\n\nConfirmed \u2014 the issue is in \u0060CreateBitmap()\u0060 where \u0060FreeBitmap()\u0060 is called twice during a size change. The first call (line 87) correctly frees the old bitmap when dimensions change, and then a new \u0060WriteableBitmap\u0060 is created (line 91). But the second call (line 106) frees the pixel buffer *and* nulls the bitmap that was just created, because \u0060FreeBitmap()\u0060 doesn\u0027t distinguish between the two resources.\n\nThe fix would be to separate pixel buffer management from bitmap management in that second code path, so that reallocating the pixel array doesn\u0027t destroy the freshly created bitmap.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3430-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3430"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3429,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "Memory leak in WPF on Windows with Nvidia Quadro GPU drivers when drawing patterns on high-resolution monitors; mitigated by WPF software-only rendering mode",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.75
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.9
          },
          {
            "value": "tenet/performance",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "severity": "medium",
          "severityReason": "Memory leak in production use with a workaround that is impractical due to performance degradation. Only affects Nvidia Quadro series GPUs.",
          "hasWorkaround": true,
          "workaroundSummary": "Set RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly in App.OnStartup to disable WPF hardware acceleration. Not practical for production due to performance impact on other application features."
        },
        "reproEvidence": {
          "relatedIssues": [
            3309,
            2660,
            2848
          ],
          "codeSnippets": [
            {
              "code": "protected override void OnStartup(StartupEventArgs e)\n{\n    RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly;\n    base.OnStartup(e);\n}",
              "language": "csharp",
              "context": "Workaround that disables WPF hardware acceleration to avoid the memory leak"
            }
          ],
          "environmentDetails": "Windows, WPF, Nvidia Quadro series GPU, high resolution monitor, Visual Studio, SkiaSharp 3.116.0"
        },
        "versionAnalysis": {
          "reason": "Issue reported on 3.116.0 which was current at time of filing. Last known good version is 2.88.9 (v2 series), suggesting the issue may have been introduced in the v3 rewrite.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.7,
          "reason": "Reporter states last known good version is 2.88.9. However, the gap between v2.88.9 and v3.116.0 is a major version jump spanning the v3 rewrite, so this is a broad regression claim rather than a pinpointed version.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "GPU-driver-specific memory leak in WPF when drawing patterns with SkiaSharp, isolated to Nvidia Quadro series. The WPF SoftwareOnly workaround points to an interaction between SkiaSharp rendering and WPF\u0027s hardware-accelerated compositing layer. Related to other GPU memory leak reports (#3309, #2660, #2848) but distinct due to Quadro-specific trigger.",
        "keySignals": [
          {
            "text": "Memory Leak on Window with Nvidia GPU driver",
            "source": "title",
            "interpretation": "GPU-driver-specific memory leak, not a general SkiaSharp issue"
          },
          {
            "text": "only occurred in the Nvidia Quadro series",
            "source": "body",
            "interpretation": "Highly specific to professional GPU line \u2014 suggests driver-level interaction, not a generic SkiaSharp bug"
          },
          {
            "text": "doesn\u0027t happen with Nvidia Geforce or AMD",
            "source": "body",
            "interpretation": "Reporter did thorough cross-GPU testing, narrowing to Quadro-specific driver behavior"
          },
          {
            "text": "RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly",
            "source": "body",
            "interpretation": "Disabling WPF hardware acceleration eliminates the leak, pointing to GPU compositing interaction as the root cause"
          },
          {
            "text": "drawing patterns in wpf, a memory leak issue was encountered on the high resolution monitor",
            "source": "body",
            "interpretation": "High-DPI display may amplify the leak due to larger backing buffers or scaling operations"
          },
          {
            "text": "Version 3.116.0, Last Known Good 2.88.9",
            "source": "body",
            "interpretation": "Possible regression from v2 to v3 series, though this is a large version gap"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a memory leak that grows over time during normal drawing operations. This is broken behavior \u2014 memory should not leak during repeated draw calls.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they are reporting broken behavior with a specific workaround they already found."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The issue occurs when drawing patterns in WPF, which uses SkiaSharp.Views.WPF controls. The workaround is a WPF-level rendering setting, further pointing to the views integration layer. Could also be area/libSkiaSharp.native if the native library leaks GPU memory on Quadro drivers.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "Possible, but the WPF SoftwareOnly workaround suggests the leak is in the compositing/presentation layer rather than core native rendering."
              },
              {
                "value": "area/SkiaSharp",
                "whyRejected": "Too broad \u2014 the issue is specific to WPF rendering integration, not core SkiaSharp API."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Memory leak that worsens over time, but has a workaround (software rendering). The workaround is impractical for production, but the issue is limited to Nvidia Quadro GPUs, reducing the affected population."
          },
          {
            "field": "regression",
            "chosen": "true",
            "expandedReason": "Reporter claims last known good version is 2.88.9. The v2-to-v3 jump involved a major rewrite of the native layer and views, making regression plausible but the specific breaking change hard to pinpoint."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "The bug is real but critical details are missing: which WPF control (SKElement vs SKGLElement), GPU model/driver version, and a minimal repro. The existing OpenTK fix (#3309) might already resolve this if SKGLElement is in use.",
            "alternatives": [
              {
                "value": "needs-investigation",
                "whyRejected": "Cannot investigate effectively without knowing which WPF control is used \u2014 the existing SKGLElement memory leak fix may already apply."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "WPF is a Windows-Classic (Win32/WPF) framework. The reporter runs on Windows with Nvidia Quadro GPUs and the workaround uses WPF-specific RenderOptions API."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/performance",
            "expandedReason": "Reliability: memory leak degrades application stability over time during normal drawing operations. Performance: the only workaround (software rendering) causes significant performance loss for the rest of the application."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter states last known good version is 2.88.9. The v2-to-v3 rewrite of the native layer and views makes regression plausible, though the large version gap means the exact breaking change is unidentified."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Reported on current SkiaSharp 3.116.0 with no indication the issue has been fixed in newer versions. The GPU-driver-specific nature makes it unlikely to self-resolve."
          }
        ],
        "uncertainties": [
          "Which WPF SkiaSharp control is being used (SKElement, SKGLElement, or SKXamlCanvas)?",
          "Whether the leak is in SkiaSharp\u0027s rendering, WPF\u0027s compositing, or the Nvidia Quadro driver itself",
          "Specific Nvidia Quadro model and driver version",
          "Whether the issue is specific to high-DPI or also occurs on standard resolution monitors",
          "Whether #3309 (SKGLElement OpenTK memory leak fix) resolves this issue as well"
        ],
        "assumptions": [
          "Assumed the reporter is using a WPF SkiaSharp view control (SKElement or SKGLElement) since they mention \u0027drawing patterns in WPF\u0027",
          "Assumed the memory leak is reproducible and not a measurement artifact, based on the reporter\u0027s cross-GPU validation"
        ],
        "resolution": {
          "hypothesis": "The Nvidia Quadro driver handles GPU resource management differently from GeForce and AMD drivers, causing SkiaSharp-rendered surfaces to leak GPU memory when composited through WPF\u0027s hardware-accelerated pipeline. The v3 rewrite may have changed how surfaces are allocated or recycled, exposing a Quadro-specific driver bug or resource management issue.",
          "proposals": [
            {
              "title": "Check if SKGLElement OpenTK fix (#3309/#3311) resolves the issue",
              "description": "Issue #3309 identified a memory leak in SKGLElement due to OpenTK not being disposed. If the reporter is using SKGLElement, the fix in #3311 (updating OpenTK dependency) may resolve this. Ask reporter which control they use.",
              "confidence": 0.5,
              "effort": "low"
            },
            {
              "title": "Switch to SKElement (software-rendered) for the SkiaSharp control",
              "description": "If using SKGLElement (GPU-accelerated), switching to SKElement (CPU-rendered) would avoid the GPU driver interaction while keeping WPF hardware acceleration for other UI elements. Better targeted than the full SoftwareOnly workaround.",
              "confidence": 0.65,
              "effort": "low"
            },
            {
              "title": "Investigate GPU resource cache management on Quadro drivers",
              "description": "Profile GPU memory allocation during pattern drawing to identify whether SkiaSharp\u0027s GrDirectContext resource cache behaves differently on Quadro. May need to explicitly flush or limit the GPU resource cache (GrDirectContext.SetResourceCacheLimit).",
              "confidence": 0.55,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Check if SKGLElement OpenTK fix (#3309/#3311) resolves the issue",
          "recommendedReason": "Lowest effort \u2014 an existing fix for WPF memory leaks may already address this. Determining the control type will immediately narrow the diagnosis."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.85,
          "reason": "Real bug with validated workaround, but missing critical details: which SkiaSharp WPF control is used, specific GPU model/driver version, and minimal reproduction project. Need this info to investigate effectively.",
          "missingInfo": [
            "reproduction-steps",
            "sample-project",
            "device-info"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp.Views and tenet/performance labels",
            "reason": "WPF views integration is the affected component. Memory leak is both a reliability and performance concern.",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp.Views",
                "tenet/performance"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Request details about WPF control type, GPU model, and ask for minimal repro",
            "reason": "Cannot investigate without knowing which SkiaSharp WPF control is in use and whether the existing SKGLElement fix applies",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the thorough GPU testing \u2014 narrowing it to Nvidia Quadro specifically is really valuable information.\n\nThe fact that WPF\u0027s SoftwareOnly mode eliminates the leak is an important clue. It suggests the memory leak is in the interaction between the SkiaSharp rendering surface and WPF\u0027s hardware-accelerated compositing, rather than in SkiaSharp\u0027s drawing operations themselves.\n\nA couple of questions that would help narrow this down:\n\n1. Which SkiaSharp WPF control are you using \u2014 \u0060SKElement\u0060 or \u0060SKGLElement\u0060? If it\u0027s \u0060SKGLElement\u0060, there\u0027s a known memory leak fix in #3309 / #3311 related to OpenTK disposal that might address this.\n\n2. Would you be able to share the Nvidia Quadro model and driver version? Some Quadro driver versions have known issues with GPU resource management under certain compositing scenarios.\n\nIf it\u0027s not too much trouble, a minimal reproduction project would make it much easier to investigate the specific interaction between SkiaSharp, WPF compositing, and the Quadro driver.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3429-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3429"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3428,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/iOS",
          "area/SkiaSharp.Views.Maui",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "SKGLView fails to bind EAGLDrawable on .NET 10 MAUI iOS, rendering white canvas instead of content",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.92
          }
        ],
        "platforms": [
          {
            "value": "os/iOS",
            "confidence": 0.98
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.9
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.85
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "high",
          "severityReason": "GL rendering is completely broken on iOS with .NET 10 \u2014 white canvas with no content. No workaround provided. Affects all SKGLView users targeting .NET 10 on iOS.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "net10.0-ios"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/Mapsui/Mapsui/blob/main/Mapsui.UI.Maui/MapControl.cs",
              "description": "Mapsui MapControl source showing the GL paint surface handler code that triggers the issue."
            }
          ],
          "stepsToReproduce": [
            "Create a MAUI app targeting .NET 10 for iOS",
            "Add SkiaSharp 3.116.0 with SKGLView (GL-accelerated rendering)",
            "Run on an iOS device or simulator",
            "Observe white canvas and \u0027Failed to bind EAGLDrawable\u0027 in device logs"
          ],
          "codeSnippets": [
            {
              "code": "private void OnGLPaintSurface(object? sender, SKPaintGLSurfaceEventArgs args)\n{\n    if (_glView?.GRContext is null)\n    {\n        Logger.Log(LogLevel.Warning, \u0022Refresh can not be called because GRContext is null\u0022);\n        return;\n    }\n    PaintSurface(args.Surface.Canvas);\n}",
              "language": "csharp",
              "context": "Mapsui MapControl GL paint handler \u2014 the callback that should render content but results in white canvas."
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, .NET 10, MAUI, iOS, Visual Studio macOS. Works on .NET 9, broken on .NET 10. Last known good SkiaSharp version: 2.88.9."
        },
        "versionAnalysis": {
          "reason": "Issue is on latest SkiaSharp 3.116.0 with bleeding-edge .NET 10. The problem is likely related to .NET 10\u0027s iOS runtime changes rather than SkiaSharp version, since 3.116.0 works on .NET 9. Apple has deprecated OpenGL ES (EAGL) since iOS 12, and .NET 10 may have removed or changed EAGL support.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "Reporter states it works on .NET 9 but not .NET 10. Same SkiaSharp version (3.116.0) works on .NET 9 but fails on .NET 10, indicating a regression introduced by .NET 10 runtime or iOS SDK changes rather than by SkiaSharp itself.",
          "workedInVersion": "3.116.0 on .NET 9",
          "brokeInVersion": "3.116.0 on .NET 10"
        }
      },
      "analysis": {
        "summary": "SKGLView fails to render on iOS when targeting .NET 10, producing a white canvas and \u0027Failed to bind EAGLDrawable\u0027 error. The root cause is likely .NET 10\u0027s handling of the deprecated OpenGL ES (EAGL) APIs on iOS, since SKGLView depends on GLKView/EAGLContext which Apple deprecated in iOS 12.",
        "keySignals": [
          {
            "text": "Failed to bind EAGLDrawable on .NET 10 in MAUI iOS",
            "source": "title",
            "interpretation": "EAGLDrawable is the iOS OpenGL ES rendering surface. Failure to bind it means the GL framebuffer cannot be created, resulting in no rendering output."
          },
          {
            "text": "not in .NET 9",
            "source": "body",
            "interpretation": "Explicitly a .NET 10-specific regression. Same SkiaSharp version works on .NET 9, pointing to a runtime or SDK change."
          },
          {
            "text": "Failed to bind EAGLDrawable: \u003CCAEAGLLayer: 0x600001767a40\u003E to GL_RENDERBUFFER 1",
            "source": "comment 2 (charlenni)",
            "interpretation": "Actual iOS system error confirming EAGL layer binding failure and incomplete framebuffer objects \u2014 the OpenGL ES rendering pipeline is broken."
          },
          {
            "text": "No error and a white canvas",
            "source": "body",
            "interpretation": "The GL view silently fails to render \u2014 no crash, just blank output. This is a silent rendering failure."
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9 (Previous)",
            "source": "body",
            "interpretation": "Reporter considers 2.88.9 the last good version, but the issue is .NET 10 specific so the SkiaSharp version may be less relevant than the .NET target framework change."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a rendering failure \u2014 expected content but gets white canvas with \u0027Failed to bind EAGLDrawable\u0027 error. This is clearly broken behavior in a previously working scenario, not a question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they have working code that broke on .NET 10."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Maui",
            "expandedReason": "The issue is in the MAUI SKGLView rendering pipeline. The code uses SKPaintGLSurfaceEventArgs in a MAUI context. The underlying SKGLView is consumed through MAUI controls.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "While SKGLView lives in SkiaSharp.Views, the user is consuming it through MAUI, making SkiaSharp.Views.Maui the more specific and accurate label."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "EAGLDrawable and EAGLContext are the iOS-specific OpenGL ES rendering infrastructure. SKGLView explicitly creates EAGLContext(OpenGLES2). The failure is in GL framebuffer binding."
          },
          {
            "field": "platforms",
            "chosen": "os/iOS",
            "expandedReason": "Reporter explicitly states iOS. EAGL is iOS-only infrastructure. No mention of other platforms being affected."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "Reliability: the GL view fails silently (white canvas) rather than rendering content. Compatibility: the issue is specific to .NET 10 \u2014 same code works on .NET 9, indicating a cross-version compatibility problem."
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "Issue is in the MAUI rendering pipeline. The .NET 10 target framework change may be a MAUI or .NET runtime-level change affecting EAGL context initialization."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "GL rendering is completely broken on iOS with .NET 10 \u2014 no content rendered at all, no workaround provided. Not critical because the app does not crash and SKCanvasView (CPU rendering) is likely a viable fallback.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "No crash or data loss. The app still runs, just shows white canvas."
              },
              {
                "value": "medium",
                "whyRejected": "Complete rendering failure with no confirmed workaround warrants high, not medium."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "GL rendering on iOS is completely broken on .NET 10 with no workaround. Need to determine whether .NET 10 or Apple removed EAGL support, and whether a fix is in SkiaSharp\u0027s scope or requires .NET runtime changes.",
            "alternatives": [
              {
                "value": "close-wontfix",
                "whyRejected": "OpenGL ES is deprecated by Apple but SKGLView is still a supported SkiaSharp component \u2014 the rendering failure needs a fix or a documented migration to Metal."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter confirms the same SkiaSharp version (3.116.0) works on .NET 9 but fails on .NET 10, indicating a regression introduced by .NET 10 runtime or iOS SDK changes affecting EAGL context binding."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Issue is on current SkiaSharp 3.116.0 with .NET 10 and relates to Apple\u0027s ongoing deprecation of OpenGL ES, making it actively relevant to current development."
          }
        ],
        "uncertainties": [
          "Exact .NET 10 preview version not specified \u2014 different previews may have different EAGL support levels",
          "Unknown whether Apple fully removed EAGL support in a recent iOS SDK or if .NET 10 changed its OpenGL ES bindings",
          "Unknown whether SKCanvasView (CPU rendering) works as a workaround on .NET 10",
          "Device model and iOS version not specified \u2014 could be relevant if newer hardware dropped EAGL support"
        ],
        "assumptions": [
          "Assumed the reporter is using a recent .NET 10 preview since they mention .NET 10 specifically",
          "Assumed EAGLDrawable error from charlenni\u0027s comment is the same error the original reporter sees, since they are both Mapsui contributors reporting the same problem"
        ],
        "resolution": {
          "hypothesis": ".NET 10\u0027s iOS runtime or Apple\u0027s latest SDK has changed how EAGLContext/EAGLDrawable binding works, breaking the deprecated OpenGL ES rendering path used by SKGLView. Apple deprecated OpenGL ES in iOS 12 (2018) and has been progressively removing support. SKGLView\u0027s GLKView\u002BEAGLContext approach may no longer function correctly under .NET 10\u0027s updated iOS bindings.",
          "proposals": [
            {
              "title": "Switch to SKCanvasView (CPU rendering) as workaround",
              "description": "Replace SKGLView with SKCanvasView which uses CPU-based raster rendering instead of OpenGL ES. Avoids the deprecated EAGL path entirely. Immediate workaround but loses GPU acceleration.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Implement Metal backend for iOS GPU rendering",
              "description": "Replace the OpenGL ES (EAGL) backend with Metal for iOS GPU rendering. This follows Apple\u0027s recommended migration path. Long-term correct solution but significant engineering effort.",
              "confidence": 0.9,
              "effort": "high"
            },
            {
              "title": "Investigate and patch .NET 10 EAGL context initialization",
              "description": "Debug why EAGLDrawable binding fails specifically on .NET 10. Create minimal repro, compare EAGL context state between .NET 9 and .NET 10, check if .NET 10 bindings removed or changed GLKit/EAGLContext APIs.",
              "confidence": 0.5,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Implement Metal backend for iOS GPU rendering",
          "recommendedReason": "Apple deprecated OpenGL ES in 2018 and has been progressively removing support. Patching EAGL is fighting a losing battle. SKCanvasView workaround can be recommended to users immediately while Metal support is implemented."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real rendering failure on .NET 10 iOS that needs investigation. Root cause is likely .NET 10 or Apple\u0027s continued deprecation of OpenGL ES (EAGL). Need to determine if this is fixable in SkiaSharp or requires .NET runtime changes.",
          "missingInfo": [
            "device-info"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add OpenGL backend, compatibility tenet, and MAUI partner labels",
            "reason": "Issue is specific to OpenGL backend on iOS, is a .NET 10 compatibility issue, and involves MAUI rendering pipeline",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL",
                "tenet/compatibility",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis noting EAGL deprecation and requesting .NET 10 preview version details",
            "reason": "Need to confirm .NET 10 preview version and offer SKCanvasView as interim workaround",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for reporting this \u2014 the EAGLDrawable binding failure is a significant signal.\n\nThe \u0060SKGLView\u0060 on iOS uses \u0060GLKView\u0060 with \u0060EAGLContext\u0060 (OpenGL ES 2), which Apple deprecated back in iOS 12 in favor of Metal. The fact that this works on .NET 9 but not .NET 10 suggests that .NET 10\u0027s iOS runtime or the underlying Apple SDK may have changed how EAGL contexts are initialized or bound.\n\nA couple of questions that would help narrow this down:\n\n1. Which .NET 10 preview version are you using?\n2. Does switching from \u0060SKGLView\u0060 to \u0060SKCanvasView\u0060 (CPU rendering) work as a temporary workaround?\n\nLonger term, the path forward for iOS GPU rendering is likely Metal rather than OpenGL ES, given Apple\u0027s deprecation timeline. But we need to understand what specifically changed in .NET 10 first.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3428-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3428"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3423,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-07-17T18:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "ClickOnce deployment of .NET Framework 4.7.2 WinForms app fails to include libSkiaSharp.dll, causing DllNotFoundException",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.97
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.9
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Hard crash via DllNotFoundException, but a community-confirmed workaround exists and the issue is specific to ClickOnce deployment \u2014 MSIX works correctly.",
          "hasWorkaround": true,
          "workaroundSummary": "Manually add libSkiaSharp.dll from the NativeAssets.Win32 NuGet package (runtimes/win-x64/native/) as an existing item in the VS project, set Build Action to Content and Copy to Output Directory to \u0027Copy if newer\u0027, then verify it appears in ClickOnce Application Files as Include/Required.",
          "targetFrameworks": [
            "net472"
          ]
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET Framework 4.7.2 WinForms application",
            "Add SkiaSharp and SkiaSharp.NativeAssets.Win32 NuGet packages",
            "Use SKBitmap.Decode() or any SkiaSharp API",
            "Publish the application using ClickOnce deployment from Visual Studio",
            "Run the published ClickOnce application \u2014 DllNotFoundException occurs"
          ],
          "codeSnippets": [
            {
              "code": "var image = SKBitmap.Decode(imageData ?? throw new ArgumentNullException(nameof(imageData)))",
              "language": "csharp",
              "context": "Code that triggers the DllNotFoundException when run in a ClickOnce-deployed application"
            }
          ],
          "environmentDetails": ".NET Framework 4.7.2, WinForms, Visual Studio 2022 (Windows), SkiaSharp 3.119.1 (description) / 3.116.0 (version dropdown), Windows 10 and Windows 11, Dell workstations, ClickOnce deployment"
        },
        "versionAnalysis": {
          "reason": "SkiaSharp 3.x is the current major version. The issue is about ClickOnce deployment not handling the runtimes/ folder structure from NuGet NativeAssets packages, which persists across versions.",
          "mentionedVersions": [
            "3.119.1",
            "3.116.0"
          ],
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "ClickOnce deployment of a .NET Framework 4.7.2 WinForms app fails to include the native libSkiaSharp.dll from the NativeAssets.Win32 NuGet package, causing DllNotFoundException at runtime. This is a well-understood ClickOnce limitation with NuGet runtimes/ directory native assets, not a SkiaSharp code defect. A community workaround exists and is confirmed working by both the reporter and another user.",
        "keySignals": [
          {
            "text": "System.DllNotFoundException: Unable to load library \u0027libSkiaSharp\u0027",
            "source": "stack-trace",
            "interpretation": "Native binary not found at runtime \u2014 the DLL was not deployed to the ClickOnce application directory"
          },
          {
            "text": "Our MSIX version of the app does not however, and I think its because libSkiaSharp.dylib is not being included in the ClickOnce publish",
            "source": "body",
            "interpretation": "User correctly identifies that ClickOnce is not including the native binary, while MSIX does. Points to a deployment mechanism issue, not a missing package."
          },
          {
            "text": ".net winforms app (framework 4.7.2)",
            "source": "body",
            "interpretation": ".NET Framework 4.7.2 WinForms \u2014 maps to Windows-Classic platform. Old-style project format may compound ClickOnce native asset issues."
          },
          {
            "text": "manually add libSkiaSharp.dll from NativeAssets.Win32 package as Content with Copy if newer",
            "source": "comment 2",
            "interpretation": "Community-confirmed workaround that addresses the deployment gap by forcing the native DLL into the ClickOnce output"
          },
          {
            "text": "That was how if I fixed it too. Had a similar issue with the native DLLs that are supposed to be part of Microsoft.Data.SqlClient",
            "source": "comment 3",
            "interpretation": "OP confirms the workaround and notes this is a broader ClickOnce issue affecting multiple NuGet packages with native assets"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The native binary fails to deploy in ClickOnce, causing a DllNotFoundException crash. While this is arguably a ClickOnce tooling limitation rather than a SkiaSharp code defect, the user\u0027s app breaks when using SkiaSharp with ClickOnce, which qualifies as a bug from the user\u0027s perspective.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting a hard crash in a deployment scenario."
              },
              {
                "value": "type/enhancement",
                "whyRejected": "Could argue SkiaSharp should add ClickOnce-friendly packaging, but the immediate issue is broken behavior, not a feature gap."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "DllNotFoundException for the native library. The issue is about native binary deployment, not the managed C# API.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The managed SkiaSharp code works correctly \u2014 the issue is the native binary not being present at runtime."
              },
              {
                "value": "area/Build",
                "whyRejected": "The build succeeds. The issue is in the ClickOnce publish/deployment step, which is outside SkiaSharp\u0027s build system."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": ".NET Framework 4.7.2 WinForms is definitively Windows-Classic (Win32 APIs). ClickOnce is a Windows-Classic deployment mechanism."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "The application crashes with an unhandled TypeInitializationException/DllNotFoundException. The app fails to function at all when deployed via ClickOnce."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash (DllNotFoundException) but a workaround exists and is confirmed by multiple users. The issue is specific to one deployment method (ClickOnce) while others (MSIX) work.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Workaround exists and is confirmed by OP. Other deployment methods work."
              },
              {
                "value": "critical",
                "whyRejected": "Not data loss or security. Deployment-specific with a known workaround."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The root cause is a ClickOnce limitation, not a SkiaSharp defect. A confirmed workaround exists. The issue could be closed with the documented workaround. However, human review is recommended because SkiaSharp might want to keep this open to track potential packaging improvements.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "Valid option if the team wants to investigate ClickOnce-friendly packaging. Marked requiresHumanReview for this reason."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "The root cause and workaround are already known. No further investigation needed."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "ClickOnce native asset deployment issue persists across SkiaSharp 3.x versions (3.116.0, 3.119.1) due to the runtimes/ folder convention used by NativeAssets packages. The root cause is a ClickOnce tooling limitation, not version-specific."
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp\u0027s NuGet packaging could be improved to better support ClickOnce (e.g., including native DLLs outside the runtimes/ folder for .NET Framework targets)",
          "Whether the user\u0027s project uses packages.config or PackageReference \u2014 this affects how NuGet native assets are handled",
          "The user mentions libSkiaSharp.dylib (macOS binary name) in the description but is on Windows \u2014 likely a terminology confusion"
        ],
        "assumptions": [
          "Assumed the user has SkiaSharp.NativeAssets.Win32 correctly referenced, since MSIX deployment works and the issue is ClickOnce-specific",
          "Assumed .NET Framework project format (not SDK-style) since it\u0027s .NET Framework 4.7.2 WinForms \u2014 this affects NuGet asset handling"
        ],
        "resolution": {
          "hypothesis": "ClickOnce deployment does not automatically include native binaries from NuGet packages that use the runtimes/{rid}/native/ directory convention. The SkiaSharp.NativeAssets.Win32 package places libSkiaSharp.dll in runtimes/win-x64/native/ (and win-x86), but ClickOnce\u0027s Application Files mechanism doesn\u0027t discover files in this path structure. MSIX handles this correctly because it processes the full output directory layout.",
          "proposals": [
            {
              "title": "Manual DLL inclusion as Content (confirmed workaround)",
              "description": "Manually add libSkiaSharp.dll from the NativeAssets.Win32 package to the project as Content with \u0027Copy if newer\u0027. This forces ClickOnce to include the native binary. Confirmed working by multiple users, but must be repeated when updating SkiaSharp version.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "MSBuild targets for ClickOnce-compatible native asset deployment",
              "description": "Add MSBuild targets to SkiaSharp.NativeAssets.Win32 that detect ClickOnce/.NET Framework projects and copy native DLLs to the output directory as content files, bypassing the runtimes/ directory structure. Permanent fix but requires ClickOnce MSBuild integration work.",
              "confidence": 0.6,
              "effort": "medium"
            },
            {
              "title": "Switch to MSIX deployment",
              "description": "Migrate the application from ClickOnce to MSIX deployment, which correctly handles the runtimes/ native asset structure. User confirmed MSIX already works, but this is a significant deployment infrastructure change.",
              "confidence": 0.85,
              "effort": "high"
            }
          ],
          "recommendedProposal": "Manual DLL inclusion as Content (confirmed workaround)",
          "recommendedReason": "Already confirmed working by both the reporter and another community member. Zero risk, low effort, and immediately actionable."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.75,
          "reason": "The root cause is a ClickOnce limitation with NuGet runtimes/ native assets, not a SkiaSharp defect. A community-confirmed workaround exists. However, human review is recommended \u2014 the team may want to keep this open to track packaging improvements.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels already match classification \u2014 no changes needed",
            "reason": "Current labels (type/bug, area/libSkiaSharp.native, os/Windows-Classic, tenet/reliability) already match the triage classification exactly",
            "confidence": 0.97,
            "payload": {
              "labelsToAdd": [],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post response acknowledging the workaround and explaining root cause",
            "reason": "The workaround is confirmed by multiple users and root cause is well-understood. A closing comment would document the resolution for future visitors.",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed report and stack trace \u2014 and @ERPCG, thanks for documenting the workaround so thoroughly.\n\nThis is a known limitation of ClickOnce deployment with NuGet packages that use the \u0060runtimes/\u0060 folder convention for native assets. ClickOnce doesn\u0027t automatically pick up files from the \u0060runtimes/{rid}/native/\u0060 directory structure that \u0060SkiaSharp.NativeAssets.Win32\u0060 uses. MSIX handles this correctly because it processes the full NuGet output layout.\n\nThe workaround @ERPCG described is the right approach for ClickOnce:\n1. Locate \u0060libSkiaSharp.dll\u0060 in \u0060packages\\SkiaSharp.NativeAssets.Win32.{version}\\runtimes\\win-x64\\native\\\u0060 (or \u0060win-x86\u0060 for 32-bit)\n2. Add it to your project as an existing item\n3. Set **Build Action = Content** and **Copy to Output = Copy if newer**\n4. Verify it appears in **Project \u2192 Properties \u2192 Publish \u2192 Application Files** as Include/Required\n\nThis isn\u0027t specific to SkiaSharp \u2014 other packages with native assets (like Microsoft.Data.SqlClient, as @ajohnstone-ks noted) hit the same ClickOnce limitation.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3423-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as answered with workaround documented",
            "reason": "Root cause is a ClickOnce tooling limitation, not a SkiaSharp defect. Workaround confirmed by reporter.",
            "confidence": 0.7,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3423"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3422,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Universal-UWP",
          "os/WASM",
          "area/SkiaSharp.Views.Blazor",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "SkiaSharp fails to load in Blazor WASM on .NET 10 with TypeInitializationException and DllNotFoundException for libSkiaSharp",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.82
        },
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.97
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.92
          },
          {
            "value": "tenet/reliability",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "severity": "high",
          "severityReason": "Complete failure to load native library in Blazor WASM on .NET 10. Workaround is inconsistent \u2014 works for some users but not others. Multiple users affected.",
          "hasWorkaround": true,
          "workaroundSummary": "Running \u0027dotnet workload restore\u0027 resolved the issue for some users (EngstromJimmy, jahnotto) but not for others (Webreaper on macOS/Linux).",
          "targetFrameworks": [
            "net10.0"
          ]
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Blazor WebAssembly project targeting net10.0",
            "Add SkiaSharp.Views.Blazor NuGet package (any version: 3.119.x, 3.118.x, or even 2.88.x)",
            "Add an SKCanvasView component to a Razor page",
            "Navigate to the page in the browser"
          ],
          "codeSnippets": [
            {
              "code": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk.BlazorWebAssembly\u0022\u003E\n\t\u003CPropertyGroup\u003E\n\t\t\u003CTargetFramework\u003Enet10.0\u003C/TargetFramework\u003E\n\t\u003C/PropertyGroup\u003E\n\t\u003CItemGroup\u003E\n\t\t\u003CPackageReference Include=\u0022SkiaSharp.Views.Blazor\u0022 Version=\u00223.119.2-preview.1\u0022 /\u003E\n\t\u003C/ItemGroup\u003E\n\u003C/Project\u003E",
              "language": "xml",
              "context": "Project file from issue body"
            },
            {
              "code": "@using SkiaSharp\n@using SkiaSharp.Views.Blazor\n\n\u003CSKCanvasView OnPaintSurface=\u0022OnPaintSurface\u0022 IgnorePixelScaling=\u0022true\u0022 /\u003E\n\n@code {\n    private void OnPaintSurface(SKPaintSurfaceEventArgs args)\n    {\n        var canvas = args.Surface.Canvas;\n        canvas.Clear(SkiaSharp.SKColors.White);\n    }\n}",
              "language": "csharp",
              "context": "Razor component from issue body"
            }
          ],
          "environmentDetails": "Windows 11 Pro, VS 2026, .NET 10, Edge/Chrome. Also reproduced on macOS (Rider) and Linux production deployments."
        },
        "versionAnalysis": {
          "reason": "Issue persists across all tested SkiaSharp versions (2.88.0 through 3.119.2-preview.1), indicating this is a .NET 10 WASM platform issue rather than a SkiaSharp version regression. The reporter explicitly notes there is no last known good SkiaSharp version for .NET 10 WASM.",
          "mentionedVersions": [
            "3.119.2-preview.1",
            "3.118.0-preview.2.3",
            "3.119.1",
            "2.88.9",
            "2.88.0"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.8,
          "reason": "Not a SkiaSharp regression \u2014 the issue occurs with all SkiaSharp versions on .NET 10 WASM. It appears to be caused by changes in .NET 10\u0027s WASM workload or native dependency handling. Rolling back SkiaSharp to 2.88.x does not help."
        }
      },
      "analysis": {
        "summary": "SkiaSharp\u0027s native library (libSkiaSharp) fails to load in Blazor WASM projects targeting .NET 10. The error manifests as TypeInitializationException on SKImageInfo or DllNotFoundException for libSkiaSharp. The issue spans all SkiaSharp versions, suggesting a breaking change in .NET 10\u0027s WASM workload or native asset resolution pipeline.",
        "keySignals": [
          {
            "text": "ManagedError: TypeInitialization_Type, SkiaSharp.SKImageInfo",
            "source": "body",
            "interpretation": "Native library failed to load during static initialization of SKImageInfo, which depends on P/Invoke into libSkiaSharp"
          },
          {
            "text": "DllNotFoundException: libSkiaSharp",
            "source": "comment 3",
            "interpretation": "Confirms the root cause is native library loading failure, not a managed code issue"
          },
          {
            "text": "it wouldn\u0027t let me clear the Last Known Good Version...there is no last known good version in this regard as it seems more related to .net 10 WASM projects",
            "source": "comment 2",
            "interpretation": "Reporter confirms this is .NET 10-specific, not a SkiaSharp version regression"
          },
          {
            "text": "I tried rolling back to 2.88.9 but the same issue occurs, so it\u0027s something specific to .Net 10",
            "source": "comment 4",
            "interpretation": "Confirmed across multiple SkiaSharp versions \u2014 issue is in .NET 10 platform"
          },
          {
            "text": "Restoring the .NET 10 wasm workload helped me. dotnet workload restore",
            "source": "comment 6",
            "interpretation": "Partial workaround \u2014 suggests missing or misconfigured WASM workload components"
          },
          {
            "text": "dotnet workload restore didn\u0027t have any effect for me - I\u0027m still seeing the same issue on MacOS",
            "source": "comment 8",
            "interpretation": "Workaround is unreliable, particularly on non-Windows platforms"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Users encounter TypeInitializationException and DllNotFoundException when using SkiaSharp in Blazor WASM on .NET 10. This is clearly broken behavior \u2014 the native library cannot be loaded at all.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not a usage question \u2014 the code follows the documented pattern and fails with an infrastructure error."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Blazor",
            "expandedReason": "The issue occurs specifically when using SKCanvasView in Blazor WASM. While the root cause is native library loading, the affected component is SkiaSharp.Views.Blazor and the fix likely involves WASM-specific packaging or workload integration.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "The native library itself isn\u0027t broken \u2014 the WASM packaging/deployment pipeline is failing to include it properly for .NET 10."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM",
            "expandedReason": "This is a Blazor WebAssembly issue. The reporter\u0027s development machine is Windows but the runtime target is WASM. The os/Windows-Universal-UWP label currently on the issue is incorrect.",
            "alternatives": [
              {
                "value": "os/Windows-Universal-UWP",
                "whyRejected": "Windows is only the dev machine OS \u2014 the issue is in the WASM runtime, not UWP."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "The core issue is compatibility with .NET 10\u0027s WASM workload. SkiaSharp works on older .NET versions but fails on .NET 10."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Complete failure to load the native library \u2014 SkiaSharp is entirely unusable in Blazor WASM on .NET 10. Workaround is inconsistent across platforms. Multiple users affected with community engagement."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Real bug on .NET 10 WASM affecting multiple users with inconsistent workaround. Root cause is unclear \u2014 likely a .NET 10 platform change in native dependency handling \u2014 requiring investigation before a fix can be applied.",
            "alternatives": [
              {
                "value": "close-wontfix",
                "whyRejected": "Multiple users are affected and the issue is in SkiaSharp deployment scope, even if the root cause is a .NET 10 change."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "The issue occurs across all SkiaSharp versions (2.88.0 through 3.119.2-preview.1) on .NET 10 WASM. No SkiaSharp version ever worked on .NET 10 WASM, so this is a platform incompatibility rather than a SkiaSharp regression."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Issue persists across all tested SkiaSharp versions on .NET 10 WASM, indicating it is a current platform-level issue not tied to a specific SkiaSharp release."
          }
        ],
        "uncertainties": [
          "Whether the root cause is a .NET 10 WASM workload packaging change or a SkiaSharp build/packaging issue for the WASM target",
          "Why \u0027dotnet workload restore\u0027 fixes the issue for some users but not others \u2014 could be OS-specific workload behavior",
          "Whether the issue also affects Blazor Server or is strictly WASM-only",
          "Whether .NET 10 preview vs stable makes a difference"
        ],
        "assumptions": [
          "Assumed the issue affects all browsers since both Edge and Chrome are mentioned and it\u0027s a native loading issue",
          "Assumed .NET 10 refers to preview/RC builds available at the time of reporting (November 2025)"
        ],
        "resolution": {
          "hypothesis": ".NET 10 changed how WASM native dependencies are resolved or packaged, and SkiaSharp\u0027s WASM native assets are not being included in the final output. The \u0027dotnet workload restore\u0027 fix suggests that the wasm-tools workload has updated components that affect native library linking, and some environments have stale or missing workload installations.",
          "proposals": [
            {
              "title": "Investigate .NET 10 WASM native dependency changes",
              "description": "Compare how libSkiaSharp.wasm is packaged and linked in .NET 9 vs .NET 10 Blazor WASM projects. Check if NativeFileReference or WasmNativeAssets handling changed. May require updating SkiaSharp.Views.Blazor packaging.",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "title": "Update SkiaSharp WASM packaging for .NET 10",
              "description": "If .NET 10 changed the WASM native asset pipeline (e.g., new MSBuild props, different file layout), update SkiaSharp.Views.Blazor to conform. This is the definitive fix.",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "title": "Document workaround: dotnet workload restore",
              "description": "As an interim measure, document that users should run \u0027dotnet workload restore\u0027 after installing .NET 10. Note the limitation that this does not work for all users/platforms.",
              "confidence": 0.5,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Investigate .NET 10 WASM native dependency changes",
          "recommendedReason": "Need to understand the root cause before applying a fix. The inconsistent workaround suggests a platform-level change that needs proper investigation before SkiaSharp can adapt."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.88,
          "reason": "Real bug affecting multiple users with .NET 10 WASM. Root cause is likely a .NET 10 platform change in native dependency handling. Needs investigation into what changed and how SkiaSharp\u0027s WASM packaging should adapt."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Fix labels: add tenet/compatibility, remove incorrect os/Windows-Universal-UWP",
            "reason": "os/Windows-Universal-UWP is wrong \u2014 the issue is WASM not UWP. Adding tenet/compatibility since this is a .NET 10 compat issue.",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "os/Windows-Universal-UWP"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging the .NET 10 WASM issue and partial workaround",
            "reason": "Multiple users are affected and need acknowledgment. The workaround is partial and should be noted with caveats.",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the detailed report and the reproduction steps.\n\nThis looks like a .NET 10 WASM platform change affecting how native dependencies are loaded \u2014 the fact that rolling back to SkiaSharp 2.88.x doesn\u0027t help confirms it\u0027s not a SkiaSharp regression.\n\nThe \u0060dotnet workload restore\u0060 workaround from @EngstromJimmy is helpful but clearly isn\u0027t consistent across platforms, as @Webreaper is still seeing the issue on macOS and Linux.\n\nTo help narrow this down: for those still experiencing the issue after \u0060dotnet workload restore\u0060, would you be able to check what version of the \u0060microsoft-net-sdk-emscripten\u0060 workload pack is installed? You can check with \u0060dotnet workload list\u0060. That would help determine if this is a workload version mismatch or something deeper in the native asset pipeline.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3422-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3422"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3421,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "User loading a .lottie (dotLottie) file with Skottie.Animation.Create gets null because .lottie is a zip archive, not raw Lottie JSON",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.82
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.92
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/9ca27c18-536b-4403-a41d-44e907329001",
              "context": "LottieFiles download page showing the .lottie file being downloaded",
              "source": "body"
            },
            {
              "url": "https://github.com/user-attachments/assets/0fe1691c-82ee-462a-a110-f53b0682833f",
              "context": "Debugger showing animation variable is null after Create call",
              "source": "body"
            }
          ],
          "stepsToReproduce": [
            "Download a .lottie file from LottieFiles (dotLottie format, which is a zip archive)",
            "Call SkiaSharp.Skottie.Animation.Create(path) with the .lottie file path",
            "Observe that the returned Animation is null"
          ],
          "codeSnippets": [
            {
              "code": "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);",
              "language": "cs",
              "context": "Loading a .lottie file by path, returns null"
            }
          ],
          "environmentDetails": "Windows 11, Visual Studio (Windows), SkiaSharp 3.116.0"
        },
        "versionAnalysis": {
          "reason": "Issue is about format support, not a version-specific regression. The .lottie (dotLottie) zip format has never been supported by Skottie.",
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.95,
          "reason": "Skottie has never supported the dotLottie (.lottie) zip archive format. It only parses raw Lottie JSON. This is not a regression."
        }
      },
      "analysis": {
        "summary": "The user is loading a .lottie file (dotLottie format), which is a zip archive containing Lottie JSON and assets. Skottie\u0027s Animation.Create() expects raw Lottie JSON data, not a zip archive, so it correctly returns null when it cannot parse the zip bytes as JSON. This is a format misunderstanding, not a defect.",
        "keySignals": [
          {
            "text": "Loading .lottie file results in null SkiaSharp.Skottie.Animation",
            "source": "title",
            "interpretation": "The .lottie extension indicates the dotLottie format (zip archive), which is distinct from raw Lottie JSON (.json)"
          },
          {
            "text": "No exception is thrown, so it fails silently",
            "source": "body",
            "interpretation": "This is expected SkiaSharp factory method behavior \u2014 Create() returns null on failure rather than throwing. Not a bug."
          },
          {
            "text": "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);",
            "source": "body",
            "interpretation": "Animation.Create reads file bytes and passes to Skottie parser, which expects JSON. A zip file will fail parsing."
          },
          {
            "text": "https://app.lottiefiles.com/animation/...",
            "source": "body",
            "interpretation": "LottieFiles offers downloads in both .json and .lottie formats. The user downloaded the .lottie (dotLottie) variant."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "The user expects Animation.Create to handle .lottie files, but the dotLottie format (a zip archive) is fundamentally different from raw Lottie JSON. The API is working as designed \u2014 it returns null for data it cannot parse. This is a format confusion, not broken behavior.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "The API correctly returns null for unparseable input. Silent null return is the documented factory method pattern in SkiaSharp."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "While dotLottie support could be a valid feature request, the user is not requesting new functionality \u2014 they are confused about why their file doesn\u0027t work."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SkiaSharp.Skottie.Animation is part of the SkiaSharp.Skottie package which wraps Skia\u0027s Skottie module. The issue is in the Skottie animation loading API.",
            "alternatives": []
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "User explicitly states Windows 11 with Visual Studio (Windows). However, this is not a platform-specific issue \u2014 the format incompatibility exists on all platforms."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The answer is clear: .lottie files are zip archives that must be extracted to get the raw Lottie JSON before passing to Skottie. The user can re-download the animation as .json from LottieFiles instead."
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "Skottie has never supported the dotLottie (.lottie) zip archive format \u2014 it only parses raw Lottie JSON. This is not a regression but a format misunderstanding."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The issue is about format support, not a version-specific bug. The .lottie zip format has never been supported by Skottie in any version, so the behavior persists in current releases."
          }
        ],
        "uncertainties": [
          "Whether the user has tried downloading the same animation in .json format from LottieFiles (which would work)",
          "Whether there is demand for native dotLottie format support in SkiaSharp.Skottie"
        ],
        "assumptions": [
          "Assumed the file is a dotLottie (.lottie) zip archive based on the title and LottieFiles download link, since LottieFiles defaults to .lottie format",
          "Assumed no prior version of SkiaSharp supported .lottie format since Skottie has always only parsed JSON"
        ],
        "resolution": {
          "hypothesis": "The user downloaded a .lottie file (dotLottie format) which is a zip archive. Skottie only supports raw Lottie JSON, so the zip bytes fail to parse and Create() returns null.",
          "proposals": [
            {
              "title": "Re-download as .json from LottieFiles",
              "description": "LottieFiles provides both .lottie and .json download options. The user should download the .json variant, which contains the raw Lottie JSON that Skottie can parse directly.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "Extract JSON from .lottie zip at runtime",
              "description": "Use System.IO.Compression.ZipArchive to open the .lottie file, read the animations/[name].json entry from inside the archive, and pass the extracted JSON string to Animation.Parse().",
              "confidence": 0.85,
              "effort": "low"
            },
            {
              "title": "Add dotLottie format support to SkiaSharp.Skottie",
              "description": "Enhance Animation.Create to detect zip magic bytes and automatically extract the Lottie JSON from dotLottie archives. This would be a new feature requiring changes to the C# wrapper layer.",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Re-download as .json from LottieFiles",
          "recommendedReason": "Simplest and most immediate solution. No code changes needed \u2014 just download the correct format."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.82,
          "reason": "The .lottie format is not supported by Skottie \u2014 the user needs to use raw Lottie JSON instead. Clear answer available."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Reclassify as question, remove bug and reliability labels",
            "reason": "This is a format misunderstanding, not a bug or reliability issue. The API works correctly for its supported input format.",
            "confidence": 0.82,
            "payload": {
              "labelsToAdd": [
                "type/question"
              ],
              "labelsToRemove": [
                "type/bug",
                "tenet/reliability"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Explain .lottie vs Lottie JSON format difference and provide workaround",
            "reason": "User needs to understand why their file doesn\u0027t load and what to do instead",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the clear reproduction steps and screenshots.\n\nThe \u0060.lottie\u0060 format (sometimes called \u0022dotLottie\u0022) is actually a zip archive that contains the raw Lottie JSON animation along with optional assets. SkiaSharp\u0027s Skottie module expects raw Lottie JSON data, so when it tries to parse the zip bytes as JSON, it fails and \u0060Animation.Create()\u0060 returns null.\n\nThe simplest fix is to re-download the animation from LottieFiles in \u0060.json\u0060 format instead of \u0060.lottie\u0060 \u2014 LottieFiles offers both options on the download panel.\n\nIf you need to work with \u0060.lottie\u0060 files directly, you can extract the JSON at runtime:\n\n\u0060\u0060\u0060csharp\nusing System.IO.Compression;\n\nusing var zip = ZipFile.OpenRead(sourceFileAbsolute);\nvar entry = zip.Entries.FirstOrDefault(e =\u003E e.FullName.EndsWith(\u0022.json\u0022));\nif (entry != null)\n{\n    using var stream = entry.Open();\n    var animation = SkiaSharp.Skottie.Animation.Create(stream);\n}\n\u0060\u0060\u0060",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3421-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as answered",
            "reason": "Question answered with explanation and workaround",
            "confidence": 0.78,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3421"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3420,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Android",
          "area/libSkiaSharp.native",
          "tenet/compatibility"
        ],
        "state": "open"
      },
      "summary": "libSkiaSharp.so is built with 4 KB page size, blocking Android 16\u002B deployment which requires 16 KB page alignment",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.98
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.95
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "severity": "high",
          "severityReason": "Google Play will reject apps with 4 KB page-aligned .so files for Android 16\u002B targets. No workaround exists short of rebuilding the native library. 5 thumbs-up reactions and community follow-ups indicate broad impact.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "net8.0-android"
          ]
        },
        "reproEvidence": {
          "attachments": [
            {
              "url": "https://github.com/user-attachments/files/23669684/16KB_PageSize_Report.txt",
              "filename": "16KB_PageSize_Report.txt",
              "type": "log-file",
              "source": "body"
            },
            {
              "url": "https://github.com/user-attachments/files/23547442/Android16_PageSize_Issue.pdf",
              "filename": "Android16_PageSize_Issue.pdf",
              "type": "other",
              "source": "body"
            }
          ],
          "stepsToReproduce": [
            "Create a .NET MAUI Android app targeting Android 16",
            "Build AAB using current SkiaSharp (v2.88.6) or MAUI workload",
            "Run page size check on .so files (e.g. readelf -l libSkiaSharp.so)",
            "Observe libSkiaSharp.so shows 4 KB page size instead of required 16 KB"
          ],
          "environmentDetails": "SkiaSharp.NativeAssets.Android v2.88.6 (description) / v3.116.0 (form field), .NET MAUI 9.0, Android 16\u002B target, Visual Studio (Windows)"
        },
        "versionAnalysis": {
          "reason": "The reporter\u0027s description references v2.88.6 but the form field says 3.116.0 (Current). Maintainer mattleibow asked if 3.x was tried, suggesting the fix may need to be in the native build pipeline for both 2.x and 3.x. The 16 KB page alignment is a build-time linker flag, so all current native binaries are likely affected regardless of version.",
          "mentionedVersions": [
            "2.88.6",
            "2.88.9",
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "migrationPath": "Rebuild libSkiaSharp.so with -Wl,-z,max-page-size=16384 linker flag"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "This is not a regression in SkiaSharp behavior \u2014 the library never supported 16 KB page alignment. It is a new platform requirement from Google for Android 16\u002B."
        }
      },
      "analysis": {
        "summary": "Google\u0027s Android 16\u002B requires 64-bit native libraries to be built with 16 KB page alignment. libSkiaSharp.so is currently built with 4 KB page alignment, which will cause Google Play rejection for apps targeting Android 16. This is a native build configuration issue, not a code bug.",
        "keySignals": [
          {
            "text": "Google Play now requires all 64-bit native libraries to use 16 KB memory page size starting with Android 16\u002B",
            "source": "body",
            "interpretation": "External platform requirement forcing a build configuration change"
          },
          {
            "text": "libSkiaSharp.so included in SkiaSharp.NativeAssets.Android v2.88.6 has a 4 KB page size",
            "source": "body",
            "interpretation": "The native binary does not meet the new requirement \u2014 this is verifiable via readelf"
          },
          {
            "text": "Have you tried the 3.x series of SkiaSharp? The 2.x series is not really supported",
            "source": "comment 3",
            "interpretation": "Maintainer mattleibow redirecting to 3.x, implying 2.x will not be fixed. But 3.x may also need the fix."
          },
          {
            "text": "5 thumbs-up reactions on issue, 7 thumbs-up on \u0027Any update on this?\u0027 comment",
            "source": "reactions",
            "interpretation": "Significant community interest \u2014 this blocks real-world Android 16 deployments"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "While this is technically a new platform requirement rather than a regression, the practical effect is that SkiaSharp\u0027s native library prevents apps from targeting Android 16\u002B. The library is built incorrectly for the target platform, which is a defect in the build configuration. The existing type/bug label is appropriate.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "This is not optional \u2014 Google Play will reject non-compliant apps. It\u0027s a hard blocker, not an improvement."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "16 KB page alignment is not new functionality \u2014 it\u0027s a build flag. The library should work on the target platform."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The issue is entirely in the native binary build configuration of libSkiaSharp.so. The fix is a linker flag change in the native build pipeline, not in C# code.",
            "alternatives": [
              {
                "value": "area/Build",
                "whyRejected": "area/Build is for C#/NuGet build issues. This is specifically about the native .so binary\u0027s ELF alignment."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Android",
            "expandedReason": "The 16 KB page size requirement is Android-specific (Android 16\u002B). No other platforms are affected."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "This is a forward-compatibility issue with Android 16\u002B. The library must be updated to remain compatible with the evolving platform requirements."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Apps using SkiaSharp cannot target Android 16\u002B at all. No user-side workaround exists \u2014 the fix must come from rebuilding the native library. High community engagement confirms broad impact."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The fix direction is clear (add linker flag), but needs verification of whether 3.x is also affected and where exactly in the build pipeline to add the flag. Maintainer already engaged.",
            "alternatives": [
              {
                "value": "close-wontfix",
                "whyRejected": "This is a hard blocker for Android 16\u002B deployment with high community interest \u2014 it must be fixed, not closed."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "This is not a regression in SkiaSharp behavior \u2014 the library never supported 16 KB page alignment. It is a new external platform requirement from Google for Android 16\u002B."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The 16 KB page alignment is a build-time linker flag, so all current native binaries (both 2.x and 3.x) are likely affected regardless of version."
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp 3.x native binaries also have 4 KB page alignment (reporter\u0027s version fields are contradictory \u2014 body says 2.88.6, form says 3.116.0)",
          "Whether the Skia build system (GN/Ninja) already supports the 16 KB page alignment flag or if additional upstream work is needed",
          "Exact timeline for Google Play enforcement \u2014 whether it\u0027s Android 16 launch or a later deadline"
        ],
        "assumptions": [
          "Assumed both 2.x and 3.x native binaries are affected since this is a build-time linker flag that likely hasn\u0027t been set for either version",
          "Assumed the reporter tested with 2.88.6 (as described in the body) despite the form field listing 3.116.0"
        ],
        "resolution": {
          "hypothesis": "libSkiaSharp.so is linked with the default 4 KB max-page-size. The fix is to add -Wl,-z,max-page-size=16384 to the Android NDK linker flags in the native build configuration.",
          "proposals": [
            {
              "title": "Add 16 KB page alignment linker flag",
              "description": "Add -Wl,-z,max-page-size=16384 to the Android arm64 build configuration in the native build scripts (GN args or CMake). This is the standard fix recommended by Google\u0027s migration guide. Low risk \u2014 only affects ELF segment alignment, no behavioral change.",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Update Android NDK version",
              "description": "Newer NDK versions (r27\u002B) default to 16 KB page alignment. Updating the NDK used for building could automatically resolve this without explicit linker flags. However, NDK version bumps can introduce other changes.",
              "confidence": 0.75,
              "effort": "medium"
            },
            {
              "title": "Verify with readelf and add CI check",
              "description": "After applying the fix, add a CI step that runs readelf -l on the output .so to verify max page size is 16384. Prevents future regressions if build tooling changes.",
              "confidence": 0.85,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Add 16 KB page alignment linker flag",
          "recommendedReason": "Simplest and most targeted fix. Directly addresses the requirement with no side effects. Google\u0027s own documentation recommends this approach."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.82,
          "reason": "The fix direction is clear (linker flag), but needs verification of whether 3.x is also affected and where exactly in the build pipeline to add the flag. Maintainer already engaged."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels already correct \u2014 no changes needed",
            "reason": "Current labels (type/bug, os/Android, area/libSkiaSharp.native, tenet/compatibility) exactly match classification",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis with 16 KB page alignment fix guidance and ask about 3.x testing",
            "reason": "Maintainer already asked about 3.x but no resolution posted. A technical summary would help move the issue forward.",
            "confidence": 0.78,
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for filing this with the detailed report and PDF \u2014 the 16 KB page alignment requirement is going to affect a lot of Android apps.\n\nThe fix on the SkiaSharp side would be adding \u0060-Wl,-z,max-page-size=16384\u0060 to the linker flags when building \u0060libSkiaSharp.so\u0060 for Android arm64. Google\u0027s migration guide covers this: https://developer.android.com/guide/practices/page-sizes\n\nAs @mattleibow mentioned, the 2.x series isn\u0027t actively maintained. Could you confirm whether you\u0027re also seeing the 4 KB page size with the 3.x native assets? Running \u0060readelf -l libSkiaSharp.so | grep -i align\u0060 on the .so from the 3.116.0 NuGet would help clarify if both branches need the fix.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3420-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3420"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3402,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/feature-request"
        ],
        "state": "open"
      },
      "summary": "Feature request for 1bpp, 2bpp, and 4bpp indexed color bitmap support to minimize memory for retro game tile graphics",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "tenets": [
          {
            "value": "tenet/performance",
            "confidence": 0.8
          }
        ]
      },
      "evidence": {},
      "analysis": {
        "summary": "User requests sub-byte indexed color formats (1bpp, 2bpp, 4bpp) with native pixel operations for NES/SNES-style tile graphics in Avalonia UI. This requires functionality that upstream Skia explicitly removed (indexed color types) and would need significant new infrastructure.",
        "keySignals": [
          {
            "text": "[FEATURE] Drawing to and from compressed indexed color bitmaps",
            "source": "title",
            "interpretation": "Explicit feature request for new pixel format support"
          },
          {
            "text": "I wanted to make a nes/snes graphics system in avalonia ui",
            "source": "body",
            "interpretation": "Use case is retro game console graphics emulation \u2014 very niche, tile-based rendering"
          },
          {
            "text": "8 * 8 * 32 * 30 * 65536 pixels which in 4bpp color would be 1.87 GiB",
            "source": "body",
            "interpretation": "Large tile atlas requiring sub-byte pixel formats for memory efficiency"
          },
          {
            "text": "Pixel operations should work on multiple pixels at a time with these formats without expanding them in memory",
            "source": "body",
            "interpretation": "Requires native bitwise operations on packed formats \u2014 not just storage but computation"
          },
          {
            "text": "Please support drawing to and from compressed 1bpp 2bpp and 4bpp indexed color graphics",
            "source": "body",
            "interpretation": "Core request: three new pixel formats plus drawing primitives for each"
          },
          {
            "text": "Writing my own blitter",
            "source": "body",
            "interpretation": "User has considered alternatives but lacks implementation experience"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "User explicitly requests new functionality that does not exist in SkiaSharp. Uses the feature request template. No broken behavior described \u2014 this is entirely new capability.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement improves existing functionality. Indexed color formats don\u0027t exist at all in SkiaSharp \u2014 this is new capability."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The request is for new pixel format types and drawing operations in the core SkiaSharp library (SKBitmap, SKColorType, pixel manipulation). Not views-specific or platform-specific.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While implementation would require native changes, the feature surface is in the managed API layer."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/performance",
            "expandedReason": "The entire motivation is memory efficiency \u2014 storing tile graphics in sub-byte formats to reduce memory from 15 GiB (32bpp) to 1.87 GiB (4bpp). Performance/memory is the core driver."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a valid feature request but requires upstream Skia support that was intentionally removed. It should remain open for maintainer consideration, but the probability of implementation is low given Skia\u0027s direction away from indexed colors."
          }
        ],
        "uncertainties": [
          "Whether the user specifically needs SkiaSharp integration or would accept a separate pixel buffer library for indexed formats",
          "Whether partial support (e.g., converting indexed bitmaps to/from SKBitmap) would satisfy the requirement versus full native operations on packed formats"
        ],
        "assumptions": [
          "Assumed the user is using a recent version of SkiaSharp since no version was mentioned",
          "Assumed \u0027compressed\u0027 refers to indexed/paletted color with sub-byte pixel packing, not image compression codecs like PNG or JPEG"
        ],
        "resolution": {
          "hypothesis": "User wants to build a retro game tile graphics system with sub-byte indexed color formats. Skia removed kIndex_8_SkColorType years ago and does not support sub-byte pixel formats natively. SkiaSharp cannot expose what Skia doesn\u0027t provide without building an entirely separate pixel processing layer.",
          "proposals": [
            {
              "title": "Use SKBitmap with manual palette conversion",
              "description": "Store indexed color data in custom byte arrays and convert to 32bpp SKBitmap only when rendering. Keeps storage compact while using SkiaSharp for final display. User manages palette lookup in C# code.",
              "confidence": 0.75,
              "effort": "medium"
            },
            {
              "title": "Use ImageSharp for indexed color processing",
              "description": "SixLabors.ImageSharp supports indexed/paletted formats natively. Use it for pixel manipulation on indexed buffers, then convert to SKBitmap for Avalonia rendering. Combines strengths of both libraries.",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "title": "Custom packed pixel buffer with Span\u003Cbyte\u003E",
              "description": "Implement a lightweight PackedPixelBuffer class using Span\u003Cbyte\u003E for bitwise operations on 1/2/4bpp data. Convert to SKBitmap via SKBitmap.InstallPixels when rendering. No external dependencies.",
              "confidence": 0.65,
              "effort": "high"
            }
          ],
          "recommendedProposal": "Use SKBitmap with manual palette conversion",
          "recommendedReason": "Simplest approach that stays within the SkiaSharp ecosystem. Storage remains compact in custom arrays; conversion to SKBitmap happens only at render time. Matches how retro game emulators typically handle tile rendering."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.75,
          "reason": "Valid feature request but requires upstream Skia support for indexed color types, which Skia intentionally removed. Low probability of implementation. Maintainer should decide whether to keep open or close as out-of-scope."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area and performance tenet labels",
            "reason": "Feature request already labeled correctly for type. Adding area/SkiaSharp and tenet/performance to match classification.",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "tenet/performance"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post response explaining Skia\u0027s lack of indexed color support and suggesting workarounds",
            "reason": "User needs to understand why this is difficult to implement and what alternatives exist",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed write-up on what you\u0027re trying to achieve \u2014 the NES/SNES tile graphics use case helps a lot in understanding the requirements.\n\nThe challenge here is that Skia (the underlying C\u002B\u002B library SkiaSharp wraps) removed support for indexed color types several years ago. There\u0027s no \u0060kIndex_8_SkColorType\u0060 or sub-byte format in modern Skia, so SkiaSharp can\u0027t expose what doesn\u0027t exist upstream. Adding 1/2/4bpp indexed formats with native pixel operations would essentially mean building a separate pixel processing engine outside of Skia.\n\nFor the tile atlas approach you\u0027re describing, a practical workaround would be to keep your indexed color data in custom \u0060byte[]\u0060 arrays (packed at 1/2/4bpp) and only convert to a 32bpp \u0060SKBitmap\u0060 at render time using a palette lookup. This is actually how most retro game emulators handle it \u2014 the compact storage stays in your own format, and the graphics library only sees the final expanded pixels. The conversion cost for a single screen\u0027s worth of tiles is minimal.\n\nAnother option worth considering is SixLabors.ImageSharp, which does support indexed/paletted pixel formats natively. You could use it for the pixel manipulation side and convert to \u0060SKBitmap\u0060 when handing off to Avalonia for display.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3402-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3402"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3400,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "backend/PDF",
          "tenet/reliability",
          "backend/Xps"
        ],
        "state": "open"
      },
      "summary": "SKDocument.CreateXps() renders embedded SVG \u003Cimage\u003E elements at ~30-40% of correct size, while CreatePdf() renders them correctly",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "backends": [
          {
            "value": "backend/XPS",
            "confidence": 0.95
          },
          {
            "value": "backend/PDF",
            "confidence": 0.8
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.92
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.88
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Incorrect visual output (images significantly undersized) with no XPS-specific workaround. PDF workaround exists but does not satisfy XPS-dependent workflows like Windows label printing.",
          "hasWorkaround": true,
          "workaroundSummary": "Use SKDocument.CreatePdf() instead of CreateXps() for correct image rendering, though this does not help users who require XPS output for Windows print pipeline.",
          "targetFrameworks": [
            "net9.0"
          ]
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Load an SVG document containing \u003Cimage\u003E elements with Base64-encoded images using SKSvg.Load()",
            "Generate XPS using SKDocument.CreateXps() with DPI scaling (72/96 = 0.75)",
            "Generate PDF using SKDocument.CreatePdf() with the same SVG and scaling",
            "Compare image dimensions in XPS vs PDF output"
          ],
          "codeSnippets": [
            {
              "code": "var skSvg = new SKSvg();\nvar picture = skSvg.Load(ms);\nconst float DPI = 72f;\nconst float SVG_DPI = 96f;\nconst float contentScale = DPI / SVG_DPI;\nvar pageWidth = bounds.Width * contentScale;\nvar pageHeight = bounds.Height * contentScale;\n\nusing (var xpsStream = File.OpenWrite(\u0022output.xps\u0022))\n{\n    using var document = SKDocument.CreateXps(xpsStream);\n    using var canvas = document.BeginPage(pageWidth, pageHeight);\n    canvas.Clear(SKColors.White);\n    canvas.Scale(contentScale);\n    canvas.DrawPicture(picture);\n    document.EndPage();\n    document.Close();\n}",
              "language": "csharp",
              "context": "Reproduction code showing XPS generation with DPI-scaled canvas"
            }
          ],
          "environmentDetails": "Windows 10/11, .NET 9.0, Visual Studio, SkiaSharp 3.116.0 (form) / 3.119.1 (description), Svg.Skia 3.2.1"
        },
        "versionAnalysis": {
          "reason": "Reporter lists 3.116.0 as current version in the form field but 3.119.1 in description body. The discrepancy is minor and both are recent v3 releases. Issue likely persists in latest.",
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.65,
          "reason": "Reporter states last known good version is 2.88.9 (v2 series). This is a major version boundary (v2 to v3) with significant Skia upstream changes, so the regression is plausible but the large version gap makes pinpointing difficult.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "Clear rendering bug in the XPS backend where embedded raster images in SVG are scaled incorrectly (~30-40% of expected size). The same SKPicture renders correctly to PDF and raster, isolating the problem to how the XPS document backend handles image drawing operations from recorded picture playback. The ~30-40% reduction is close to 0.75\u00B2 = 0.5625, suggesting a DPI scale factor may be applied twice to images.",
        "keySignals": [
          {
            "text": "Images are significantly smaller (approximately 30-40% of correct size)",
            "source": "body",
            "interpretation": "Quantified rendering error; the ~0.56x factor is suspiciously close to 0.75\u00B2 suggesting double-application of the 72/96 DPI scale"
          },
          {
            "text": "All other SVG elements (text, barcodes, rectangles, shapes) render correctly in both formats",
            "source": "body",
            "interpretation": "Bug is isolated to raster image handling in XPS backend, not a general scaling issue"
          },
          {
            "text": "The same SKPicture object produces correct output with CreatePdf() and CreateImage()",
            "source": "body",
            "interpretation": "Problem is in XPS backend specifically, not in SKPicture recording or SVG parsing"
          },
          {
            "text": "This severely impacts label printing applications that require XPS output for Windows print pipeline",
            "source": "body",
            "interpretation": "Real-world impact for Windows printing workflows that depend on XPS"
          },
          {
            "text": "SkiaSharp Version: 3.119.1 / Version of SkiaSharp: 3.116.0",
            "source": "body",
            "interpretation": "Version discrepancy between description and form field \u2014 unclear which version was actually tested"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes incorrect rendering output (images undersized by ~60%) in XPS compared to PDF. This is clearly broken behavior, not a usage question or feature request. The [BUG] prefix matches the content.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting measurably wrong output."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKDocument.CreateXps() is in the core SkiaSharp package (binding/SkiaSharp/SKDocument.cs). The bug is in document generation, not views or HarfBuzz.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the root cause is likely in native Skia XPS code, the surface-level API is in SkiaSharp core."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/XPS, backend/PDF",
            "expandedReason": "XPS is the primary affected backend. PDF is included because the bug is defined by the discrepancy between the two backends rendering the same SKPicture."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Incorrect visual output with no XPS-specific workaround. PDF workaround exists but doesn\u0027t help XPS-dependent workflows. Not a crash or data loss, but renders XPS output unusable for the reporter\u0027s label printing use case."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Real rendering bug with partial reproduction code. The double-scaling hypothesis needs confirmation and the version discrepancy needs clarification before a fix can proceed.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "While version clarification is needed, the bug is substantive enough to warrant investigation rather than just requesting more info."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "XPS is a Windows-specific document format and the reporter is using Windows 10/11. The XPS backend in Skia is only relevant on Windows.",
            "alternatives": [
              {
                "value": "os/macOS",
                "whyRejected": "XPS output is a Windows-specific technology; macOS does not use XPS for printing."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Embedded images render at incorrect size in XPS output, producing unreliable visual output. The same SKPicture renders correctly to PDF, confirming broken XPS backend behavior.",
            "alternatives": [
              {
                "value": "tenet/compatibility",
                "whyRejected": "Not a platform compatibility issue \u2014 this is incorrect rendering within a single platform/backend combination."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter states last known good version is 2.88.9 and the bug appeared in v3. The major version boundary makes this a plausible regression though the large version gap makes pinpointing difficult.",
            "alternatives": [
              {
                "value": "false",
                "whyRejected": "Reporter explicitly identified a working version (2.88.9) and a broken version (3.116.0), indicating changed behavior."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Reporter mentions both 3.116.0 and 3.119.1, both recent v3 releases. The XPS backend scaling issue is unlikely to have been fixed between these versions."
          }
        ],
        "uncertainties": [
          "Which exact version was tested \u2014 3.116.0 or 3.119.1? The description and form field disagree.",
          "Whether the issue exists without the DPI scaling (contentScale = 0.75) \u2014 the scaling factor may be the trigger.",
          "Whether this is a Skia upstream XPS backend bug or specific to the SkiaSharp C API layer.",
          "Whether the 2.88.9 \u0027last known good\u0027 means it was specifically tested with XPS or is just the previous version used."
        ],
        "assumptions": [
          "Assumed the bug is in the Skia XPS backend\u0027s handling of DrawImage operations during picture playback, since all other primitives render correctly.",
          "Assumed the Svg.Skia library is not the source of the bug since the same SKPicture works correctly with CreatePdf().",
          "Assumed net9.0 target framework based on description mention of .NET 9.0, though the form field does not specify."
        ],
        "resolution": {
          "hypothesis": "The Skia XPS backend applies an additional DPI-based scaling to raster images drawn from SKPicture playback that the PDF backend does not. When the canvas already has a scale transform (0.75 for 72/96 DPI conversion), images get double-scaled while vector primitives (text, shapes) are only scaled once. The ~30-40% size reduction aligns with 0.75\u00B2 \u2248 0.5625.",
          "proposals": [
            {
              "title": "Investigate XPS backend DPI handling in Skia",
              "description": "Examine how SkXPSDevice handles DrawImage vs DrawPath operations in picture playback. Compare with SkPDFDevice to find where the additional scale is applied to images. This is likely in upstream Skia\u0027s XPS device code.",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "title": "Test without DPI scaling as diagnostic",
              "description": "Ask reporter to test with contentScale=1.0 (no DPI conversion) to confirm whether the scaling factor triggers the bug. If images render correctly at 1.0x, this confirms the double-scaling hypothesis.",
              "confidence": 0.65,
              "effort": "low"
            },
            {
              "title": "Pre-render images to bitmap before XPS generation",
              "description": "As a workaround, rasterize the SVG to an SKImage first, then draw the rasterized image to the XPS canvas. This bypasses the SKPicture playback path in the XPS backend.",
              "confidence": 0.5,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Test without DPI scaling as diagnostic",
          "recommendedReason": "Low effort first step that would confirm the double-scaling hypothesis and narrow down the root cause before diving into Skia XPS backend code."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real rendering bug with partial reproduction code. Root cause likely in Skia\u0027s XPS backend DPI handling. Needs confirmation of the double-scaling hypothesis and version clarification."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels already match classification \u2014 no changes needed",
            "reason": "Current labels (type/bug, area/SkiaSharp, backend/PDF, backend/Xps, os/Windows-Classic, tenet/reliability) already match the classification",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge report and request diagnostic test without DPI scaling",
            "reason": "Need to clarify version discrepancy and test the double-scaling hypothesis",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the detailed reproduction code and clear comparison between PDF and XPS output \u2014 that makes this much easier to investigate.\n\nThe scaling numbers are interesting: images at ~30-40% of expected size with a 0.75 content scale factor could suggest the XPS backend is applying the DPI scale twice to raster images (0.75\u00B2 \u2248 0.56), while vector elements only get scaled once.\n\nTo help narrow this down:\n\n1. Could you confirm which SkiaSharp version you\u0027re testing with? The description mentions 3.119.1 but the form field says 3.116.0.\n2. Would you be able to test with \u0060contentScale = 1.0f\u0060 (removing the DPI conversion) to see if images render at the correct size in XPS? That would confirm whether the scale factor is triggering the issue.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3400-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3400"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3398,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-10T04:10:29Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "Intermittent crash in sk_canvas_draw_path called from Mapsui\u0027s GetMapInfo() during PointerMoved \u2014 likely a threading issue in Mapsui, not SkiaSharp",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.8
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/cf361924-61d3-4773-9689-b4c36b927b71",
              "context": "Debugger showing crash in sk_canvas_draw_path",
              "source": "description"
            },
            {
              "url": "https://github.com/user-attachments/assets/40e7de45-62b9-42bf-9c05-7073203d9258",
              "context": "Additional debugger view of the crash",
              "source": "description"
            }
          ],
          "relatedIssues": [
            3428,
            1315
          ],
          "environmentDetails": "Windows 11, .NET 9.0.7, CoreCLR 9.0.725.31616, Avalonia 11.3.7, Visual Studio (Windows), FluentAvalonia"
        },
        "versionAnalysis": {
          "reason": "Reporter selected 3.116.0 in the form but comment 2 says DLL version is 2.88.8.0. These are very different versions. The actual version in use is uncertain.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.8.0",
            "2.88.9"
          ],
          "currentRelevance": "unknown"
        }
      },
      "analysis": {
        "summary": "Intermittent crash in native sk_canvas_draw_path called through Mapsui\u0027s rendering pipeline during a PointerMoved event. The crash occurs when Mapsui\u0027s GetMapInfo() performs rendering (drawing paths with cached SKPath/SKPaint via CacheTracker\u003CT\u003E) concurrently with the main render loop. Since Skia objects are NOT thread-safe, concurrent access causes intermittent native crashes. This is almost certainly a Mapsui threading bug, not a SkiaSharp defect.",
        "keySignals": [
          {
            "text": "always collapse when drawing graphics, Occasionally, it does not necessarily appear, but it appears frequently",
            "source": "body",
            "interpretation": "Intermittent crash is a classic threading/concurrency symptom \u2014 deterministic bugs don\u0027t appear \u0027occasionally\u0027"
          },
          {
            "text": "The crash indeed occurred during the process of using MapInfo\u0027s query GetMapInfo(). It was retrieving MapInfo in the PointerMoved event.",
            "source": "body",
            "interpretation": "GetMapInfo() performs rendering operations (DrawPath) from the PointerMoved event handler while the main render loop may also be drawing \u2014 concurrent Skia access"
          },
          {
            "text": "at Mapsui.Rendering.Skia.Extensions.SkCanvasExtensions.DrawPath(SKCanvas, CacheTracker\u003CSKPath\u003E, CacheTracker\u003CSKPaint\u003E)",
            "source": "comment-3",
            "interpretation": "Mapsui uses CacheTracker\u003CT\u003E to cache and reuse SKPath/SKPaint objects. If shared between the render thread and GetMapInfo, concurrent access crashes Skia"
          },
          {
            "text": "the SkiaSharp.dll version is 2.88.8.0",
            "source": "comment-2",
            "interpretation": "Contradicts the 3.116.0 selected in the bug form. Reporter may be confused about which version is loaded"
          },
          {
            "text": "Looks more like a Mapsui issue? There\u0027s doesn\u0027t look like there\u0027s anything here that suggests that SkiaSharp is at fault...",
            "source": "comment-4",
            "interpretation": "Community member independently reached the same conclusion \u2014 entire crash stack is within Mapsui\u0027s rendering code"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "The crash occurs entirely within Mapsui\u0027s rendering pipeline. SkiaSharp\u0027s DrawPath works correctly when called in a thread-safe manner. The reporter needs guidance that this is a Mapsui threading issue, not a SkiaSharp bug. Reclassifying from type/bug because SkiaSharp is functioning as designed \u2014 Skia is documented as not thread-safe.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "No evidence of a defect in SkiaSharp itself. The crash is in native Skia code because Mapsui violates Skia\u0027s threading contract."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The crash site is in core SkiaSharp (SKCanvas.DrawPath \u2192 sk_canvas_draw_path), though the root cause is in the caller (Mapsui). No SkiaSharp.Views involvement."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Reporter runs Avalonia desktop on Windows 11. Avalonia uses a non-MAUI, non-WPF windowing model, so Windows-Classic is the closest fit."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Hard crash / process termination during normal usage."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "Root cause is Mapsui\u0027s concurrent access to Skia objects. The explanation of Skia\u0027s threading contract and the recommendation to report upstream to Mapsui serves as the documentation-based closure. SkiaSharp cannot guard against callers violating threading contracts without unacceptable performance cost."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unknown",
            "expandedReason": "Reporter claims 3.116.0 but DLL shows 2.88.8.0. Cannot determine version relevance without knowing which is actually loaded. The threading issue would exist regardless of version."
          }
        ],
        "uncertainties": [
          "Actual SkiaSharp version in use \u2014 form says 3.116.0 but comment says DLL is 2.88.8.0",
          "Whether Mapsui has fixed this threading issue in a newer version",
          "Whether the crash could also occur with a single-threaded usage pattern (unlikely given intermittent nature)"
        ],
        "assumptions": [
          "Assumed intermittent nature indicates threading rather than a corrupted object, because the same code path succeeds most of the time",
          "Assumed the CacheTracker\u003CT\u003E pattern in Mapsui shares objects between threads based on the call stack showing GetMapInfo rendering from PointerMoved"
        ],
        "resolution": {
          "hypothesis": "Mapsui\u0027s GetMapInfo() renders features (calling SKCanvas.DrawPath with cached SKPath/SKPaint) from the PointerMoved UI event handler while the main render loop is also drawing on the same canvas/objects. Skia is not thread-safe, so concurrent access causes intermittent native crashes.",
          "proposals": [
            {
              "title": "Report to Mapsui project",
              "description": "File an issue on Mapsui\u0027s GitHub repo describing the concurrent GetMapInfo/render threading issue. The fix needs to be in Mapsui \u2014 either by synchronizing GetMapInfo with the render loop, or by using separate Skia objects for hit-testing.",
              "confidence": 0.85,
              "effort": "low"
            },
            {
              "title": "Workaround: debounce or queue GetMapInfo calls",
              "description": "In the user\u0027s code, avoid calling GetMapInfo() directly in PointerMoved. Instead, debounce the call or queue it to run after the current render completes. This reduces but may not eliminate concurrent access.",
              "confidence": 0.65,
              "effort": "low"
            },
            {
              "title": "Workaround: lock around map operations",
              "description": "Add a lock in user code around both the render callback and the GetMapInfo call to prevent concurrent Skia access. May cause UI jank but will prevent crashes.",
              "confidence": 0.7,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Report to Mapsui project",
          "recommendedReason": "The root cause is in Mapsui\u0027s architecture. User-side workarounds are fragile. Mapsui needs to fix the thread safety of GetMapInfo."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "Crash is caused by Mapsui\u0027s concurrent access to Skia objects from PointerMoved and the render loop. Not a SkiaSharp defect \u2014 closing with threading explanation."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Reclassify as question, keep Windows and reliability labels",
            "reason": "Not a SkiaSharp bug \u2014 it\u0027s a threading misuse question. Keep platform and tenet labels as they\u0027re accurate.",
            "confidence": 0.75,
            "payload": {
              "labelsToAdd": [
                "type/question"
              ],
              "labelsToRemove": [
                "type/bug"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Explain threading root cause and point to Mapsui as the responsible project",
            "reason": "Reporter needs to understand why this happens and where to file it",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "close-message",
              "draftBody": "Thanks for the stack trace \u2014 that\u0027s really helpful for understanding what\u0027s going on here.\n\nThe intermittent nature of this crash is a strong signal that it\u0027s a threading issue. Looking at the stack trace, the crash happens inside \u0060sk_canvas_draw_path\u0060 called from Mapsui\u0027s \u0060GetMapInfo()\u0060, which is triggered from your \u0060PointerMoved\u0060 event handler. The key issue is that Skia (the native library underneath SkiaSharp) is **not thread-safe** \u2014 if \u0060GetMapInfo()\u0060 is performing draw operations on the same \u0060SKCanvas\u0060, \u0060SKPath\u0060, or \u0060SKPaint\u0060 objects that the main render loop is using concurrently, intermittent native crashes are the expected result.\n\nThe \u0060CacheTracker\u003CSKPath\u003E\u0060 and \u0060CacheTracker\u003CSKPaint\u003E\u0060 in the stack suggest Mapsui is reusing cached Skia objects across these code paths. This would need to be addressed in Mapsui itself \u2014 either by synchronizing the GetMapInfo path with the render loop, or by using separate objects.\n\nAs a short-term workaround, you could try debouncing or queuing your \u0060GetMapInfo()\u0060 calls so they don\u0027t overlap with active rendering.\n\nAlso \u2014 you mentioned SkiaSharp 3.116.0 in the form, but your comment says the DLL version is 2.88.8.0. Would you be able to double-check which version is actually loaded? It won\u0027t change the diagnosis here, but it\u0027s worth getting straight.\n\nI\u0027d suggest raising this with the [Mapsui project](https://github.com/Mapsui/Mapsui/issues) as they\u0027d be best positioned to fix the threading issue.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3398-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as external \u2014 root cause is in Mapsui, not SkiaSharp",
            "reason": "SkiaSharp is working as designed. Skia\u0027s threading contract is documented. Fix belongs in Mapsui.",
            "confidence": 0.75,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3398"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3396,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/feature-request",
          "os/WASM",
          "area/SkiaSharp.Views.Uno"
        ],
        "state": "open"
      },
      "summary": "User unable to load libSkiaSharp native library in Unity WebGL \u2014 gets DllNotFoundException despite trying multiple NativeAssets packages",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.8
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.9
        },
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.8
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Download managed SkiaSharp NuGet and NativeAssets.Windows, NativeAssets.Android, NativeAssets.WebAssembly",
            "Set up Unity project targeting WebGL",
            "Place libSkiaSharp.a files in Unity project",
            "Build and run \u2014 browser console shows DllNotFoundException for libSkiaSharp"
          ],
          "environmentDetails": "Unity 2021.2 and 2022.3, targeting WebGL/WebAssembly"
        },
        "versionAnalysis": {
          "reason": "No specific SkiaSharp version mentioned. User references NativeAssets.Windows, NativeAssets.Android, and NativeAssets.WebAssembly NuGet packages but no version numbers."
        }
      },
      "analysis": {
        "summary": "User is trying to use SkiaSharp in Unity WebGL, which is not an officially supported scenario. Unity\u0027s native plugin system differs from .NET\u0027s standard P/Invoke, and the NativeAssets.WebAssembly package is designed for Blazor/browser WASM via Emscripten, not Unity\u0027s WebGL build pipeline. The DllNotFoundException indicates the native library is not being linked into the Unity WebGL build correctly.",
        "keySignals": [
          {
            "text": "[FEATURE] Can\u0027t get it to work on Unity WebGL",
            "source": "title",
            "interpretation": "Filed as feature request but content is a how-to question about unsupported platform"
          },
          {
            "text": "DLLNotFound libSkiaSharp",
            "source": "body",
            "interpretation": "Native library not loading \u2014 Unity WebGL requires static linking via Emscripten, not dynamic loading"
          },
          {
            "text": "I have downloaded the managed SkiaSharp nuget and the Native.Windows and Native.Android and Native.WebAssemebly nugets",
            "source": "body",
            "interpretation": "User tried NativeAssets.WebAssembly but it is designed for Blazor WASM, not Unity WebGL"
          },
          {
            "text": "I have so far got it to run on Windows and Android",
            "source": "body",
            "interpretation": "SkiaSharp works in Unity for desktop/Android where dynamic linking is possible"
          },
          {
            "text": "I am not sure if this is because the managed C# dll is expecting a dynamic linked library instead of a static one",
            "source": "body",
            "interpretation": "User correctly suspects the static vs dynamic linking mismatch"
          },
          {
            "text": "Has anyone got this working on Unity for WebGL?",
            "source": "body",
            "interpretation": "Asking for community help \u2014 this is a question, not a feature request"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "Despite the [FEATURE] template prefix, the actual content is asking how to get SkiaSharp working in Unity WebGL. The user says \u0027Has anyone got this working?\u0027 and \u0027I have been trying for about 5 hours\u0027. This is a support/how-to question about an unsupported platform, not a request for new API functionality.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "User is not requesting a new API or capability \u2014 they are asking how to make existing functionality work in Unity WebGL. The [FEATURE] prefix comes from the issue template, but the content is a usage question."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The core error is DllNotFoundException for libSkiaSharp, which is a native library loading issue. The previous label area/SkiaSharp.Views.Uno was incorrect \u2014 Unity and Uno Platform are entirely different frameworks.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Uno",
                "whyRejected": "Unity is NOT Uno Platform. These are completely different technologies. The previous automated triage incorrectly conflated them."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM",
            "expandedReason": "Unity WebGL compiles to WebAssembly. The os/WASM label is the correct platform classification."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "This is fundamentally a cross-platform compatibility question \u2014 SkiaSharp works on Windows and Android in Unity but not in the WebGL/WASM target."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "convert-to-discussion",
            "expandedReason": "Unity is not an officially supported platform. This is a community support question better suited to a Q\u0026A discussion where other Unity users can share their experiences."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unknown",
            "expandedReason": "No specific SkiaSharp version was mentioned in the issue. The user referenced NativeAssets packages but provided no version numbers, so relevance to current releases cannot be determined."
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp can technically work in Unity WebGL at all given the static linking requirement",
          "Which exact SkiaSharp version the user is trying to use",
          "Whether the user has tried building libSkiaSharp from source with Emscripten for Unity\u0027s WebGL target"
        ],
        "assumptions": [
          "Assumed the user is using the latest stable SkiaSharp since no version was specified",
          "Assumed Unity WebGL requires static linking of native plugins based on Unity documentation reference in the issue"
        ],
        "resolution": {
          "hypothesis": "Unity WebGL requires native plugins to be statically linked .a files compiled with Emscripten, but the NativeAssets.WebAssembly package provides binaries built for the Blazor/browser WASM runtime, not for Unity\u0027s build pipeline. The P/Invoke mechanism in Unity WebGL also works differently from standard .NET.",
          "proposals": [
            {
              "title": "Build libSkiaSharp from source for Unity WebGL",
              "description": "Compile libSkiaSharp using Emscripten with Unity-compatible settings. This would produce a .a static library that Unity can link into its WebGL build. Requires knowledge of Skia\u0027s build system (GN/Ninja) and Unity\u0027s native plugin requirements.",
              "confidence": 0.5,
              "effort": "high"
            },
            {
              "title": "Use SkiaSharp.Views.Blazor approach as reference",
              "description": "Study how SkiaSharp.Views.Blazor integrates with WebAssembly and adapt the approach for Unity WebGL. The Blazor integration already solves WASM compilation but uses a different hosting model.",
              "confidence": 0.35,
              "effort": "high"
            },
            {
              "title": "Use alternative 2D graphics for Unity WebGL",
              "description": "Consider Unity\u0027s built-in Vector Graphics package or other Unity-native solutions for vector art rendering in WebGL, since SkiaSharp does not officially support Unity as a host platform.",
              "confidence": 0.7,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Use alternative 2D graphics for Unity WebGL",
          "recommendedReason": "Unity is not an officially supported platform for SkiaSharp. Getting it to work in WebGL would require significant custom build work with no guarantee of success or ongoing support. Unity\u0027s own vector graphics tools are a more sustainable path."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "convert-to-discussion",
          "confidence": 0.75,
          "reason": "Unity is not an officially supported platform for SkiaSharp. This is a community support question better suited to a Q\u0026A discussion where Unity users can share experiences and workarounds.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Fix area label (Uno \u2192 native) and change type to question",
            "reason": "Unity is not Uno Platform \u2014 previous triage incorrectly applied area/SkiaSharp.Views.Uno. Content is a question, not a feature request.",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "type/question",
                "area/libSkiaSharp.native",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "type/feature-request",
                "area/SkiaSharp.Views.Uno"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Explain Unity WebGL limitations and suggest alternatives",
            "reason": "User has been struggling for hours and deserves a clear explanation of why NativeAssets.WebAssembly does not work in Unity WebGL",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed write-up of what you\u0027ve tried \u2014 that\u0027s helpful context.\n\nThe \u0060NativeAssets.WebAssembly\u0060 package is built for the Blazor/browser WASM runtime, not for Unity\u0027s WebGL pipeline. Unity WebGL requires native plugins to be statically linked \u0060.a\u0060 files compiled with Emscripten using Unity-compatible settings, which is a different build target than what the NuGet package provides.\n\nYour intuition about static vs dynamic linking is on the right track \u2014 Unity WebGL can\u0027t dynamically load \u0060.dll\u0060 or \u0060.so\u0060 files the way desktop and Android can. The native library needs to be compiled specifically for Unity\u0027s Emscripten toolchain and placed in a \u0060Plugins/WebGL\u0060 folder.\n\nUnity is not an officially supported host platform for SkiaSharp, so getting this working would require building libSkiaSharp from source targeting Unity\u0027s Emscripten environment \u2014 which is a significant undertaking. You might want to explore Unity\u0027s built-in Vector Graphics package or other Unity-native solutions for vector art in WebGL as a more sustainable alternative.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3396-comment-1"
            }
          },
          {
            "id": "convert-1",
            "type": "convert-to-discussion",
            "risk": "high",
            "description": "Convert to Q\u0026A discussion for community input",
            "reason": "This is a support question about an unsupported platform \u2014 better suited to discussion format where Unity users can share experiences",
            "confidence": 0.65,
            "dependsOn": "comment-1",
            "payload": {
              "categorySlug": "q-a",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3396"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3393,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Android",
          "area/SkiaSharp",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "All P/Invoke wrapper methods lack GC.KeepAlive calls, allowing premature collection of managed objects while native code is using their handles",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": {
          "value": "partner/unoplatform",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "high",
          "severityReason": "Race condition between GC and native code can cause use-after-free crashes on any platform. Non-deterministic and hard to diagnose. Affects all P/Invoke wrappers across the entire binding surface.",
          "hasWorkaround": true,
          "workaroundSummary": "Callers can manually add GC.KeepAlive() after SkiaSharp API calls, but this is fragile and shifts the burden to every consumer.",
          "targetFrameworks": [
            "net8.0-android"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/unoplatform/uno/pull/21660",
              "description": "Uno Platform PR demonstrating the GC race with SkiaSharp canvas.DrawPicture"
            },
            {
              "url": "https://github.com/dotnet/java-interop/issues/719",
              "description": "Related .NET java-interop issue showing same GC.KeepAlive problem"
            }
          ],
          "relatedIssues": [
            3393
          ],
          "codeSnippets": [
            {
              "code": "var canvas = \u2026\nvar picture = \u2026\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point.",
              "language": "csharp",
              "context": "Demonstration of the GC race: after extracting picture.Handle, nothing keeps picture alive during the native call"
            },
            {
              "code": "public void DrawPicture (SKPicture picture, SKPaint paint = null)\n{\n\tif (picture == null)\n\t\tthrow new ArgumentNullException (nameof (picture));\n\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n\tGC.KeepAlive (picture);\n\tGC.KeepAlive (paint);\n}",
              "language": "csharp",
              "context": "Proposed fix: add GC.KeepAlive for all reference type parameters after the P/Invoke call"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, VS Code macOS, Android and all platforms affected"
        },
        "versionAnalysis": {
          "reason": "This is a latent bug present since the inception of the P/Invoke wrappers. It has never been systematically addressed \u2014 only a handful of methods (SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) have GC.KeepAlive calls.",
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.95,
          "reason": "This has always been the case. The GC race exists in every version of SkiaSharp \u2014 it was never systematically protected."
        }
      },
      "analysis": {
        "summary": "Well-documented GC race condition bug. When a managed SkiaSharp object\u0027s Handle is passed to a P/Invoke method, the .NET GC can collect the managed object (and run its finalizer, freeing native memory) before the native call completes. The reporter provides authoritative Microsoft documentation, a concrete Uno Platform reproduction, and a clear fix pattern.",
        "keySignals": [
          {
            "text": "[BUG] P/Invokes should protect parameters across invocations",
            "source": "title",
            "interpretation": "Clearly identifies a systematic bug in P/Invoke parameter lifetime management"
          },
          {
            "text": "this can be collected even while you are executing an instance method on that object",
            "source": "body",
            "interpretation": "Quotes Microsoft documentation confirming the GC behavior that causes the race"
          },
          {
            "text": "once execution hits SkiaApi.sk_canvas_draw_picture(), nothing ensures that picture is kept alive",
            "source": "body",
            "interpretation": "Identifies the exact point where the race can occur in SkiaSharp"
          },
          {
            "text": "The fix: audit the code (is there a generator?) such that all reference type parameters are explicitly kept alive across P/Invoke boundaries",
            "source": "body",
            "interpretation": "Reporter proposes systematic fix via GC.KeepAlive and asks about generator support"
          },
          {
            "text": "unoplatform/uno#21660 is a Skia-related example of this",
            "source": "body",
            "interpretation": "Real-world evidence from Uno Platform where this race was observed"
          },
          {
            "text": "Platform: Android, All",
            "source": "body",
            "interpretation": "Affects all platforms, not just Android \u2014 the GC race is a .NET runtime behavior"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a real bug \u2014 a GC race condition that can cause use-after-free crashes. The reporter provides Microsoft documentation, a concrete reproduction scenario via Uno Platform, and a clear fix. This is not a feature request or question.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "While the fix involves adding code, the underlying behavior (potential crash due to premature GC) is broken, not just suboptimal."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The bug is in the core SkiaSharp binding layer where P/Invoke wrapper methods extract Handle properties without protecting the managed objects from GC. This spans all of binding/SkiaSharp/.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "The Views layer is not the source of the problem \u2014 it\u0027s the core P/Invoke wrappers in SKCanvas, etc."
              }
            ]
          },
          {
            "field": "classification.platforms",
            "chosen": "null",
            "expandedReason": "While Android is mentioned in the form, the reporter explicitly says \u0027All\u0027 platforms are affected. The GC race is a .NET runtime behavior, not platform-specific. Removing os/Android is appropriate since this is cross-platform."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Use-after-free due to GC racing with native code causes crashes, data corruption, or undefined behavior. This is a reliability concern."
          },
          {
            "field": "partner",
            "chosen": "partner/unoplatform",
            "expandedReason": "The Uno Platform team discovered this in practice (uno#21660) and the reporter (jonpryor) references their PR as evidence. Flagging for partner visibility."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Non-deterministic use-after-free crash affecting the entire public API surface. The race is hard to reproduce but real, as demonstrated by the Uno Platform team. No easy workaround for consumers."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Valid bug with a clear fix pattern (GC.KeepAlive), but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant.",
            "alternatives": [
              {
                "value": "ready-to-fix",
                "whyRejected": "While the fix pattern is known, a full audit of hundreds of P/Invoke wrappers is needed before implementation can begin."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "This has always been the case \u2014 the GC race exists in every version of SkiaSharp. The P/Invoke wrappers were never systematically protected with GC.KeepAlive calls."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "This is a latent bug present since the inception of the P/Invoke wrappers and has never been systematically addressed. Only a handful of methods currently have GC.KeepAlive calls."
          }
        ],
        "uncertainties": [
          "How many of the ~hundreds of P/Invoke wrapper methods need GC.KeepAlive added \u2014 a full audit is needed",
          "Whether the code generator (utils/generate.ps1) can be extended to automatically emit GC.KeepAlive calls, or if hand-written wrappers must be individually patched",
          "Whether GC.KeepAlive(this) should also be added to instance methods, or if callers are expected to keep \u0060this\u0060 alive"
        ],
        "assumptions": [
          "Assumed the handful of existing GC.KeepAlive calls (in SKData, SKImage, SKSurface, etc.) were added ad-hoc, not as part of a systematic effort",
          "Assumed the bug affects all .NET runtimes (CoreCLR, Mono, NativeAOT) since the GC behavior is specified by the ECMA CLI standard"
        ],
        "resolution": {
          "hypothesis": "The .NET GC can collect managed SkiaSharp objects after their Handle property is read but before the P/Invoke call completes, because the runtime cannot see into native code. If the finalizer runs during this window, it frees the native handle, causing use-after-free in Skia.",
          "proposals": [
            {
              "title": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
              "description": "Audit all public methods in binding/SkiaSharp/ that call SkiaApi.* and add GC.KeepAlive() for every reference-type parameter (including \u0060this\u0060 for instance methods) after the P/Invoke call. This is the approach the reporter suggests and is the most thorough fix.",
              "confidence": 0.9,
              "effort": "high"
            },
            {
              "title": "Extend code generator to emit GC.KeepAlive",
              "description": "Modify the binding generator (utils/generate.ps1 or the underlying tool) to automatically emit GC.KeepAlive calls in generated P/Invoke wrappers. This prevents future regressions and reduces manual effort, but requires understanding the generator\u0027s architecture.",
              "confidence": 0.8,
              "effort": "high"
            },
            {
              "title": "Targeted fix for highest-risk methods first",
              "description": "Add GC.KeepAlive to the most commonly used methods (SKCanvas.Draw*, SKPaint, SKPath operations) as an incremental first step, with a follow-up for the full audit. Lower effort but leaves long-tail risk.",
              "confidence": 0.85,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
          "recommendedReason": "The reporter is an experienced .NET runtime engineer (jonpryor) who clearly understands the problem. A systematic fix is the only way to fully address this \u2014 partial fixes leave the same class of bug in less-used code paths."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Valid bug with clear fix pattern, but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add partner/unoplatform label and remove os/Android since issue affects all platforms",
            "reason": "Issue is cross-platform (reporter selected \u0027All\u0027), and Uno Platform is directly involved via their PR #21660",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "partner/unoplatform"
              ],
              "labelsToRemove": [
                "os/Android"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug report and outline investigation plan",
            "reason": "High-quality report from a knowledgeable contributor deserves a substantive response confirming the issue is understood",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the thorough write-up and the Microsoft documentation references \u2014 this is a well-documented GC race that we need to address systematically.\n\nA quick audit shows that only a handful of methods (in SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) currently have \u0060GC.KeepAlive\u0060 calls, so the vast majority of P/Invoke wrappers are unprotected.\n\nThe main question is whether to extend the code generator to emit these automatically, or do a manual audit. Do you have a sense of whether the Uno Platform team has hit this in practice beyond the \u0060DrawPicture\u0060 case, or if that\u0027s been the primary trigger?",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3393-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3393"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3386,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Linux",
          "area/libSkiaSharp.native",
          "tenet/compatibility"
        ],
        "state": "open"
      },
      "summary": "DllNotFoundException for libSkiaSharp when deploying to Azure Container App via .NET Aspire \u2014 NoDependencies package binary not deployed, wrong variant loaded",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Linux",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          },
          {
            "value": "tenet/reliability",
            "confidence": 0.8
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Application crashes on startup in container deployment, but a workaround exists using a custom Docker image with NativeAssets.Linux.",
          "hasWorkaround": true,
          "workaroundSummary": "Switch from NativeAssets.Linux.NoDependencies to NativeAssets.Linux and use a custom Docker image (ghcr.io/avantipoint/aspnet-skia) with fontconfig and other native dependencies pre-installed. Also add System.Memory.Data as a direct PackageReference to prevent trimming.",
          "targetFrameworks": [
            "net9.0"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/AvantiPoint/aspnet-skia",
              "description": "Custom Docker image repo created by reporter as a workaround \u2014 based on mcr.microsoft.com/dotnet/aspnet with SkiaSharp native dependencies installed"
            }
          ],
          "stepsToReproduce": [
            "Create a .NET 9 Web API project using .NET Aspire",
            "Add SkiaSharp 3.116.0 and SkiaSharp.NativeAssets.Linux.NoDependencies package references",
            "Deploy to Azure Container App via Aspire",
            "Invoke an endpoint that uses SkiaSharp (e.g., SKBitmap.Decode)"
          ],
          "codeSnippets": [
            {
              "code": "\u003CPackageReference Include=\u0022SkiaSharp\u0022 /\u003E\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022 /\u003E",
              "language": "xml",
              "context": "Package references used in the project"
            }
          ],
          "environmentDetails": "Linux Azure Container App deployed via .NET Aspire, .NET 9.0.10 runtime, Visual Studio (Windows) IDE"
        },
        "versionAnalysis": {
          "reason": "Issue reported on 3.116.0 (current at time of filing). The user reports 2.88.9 as the last known good version. This suggests a regression or packaging change between the 2.x and 3.x major versions that affects native asset deployment in containerized environments.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.7,
          "reason": "User reports 2.88.9 as last known good version. However, the NoDependencies package may not have existed in 2.x, so this may be a new issue with the 3.x packaging rather than a true regression of previously-working functionality.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "The user references SkiaSharp.NativeAssets.Linux.NoDependencies but the DllNotFoundException error shows libfontconfig.so.1 as the first missing dependency. NoDependencies has zero fontconfig dependency, so the deployed binary is NOT from the NoDependencies package \u2014 it is from NativeAssets.Linux or another source. This is a known failure mode documented in packages.md, likely caused by .NET Aspire\u0027s container deployment deploying the wrong native binary variant.",
        "keySignals": [
          {
            "text": "libfontconfig.so.1: cannot open shared object file: No such file or directory",
            "source": "stack-trace",
            "interpretation": "The NoDependencies variant has zero fontconfig dependency. Seeing this error means the deployed binary is NOT from NoDependencies \u2014 the wrong native binary variant was deployed."
          },
          {
            "text": "SkiaSharp.NativeAssets.Linux.NoDependencies",
            "source": "body",
            "interpretation": "User explicitly added NoDependencies package, but the deployed binary still requires fontconfig, indicating a package selection or deployment conflict."
          },
          {
            "text": "deployed with .NET Aspire",
            "source": "body",
            "interpretation": "Aspire uses container deployment which may interfere with NativeAssets resolution. The container build tooling may select or override the wrong RID variant."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "body",
            "interpretation": "Suggests something changed between 2.x and 3.x in how native assets are packaged or resolved in container scenarios."
          },
          {
            "text": "I switched to SkiaSharp.NativeAssets.Linux",
            "source": "comment 2",
            "interpretation": "User\u0027s workaround confirms the NoDependencies binary was not being deployed. Switching to the full Linux variant with fontconfig installed in a custom image resolved it."
          },
          {
            "text": "System.Memory.Data was not found... trimming is enabled",
            "source": "comment 2",
            "interpretation": "Secondary issue: Aspire\u0027s container deployment enables trimming which strips transitive dependencies. This compounds the native loading issue."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The application crashes with a TypeInitializationException wrapping a DllNotFoundException. The user correctly added the NoDependencies package but the wrong native binary was deployed, causing a crash. This is broken deployment behavior, not a usage error.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "User is not asking how to do something \u2014 the application crashes despite following documented package references."
              },
              {
                "value": "type/documentation",
                "whyRejected": "While the troubleshooting section of packages.md documents this exact scenario, the underlying issue is a real packaging/deployment bug, not a documentation gap."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The error is a DllNotFoundException for libSkiaSharp, which is a native library loading failure. The root cause is in how native assets are packaged and deployed, making area/libSkiaSharp.native the correct classification.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "Not a managed API issue \u2014 the failure is in native binary resolution/deployment."
              },
              {
                "value": "area/Build",
                "whyRejected": "Not a build issue per se \u2014 the project builds successfully. The failure is in runtime native binary selection during container deployment."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Application crashes on any SkiaSharp API call in the container, which is high impact. However, the user found a complete workaround (custom Docker image with fontconfig \u002B NativeAssets.Linux), dropping severity from high to medium."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility, tenet/reliability",
            "expandedReason": "Compatibility: worked in 2.88.9 but not in 3.116.0 in container deployments. Reliability: results in a hard crash (TypeInitializationException) on the first SkiaSharp API call."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The workaround exists but the root cause \u2014 why NoDependencies binary is not deployed in Aspire container builds \u2014 is undetermined and could be a SkiaSharp packaging issue or Aspire tooling bug.",
            "alternatives": [
              {
                "value": "close-answered",
                "whyRejected": "While a workaround was found, the underlying packaging/deployment bug remains unfixed and affects other users."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Linux",
            "expandedReason": "The issue occurs in Linux Azure Container Apps deployed via .NET Aspire. The DllNotFoundException for libSkiaSharp and missing libfontconfig are Linux-specific native dependency issues."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "User reports 2.88.9 as last known good version. However, the NoDependencies package may not have existed in 2.x, so this may be a new issue with 3.x packaging rather than a true regression of identical functionality."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Issue reported on 3.116.0 with no indication the native asset selection behavior in container deployments has been fixed in later releases."
          }
        ],
        "uncertainties": [
          "Whether the user had a conflicting transitive NativeAssets.Linux reference that overrode NoDependencies",
          "Whether .NET Aspire specifically selects the wrong RID variant during container image build, or if this is a general dotnet publish issue",
          "Whether NoDependencies package existed in 2.88.9 or if the user used a different package configuration with the older version"
        ],
        "assumptions": [
          "Assumed the user correctly added NoDependencies to the executable project, not just a library project",
          "Assumed this is specific to .NET Aspire container deployment since local development works fine",
          "Assumed net9.0 target framework based on the .NET 9.0.10 runtime path in the stack trace"
        ],
        "resolution": {
          "hypothesis": ".NET Aspire\u0027s container deployment pipeline resolves or deploys the wrong native binary variant for SkiaSharp. The NoDependencies binary should have no fontconfig dependency, but the deployed binary does, indicating the standard NativeAssets.Linux binary (or none) ends up in the container instead.",
          "proposals": [
            {
              "title": "Use custom Docker image with NativeAssets.Linux",
              "description": "The reporter\u0027s own workaround: switch to NativeAssets.Linux, use a custom base image with fontconfig installed, and set ContainerBaseImage in the csproj. This is a complete workaround available now.",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Investigate NoDependencies package selection in Aspire",
              "description": "Determine why .NET Aspire\u0027s container build doesn\u0027t deploy the NoDependencies binary. May require adding MSBuild diagnostics to trace which native assets are selected during publish. Could result in documentation improvement or MSBuild targets fix.",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "title": "Add Aspire-specific guidance to documentation",
              "description": "Document the .NET Aspire container deployment scenario in packages.md or a dedicated troubleshooting guide. Include the ContainerBaseImage workaround and the trimming fix for System.Memory.Data.",
              "confidence": 0.85,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Add Aspire-specific guidance to documentation",
          "recommendedReason": "The reporter\u0027s workaround is already complete and shared in the issue. Adding this to official documentation prevents others from hitting the same problem. Investigation into the root MSBuild/Aspire interaction can proceed separately."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The workaround exists but the root cause \u2014 why NoDependencies binary isn\u0027t deployed in Aspire container builds \u2014 is not determined. This could be a SkiaSharp packaging issue or an Aspire tooling bug.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add tenet/reliability label to reflect the hard crash behavior",
            "reason": "The issue causes a TypeInitializationException crash. Current labels cover type/bug, area, os, and tenet/compatibility but miss tenet/reliability.",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "tenet/reliability"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging workaround and explaining the fontconfig diagnostic signal",
            "reason": "The reporter and future visitors would benefit from understanding why the fontconfig error appears with NoDependencies, and official acknowledgment of the Aspire deployment gap.",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the thorough write-up and the workaround \u2014 that custom image approach is solid and will help others hitting this.\n\nThe fontconfig error with \u0060NoDependencies\u0060 is a tell: that package ships a binary with zero fontconfig dependency (only libc/libm/libpthread/libdl), so seeing \u0060libfontconfig.so.1: cannot open\u0060 means the deployed binary isn\u0027t actually from the NoDependencies package. Something in the Aspire container build pipeline is either selecting the wrong variant or not deploying the NoDependencies binary at all.\n\nWe\u0027ll look into what\u0027s happening with native asset selection in Aspire container deployments. In the meantime, your approach of using \u0060NativeAssets.Linux\u0060 with a custom base image that has fontconfig installed is the right call for this scenario.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3386-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3386"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3385,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/feature-request"
        ],
        "state": "open"
      },
      "summary": "Request to add SkColorType.Gray16 for 16-bit grayscale PNG support, but upstream Skia lacks Gray16",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        }
      },
      "evidence": {},
      "analysis": {
        "summary": "User requests adding SkColorType.Gray16 for 16-bit grayscale PNG support. However, upstream Skia does not define a kGray_16 color type \u2014 confirmed by both the Skia API header (SkColorType.h) and a community comment. Since SkiaSharp wraps Skia, this cannot be implemented without upstream support.",
        "keySignals": [
          {
            "text": "[FEATURE] Gray16 support",
            "source": "title",
            "interpretation": "Explicitly tagged as a feature request"
          },
          {
            "text": "i want to use 16bit grayscale pngs but it looks like it doesnt exist in skiasharp",
            "source": "body",
            "interpretation": "User identified a missing color type in SkiaSharp\u0027s SKColorType enum"
          },
          {
            "text": "add SkColorType.Gray16",
            "source": "body",
            "interpretation": "Clear request for a specific new enum value"
          },
          {
            "text": "There\u0027s no Gray16 support upstream: https://api.skia.org/SkColorType_8h.html",
            "source": "comment 2",
            "interpretation": "Community member confirmed the limitation is in upstream Skia, not just a missing SkiaSharp wrapper"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "The user explicitly asks for new functionality (a new SKColorType value) that does not currently exist in SkiaSharp or upstream Skia. The title is prefixed with [FEATURE] and the issue uses the feature request template.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement implies improving something that exists. Gray16 support doesn\u0027t exist at all \u2014 this is new capability."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKColorType is a core SkiaSharp enum in the main binding library. It\u0027s not specific to views, HarfBuzz, or native loading.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the limitation is in the native layer, the requested API surface change is in the managed SKColorType enum."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a legitimate feature request, but it\u0027s blocked on upstream Skia adding kGray_16_SkColorType first. A community member has already provided the key information. The issue should stay open to track demand, but no immediate action is possible."
          }
        ],
        "uncertainties": [
          "Whether the user\u0027s use case could be served by an alternative approach such as converting 16-bit grayscale data to a supported format like RGBA_F16 or R16G16_unorm"
        ],
        "assumptions": [
          "Assumed the user specifically needs native Gray16 pixel format support, not just the ability to decode 16-bit grayscale PNGs into a wider format"
        ],
        "resolution": {
          "hypothesis": "The user wants to work with 16-bit grayscale images natively in SkiaSharp, but the underlying Skia C\u002B\u002B library does not define a kGray_16 color type, making direct support impossible without upstream changes.",
          "proposals": [
            {
              "title": "Wait for upstream Skia to add kGray_16_SkColorType",
              "description": "Monitor Skia\u0027s development for the addition of a 16-bit grayscale color type. Once added upstream, SkiaSharp can expose it as SKColorType.Gray16. This is the only path to native support.",
              "confidence": 0.4,
              "effort": "low"
            },
            {
              "title": "Use A16_unorm as a workaround for single-channel 16-bit data",
              "description": "SkColorType.A16Unorm (kA16_unorm_SkColorType) stores a single 16-bit channel. While semantically it represents alpha, the user could repurpose it for grayscale data if they only need the raw pixel storage. Rendering would require custom shader logic.",
              "confidence": 0.5,
              "effort": "low"
            },
            {
              "title": "Decode 16-bit grayscale PNGs into RGBA_F16",
              "description": "Load the PNG and convert pixel data into SKColorType.RgbaF16, mapping the 16-bit grayscale value to all RGB channels. This preserves precision but uses 4x the memory and requires manual conversion.",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Decode 16-bit grayscale PNGs into RGBA_F16",
          "recommendedReason": "Most practical workaround available today. Preserves 16-bit precision while using supported Skia color types."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.8,
          "reason": "Legitimate feature request blocked on upstream Skia. Community has already clarified the upstream limitation. Keep open to track demand."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp label to the feature request",
            "reason": "Issue is about the core SKColorType enum in the main SkiaSharp binding",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post comment explaining upstream dependency and suggesting workarounds",
            "reason": "While a community member noted the upstream gap, an official response with workarounds would add value",
            "confidence": 0.7,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the request. As noted in the comments, upstream Skia doesn\u0027t currently define a \u0060kGray_16\u0060 color type, so SkiaSharp can\u0027t expose \u0060SKColorType.Gray16\u0060 without that support landing in Skia first.\n\nIf you need to work with 16-bit grayscale PNG data in the meantime, one approach is to decode the pixel data and map it into \u0060SKColorType.RgbaF16\u0060 \u2014 this preserves 16-bit precision, though at the cost of higher memory usage. Another option is \u0060SKColorType.A16Unorm\u0060, which stores a single 16-bit channel (semantically alpha, but usable for raw grayscale storage if rendering isn\u0027t the primary goal).\n\nWe\u0027ll keep this open to track demand for native Gray16 support.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3385-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3385"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3379,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp.Views",
          "tenet/compatibility"
        ],
        "state": "open"
      },
      "summary": "SkiaSharp.Views.WPF references OpenTK.GLWpfControl 3.3.0 which lacks strong-naming, breaking strong-named .NET Framework applications with FileLoadException",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.8
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.95
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Runtime FileLoadException blocks usage entirely for strong-named apps, but workaround exists by downgrading to 2.88.x or not strong-naming.",
          "hasWorkaround": true,
          "workaroundSummary": "Downgrade to SkiaSharp 2.88.x which did not have the OpenTK.GLWpfControl dependency, or avoid strong-naming the consuming application.",
          "targetFrameworks": [
            "net48"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/blob/c38c6820b05fb2538afdd5a2f6662c5aff1d07e0/source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj#L15",
              "description": "Line in csproj referencing OpenTK.GLWpfControl 3.3.0 for net4x"
            }
          ],
          "stepsToReproduce": [
            "Create a .NET Framework 4.8 WPF application",
            "Enable strong-naming with SignAssembly and an .snk key file",
            "Add PackageReference to SkiaSharp.Views.WPF 3.119.1",
            "Build and run \u2014 FileLoadException on GLWpfControl assembly"
          ],
          "codeSnippets": [
            {
              "code": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EWinExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet48\u003C/TargetFramework\u003E\n    \u003CSignAssembly\u003Etrue\u003C/SignAssembly\u003E\n    \u003CAssemblyOriginatorKeyFile\u003EMyStrongNameKey.snk\u003C/AssemblyOriginatorKeyFile\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp.Views.WPF\u0022 Version=\u00223.119.1\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E",
              "language": "xml",
              "context": "Minimal csproj demonstrating strong-named WPF app with SkiaSharp.Views.WPF"
            }
          ],
          "environmentDetails": "Windows, Visual Studio, .NET Framework 4.8, SkiaSharp 3.116.0\u002B"
        },
        "versionAnalysis": {
          "reason": "The csproj on main still references OpenTK.GLWpfControl 3.3.0 for net4x targets. Issue is present in all SkiaSharp 3.x releases.",
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "migrationPath": "Bump OpenTK.GLWpfControl from 3.3.0 to 3.3.1 in SkiaSharp.Views.WPF.csproj"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "User reports last known good version was 2.88.9 which did not have the OpenTK.GLWpfControl dependency. The SkiaSharp 3.x series introduced this dependency, and version 3.3.0 lacks strong-naming.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.9,
          "reason": "PR #3380 is open and proposes bumping OpenTK.GLWpfControl from 3.3.0 to 3.3.1. The fix has not been merged yet.",
          "relatedPRs": [
            3380
          ],
          "verificationStatus": "unverified"
        }
      },
      "analysis": {
        "summary": "SkiaSharp.Views.WPF packages OpenTK.GLWpfControl 3.3.0 for .NET Framework targets. That version is not strong-named, so any strong-named consuming application gets a FileLoadException at runtime. The fix is a one-line version bump to 3.3.1 where strong-naming was added upstream.",
        "keySignals": [
          {
            "text": "OpenTK.GLWpfControl version 3.3.0 for .NET Framework... the GLWpfControl assembly is not strong-named",
            "source": "body",
            "interpretation": "Root cause identified by reporter \u2014 upstream dependency lacks strong name"
          },
          {
            "text": "Strong-naming was added in OpenTK.GLWpfControl 3.3.1",
            "source": "body",
            "interpretation": "Reporter has already identified the fix version"
          },
          {
            "text": "FileLoadException: Could not load file or assembly \u0027GLWpfControl, Version=3.3.0.0... A strongly-named assembly is required (0x80131044)\u0027",
            "source": "body",
            "interpretation": "Runtime error confirming strong-name enforcement failure"
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "body",
            "interpretation": "Regression from SkiaSharp 2.x to 3.x which introduced the OpenTK.GLWpfControl dependency"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a runtime failure \u2014 FileLoadException prevents the application from running. The dependency on a non-strong-named assembly is a defect in the package configuration, not a feature request or question.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Not an improvement request \u2014 the application fails to load entirely."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The issue is in the SkiaSharp.Views.WPF csproj which references OpenTK.GLWpfControl. This is the Views package, specifically the WPF variant.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "Core SkiaSharp is unaffected \u2014 only the WPF views package has this dependency."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "GLWpfControl is the OpenGL rendering control for WPF. The issue is specific to this OpenGL integration dependency."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "The error completely blocks strong-named applications from using SkiaSharp.Views.WPF 3.x. However, a workaround exists (downgrade to 2.88.x or remove strong-naming), and the fix is a trivial version bump with an open PR."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "PR #3380 is already open with the fix (version bump to 3.3.1). The issue should remain open until the PR is merged and released."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "The issue is specific to WPF on Windows with .NET Framework 4.8. Strong-naming enforcement and the OpenTK.GLWpfControl dependency only apply to Windows Classic desktop scenarios."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "Strong-named applications cannot load non-strong-named assemblies, breaking backward compatibility for .NET Framework WPF consumers who upgraded from SkiaSharp 2.88.x to 3.x."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "SkiaSharp 2.88.9 did not have the OpenTK.GLWpfControl dependency. The 3.x series introduced it at version 3.3.0 which lacks strong-naming, breaking strong-named apps that previously worked."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "false",
            "expandedReason": "PR #3380 is open proposing bumping OpenTK.GLWpfControl from 3.3.0 to 3.3.1, but it has not been merged yet so the fix is not available in any release."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The csproj on main still references OpenTK.GLWpfControl 3.3.0 for net4x targets, so the issue is present in all SkiaSharp 3.x releases including the latest."
          }
        ],
        "uncertainties": [
          "Whether bumping OpenTK.GLWpfControl from 3.3.0 to 3.3.1 introduces any behavioral changes beyond the strong-naming fix",
          "Whether the net4x OpenTK dependency (also at 3.3.1) is similarly affected by strong-naming requirements"
        ],
        "assumptions": [
          "Assumed the reporter is using .NET Framework 4.8 based on the csproj TargetFramework of net48",
          "Assumed the issue only affects net4x targets since the non-net4x ItemGroup uses OpenTK.GLWpfControl 4.2.3 which may already be strong-named"
        ],
        "resolution": {
          "hypothesis": "The SkiaSharp.Views.WPF.csproj pins OpenTK.GLWpfControl to 3.3.0 for net4x targets. That version is not strong-named, which breaks the CLR\u0027s strong-name validation chain when the consuming app is strong-named. Version 3.3.1 added strong-naming.",
          "proposals": [
            {
              "title": "Bump OpenTK.GLWpfControl to 3.3.1",
              "description": "Change the PackageReference version from 3.3.0 to 3.3.1 in SkiaSharp.Views.WPF.csproj for the net4x condition. This is the minimal change \u2014 3.3.1 added strong-naming with no other breaking changes. PR #3380 already implements this.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "Bump OpenTK.GLWpfControl to latest 3.x",
              "description": "Update to the latest 3.x release rather than just 3.3.1. This would pick up any additional bug fixes since 3.3.1, but carries slightly more risk of behavioral changes.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Disable SignAssembly for net4x WPF targets",
              "description": "Set SignAssembly to false for net4x targets in the SkiaSharp.Views.WPF csproj, matching the non-net4x behavior. However this would break SkiaSharp\u0027s own strong-naming contract for .NET Framework consumers.",
              "confidence": 0.3,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Bump OpenTK.GLWpfControl to 3.3.1",
          "recommendedReason": "Minimal, targeted fix that resolves the strong-naming gap. PR #3380 already implements exactly this change. No behavioral changes expected."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "PR #3380 is open with the fix. Issue should remain open until merged and released."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add OpenGL backend label to existing correct labels",
            "reason": "The issue involves the OpenGL WPF control dependency. Current labels are correct but missing the backend classification.",
            "confidence": 0.8,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the issue and note the existing PR",
            "reason": "Reporter should know their diagnosis is correct and a fix PR exists",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the clear write-up and for pinpointing the exact version where strong-naming was added.\n\nYou\u0027re right \u2014 the net4x target in SkiaSharp.Views.WPF pins OpenTK.GLWpfControl to 3.3.0, which isn\u0027t strong-named. PR #3380 bumps this to 3.3.1 to resolve the issue.\n\nIn the meantime, if you need a workaround, you could try adding a binding redirect in your app.config to force-load the 3.3.1 package manually, though ideally this will be resolved once the PR is merged.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3379-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3379"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3378,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "os/Android",
          "area/SkiaSharp",
          "backend/Metal",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "Memory leak in ToHarfBuzzBlob() \u2014 SKStreamAsset not disposed in the non-memory-mapped code path",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.8
          },
          {
            "value": "os/Windows-Classic",
            "confidence": 0.75
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.9
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Memory leak that grows with each SKShaper instantiation. No crash, but can degrade application performance over time and eventually cause OOM on resource-constrained devices like Android.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "net8.0-android"
          ]
        },
        "reproEvidence": {
          "codeSnippets": [
            {
              "code": "class TextSegmentShaper : IDisposable\n{\n    public SKPaint Paint { get; set; }\n    public SKShaper Shaper { get; set; }\n    ...\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposedValue)\n        {\n            Paint?.Dispose();\n            Shaper?.Dispose();\n            ...\n        }\n    }\n}",
              "language": "csharp",
              "context": "User\u0027s wrapper class that properly disposes SKShaper, but the underlying leak is in ToHarfBuzzBlob()"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), first observed on Android but also reproduces on Windows"
        },
        "versionAnalysis": {
          "reason": "The leak exists in BlobExtensions.ToHarfBuzzBlob() which has not changed in recent versions. The else branch at line 28-30 copies data from SKStreamAsset but never disposes it.",
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "The code in BlobExtensions.cs has had this pattern since the extension was introduced. The else branch has never disposed the SKStreamAsset. This is a latent bug, not a regression."
        }
      },
      "analysis": {
        "summary": "Confirmed memory leak in BlobExtensions.ToHarfBuzzBlob(). When the SKStreamAsset has no memory base (the else branch), data is copied to unmanaged memory but the SKStreamAsset is never disposed. The if branch correctly disposes via the Blob\u0027s destroy callback, but the else branch only frees the copied CoTaskMem allocation. Title says SKShader but the actual issue is about SKShaper (HarfBuzz).",
        "keySignals": [
          {
            "text": "I think the bug is in ToHarfBuzzBlob() extension - it doesn\u0027t dispose SKStreamAsset in all paths",
            "source": "body",
            "interpretation": "User correctly identified the root cause. The else branch in ToHarfBuzzBlob() copies data but never disposes the source SKStreamAsset."
          },
          {
            "text": "SKShaper Shaper = new SKShaper(typeface)",
            "source": "body",
            "interpretation": "SKShaper constructor calls Typeface.OpenStream().ToHarfBuzzBlob(), creating the leak on every instantiation."
          },
          {
            "text": "First observed bug on Android, but seems to be a problem also on Windows",
            "source": "body",
            "interpretation": "Cross-platform code bug \u2014 affects all platforms, more visible on memory-constrained Android devices."
          },
          {
            "text": "Title says SKShader but code references SKShaper",
            "source": "title",
            "interpretation": "Typo in title \u2014 the actual issue is about SKShaper in the HarfBuzz package, not SKShader."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a memory leak with code evidence pointing to a specific disposal path bug. This is broken behavior in the library, not a usage question.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting a code defect with specific root cause analysis."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.HarfBuzz",
            "expandedReason": "The leak is in BlobExtensions.ToHarfBuzzBlob() which is in the SkiaSharp.HarfBuzz package. SKShaper is also in this package. The current label area/SkiaSharp is incorrect.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The bug is not in core SkiaSharp. BlobExtensions and SKShaper are in the SkiaSharp.HarfBuzz package."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "null",
            "expandedReason": "This is a managed code memory leak in a HarfBuzz extension method. It has nothing to do with rendering backends. The existing backend/Metal label is incorrect."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Memory leak that grows with each SKShaper creation. Not a crash, but can cause OOM on constrained devices over time. The leak is in library code, not user code, so there is no straightforward workaround."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The code-level bug in ToHarfBuzzBlob() is confirmed by source analysis, but a memory profiling test should verify the leak and validate the proposed one-line disposal fix.",
            "alternatives": [
              {
                "value": "close-fixed",
                "whyRejected": "No fix has been merged yet; the bug is identified but not resolved."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Android, os/Windows-Classic",
            "expandedReason": "Reporter first observed the leak on Android and confirmed it also reproduces on Windows. The bug is in managed code (BlobExtensions.cs) so it affects all platforms, but only Android and Windows are explicitly reported."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Memory leak that grows with each SKShaper instantiation can degrade performance over time and eventually cause OOM, particularly on resource-constrained Android devices."
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "The else branch in BlobExtensions.ToHarfBuzzBlob() has never disposed the SKStreamAsset since the extension was introduced. This is a latent bug, not a regression from a previously working state."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The leak exists in BlobExtensions.ToHarfBuzzBlob() which has not changed in recent versions; the else branch still does not dispose the SKStreamAsset."
          }
        ],
        "uncertainties": [
          "Whether the else branch (non-memory-mapped path) is commonly hit in practice \u2014 if most streams have a memory base, the leak may be rare",
          "Exact memory footprint per leak \u2014 depends on font file size, could be significant for large fonts",
          "Whether the title typo (SKShader vs SKShaper) has caused confusion in previous triage"
        ],
        "assumptions": [
          "Assumed net8.0-android as target framework since user mentions Android and SkiaSharp 3.116.0",
          "Assumed the leak is cross-platform based on code analysis, not limited to Android and Windows"
        ],
        "resolution": {
          "hypothesis": "In BlobExtensions.ToHarfBuzzBlob(), the else branch copies font data from the SKStreamAsset into unmanaged memory but never disposes the SKStreamAsset. The if branch correctly passes asset.Dispose() as the Blob destroy callback, but the else branch only frees the CoTaskMem copy.",
          "proposals": [
            {
              "title": "Dispose SKStreamAsset in else branch",
              "description": "Add asset.Dispose() in the else branch of ToHarfBuzzBlob() after reading data, mirroring how the if branch handles disposal via the Blob callback. This is a one-line fix in BlobExtensions.cs.",
              "confidence": 0.92,
              "effort": "low"
            },
            {
              "title": "Always dispose SKStreamAsset after use in SKShaper constructor",
              "description": "Capture the SKStreamAsset in a variable in the SKShaper constructor and wrap it in a using statement, rather than relying on ToHarfBuzzBlob() to manage its lifetime. Decouples disposal responsibility from the extension method.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Unify both paths to always copy data",
              "description": "Simplify ToHarfBuzzBlob() to always copy data and always dispose the asset, removing the memory-mapped optimization. Trades minor performance for simpler, less error-prone code.",
              "confidence": 0.7,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Dispose SKStreamAsset in else branch",
          "recommendedReason": "Minimal change, directly fixes the root cause. The if branch already correctly manages disposal via the Blob callback, so adding disposal in the else branch makes both paths consistent."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.88,
          "reason": "Code-level bug confirmed by source analysis. The fix is straightforward but should be verified with a memory profiling test to confirm the leak and validate the fix.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Correct area to SkiaSharp.HarfBuzz and remove incorrect Metal backend label",
            "reason": "The bug is in BlobExtensions.ToHarfBuzzBlob() in the SkiaSharp.HarfBuzz package, not core SkiaSharp. No rendering backend is involved.",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp.HarfBuzz"
              ],
              "labelsToRemove": [
                "area/SkiaSharp",
                "backend/Metal"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug report and confirm the root cause analysis",
            "reason": "User correctly identified the root cause \u2014 confirm their analysis and outline the likely fix",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed analysis \u2014 you\u0027re right that \u0060ToHarfBuzzBlob()\u0060 in \u0060BlobExtensions.cs\u0060 doesn\u0027t dispose the \u0060SKStreamAsset\u0060 in all paths.\n\nWhen the stream has a memory base, disposal is handled via the \u0060Blob\u0060 destroy callback. But when it falls through to the \u0060else\u0060 branch (data is copied to unmanaged memory), the \u0060SKStreamAsset\u0060 is never disposed.\n\nThis would leak one \u0060SKStreamAsset\u0060 per \u0060SKShaper\u0060 instantiation, which lines up with what you\u0027re seeing. The fix should be straightforward \u2014 disposing the asset after reading in the else branch.\n\n(Note: the issue title mentions SKShader, but the actual bug is in SKShaper/HarfBuzz \u2014 just flagging in case it causes confusion.)",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3378-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3378"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3375,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "SkiaSharp 3.116\u002B crashes on Windows x86 (.NET 8/9) with stack overflow at P/Invoke boundary; works on x64 and on older v2.88.9",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.85
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "steps-only",
          "severity": "high",
          "severityReason": "Hard crash (stack overflow) on x86 with no clean fix. Workarounds exist but require architecture change or version downgrade, which may not be viable for all users.",
          "hasWorkaround": true,
          "workaroundSummary": "Use x64 instead of x86, copy native DLLs to application root directory, or downgrade to SkiaSharp 2.88.9",
          "targetFrameworks": [
            "net9.0",
            "net8.0",
            "netstandard2.0"
          ]
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET 8 or 9 application referencing SkiaSharp 3.116\u002B (or 3.119.1)",
            "Compile and publish for x86 (win-x86)",
            "Run the application on Windows and invoke any SkiaSharp API (e.g., sk_bitmap_get_pixel_color)",
            "Observe stack overflow crash"
          ],
          "environmentDetails": "Windows 11 Pro (ARM CPU) 23H2 build 22631; also reproduced on standard x86 Windows with .NET 8.0"
        },
        "versionAnalysis": {
          "reason": "Issue reported against 3.116.0 and confirmed still present in 3.119.1. No indication of a fix in later versions.",
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Original reporter states 2.88.9 works correctly with x86. Second commenter confirms x86 works with net472 (implying older SkiaSharp or same v3 but different runtime). The v2-to-v3 transition changed native library structure significantly.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "Two independent reporters confirm SkiaSharp 3.x crashes on x86 Windows with .NET 8/9. The second reporter\u0027s stack trace shows a stack overflow originating at the P/Invoke boundary (sk_bitmap_get_pixel_color), which strongly suggests a calling convention mismatch in the x86 native binary or P/Invoke declarations. The issue does not affect x64, and the second reporter confirms x86 works under .NET Framework 4.7.2, pointing to an interaction between the new .NET runtime\u0027s x86 marshalling and SkiaSharp 3.x\u0027s native layer.",
        "keySignals": [
          {
            "text": "when we compile the application for x86 then we are getting app crash (no event log, no dump)",
            "source": "body",
            "interpretation": "Silent crash on x86 suggests native-level failure before managed exception handling can capture it"
          },
          {
            "text": "Stack overflow at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color",
            "source": "comment 2",
            "interpretation": "Stack overflow at P/Invoke boundary is a classic symptom of calling convention mismatch on x86 (cdecl vs stdcall stack cleanup disagreement)"
          },
          {
            "text": "x86 \u002B net472: working / x86 \u002B Net8.0: ISSUE",
            "source": "comment 2",
            "interpretation": ".NET 8 changed default P/Invoke behavior; combined with x86 calling convention, this may trigger the mismatch"
          },
          {
            "text": "when we copy the DLLs from subdirectory to application root directory then the app crash is gone",
            "source": "body",
            "interpretation": "DLL loading path affects which native binary is loaded; a different binary in root may have correct calling convention or architecture"
          },
          {
            "text": "When we rollback the SkiaSharp nuget to version 2.88.9 then DLLs loading from subdirectory also work as expected",
            "source": "body",
            "interpretation": "Confirms regression \u2014 v2 native binaries work on x86, v3 do not"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Application crashes with stack overflow when using SkiaSharp on x86. This is clearly broken behavior \u2014 a hard crash, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something; they are reporting a crash that blocks their x86 builds."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The crash occurs at the P/Invoke boundary to the native library. The stack overflow at sk_bitmap_get_pixel_color indicates the native binary or its calling convention is the root cause, not the managed C# wrapper. The DLL loading path workaround also points to native binary issues.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "While the P/Invoke declarations are in SkiaSharp, the root cause is more likely in the native binary\u0027s x86 compilation (calling convention or architecture mismatch)."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Hard crash (stack overflow) with no clean workaround \u2014 all workarounds require significant changes (switch architecture, restructure DLL deployment, or downgrade to v2). Two independent reporters confirm the issue."
          },
          {
            "field": "regression",
            "chosen": "true",
            "expandedReason": "Explicitly stated: v2.88.9 works on x86, v3.116.0\u002B does not. The v2-to-v3 native library restructuring is the likely point where x86 support broke."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "Two reporters confirm the x86 crash with stack trace evidence, but root cause (calling convention mismatch vs native build issue) needs code inspection of P/Invoke declarations and native build config.",
            "alternatives": [
              {
                "value": "close-wontfix",
                "whyRejected": "This is a confirmed crash affecting x86 users with no clean workaround, not something to dismiss."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Both reporters are on Windows, and the crash is specific to x86 P/Invoke calling conventions on Windows. No other platforms mentioned or affected."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "Reliability: hard crash (stack overflow) with no managed exception handling. Compatibility: regression from v2.88.9 to v3.116.0\u002B breaking existing x86 deployments."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter explicitly states v2.88.9 works on x86 while v3.116.0\u002B crashes. Second reporter confirms x86 works under .NET Framework 4.7.2, pointing to a v2-to-v3 regression in native library structure."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Issue reported against 3.116.0 and confirmed still present in 3.119.1, with no indication of a fix in subsequent releases."
          }
        ],
        "uncertainties": [
          "Whether the root cause is a calling convention mismatch in P/Invoke declarations or in the native binary compilation",
          "Whether the issue is specific to Windows on ARM (original reporter) or affects all Windows x86 scenarios",
          "Whether the DLL-copy workaround from the first reporter applies to the second reporter\u0027s scenario (they say it doesn\u0027t help)",
          "Whether this affects all SkiaSharp APIs or only specific P/Invoke calls"
        ],
        "assumptions": [
          "Assumed the stack overflow in comment 2 is the same underlying issue as the silent crash in the original report, given both are x86-specific with SkiaSharp 3.x",
          "Assumed no fix has been released since 3.119.1 based on no follow-up comments indicating resolution"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp 3.x native binaries or P/Invoke declarations have a calling convention mismatch on x86. On x86 Windows, cdecl and stdcall differ in stack cleanup responsibility. If the native library uses cdecl but the P/Invoke declaration defaults to stdcall (or vice versa), each call leaks stack space, leading to stack overflow. .NET 8\u002B may have changed default marshalling behavior that surfaces this issue where .NET Framework 4.7.2 tolerated it.",
          "proposals": [
            {
              "title": "Audit and fix x86 calling conventions in P/Invoke declarations",
              "description": "Review all DllImport/LibraryImport declarations in SkiaSharp for explicit CallingConvention specification. Ensure they match the native library\u0027s actual calling convention (likely cdecl). On x86, mismatched conventions cause stack corruption on every call.",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "title": "Verify x86 native binary compilation flags",
              "description": "Check the build configuration for win-x86 native binaries to ensure correct calling convention (__cdecl vs __stdcall) is specified consistently. The v2-to-v3 build system change may have altered defaults.",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "title": "Test with explicit NativeLibrary.SetDllImportResolver",
              "description": "As a diagnostic step, use NativeLibrary.SetDllImportResolver to control exactly which native binary is loaded on x86. This would help isolate whether the issue is DLL resolution (wrong binary loaded) or a genuine calling convention problem.",
              "confidence": 0.5,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Audit and fix x86 calling conventions in P/Invoke declarations",
          "recommendedReason": "Stack overflow at P/Invoke boundary is the strongest signal. Calling convention audit is the most direct path to root cause and fix."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real bug confirmed by two reporters with stack trace evidence. Root cause hypothesis is strong but needs verification through code inspection of P/Invoke declarations and native build configuration for x86.",
          "missingInfo": [
            "sample-project"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Update area label to libSkiaSharp.native and add compatibility tenet",
            "reason": "Crash is in native layer at P/Invoke boundary, and this is a v2\u2192v3 regression affecting compatibility",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "area/libSkiaSharp.native",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "area/SkiaSharp"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging the bug and asking for a minimal repro project",
            "reason": "Two reporters confirm the issue but neither provides a minimal reproduction. A repro project would accelerate investigation of the x86 calling convention hypothesis.",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the report and for the additional confirmation from @TomPMoleman \u2014 the stack trace showing a stack overflow at \u0060sk_bitmap_get_pixel_color\u0060 is very helpful.\n\nThe pattern here (x86 \u002B .NET 8/9 = crash, while x64 and .NET Framework 4.7.2 work fine) suggests a possible calling convention mismatch at the P/Invoke boundary that only manifests on x86.\n\nWould either of you be able to share a minimal reproduction project? Even a small console app that references SkiaSharp and calls a single API when built for x86 would be enough to narrow this down.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3375-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3375"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3372,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-09-22T00:00:00Z",
        "currentLabels": [
          "area/SkiaSharp.Views",
          "type/feature-request",
          "os/Windows-WinUI"
        ],
        "state": "open"
      },
      "summary": "Upgrade SkiaSharp.Views.WinUI to use Microsoft.WindowsAppSDK.WinUI 1.8 instead of the full metapackage to reduce transitive dependency bloat for MAUI and other consumers.",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Windows-WinUI",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.8
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.75
        }
      },
      "evidence": {
        "versionAnalysis": {
          "reason": "WinAppSDK 1.8 is the version that introduced split packages. The request is to target this version specifically.",
          "mentionedVersions": [
            "1.8"
          ],
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "Feature request to change SkiaSharp.Views.WinUI\u0027s NuGet dependency from the Microsoft.WindowsAppSDK metapackage to the narrower Microsoft.WindowsAppSDK.WinUI 1.8 package. The metapackage currently forces all downstream consumers (including MAUI) to pull in the entire WinAppSDK. Active discussion between dotMorten (requester, advocating for the change to unblock MAUI RC2) and jeromelaban (Uno Platform, cautioning about forcing version upgrades). Maintainer has not yet weighed in.",
        "keySignals": [
          {
            "text": "[FEATURE] Upgrade SkiaSharp.Views.WinUI to 1.8",
            "source": "title",
            "interpretation": "Feature request to bump WinUI dependency version"
          },
          {
            "text": "it no longer relies on the Microsoft.WindowsAppSDK metapackage that\u0027ll force you and any other library that depends on Skia (like .NET MAUI) to pull in the entire metapackage",
            "source": "body",
            "interpretation": "Core problem: metapackage dependency causes transitive bloat"
          },
          {
            "text": "1.8 upgrade is planned for RC2, but it can\u0027t be done right without this",
            "source": "comment",
            "interpretation": "MAUI RC2 is blocked on this change; creates urgency"
          },
          {
            "text": "requires all consumers to upgrade to the latest",
            "source": "comment",
            "interpretation": "Counter-argument: bumping minimum version may break existing consumers"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "This is a request to change package dependency targeting, not a bug or enhancement to existing drawing/rendering behavior. The feature (split packages) is new in WinAppSDK 1.8.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement implies improving existing behavior. This is about adopting a new packaging model."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The change targets SkiaSharp.Views.WinUI specifically \u2014 its NuGet package dependency declarations.",
            "alternatives": [
              {
                "value": "area/Build",
                "whyRejected": "While it involves NuGet packaging, the primary affected component is the Views.WinUI package."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "dotMorten explicitly states MAUI RC2 is blocked on this change. MAUI is a key downstream consumer.",
            "alternatives": [
              {
                "value": "partner/unoplatform",
                "whyRejected": "jeromelaban participates in discussion but Uno Platform is not requesting this change."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "Legitimate feature request with active community discussion. Labels are already correct. Maintainer needs to weigh in on the version bump tradeoff."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-WinUI",
            "expandedReason": "The request specifically targets SkiaSharp.Views.WinUI and its WinAppSDK dependency. The WinUI platform label was already applied to this issue.",
            "alternatives": [
              {
                "value": "os/Windows-Classic",
                "whyRejected": "This is about the WinUI/WinAppSDK package dependency, not classic Win32/WPF/WinForms."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "The metapackage dependency forces all downstream consumers (including MAUI) to pull in the entire WinAppSDK, creating transitive dependency compatibility issues.",
            "alternatives": [
              {
                "value": "tenet/reliability",
                "whyRejected": "No crashes or runtime failures are reported \u2014 this is purely about package dependency management and version compatibility."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "WinAppSDK 1.8 introduced split packages and MAUI RC2 is blocked on this change. The request targets current SDK versions and active ecosystem needs.",
            "alternatives": [
              {
                "value": "unlikely",
                "whyRejected": "The split packages in WinAppSDK 1.8 are a current feature and MAUI actively needs this change."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether bumping to WinAppSDK 1.8 minimum would break existing consumers on older WinAppSDK versions",
          "Whether maintainer considers the MAUI RC2 urgency sufficient justification for the version bump",
          "Impact on Uno Platform and other downstream consumers"
        ],
        "assumptions": [
          "WinAppSDK 1.8 has stable split packages available on NuGet",
          "The change would involve modifying the .csproj or .nuspec for SkiaSharp.Views.WinUI"
        ],
        "resolution": {
          "hypothesis": "Switching from the Microsoft.WindowsAppSDK metapackage to Microsoft.WindowsAppSDK.WinUI 1.8 would reduce transitive dependency bloat and unblock downstream consumers like MAUI from cleanly adopting WinAppSDK 1.8.",
          "proposals": [
            {
              "title": "Switch to Microsoft.WindowsAppSDK.WinUI 1.8",
              "description": "Replace the Microsoft.WindowsAppSDK metapackage reference with Microsoft.WindowsAppSDK.WinUI 1.8 in the SkiaSharp.Views.WinUI project. This directly addresses the request but raises the minimum WinAppSDK version.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Conditional package references by TFM",
              "description": "Use conditional PackageReference elements to target WinUI-only package on newer TFMs while keeping metapackage compatibility for older ones. More complex but avoids breaking existing consumers.",
              "confidence": 0.55,
              "effort": "medium"
            },
            {
              "title": "Document metapackage workaround",
              "description": "Document how downstream consumers can use PackageReference overrides to avoid pulling the full metapackage, without changing SkiaSharp itself. Preserves backward compatibility but doesn\u0027t fix the root cause.",
              "confidence": 0.4,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Switch to Microsoft.WindowsAppSDK.WinUI 1.8",
          "recommendedReason": "Simplest change, directly addresses the request, and aligns with the ecosystem direction. The version bump tradeoff is acceptable given WinAppSDK 1.8 is the current stable release."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Legitimate feature request with active community discussion and MAUI ecosystem impact. Labels are already correct. Maintainer decision needed on version bump tradeoff."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add compatibility tenet and MAUI partner labels",
            "reason": "Issue impacts dependency compatibility and explicitly mentions MAUI as blocked downstream consumer",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "tenet/compatibility",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3372"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3365,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ],
        "state": "open"
      },
      "summary": "libSkiaSharp.dll has hard link-time dependency on d3d12.dll causing crashes on Windows 10 systems without DX12",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/Direct3D",
            "confidence": 0.92
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "severity": "critical",
          "severityReason": "Hard crash at DLL load time with no managed-code workaround. Affects 0.1% of a 1 million user base (~1000 users). The crash occurs before any SkiaSharp API is called, making it impossible to catch or handle in application code.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "reproEvidence": {
          "relatedIssues": [
            3267
          ],
          "stepsToReproduce": [
            "Install SkiaSharp 3.116.0 or later in a Win32 application",
            "Deploy to a Windows 10 system that does not have d3d12.dll (systems without DX12 support or missing Windows updates)",
            "Launch the application \u2014 it crashes on native library load due to missing d3d12.dll dependency"
          ],
          "environmentDetails": "Windows 10 (not fully updated, lacking DX12 support). SkiaSharp 3.116.0. Legacy Win32 application. Sample of ~1 million installations with 0.1% crash rate."
        },
        "versionAnalysis": {
          "reason": "Issue is reported on version 3.116.0 and the D3D12 dependency is still present in the latest builds. The root cause (static linking of d3d12.dll) has not been addressed.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Reporter states last known good version is 2.88.9 and the issue appeared in 3.116.0. Related issue #3267 pinpoints the regression to when D3D12 support was added.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "This is a bug where libSkiaSharp.dll has a hard link-time dependency on d3d12.dll introduced when Direct3D 12 rendering support was added in SkiaSharp 3.x. Systems without DX12 (certain Windows 10 configurations lacking updates) crash on DLL load. Closely related to #3267 which reports the identical root cause on Windows 7.",
        "keySignals": [
          {
            "text": "There is a hard dependency on DX12 in the latest versions of SkiaSharp",
            "source": "body",
            "interpretation": "Reporter identifies the root cause as a static/link-time dependency on d3d12.dll rather than a dynamic/runtime load, pointing to a native build configuration issue."
          },
          {
            "text": "out of a sample of 1 million installations around 0.1% are crashing because their systems don\u0027t have DX12",
            "source": "body",
            "interpretation": "Quantified real-world impact: ~1000 affected users. This elevates severity to critical \u2014 it\u0027s a hard crash affecting a measurable production user base."
          },
          {
            "text": "porting one of our legacy Win32 apps to use SkiaSharp",
            "source": "body",
            "interpretation": "Confirms Windows-Classic platform (Win32/WPF/WinForms), not WinUI or UWP."
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9",
            "source": "body",
            "interpretation": "Confirms this is a regression from the 2.x to 3.x transition, when D3D12 support was added to the Skia build."
          },
          {
            "text": "While this is in reference to Windows 7, all of our crashes occur on Windows 10",
            "source": "comment 3",
            "interpretation": "Reporter distinguishes their issue from #3267 by noting it affects Windows 10, not just Win7. Same root cause but broader impact than originally thought."
          },
          {
            "text": "the common theme is that they\u0027re on systems that don\u0027t support DX12... and the resolution would be the same. So this is still a duplicate.",
            "source": "comment 4",
            "interpretation": "Community member confirms same root cause as #3267. While technically a duplicate, #3365 adds valuable scale data about Windows 10 impact."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The issue describes a hard crash caused by a static dependency on d3d12.dll in the native binary. This is clearly broken behavior \u2014 the library should gracefully handle missing DX12 support rather than failing to load entirely.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "Not requesting new functionality \u2014 reporting a crash in existing functionality."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The issue is in the native binary build configuration \u2014 d3d12.dll is a link-time import in libSkiaSharp.dll. This is a native build/linking issue, not a managed code or views issue.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The core managed library is not the problem \u2014 it\u0027s the native binary\u0027s link-time dependency."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/Direct3D",
            "expandedReason": "The d3d12.dll dependency exists because Skia added Direct3D 12 rendering backend support. The fix involves making this backend\u0027s dependency optional at the native level."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Reporter explicitly describes a legacy Win32 app on Windows 10. The os/Windows-Classic label was already applied by the automated triage."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "Reliability: hard crashes on systems without DX12 support with quantified 0.1% of 1M impact. Compatibility: regression from 2.x to 3.x breaks backward compatibility with Windows 10 systems that lack DX12 drivers."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "critical",
            "expandedReason": "Hard crash at DLL load time with no managed-code workaround. Quantified impact of ~1000 affected users (0.1% of 1M). The crash prevents any SkiaSharp functionality from being used, and there is no way to catch or handle it in application code.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "The inability to work around the crash in managed code and the quantified production impact elevate this beyond \u0027high\u0027 to \u0027critical\u0027."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "While closely related to #3267, the fix requires engineering work in the Skia build configuration to change d3d12.dll from a static import to a dynamic load. This hasn\u0027t been addressed yet and the issue remains open.",
            "alternatives": [
              {
                "value": "close-as-duplicate",
                "whyRejected": "While the root cause is identical to #3267, this issue adds significant value with real-world scale data (1M installations, 0.1% affected on Win10). A community member suggested closing as duplicate, but the additional context is worth preserving."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter states last known good version is 2.88.9 and the crash appeared in 3.116.0, coinciding with when D3D12 rendering support was added to the Skia build."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The D3D12 static link-time dependency has not been changed to dynamic loading in any subsequent release. The root cause persists in current builds.",
            "alternatives": [
              {
                "value": "unlikely",
                "whyRejected": "No fix or workaround has been applied \u2014 systems without d3d12.dll will still crash on current SkiaSharp 3.x versions."
              }
            ]
          }
        ],
        "uncertainties": [
          "Exact Windows 10 build numbers affected \u2014 likely systems missing specific Windows Updates that provide d3d12.dll",
          "Whether the Skia upstream has already addressed this with delayed/dynamic loading of D3D12, or if this requires a SkiaSharp-specific build change",
          "Whether the version discrepancy matters \u2014 reporter says 3.116.0 but #3267 pinpoints 3.119.0-preview.1.2 as the introduction point"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s version 3.116.0 is correct and that D3D12 support may have been present since that version",
          "Assumed targetFramework is net8.0-windows based on \u0027legacy Win32 app\u0027 and modern SkiaSharp 3.x usage, though reporter did not explicitly state this"
        ],
        "resolution": {
          "hypothesis": "The Skia build configuration statically imports d3d12.dll, causing the Windows loader to fail when that DLL is absent. The fix requires changing the D3D12 dependency from a load-time import to a runtime dynamic load (LoadLibrary/GetProcAddress or /DELAYLOAD pattern), allowing Skia to gracefully fall back when D3D12 is unavailable.",
          "proposals": [
            {
              "title": "Dynamic-load d3d12.dll in Skia build",
              "description": "Modify the Skia GN build to use delayed/dynamic loading of d3d12.dll instead of static imports. This is the proper fix \u2014 Skia should probe for DX12 availability at runtime and fall back gracefully. Involves adding /DELAYLOAD:d3d12.dll linker flag or using LoadLibrary/GetProcAddress pattern.",
              "confidence": 0.85,
              "effort": "medium"
            },
            {
              "title": "Disable D3D12 backend in SkiaSharp build",
              "description": "Set skia_use_direct3d=false in the GN build args for Windows, removing the d3d12.dll dependency entirely. Simple change but removes D3D12 rendering capability for all users.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Ship separate NativeAssets packages with and without D3D12",
              "description": "Provide two Windows native asset variants \u2014 one with D3D12 support and one without \u2014 allowing users to choose based on their target environment. Does not fix the root cause for the default package.",
              "confidence": 0.6,
              "effort": "high"
            }
          ],
          "recommendedProposal": "Dynamic-load d3d12.dll in Skia build",
          "recommendedReason": "Addresses root cause without removing functionality. Delay-loading d3d12.dll lets the library probe for DX12 at runtime and fall back gracefully, which is exactly what the reporter expects. Preserves D3D12 acceleration where available while being safe on systems without it."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The fix requires engineering work in the Skia build configuration to change d3d12.dll from a static import to a dynamic load. Closely related to #3267 but provides additional Windows 10 scale data."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add backend/Direct3D and tenet/compatibility labels",
            "reason": "Classification identifies Direct3D backend involvement and compatibility regression from 2.x to 3.x. These labels are not yet on the issue.",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "backend/Direct3D",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "related-1",
            "type": "link-related",
            "risk": "low",
            "description": "Link to related issue #3267 (same d3d12.dll root cause on Win7)",
            "reason": "Issue #3267 reports the identical root cause on Windows 7. Linking preserves cross-reference for the engineering fix.",
            "confidence": 0.95,
            "payload": {
              "relatedIssues": [
                3267
              ],
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging the issue and linking to #3267",
            "reason": "Reporter asked for updates and the issue has been open without maintainer response. A response acknowledging the problem and linking to the existing tracking issue is appropriate.",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed report and the deployment scale data \u2014 knowing this affects ~0.1% of 1M installations on Windows 10 specifically is valuable context.\n\nThis is the same root cause as #3267: \u0060libSkiaSharp.dll\u0060 has a static (link-time) dependency on \u0060d3d12.dll\u0060 since D3D12 rendering support was added in SkiaSharp 3.x. On systems where \u0060d3d12.dll\u0060 isn\u0027t present \u2014 whether Win7 or Windows 10 without the necessary updates \u2014 the DLL fails to load entirely.\n\nThe fix would need to happen at the Skia build level, changing the D3D12 dependency from a static import to a runtime \u0060LoadLibrary\u0060/\u0060GetProcAddress\u0060 pattern so Skia can gracefully fall back when D3D12 isn\u0027t available.\n\nLinking this to #3267 as the canonical tracking issue since the resolution would be the same. Your data about Windows 10 impact is a helpful addition to that issue.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3365-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3365"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3357,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-09-04T20:00:00Z",
        "currentLabels": [
          "area/Docs"
        ],
        "state": "open"
      },
      "summary": "Maintainer request to migrate XML API documentation from docs folder into inline C# source code triple-slash comments",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.95
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.95
        }
      },
      "evidence": {},
      "analysis": {
        "summary": "This is a documentation migration task filed by the maintainer (mattleibow). The issue requests migrating API documentation from a separate docs folder into inline C# source code comments. It references a migration guide and checklist, with specific rules about committing each type separately.",
        "keySignals": [
          {
            "text": "Can you help migrate my docs from the docs folder into the c# source",
            "source": "body",
            "interpretation": "Explicit documentation migration request \u2014 not a bug, question, or feature"
          },
          {
            "text": "There is a guide here: ~/API.Docs.Migration.Guide.md",
            "source": "body",
            "interpretation": "Structured migration task with existing tooling and guidelines"
          },
          {
            "text": "Each type should be migrated and commited separately",
            "source": "body",
            "interpretation": "Operational constraint for the migration process, indicates incremental work"
          },
          {
            "text": "Assigned to Copilot bot",
            "source": "labels",
            "interpretation": "This is an automation/agent task, not a user-reported issue"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/documentation",
            "expandedReason": "The issue is entirely about migrating documentation from one location to another. No broken behavior, no new functionality, no question being asked. The maintainer is requesting a docs migration task.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Not improving existing functionality \u2014 purely a documentation format/location change."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "No new capability is being requested. The docs already exist and need to be moved."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/Docs",
            "expandedReason": "The issue is about documentation files and their migration into source code. The area/Docs label is already applied and is the correct classification.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "While the target is C# source files in SkiaSharp, the work itself is documentation migration, not code changes."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is an active task assigned to the Copilot bot. The maintainer filed it as a work item to be executed. It should remain open until the migration is complete."
          }
        ],
        "uncertainties": [
          "Whether the referenced migration guide and checklist files exist and are up to date",
          "How many types remain to be migrated from the checklist"
        ],
        "assumptions": [
          "Assumed this is a legitimate maintainer-filed work item since the author is mattleibow (project maintainer)",
          "Assumed the migration guide contains sufficient instructions for the assigned bot to execute"
        ],
        "resolution": {
          "hypothesis": "The maintainer wants all API documentation migrated from standalone docs files into inline triple-slash XML comments in the C# source, with each type committed separately for review purposes.",
          "proposals": [
            {
              "title": "Execute migration per checklist",
              "description": "Follow the API.Docs.Migration.Guide.md and API.Docs.Migration.Checklist.md to migrate each type one at a time, committing separately. This is the approach requested in the issue.",
              "confidence": 0.95,
              "effort": "high"
            },
            {
              "title": "Batch migration with squash commits",
              "description": "Migrate all types at once and use git interactive rebase to create per-type commits. Faster execution but riskier if conflicts arise.",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Execute migration per checklist",
          "recommendedReason": "The maintainer explicitly requested one-type-at-a-time commits. Following the stated process ensures reviewability and matches the team\u0027s workflow."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Active work item assigned to Copilot bot. Migration task is in progress or pending execution."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add type/documentation label to classify the issue type",
            "reason": "Issue is a documentation migration task. area/Docs is already applied; adding the type label completes classification.",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [
                "type/documentation"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3357"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3346,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-09-08T00:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ],
        "state": "closed"
      },
      "summary": "MAUI app crashes on Windows ARM64 when published as MSIX; installing VC\u002B\u002B Redistributable resolves it",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.85
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "severity": "medium",
          "severityReason": "Crash on published builds is severe (app won\u0027t start), but a workaround exists (install VC\u002B\u002B Redistributable) and the affected audience is narrow (ARM64 Windows published deployments only).",
          "hasWorkaround": true,
          "workaroundSummary": "Install Microsoft Visual C\u002B\u002B Redistributable on the target ARM64 Windows machine before running the published app.",
          "targetFrameworks": [
            "net9.0-windows10.0.19041.0"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/riccardomartins/ArmDemoTryout",
              "description": ".NET MAUI app demonstrating the ARM64 Windows crash. Uses SkiaSharp.Views.Maui.Controls 3.119.0 and Svg.Skia 3.0.6 with MSIX packaging."
            }
          ],
          "relatedIssues": [
            3155,
            136
          ],
          "stepsToReproduce": [
            "Clone https://github.com/riccardomartins/ArmDemoTryout",
            "Open in Visual Studio on a Windows ARM64 machine",
            "Build and run in Debug or Release mode \u2014 works fine",
            "Publish the app as MSIX for Windows ARM64",
            "Run the published executable on a fresh ARM64 Windows machine without VC\u002B\u002B Redistributable installed",
            "App starts and crashes immediately"
          ],
          "codeSnippets": [
            {
              "code": "\u003CPackageReference Include=\u0022SkiaSharp.Views.Maui.Controls\u0022 Version=\u00223.119.0\u0022 /\u003E\n\u003CPackageReference Include=\u0022Svg.Skia\u0022 Version=\u00223.0.6\u0022 /\u003E",
              "language": "xml",
              "context": "Project dependencies from the repro csproj. Uses MAUI with MSIX packaging (WindowsPackageType=MSIX)."
            }
          ],
          "environmentDetails": "Windows 10 and 11 ARM64, Visual Studio (Windows), SkiaSharp 3.116.0 (reported) / 3.119.0 (in repro csproj), .NET 9, MSIX packaging"
        },
        "versionAnalysis": {
          "reason": "Issue reported against 3.116.0 but repro project references 3.119.0, indicating it persists across recent versions. The VC\u002B\u002B Redistributable dependency on ARM64 is a build configuration issue that likely still exists.",
          "mentionedVersions": [
            "3.116.0",
            "3.119.0"
          ],
          "currentRelevance": "likely"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.55,
          "reason": "Maintainer mattleibow asked if GPU rendering was being used, noting \u0027I am trying to release a fix for that\u0027. However, the repro uses SKCanvasView (CPU rendering), so the GPU fix may not fully address this issue. The VC\u002B\u002B Redistributable dependency suggests a native build configuration issue that may require separate attention."
        }
      },
      "analysis": {
        "summary": "A .NET MAUI app using SkiaSharp crashes on Windows ARM64 when published as MSIX, but works in Debug/Release modes. The reporter discovered that installing VC\u002B\u002B Redistributable resolves the crash, indicating the native binaries have a dynamic C\u002B\u002B runtime dependency not satisfied on fresh ARM64 deployments. The repro uses CPU rendering (SKCanvasView), so the maintainer\u0027s in-progress GPU fix may not fully address this.",
        "keySignals": [
          {
            "text": "installing Microsoft Visual C\u002B\u002B Redistributable that app works correctly in a fresh arm64 windows",
            "source": "comment 2",
            "interpretation": "The native binary (libSkiaSharp.dll or ANGLE libraries) dynamically links to the C\u002B\u002B runtime rather than statically linking it. This is the root cause of the crash on fresh ARM64 systems."
          },
          {
            "text": "runs correctly in Debug and Release modes on Windows ARM64, but when creating a Publish build for Windows ARM64, the app starts but crashes immediately",
            "source": "body",
            "interpretation": "Debug/Release work because Visual Studio installs VC\u002B\u002B runtime. Published MSIX on a fresh system lacks it. The difference is deployment context, not code."
          },
          {
            "text": "Were you using the GPU rendering? If so, I am trying to release a fix for that.",
            "source": "comment 3",
            "interpretation": "Maintainer is aware of a related ARM64 GPU issue and has a fix in progress. However, the repro uses SKCanvasView (CPU), so the GPU fix may not fully resolve this."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes an app crash on published ARM64 builds. This is clearly broken behavior \u2014 a published app should not crash on a supported platform. Debug/Release builds work fine, confirming it\u0027s a deployment issue, not user error.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting a crash with clear expected vs actual behavior and a repro project."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The crash is resolved by installing VC\u002B\u002B Redistributable, which points to the native binary build configuration. Either libSkiaSharp.dll ARM64 or the ANGLE libraries from NativeAssets.WinUI are dynamically linking the C\u002B\u002B runtime instead of statically linking it. The skia-patterns.md reference confirms this as a known pattern.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "While the repro uses MAUI, the root cause is in the native binary packaging, not the managed MAUI view layer."
              },
              {
                "value": "area/Build",
                "whyRejected": "Build area would suggest a build system issue, but this is specifically about native library linking configuration for ARM64."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash preventing the app from starting is severe, but a straightforward workaround exists (install VC\u002B\u002B Redistributable) and the affected audience is narrow (ARM64 Windows published deployments only).",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "A workaround exists (VC\u002B\u002B Redistributable installation), which lowers severity from high to medium."
              },
              {
                "value": "low",
                "whyRejected": "An app crash preventing all functionality is more than cosmetic/minor, even with a workaround."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "The repro is a MAUI app with MSIX packaging. The ANGLE libraries from NativeAssets.WinUI are part of the MAUI/WinUI rendering pipeline and may contribute to the VC\u002B\u002B dependency."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The VC\u002B\u002B Redistributable dependency on ARM64 needs investigation. Is it libSkiaSharp.dll or the ANGLE libraries? Was static linking intentionally omitted for ARM64? Static CRT linking was fixed for x86/x64 in issue #136 but may not cover ARM64.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "The reporter provided a full repro project and identified the root cause (VC\u002B\u002B Redistributable). There\u0027s enough info to investigate without additional reporter input."
              },
              {
                "value": "close-as-fixed",
                "whyRejected": "No fix has been released. The maintainer mentioned a fix in progress but hasn\u0027t confirmed it addresses this specific issue."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "The crash occurs on Windows ARM64 when deploying a MAUI app as MSIX. The label reflects the Windows desktop deployment target where the VC\u002B\u002B runtime dependency manifests.",
            "alternatives": [
              {
                "value": "os/Windows-WinUI",
                "whyRejected": "While MAUI uses WinUI under the hood, the deployment issue is about the native binary on Windows desktop ARM64, not WinUI-specific behavior."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "The app crashes immediately on launch when published to ARM64 Windows without VC\u002B\u002B Redistributable. A hard crash preventing any app functionality is a core reliability issue.",
            "alternatives": [
              {
                "value": "tenet/compatibility",
                "whyRejected": "While there is a platform-specific aspect (ARM64 vs x64), the primary concern is that the published app crashes rather than a cross-version compatibility gap."
              }
            ]
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "false",
            "expandedReason": "The maintainer mentioned an in-progress GPU fix, but the repro uses CPU rendering (SKCanvasView). The VC\u002B\u002B dependency suggests a native build config issue requiring separate attention."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Reported on 3.116.0 and reproduced with 3.119.0, indicating the ARM64 VC\u002B\u002B runtime dependency persists across recent versions and likely remains unfixed.",
            "alternatives": [
              {
                "value": "unlikely",
                "whyRejected": "No evidence the static CRT linking was applied to ARM64 builds, so the issue likely persists in current releases."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the crash is in libSkiaSharp.dll or the ANGLE libraries (libEGL.dll/libGLESv2.dll) from NativeAssets.WinUI \u2014 both could require VC\u002B\u002B runtime",
          "Whether the maintainer\u0027s in-progress GPU fix also addresses the VC\u002B\u002B runtime linking for CPU rendering scenarios",
          "The reporter says version 3.116.0 but the repro csproj shows 3.119.0 \u2014 unclear if the version discrepancy matters"
        ],
        "assumptions": [
          "Assumed the SKCanvasView usage in the repro code represents the reporter\u0027s actual usage pattern, making this a CPU rendering issue not a GPU one",
          "Assumed the ARM64 native build configuration is the root cause since the same app works in Debug/Release (where VC\u002B\u002B runtime is available from VS)"
        ],
        "resolution": {
          "hypothesis": "The ARM64 Windows build of libSkiaSharp.dll (or the ANGLE libraries from NativeAssets.WinUI) dynamically links the C\u002B\u002B runtime instead of statically linking it. When deployed via MSIX to a fresh ARM64 system, the C\u002B\u002B runtime isn\u0027t present, causing an immediate crash. Debug/Release from VS works because VS installs the VC\u002B\u002B runtime.",
          "proposals": [
            {
              "title": "Statically link C\u002B\u002B runtime for ARM64 Windows builds",
              "description": "Update the native build configuration to statically link the C\u002B\u002B runtime (/MT instead of /MD) for the ARM64 Windows target, matching what was done for x86/x64 in issue #136 (v1.68.0). This eliminates the dependency for all users.",
              "confidence": 0.8,
              "effort": "medium"
            },
            {
              "title": "Include VC\u002B\u002B Redistributable in MSIX package",
              "description": "Configure the MSIX packaging to include the VC\u002B\u002B Redistributable merge modules or declare a dependency on the VC\u002B\u002B runtime framework package. Doesn\u0027t require rebuilding native libraries but pushes the fix to app developers.",
              "confidence": 0.6,
              "effort": "low"
            },
            {
              "title": "Document VC\u002B\u002B Redistributable requirement for ARM64",
              "description": "Document that ARM64 Windows deployments require the VC\u002B\u002B Redistributable, and recommend including it in deployment scripts or installation prerequisites. Immediate workaround for affected users.",
              "confidence": 0.9,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Statically link C\u002B\u002B runtime for ARM64 Windows builds",
          "recommendedReason": "This is the proper fix that eliminates the dependency for all users. It\u0027s consistent with how x86/x64 builds were fixed in issue #136 and ensures ARM64 published apps work without additional prerequisites."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The VC\u002B\u002B Redistributable dependency on ARM64 Windows suggests the native library is not statically linking the C\u002B\u002B runtime for ARM64 builds. This was fixed for x86/x64 in issue #136 but may not have been applied to ARM64. The repro uses CPU rendering, so the maintainer\u0027s GPU fix may not fully address this."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/libSkiaSharp.native and partner/maui labels",
            "reason": "Crash caused by missing VC\u002B\u002B Redistributable is a native library deployment issue. Repro is a MAUI app with MSIX packaging.",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "area/libSkiaSharp.native",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "related-1",
            "type": "link-related",
            "risk": "low",
            "description": "Cross-reference related ARM64 and CRT linking issues",
            "reason": "Issue #3155 is a related ARM64 Windows GPU issue. Issue #136 is where static CRT linking was implemented for x86/x64 \u2014 the same fix may need to be applied for ARM64.",
            "confidence": 0.8,
            "payload": {
              "relatedIssues": [
                3155,
                136
              ],
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge workaround and explain the ARM64 VC\u002B\u002B dependency",
            "reason": "Reporter found a workaround but asked if it\u0027s expected. The maintainer\u0027s GPU question is also unanswered. A response would clarify the situation and provide context.",
            "confidence": 0.75,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for tracking that down \u2014 the VC\u002B\u002B Redistributable dependency is a really useful finding.\n\nTo answer your question: ideally, no, you shouldn\u0027t need to install the VC\u002B\u002B Redistributable separately. The native libraries should either statically link the C\u002B\u002B runtime or the MSIX package should include it.\n\nThis looks like it could be specific to the ARM64 build of the native libraries \u2014 the x64 builds have had static C\u002B\u002B runtime linking since v1.68.0, but the ARM64 build may not have the same configuration.\n\nLooking at your repro code, it appears you\u0027re using \u0060SKCanvasView\u0060 (CPU rendering). Would you be able to confirm? That would help clarify whether the GPU rendering fix @mattleibow mentioned would also cover this scenario.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3346-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3346"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 3188,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T22:25:00Z",
        "currentLabels": [
          "type/bug"
        ],
        "state": "open"
      },
      "summary": "DrawVertices outputs black triangle instead of colored gradient in SkiaSharp 3.x \u2014 upstream Skia behavior change requires a shader on the paint when using vertex colors with SKBlendMode.Modulate",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.88
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "severity": "medium",
          "severityReason": "No crash but produces visually wrong output (black instead of colored vertices). Simple workaround exists. The SkiaSharp sample itself has the same issue, suggesting documentation/migration guidance is needed.",
          "hasWorkaround": true,
          "workaroundSummary": "Set a white shader on the paint: \u0060paint.Shader = SKShader.CreateColor(SKColors.White)\u0060. This gives the same visual result as SkiaSharp 2.x without a shader."
        },
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/afa656d4-1966-496c-be0f-50d3d325f554",
              "context": "Expected: gradient triangle (v2.88.9)"
            },
            {
              "url": "https://github.com/user-attachments/assets/5a9f1421-92d4-49f6-8f65-e7fb990cb82f",
              "context": "Actual: black triangle (v3.116.1)"
            }
          ],
          "relatedIssues": [
            351,
            1687,
            3319
          ],
          "codeSnippets": [
            {
              "code": "var paint = new SKPaint { IsAntialias = true };\nvar vertices = new[] { new SKPoint(110, 20), new SKPoint(160, 200), new SKPoint(10, 200) };\nvar colors = new[] { SKColors.Red, SKColors.Green, SKColors.Blue };\nsurface.Canvas.DrawVertices(SKVertexMode.Triangles, vertices, colors, paint);",
              "language": "csharp",
              "context": "Minimal reproduction from reporter \u2014 identical to DrawVerticesSample.cs in SkiaSharp samples"
            }
          ],
          "environmentDetails": "Windows 11, .NET 8, Visual Studio, SkiaSharp 3.116.1"
        },
        "versionAnalysis": {
          "reason": "The behavior change is in upstream Skia, not SkiaSharp C# code. SKCanvas.DrawVertices uses SKBlendMode.Modulate by default, which multiplies vertex colors by the paint color/shader. Without a shader, the paint\u0027s default black color causes all vertex colors to be black. This was different in the Skia version used by SkiaSharp 2.88.x.",
          "mentionedVersions": [
            "3.116.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "migrationPath": "Set paint.Shader = SKShader.CreateColor(SKColors.White) before calling DrawVertices to restore v2 behavior."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.82,
          "reason": "The behavior changed between SkiaSharp 2.88.9 (Skia m88) and 3.116.x (newer Skia milestone). In the older Skia, drawVertices with vertex colors and no shader produced the expected gradient. In the newer Skia, the blend mode strictly applies the paint color (black by default) against vertex colors via Modulate, producing black. This is an upstream Skia behavioral change, not a SkiaSharp wrapper bug.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "This is an upstream Skia behavioral change exposed in SkiaSharp 3.x. The DrawVertices overloads in SKCanvas.cs use SKBlendMode.Modulate by default (line 915). In Modulate mode, vertex colors are multiplied by the paint\u0027s source \u2014 either a shader or the opaque paint color. Without a shader, the default paint color is black (0,0,0), so Modulate produces black regardless of vertex colors. A community member already provided the correct workaround: set a white shader on the paint.",
        "keySignals": [
          {
            "text": "Passing in a color array works fine in v2.88.9 but after updating to 3.116.1 the output is simply black",
            "source": "body",
            "interpretation": "Classic v2\u2192v3 behavioral regression. The code didn\u0027t change \u2014 the underlying Skia engine changed how it handles vertex colors without a shader."
          },
          {
            "text": "Code copied from Samples",
            "source": "body",
            "interpretation": "The reporter is using the exact same code as DrawVerticesSample.cs \u2014 the sample itself is broken in v3, confirming this is a SkiaSharp-side issue (at minimum a docs/sample problem)."
          },
          {
            "text": "paint.Shader = SKShader.CreateColor(SKColors.White)",
            "source": "comment-1",
            "interpretation": "Community workaround by molesmoke. Setting a white shader means Modulate multiplies vertex colors by white (1,1,1), preserving the original vertex colors."
          },
          {
            "text": "https://api.skia.org/classSkCanvas.html",
            "source": "comment-1",
            "interpretation": "Community member linked upstream Skia docs confirming the behavior is intentional in newer Skia \u2014 vertex colors blend with shader or \u0027opaque paint color\u0027."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "While this is technically an upstream Skia behavioral change, it manifests as a breaking change in SkiaSharp 3.x that produces incorrect visual output from code that worked in 2.x. The SkiaSharp sample itself is broken. This warrants bug classification because: (1) existing code silently produces wrong output, (2) no migration guidance was provided, (3) the SkiaSharp convenience overloads hardcode SKBlendMode.Modulate without documentation of the shader requirement.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Could argue this is \u0027expected behavior\u0027 per upstream Skia, but the silent breakage of existing code without migration guidance makes it a bug from the user\u0027s perspective."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The DrawVertices methods and their default blend mode are in core SkiaSharp (SKCanvas.cs). The upstream Skia behavior change surfaces through SkiaSharp\u0027s convenience overloads."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Visual output is wrong (black instead of gradient), but no crash or data loss. Workaround is simple (one line) and already provided by a community member. The severity is elevated slightly because the breakage is silent \u2014 no error or warning, just wrong output."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Reporter tested on Windows 11. The issue is platform-independent (it\u0027s in the blend mode logic), but only Windows was explicitly tested."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "This is a v2\u2192v3 compatibility break. Existing code produces different (wrong) output after upgrading, with no compile-time or runtime warning."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Working v2 code produces black output in v3. The regression is in upstream Skia\u0027s handling of drawVertices blend mode with no shader, exposed through SkiaSharp\u0027s unchanged wrapper code."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The behavior is inherent to the Skia version in SkiaSharp 3.x and will persist. Workaround or convenience API change needed."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "The SkiaSharp sample itself is broken and the convenience overloads may need updating (e.g., default to SKBlendMode.Dst when colors are provided and no shader exists, or document the shader requirement). Workaround exists but the API should be improved or documented."
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp should change the default blend mode in the convenience overloads (e.g., use Dst instead of Modulate when no shader is present) or just document the requirement",
          "Whether this affects all platforms or just CPU raster surfaces (reporter only tested on Windows)",
          "Whether SkiaSharp 3.x migration guide already mentions this change (none found)"
        ],
        "assumptions": [
          "Assumed the upstream Skia behavior change is intentional based on the Skia API docs and community member\u0027s analysis",
          "Assumed the default SKPaint color is black (0xFF000000) based on Skia\u0027s default initialization"
        ],
        "resolution": {
          "hypothesis": "Upstream Skia changed how drawVertices blends vertex colors with the paint source. Without a shader, the paint\u0027s default black color is used as the blend source with Modulate mode, producing black output. Setting a white shader restores the v2 behavior.",
          "proposals": [
            {
              "title": "Set a white shader on the paint (workaround)",
              "description": "Add \u0060paint.Shader = SKShader.CreateColor(SKColors.White)\u0060 before calling DrawVertices. This makes the Modulate blend multiply vertex colors by white (1,1,1), preserving them. This is the workaround suggested by community member molesmoke.",
              "confidence": 0.92,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "var paint = new SKPaint\n{\n    IsAntialias = true,\n    Shader = SKShader.CreateColor(SKColors.White)\n};\n\nvar vertices = new[] { new SKPoint(110, 20), new SKPoint(160, 200), new SKPoint(10, 200) };\nvar colors = new[] { SKColors.Red, SKColors.Green, SKColors.Blue };\n\ncanvas.DrawVertices(SKVertexMode.Triangles, vertices, colors, paint);",
              "validated": "yes"
            },
            {
              "title": "Update convenience overloads to use SKBlendMode.Dst",
              "description": "Change the default blend mode in the convenience DrawVertices overloads from Modulate to Dst when vertex colors are provided. Dst uses only the destination (vertex colors) and ignores the paint color. This would restore v2 visual behavior without requiring users to change their code.",
              "confidence": 0.55,
              "effort": "low",
              "category": "fix"
            },
            {
              "title": "Update sample and add migration docs",
              "description": "Fix DrawVerticesSample.cs to include a shader on the paint, and add a note to SkiaSharp 3.x migration guide about the DrawVertices behavior change.",
              "confidence": 0.85,
              "effort": "low",
              "category": "fix"
            }
          ],
          "recommendedProposal": "Set a white shader on the paint (workaround)",
          "recommendedReason": "Immediate fix for users. The convenience overload change needs design discussion. The sample/docs fix should also happen regardless."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "lines": "912-916",
            "relevance": "DrawVertices(SKVertexMode, SKPoint[], SKColor[], SKPaint) creates SKVertices.CreateCopy then calls DrawVertices with SKBlendMode.Modulate. The Modulate blend mode multiplies vertex colors by paint source. Without a shader, paint source = paint color (black by default), so result is black."
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "lines": "936-943",
            "relevance": "The core DrawVertices overload passes blend mode directly to sk_canvas_draw_vertices. No SkiaSharp-level transformation of colors \u2014 the behavior change is purely in native Skia\u0027s handling of the blend."
          },
          {
            "file": "samples/Gallery/Shared/Samples/DrawVerticesSample.cs",
            "lines": "19-31",
            "relevance": "The official SkiaSharp sample uses identical code to the reporter \u2014 no shader set on paint. This sample is broken in v3 and needs updating, confirming this is a known gap."
          },
          {
            "file": "externals/skia/include/core/SkCanvas.h",
            "lines": "1953-1975",
            "relevance": "Upstream Skia docs state: mode \u0027combines vertices colors with SkShader if present or SkPaint opaque color if not\u0027. This clarifies the new behavior \u2014 without a shader, the paint\u0027s opaque color (default black) is used in the blend."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.8,
          "reason": "Real behavioral regression with a simple workaround. Keep open to track the sample fix and potential convenience API improvement. The workaround is already provided by a community member."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply area, platform, and compatibility labels",
            "reason": "Matches classification \u2014 core SkiaSharp behavioral change on Windows, v2\u2192v3 compatibility issue",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "os/Windows-Classic",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the regression, confirm the workaround, and explain the upstream Skia change",
            "reason": "Reporter needs confirmation and context for the behavior change",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "workaround",
              "draftBody": "Thanks for the clear reproduction \u2014 and thanks to @molesmoke for the workaround.\n\nThis is a behavioral change in the upstream Skia engine that SkiaSharp 3.x is built on. In the newer Skia, \u0060drawVertices\u0060 with \u0060Modulate\u0060 blend mode strictly blends vertex colors with the paint\u0027s source \u2014 either a shader, or the paint\u0027s opaque color. Without a shader, the default paint color is black, so \u0060Modulate\u0060 (multiply) produces black regardless of vertex colors.\n\nThe workaround @molesmoke posted is correct \u2014 setting a white shader makes the multiply a no-op on the vertex colors:\n\n\u0060\u0060\u0060csharp\nvar paint = new SKPaint\n{\n    IsAntialias = true,\n    Shader = SKShader.CreateColor(SKColors.White)\n};\n\u0060\u0060\u0060\n\nOur own \u0060DrawVerticesSample.cs\u0060 has the same issue, so we\u0027ll need to update that too. We\u0027ll also look at whether the convenience overloads should default to a different blend mode when no shader is set.\n\nAs a best practice, wrap \u0060SKPaint\u0060 in a \u0060using\u0060 statement to ensure proper disposal.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3188-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3188"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 3175,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T22:12:00Z",
        "currentLabels": [
          "type/bug"
        ],
        "state": "open"
      },
      "summary": "SKBitmap.Decode returns incomplete/corrupt image when reading from Azure Blob stream due to single-call Stream.Read in SKManagedStream \u2014 duplicate of #1962",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Linux",
            "confidence": 0.9
          },
          {
            "value": "os/Windows-Classic",
            "confidence": 0.9
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.92
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Image decoding produces corrupt/incomplete output but doesn\u0027t crash. The reporter has a working workaround (MemoryStream copy). Affects network/chunked streams only.",
          "hasWorkaround": true,
          "workaroundSummary": "Copy the Azure Blob stream to a MemoryStream before calling SKBitmap.Decode. The reporter already discovered this workaround independently."
        },
        "reproEvidence": {
          "relatedIssues": [
            1962,
            2514,
            2249,
            1985,
            335
          ],
          "codeSnippets": [
            {
              "code": "await using var image = await blobStorage.GetBlob(blobName, cancellationToken);\nawait using MemoryStream memoryStream = new();\nawait image.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var originalImage = SKBitmap.Decode(memoryStream);",
              "language": "csharp",
              "context": "body"
            }
          ],
          "environmentDetails": "Azure Blob Storage stream with 4MB default chunk size. Visual Studio on Windows. Targets Linux and Windows."
        },
        "versionAnalysis": {
          "reason": "The root cause \u2014 a single stream.Read() call in SKManagedStream.OnReadManagedStream that doesn\u0027t loop to fill the buffer \u2014 has been present since PR #1510 (SkiaSharp 2.80.3) and remains unfixed in 3.116.x. The reporter\u0027s claim that 2.88.9 was \u0027last known good\u0027 is likely inaccurate; the regression was introduced in 2.80.3 per #1962.",
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "PR #1510 (commit 61b71d6e4893) replaced BinaryReader.ReadBytes() \u2014 which loops internally until all requested bytes are read or EOF \u2014 with a single stream.Read() call that may return fewer bytes than requested per the .NET Stream contract.",
          "workedInVersion": "2.80.2",
          "brokeInVersion": "2.80.3"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "Inspected SKManagedStream.OnReadManagedStream at line 99 of binding/SkiaSharp/SKManagedStream.cs \u2014 still uses a single stream.Read() call without a read loop. The bug remains in current main branch."
        }
      },
      "analysis": {
        "summary": "This is a duplicate of #1962 (and related to #2514, #2249, #1985, #335). The root cause is in SKManagedStream.OnReadManagedStream which calls stream.Read() once without looping. Per the .NET Stream.Read contract, a single call may return fewer bytes than requested even when more data is available (e.g., Azure Blob streams deliver data in chunks). Skia\u0027s native code interprets the short read as a signal that no more data is available, causing incomplete image decoding. The reporter\u0027s workaround of copying to MemoryStream first is correct \u2014 MemoryStream.Read always returns the full requested amount when data is available.",
        "keySignals": [
          {
            "text": "When png is larger than 4mb it looks like image creates only for first 4mb, but image size is correct",
            "source": "body",
            "interpretation": "Azure Blob default chunk size is 4MB. stream.Read returns one chunk, Skia treats short read as EOF, so only the first 4MB of pixel data is decoded."
          },
          {
            "text": "When I\u0027m copying blob stream into memory stream it works correctly",
            "source": "body",
            "interpretation": "MemoryStream.Read returns all requested bytes from its internal buffer, so the single-read issue doesn\u0027t manifest \u2014 confirms root cause is partial stream reads."
          },
          {
            "text": "Even if I change default size of stream chunk for example into 50mb png/bmp images belove 50mb downloads correctly",
            "source": "body",
            "interpretation": "Increasing Azure Blob stream buffer size makes a single Read return all bytes, further confirming the single-call Read as root cause."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "body",
            "interpretation": "Likely inaccurate \u2014 regression was introduced in 2.80.3 per #1962. Reporter may not have tested with chunked streams on earlier versions."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter describes incorrect behavior \u2014 images decoded from Azure Blob streams are incomplete/corrupt while the same images decode correctly from MemoryStream. This is caused by a known code defect in SKManagedStream.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something. Reporting a reproducible defect with clear root cause."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The bug is in SKManagedStream.OnReadManagedStream in the core SkiaSharp binding. Not in Views or any other sub-package."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Produces corrupt output but doesn\u0027t crash. The workaround (MemoryStream copy) is simple and the reporter already found it. However, it\u0027s a correctness bug that affects many users with network/cloud streams."
          },
          {
            "field": "platforms",
            "chosen": "os/Linux, os/Windows-Classic",
            "expandedReason": "Reporter lists both Linux and Windows as affected. The bug is platform-independent (it\u0027s in managed C# code), but these are the platforms the reporter tested on."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Decoding produces silently corrupt images from certain stream types \u2014 a reliability concern."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "PR #1510 changed from BinaryReader.ReadBytes (which loops internally) to stream.Read (which doesn\u0027t guarantee full reads). This was documented in detail by #1962."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "false",
            "expandedReason": "Verified in current source: SKManagedStream.cs line 99 still uses a single stream.Read() call without a loop."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The buggy code path is unchanged in the current main branch. The issue remains relevant."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "This is the same bug as #1962, which has a detailed root cause analysis and is still open. Closing as duplicate consolidates tracking."
          }
        ],
        "uncertainties": [
          "Reporter claims 2.88.9 was the last known good version, but #1962 documents the regression at 2.80.3 \u2014 the reporter may not have tested chunked streams on the older version",
          "Whether the reporter is using SKBitmap.Decode(Stream) directly on the blob stream or through another path \u2014 the code shown uses MemoryStream (the workaround)"
        ],
        "assumptions": [
          "Assumed the reporter tried SKBitmap.Decode directly with the blob stream before discovering the MemoryStream workaround, even though the code shown already uses the workaround",
          "Assumed Azure Blob stream is seekable (CanSeek=true) based on the default Azure SDK behavior, routing it through SKManagedStream rather than SKFrontBufferedManagedStream"
        ],
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKManagedStream.cs",
            "lines": "89-112",
            "relevance": "OnReadManagedStream calls stream.Read() once at line 99 without looping. Per .NET docs, Stream.Read may return fewer bytes than requested even when more data is available \u2014 this is the root cause. Azure Blob streams return data in chunks (default 4MB), so a single Read returns at most one chunk."
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "lines": "278-290",
            "relevance": "WrapManagedStream decides the stream wrapper: seekable streams get SKManagedStream (the buggy path), non-seekable get SKFrontBufferedManagedStream. Azure Blob streams are seekable, so they hit the buggy SKManagedStream path."
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "lines": "461-471",
            "relevance": "SKBitmap.Decode(Stream) creates an SKCodec from the stream, which wraps it in SKManagedStream. The codec then reads through SKManagedStream during decoding, hitting the partial-read bug."
          },
          {
            "file": "binding/SkiaSharp/SKFrontBufferedManagedStream.cs",
            "lines": "64-124",
            "relevance": "The non-seekable stream path also doesn\u0027t loop reads (line 91, 111), but passes through to SKManagedStream which has the same bug. Related issue #2514 reports partial reads on non-seekable streams too."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.92,
          "reason": "This is the same root cause as #1962 \u2014 SKManagedStream.OnReadManagedStream uses a single stream.Read() call that doesn\u0027t loop to fill the buffer. Multiple other issues (#2514, #2249, #1985, #335) report the same problem with network/cloud streams."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply area, platform, and tenet labels",
            "reason": "Matches classification \u2014 core SkiaSharp bug affecting Linux and Windows, reliability tenet",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "os/Linux",
                "os/Windows-Classic",
                "tenet/reliability"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "dup-1",
            "type": "link-duplicate",
            "risk": "medium",
            "description": "Mark as duplicate of #1962",
            "reason": "Identical root cause: SKManagedStream.OnReadManagedStream single-call Stream.Read bug. #1962 has detailed analysis and is the canonical tracking issue.",
            "confidence": 0.92,
            "payload": {
              "duplicateOf": 1962,
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug, confirm workaround, and link to the canonical issue",
            "reason": "Reporter needs confirmation their workaround is correct and a pointer to the tracked issue",
            "confidence": 0.88,
            "dependsOn": "dup-1",
            "payload": {
              "commentType": "duplicate-notice",
              "draftBody": "Thanks for the report \u2014 you\u0027ve identified a real bug, and your workaround of copying to a \u0060MemoryStream\u0060 first is the right approach.\n\nThe root cause is in \u0060SKManagedStream.OnReadManagedStream\u0060, which calls \u0060stream.Read()\u0060 once without looping. Per the .NET \u0060Stream.Read\u0060 contract, a single call can return fewer bytes than requested even when more data is available \u2014 which is exactly what happens with Azure Blob streams that deliver data in chunks.\n\nThis is tracked in #1962 (and also reported in #2514, #2249). Closing as a duplicate so discussion stays consolidated there.\n\nIn the meantime, the \u0060MemoryStream\u0060 copy workaround you\u0027re already using is the most reliable path:\n\n\u0060\u0060\u0060csharp\nawait using var blobStream = await blobStorage.GetBlob(blobName, cancellationToken);\nawait using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var bitmap = SKBitmap.Decode(memoryStream);\n\u0060\u0060\u0060\n\nNote: \u0060SKBitmap.Decode()\u0060 can return \u0060null\u0060 if the codec fails to parse the image, so you may want to add a null check before using the result.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3175-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as duplicate of #1962",
            "reason": "Same root cause, same code path, canonical issue is #1962",
            "confidence": 0.92,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3175"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 2997,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T20:18:46Z",
        "currentLabels": [
          "type/bug"
        ],
        "state": "open"
      },
      "summary": "SKMatrix.MapRect normalizes output rect due to upstream Skia\u0027s sort_as_rect. Workaround: use MapPoint on corners.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.6
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "severity": "low",
          "severityReason": "No crash. Unexpected behavior from upstream Skia\u0027s design choice, with a straightforward workaround using MapPoint.",
          "hasWorkaround": true,
          "workaroundSummary": "Use MapPoint to transform the rect corners individually instead of MapRect, preserving the original left/right/top/bottom ordering.",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "reproEvidence": {
          "relatedIssues": [
            3001,
            3002
          ],
          "codeSnippets": [
            {
              "code": "var inputRect = new SKRect();\ninputRect.Left =25;\ninputRect.Right = 15;\ninputRect.Bottom = 2;\ninputRect.Top = 10;\nvar resultRect = SKMatrix.CreateIdentity().MapRect(inputRect);\nAssert.AreEqual(inputRect.Right,resultRect.Right);",
              "language": "csharp",
              "context": "Repro code from issue body demonstrating identity matrix normalizing non-standard rect"
            }
          ]
        },
        "versionAnalysis": {
          "reason": "The Skia sort_as_rect function in SkMatrix::mapRect has not changed \u2014 the normalization behavior is inherent to upstream Skia\u0027s mapRect implementation and is present in all SkiaSharp versions.",
          "mentionedVersions": [
            "2.88.3",
            "2.88.2"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "Reporter claims 2.88.2 was the last good version, but the sort_as_rect function has existed in Skia for many years. The reporter may not have noticed the behavior previously, or may have used a different code path."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "This is Skia\u0027s intended behavior \u2014 sort_as_rect normalizes rects in mapRect. SkiaSharp passes through to Skia directly. No fix expected unless Skia changes upstream."
        }
      },
      "analysis": {
        "summary": "SKMatrix.MapRect calls Skia\u0027s SkMatrix::mapRect, which uses sort_as_rect to normalize the output rectangle so left\u003C=right and top\u003C=bottom. This is upstream Skia behavior, not a SkiaSharp bug. The C# binding simply passes through to the C API, which calls SkMatrix::mapRect. A community comment confirms this with a link to the Skia source.",
        "keySignals": [
          {
            "text": "The \u0022Top\u0022 of an SKRect artifact is not always the smallest Y number",
            "source": "body",
            "interpretation": "Reporter works with non-standard coordinate systems where left\u003Eright or top\u003Ebottom is meaningful"
          },
          {
            "text": "operation1 and operation2 done separately will no longer equal their concatenation if operation1 decides to standardize the intermediate result",
            "source": "body",
            "interpretation": "Valid concern about composability, but this is inherent to how Skia defines rect mapping"
          },
          {
            "text": "That\u0027s what Skia does, it\u0027s not really an issue with the bindings themselves",
            "source": "comment-molesmoke",
            "interpretation": "Community member correctly identified this as upstream Skia behavior, linking to SkMatrix.cpp:1156"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "While this is upstream Skia\u0027s intended behavior, the reporter\u0027s expectation is reasonable \u2014 an identity matrix should preserve the rect unchanged. Keeping as type/bug since it\u0027s a valid behavioral concern, but confidence is lower because it\u0027s Skia\u0027s design choice, not a SkiaSharp defect.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to use the API \u2014 they\u0027re reporting that MapRect changes values unexpectedly."
              },
              {
                "value": "type/enhancement",
                "whyRejected": "Could be an enhancement to add a MapRect overload that preserves ordering, but the existing issue is framed as unexpected behavior."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKMatrix is in the core SkiaSharp package. The behavior originates from upstream Skia but surfaces through the SkiaSharp API."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "low",
            "expandedReason": "No crash, no data loss. Behavioral surprise with a clear workaround (MapPoint on corners). Affects niche use case of non-standard coordinate systems."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "This is upstream Skia\u0027s intended behavior. SkiaSharp faithfully wraps it. A workaround using MapPoint exists. The community has already provided the explanation."
          },
          {
            "field": "regression.isRegression",
            "chosen": "false",
            "expandedReason": "sort_as_rect has been in Skia for many years. The claimed regression from 2.88.2 to 2.88.3 is likely a coincidence \u2014 the reporter may have changed their usage pattern."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "false",
            "expandedReason": "This is Skia\u0027s design, not a bug. No fix expected or appropriate."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The behavior persists in all SkiaSharp versions since sort_as_rect has not been changed in Skia."
          }
        ],
        "uncertainties": [
          "Whether there\u0027s demand for a SkiaSharp-level MapRect overload that preserves corner ordering",
          "Whether the reporter\u0027s claim of regression from 2.88.2 reflects a real behavior change or coincidence"
        ],
        "assumptions": [
          "Assumed the reporter is using a standard CPU/raster backend since no GPU-specific details are mentioned"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s SkMatrix::mapRect intentionally normalizes the output rect via sort_as_rect. This is by-design upstream behavior. SkiaSharp should document this and provide a workaround.",
          "proposals": [
            {
              "title": "Use MapPoint on rect corners",
              "description": "Transform the four corners of the rect individually using MapPoint, then construct a new SKRect from the transformed corners. This preserves the original left/right/top/bottom ordering since MapPoint doesn\u0027t normalize.",
              "confidence": 0.95,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "// Workaround: map corners individually to preserve ordering\nvar matrix = SKMatrix.CreateIdentity(); // or your actual matrix\nvar inputRect = new SKRect(25, 10, 15, 2); // left \u003E right, top \u003E bottom\n\nvar topLeft = matrix.MapPoint(inputRect.Left, inputRect.Top);\nvar bottomRight = matrix.MapPoint(inputRect.Right, inputRect.Bottom);\n\nvar resultRect = new SKRect(topLeft.X, topLeft.Y, bottomRight.X, bottomRight.Y);\n// resultRect preserves the original left/right/top/bottom ordering",
              "validated": "yes"
            },
            {
              "title": "Add MapRectUnsorted overload",
              "description": "Add a new C# method SKMatrix.MapRectUnsorted that maps the rect corners via MapPoint instead of calling Skia\u0027s mapRect. This would be a SkiaSharp-level convenience that avoids the upstream normalization.",
              "confidence": 0.7,
              "effort": "low",
              "category": "fix"
            }
          ],
          "recommendedProposal": "Use MapPoint on rect corners",
          "recommendedReason": "Immediate workaround that preserves corner ordering without requiring any library changes."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKMatrix.cs",
            "lines": "299-306",
            "relevance": "MapRect is a thin wrapper: calls SkiaApi.sk_matrix_map_rect, no C# normalization \u2014 the standardization happens entirely in Skia C\u002B\u002B"
          },
          {
            "file": "externals/skia/src/c/sk_matrix.cpp",
            "lines": "47-49",
            "relevance": "C API sk_matrix_map_rect passes directly through to AsMatrix(matrix).mapRect \u2014 no additional logic in the C shim"
          },
          {
            "file": "externals/skia/src/core/SkMatrix.cpp",
            "lines": "1120-1127",
            "relevance": "sort_as_rect function: uses min/max on ltrb components to ensure left\u003C=right and top\u003C=bottom. This is the root cause of the normalization."
          },
          {
            "file": "externals/skia/src/core/SkMatrix.cpp",
            "lines": "1142-1169",
            "relevance": "SkMatrix::mapRect calls sort_as_rect in the translate-only path (line 1149) and mapRectScaleTranslate (which also calls sort_as_rect at line 1139) for scale\u002Btranslate. All paths normalize the output rect."
          },
          {
            "file": "binding/SkiaSharp/SKMatrix.cs",
            "lines": "310-320",
            "relevance": "MapPoint transforms individual points via sk_matrix_map_xy without normalization \u2014 this is the workaround path for preserving corner ordering"
          },
          {
            "file": "binding/SkiaSharp/MathTypes.cs",
            "lines": "382-398",
            "relevance": "SKRect.Standardized property already exists in SkiaSharp for explicit normalization, confirming the reporter\u0027s expectation that normalization should be opt-in"
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "This is upstream Skia\u0027s intended behavior (sort_as_rect in mapRect). A community member has already explained this. A workaround using MapPoint exists."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Keep type/bug, add area/SkiaSharp",
            "reason": "Area label is missing. Type/bug is borderline appropriate \u2014 the behavior is unexpected even if by-design upstream.",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the report, explain the upstream cause, and provide a MapPoint workaround",
            "reason": "Reporter deserves a response with explanation and actionable workaround",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "documentation",
              "draftBody": "Thanks for the detailed report and repro code.\n\nAs @molesmoke pointed out, this normalization comes from Skia itself \u2014 \u0060SkMatrix::mapRect\u0060 runs the output through a \u0060sort_as_rect\u0060 function that ensures \u0060left \u003C= right\u0060 and \u0060top \u003C= bottom\u0060 ([source](https://github.com/google/skia/blob/158dc9d7d4cafb177b99b68c5dc502f8f4282092/src/core/SkMatrix.cpp#L1120-L1127)). SkiaSharp\u0027s \u0060MapRect\u0060 passes straight through to Skia, so the normalization isn\u0027t something we can bypass at the binding level.\n\nYour concern about composability with non-standard coordinate systems makes sense. Here\u0027s a workaround \u2014 transform the corners individually with \u0060MapPoint\u0060, which doesn\u0027t normalize:\n\n\u0060\u0060\u0060csharp\nvar topLeft = matrix.MapPoint(inputRect.Left, inputRect.Top);\nvar bottomRight = matrix.MapPoint(inputRect.Right, inputRect.Bottom);\nvar resultRect = new SKRect(topLeft.X, topLeft.Y, bottomRight.X, bottomRight.Y);\n\u0060\u0060\u0060\n\nThis preserves whatever ordering the original rect had. You could wrap this in an extension method if you use it frequently.\n\nClosing this since the behavior is in upstream Skia, but the workaround should unblock you.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2997-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as upstream Skia behavior with workaround provided",
            "reason": "By-design upstream behavior, workaround available, community already explained the cause",
            "confidence": 0.78,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2997"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 2759,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T22:41:00Z",
        "currentLabels": [
          "type/bug"
        ],
        "state": "open"
      },
      "summary": "SKBitmap.Decode returns null for a specific PNG \u2014 follow-up to #933/#1981. No image file attached, insufficient info to diagnose.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.72
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "none",
          "severity": "low",
          "severityReason": "No crash, SKBitmap.Decode returns null for an unattached PNG file. No reproduction material provided \u2014 no image file, no error output from SKCodec, no details about the PNG format. Without the actual image, this cannot be investigated.",
          "hasWorkaround": false
        },
        "reproEvidence": {
          "relatedIssues": [
            933,
            1981,
            2801,
            2874,
            2429
          ],
          "codeSnippets": [
            {
              "code": "SkiaSharp.SKBitmap bmp = SkiaSharp.SKBitmap.Decode(@\u0022C:\\Temp\\image1.png\u0022);\nAssert.IsNotNull(bmp);",
              "language": "csharp",
              "context": "Reporter\u0027s reproduction code \u2014 references a local file not attached to the issue"
            }
          ],
          "environmentDetails": "Windows, Visual Studio, SkiaSharp 2.88.6 (description) / 2.88.3 (form field). All platforms claimed affected."
        },
        "versionAnalysis": {
          "reason": "Reporter claims the issue persists in 2.88.6, but without the actual PNG file, we cannot determine if this is the same zlib bug fixed in #1981 or a different PNG decoding issue (e.g., CRC mismatch as in #2874, or format-specific codec failure as in #2429). The version field says 2.88.3 but the description says 2.88.6 \u2014 inconsistency reduces confidence.",
          "mentionedVersions": [
            "2.88.6",
            "2.88.3",
            "2.88.2"
          ],
          "currentRelevance": "unknown"
        }
      },
      "analysis": {
        "summary": "The reporter reopens #933 (closed as dup of #1981) claiming the fix didn\u0027t work. However, they provide no image file, no SKCodec error output, and no details about the PNG\u0027s properties (bit depth, color type, interlacing, chunk structure). Multiple distinct PNG decoding issues exist in SkiaSharp \u2014 the zlib SSE bug (#1981), CRC mismatch rejection (#2874), and format-specific codec failures (#2429, #2801). Without the image, we cannot determine which issue this is or whether the #1981 fix addresses it.",
        "keySignals": [
          {
            "text": "This is follow-up of #933 issue, which is closed as resolved, but the problem is still there 2.88.6 version",
            "source": "body",
            "interpretation": "Reporter believes #933\u0027s fix didn\u0027t work. However, #933 was closed as dup of #1981, which was fixed by updating zlib. The reporter may be hitting a different PNG issue entirely."
          },
          {
            "text": "SKBitmap.Decode(@\u0022C:\\Temp\\image1.png\u0022)",
            "source": "body",
            "interpretation": "References a local file (image1.png) that is not attached to this issue. Same filename as #933 \u2014 but #933\u0027s image was an inline GitHub attachment that may no longer be the same format."
          },
          {
            "text": "Version: 2.88.3 (Current) / Last Known Good: 2.88.2",
            "source": "body",
            "interpretation": "Contradicts the description which says 2.88.6. The 2.88.2\u21922.88.3 transition aligns with the original #1981 regression (zlib SSE changes), but 2.88.6 should include the fix."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes SKBitmap.Decode returning null for a valid PNG. If the image is genuinely valid, this is a bug. However, without the image, we can\u0027t confirm validity \u2014 the PNG might have CRC errors, unusual encoding, or other issues that Skia intentionally rejects.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to use an API \u2014 they report a specific failure. Even though the report is incomplete, the intent is a bug report."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKBitmap.Decode is in the core SkiaSharp binding. The failure could be in native Skia\u0027s codec, but the entry point is SkiaSharp."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "low",
            "expandedReason": "No crash, no stack trace, no reproduction material. The report has zero comments and no image file attached. Cannot investigate without additional information from the reporter."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "We need the actual PNG file to diagnose the issue. We also need SKCodecResult output to understand why decoding fails. Without these, we cannot determine if this is a new bug, an unfixed old bug, or an invalid image."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unknown",
            "expandedReason": "Without the actual PNG file, we cannot determine if this is the same zlib bug fixed in #1981 (which would be fixed in current versions) or a different PNG issue. The reporter\u0027s version info is contradictory (2.88.3 vs 2.88.6)."
          }
        ],
        "uncertainties": [
          "Whether the PNG file is the same one from #933 \u2014 the original #933 image was embedded as a GitHub attachment but we can\u0027t verify it\u0027s the same file referenced as C:\\Temp\\image1.png",
          "Whether the reporter actually tested on 2.88.6 (description) or 2.88.3 (version field) \u2014 these are different releases",
          "Whether the PNG has structural issues (CRC mismatch, unusual bit depth, interlacing) that Skia intentionally rejects",
          "Whether upgrading to SkiaSharp 3.x (with newer Skia/zlib) would resolve this"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s PNG is a local copy of the image from #933, but cannot verify without the file",
          "Assumed the issue is platform-independent since the decode path is the same on all platforms, despite reporter selecting \u0027All\u0027"
        ],
        "resolution": {
          "hypothesis": "SKBitmap.Decode returns null because Skia\u0027s native codec rejects the PNG. The reason could be: (1) the same zlib decompression bug from #1981 (unlikely if on 2.88.6\u002B), (2) CRC mismatch in PNG chunks (like #2874), (3) unsupported PNG features, or (4) a different native codec bug. Without the image, we cannot distinguish these.",
          "proposals": [
            {
              "title": "Use SKCodec.Create with SKCodecResult to diagnose",
              "description": "Use the SKCodec.Create overload that returns an SKCodecResult to get the specific failure reason. This narrows down whether it\u0027s a codec initialization failure or a pixel decoding failure.",
              "confidence": 0.85,
              "effort": "low",
              "category": "investigation",
              "codeSnippet": "var codec = SKCodec.Create(@\u0022C:\\Temp\\image1.png\u0022, out var result);\nConsole.WriteLine($\u0022Codec result: {result}\u0022);\nif (codec != null)\n{\n    var info = codec.Info;\n    Console.WriteLine($\u0022Size: {info.Width}x{info.Height}, ColorType: {info.ColorType}, AlphaType: {info.AlphaType}\u0022);\n    \n    var bitmap = new SKBitmap(info);\n    var pixelResult = codec.GetPixels(info, bitmap.GetPixels(out _));\n    Console.WriteLine($\u0022Pixel result: {pixelResult}\u0022);\n}",
              "validated": "untested"
            },
            {
              "title": "Try SkiaSharp 3.x",
              "description": "SkiaSharp 3.x uses a significantly newer Skia engine with updated libpng and zlib. If the issue is a native codec bug, upgrading may resolve it.",
              "confidence": 0.5,
              "effort": "medium",
              "category": "alternative"
            }
          ],
          "recommendedProposal": "Use SKCodec.Create with SKCodecResult to diagnose",
          "recommendedReason": "First step is diagnosis \u2014 we need to know WHY the decode fails before we can fix or work around it."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "lines": "539-549",
            "relevance": "SKBitmap.Decode(string) creates SKCodec via SKCodec.Create(filename). If the codec is null (Skia rejected the image), Decode returns null. The reporter sees null, meaning SKCodec.Create failed \u2014 but we don\u0027t know why without the image."
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "lines": "232-241",
            "relevance": "SKCodec.Create(string) opens an SKFileStream and passes to sk_codec_new_from_stream. The out parameter SKCodecResult would reveal the failure reason, but the reporter\u0027s code doesn\u0027t capture it."
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "lines": "446-459",
            "relevance": "Even if SKCodec creation succeeds, Decode(codec, bitmapInfo) can still return null if GetPixels fails (result != Success \u0026\u0026 result != IncompleteInput). This is a second failure point."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.88,
          "reason": "The report is missing critical information: no image file attached, no SKCodecResult output, and conflicting version numbers. Cannot investigate without the actual PNG file."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply area label",
            "reason": "Matches classification \u2014 core SkiaSharp decode issue",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Request the PNG file and diagnostic output",
            "reason": "Cannot investigate without the actual image and codec error details",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the follow-up. We understand this is frustrating, especially since #933 was closed.\n\nTo investigate, we\u0027d need two things:\n\n1. **The actual PNG file** \u2014 could you attach \u0060image1.png\u0060 to this issue? (Drag and drop, or zip it first if GitHub won\u0027t accept the format.) Without the file, we can\u0027t reproduce or diagnose.\n\n2. **The codec error** \u2014 this will tell us exactly why Skia rejected it:\n\n\u0060\u0060\u0060csharp\nvar codec = SKCodec.Create(@\u0022C:\\Temp\\image1.png\u0022, out var result);\nConsole.WriteLine($\u0022Codec result: {result}\u0022);\n\u0060\u0060\u0060\n\nThere are several distinct reasons Skia can reject a PNG (format issues, CRC mismatches, compression quirks), and the fix depends on which one it is. The \u0060SKCodecResult\u0060 output will point us in the right direction.\n\nAlso \u2014 could you confirm which SkiaSharp version you\u0027re on? The description mentions 2.88.6, but the version field says 2.88.3.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2759-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2759"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 2511,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [],
        "state": "closed"
      },
      "summary": "AccessViolationException in finalizer thread when closing WinForms app \u2014 duplicate of #2194, fixed in v2.88.1",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.92
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.93
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "none",
          "severity": "high",
          "severityReason": "Uncatchable AccessViolationException crashes the application during shutdown. However, a fix already exists in v2.88.1.",
          "hasWorkaround": true,
          "workaroundSummary": "Explicitly dispose all SkiaSharp objects before application exit instead of relying on finalizers, or upgrade to SkiaSharp v2.88.1\u002B which includes the fix from PR #2195."
        },
        "reproEvidence": {
          "relatedIssues": [
            2194,
            1817
          ],
          "stepsToReproduce": [
            "Use SkiaSharp in a WinForms application on Windows (version prior to v2.88.1)",
            "Create and use SKObject-derived instances without explicit disposal",
            "Close the application, allowing finalizers to run"
          ],
          "environmentDetails": "Windows, WinForms application. No SkiaSharp version specified by reporter."
        },
        "versionAnalysis": {
          "reason": "The exact crash (AccessViolationException in NonAlertableWin32Lock.EnterCriticalSection during finalization) was fixed in PR #2195, released in v2.88.1. The current code has null guards on the critical section pointer before calling EnterCriticalSection. Reporter did not specify a version, but the identical stack trace to #2194 strongly suggests they were running a version before the fix.",
          "currentRelevance": "unlikely"
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.9,
          "reason": "PR #2195 added null checks to NonAlertableWin32Lock.Enter() and Leave() methods, preventing AccessViolationException when the critical section has already been finalized. This fix shipped in v2.88.1. The stack trace in #2511 is identical to #2194.",
          "relatedPRs": [
            2195
          ],
          "fixedInVersion": "2.88.1",
          "verificationStatus": "unverified"
        }
      },
      "analysis": {
        "summary": "This is a duplicate of #2194. The crash occurs because .NET finalizer ordering is non-deterministic \u2014 during app shutdown, the NonAlertableWin32Lock\u0027s finalizer can destroy the Win32 CRITICAL_SECTION before other SKNativeObject finalizers finish deregistering their handles. PR #2195 fixed this by adding null guards on the critical section pointer. The reporter provided no version info but the stack trace is byte-for-byte identical to the fixed issue.",
        "keySignals": [
          {
            "text": "System.AccessViolationException at NonAlertableWin32Lock.EnterCriticalSection",
            "source": "stack-trace",
            "interpretation": "Identical crash signature to #2194 \u2014 critical section accessed after finalization"
          },
          {
            "text": "SKNativeObject.Finalize() at bottom of stack",
            "source": "stack-trace",
            "interpretation": "Crash happens during GC finalization, not during normal usage \u2014 classic finalizer ordering problem"
          },
          {
            "text": "When I close my winform program",
            "source": "body",
            "interpretation": "App shutdown triggers GC finalization of all remaining objects, exposing the race condition"
          },
          {
            "text": "what is the problem?",
            "source": "body",
            "interpretation": "Reporter is asking for diagnosis, not reporting a specific repro \u2014 minimal information provided"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes an AccessViolationException crash during normal app shutdown. This is clearly broken behavior \u2014 finalizer cleanup should not crash.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "While phrased as a question (\u0027what is the problem?\u0027), the core content is a crash report with a stack trace."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The crash is in SkiaSharp\u0027s core HandleDictionary and PlatformLock infrastructure, not in any specific view or platform package.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "Stack trace does not involve any Views components \u2014 the crash is in core object disposal."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "AccessViolationException is uncatchable and terminates the process. However, it only occurs during app shutdown and a fix exists, which prevents it from being critical."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "The stack trace is identical to #2194. PR #2195 fixed this exact issue in v2.88.1. The issue was already closed with zero comments, confirming it was recognized as a known/fixed issue."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "The crash is in NonAlertableWin32Lock (Win32 CRITICAL_SECTION) and reporter explicitly says \u0022my winform program,\u0022 confirming a Windows Classic desktop application.",
            "alternatives": [
              {
                "value": "os/Windows-WinUI",
                "whyRejected": "WinForms is a classic Win32 framework, not WinUI/UWP."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "An uncatchable AccessViolationException during normal app shutdown is a reliability defect \u2014 finalizer cleanup should never crash the process.",
            "alternatives": [
              {
                "value": "tenet/compatibility",
                "whyRejected": "This is not a cross-version or cross-platform compatibility issue; it is a crash caused by non-deterministic finalizer ordering."
              }
            ]
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "true",
            "expandedReason": "PR #2195 added null guards to NonAlertableWin32Lock.Enter() and Leave(), shipping in v2.88.1. The stack trace is identical to the fixed issue #2194."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unlikely",
            "expandedReason": "The fix shipped in v2.88.1 and current SkiaSharp is 3.x. The reporter likely used a pre-fix version given the identical stack trace to #2194.",
            "alternatives": [
              {
                "value": "likely",
                "whyRejected": "The null guards from PR #2195 are present in all versions since v2.88.1, so the crash cannot occur on current releases."
              }
            ]
          }
        ],
        "uncertainties": [
          "Reporter did not specify SkiaSharp version \u2014 cannot confirm they were on a pre-fix version",
          "No .NET framework version specified \u2014 unclear if .NET Framework or .NET Core"
        ],
        "assumptions": [
          "Reporter was using a SkiaSharp version prior to v2.88.1 based on the identical stack trace to the fixed issue #2194"
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.9,
          "reason": "Identical stack trace to #2194, which was fixed in PR #2195 (v2.88.1). Issue was already closed with no comments."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, core SkiaSharp, Windows, and reliability labels",
            "reason": "Matches classification \u2014 crash in core SkiaSharp on Windows during finalization",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/SkiaSharp",
                "os/Windows-Classic",
                "tenet/reliability"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "dup-1",
            "type": "link-duplicate",
            "risk": "medium",
            "description": "Mark as duplicate of #2194",
            "reason": "Byte-for-byte identical stack trace \u2014 same finalizer ordering crash in NonAlertableWin32Lock",
            "confidence": 0.9,
            "payload": {
              "duplicateOf": 2194,
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post duplicate notice with upgrade guidance",
            "reason": "Let reporter know the issue is tracked and fixed",
            "confidence": 0.85,
            "dependsOn": "dup-1",
            "payload": {
              "commentType": "duplicate-notice",
              "draftBody": "Thanks for the stack trace \u2014 this is a known finalizer ordering issue on Windows that was tracked in #2194 and fixed in PR #2195.\n\nThe crash happens because the Win32 critical section used by SkiaSharp\u0027s handle dictionary can be finalized before other SkiaSharp objects during app shutdown. This was fixed in SkiaSharp v2.88.1 by adding null guards on the critical section pointer.\n\nIf you\u0027re able to upgrade to v2.88.1 or later, this should be resolved. Closing as a duplicate of #2194.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2511-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as duplicate of #2194",
            "reason": "Fixed in v2.88.1, identical to tracked issue",
            "confidence": 0.9,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2511"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 2421,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T23:45:00Z",
        "currentLabels": [],
        "state": "open"
      },
      "summary": "DllNotFoundException on iOS physical device \u2014 @rpath/libSkiaSharp.framework/libSkiaSharp not found when creating SKPaint in .NET MAUI app",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.8
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.9
        },
        "platforms": [
          {
            "value": "os/iOS",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.9
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Crash with workarounds available. Primarily affects Windows Hot Restart deployment to physical iOS devices. Simulator and Android work fine.",
          "hasWorkaround": true,
          "workaroundSummary": "Deploy via Mac-connected device (not Windows Hot Restart). Alternatively, set \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E to prevent linker from stripping the native framework.",
          "targetFrameworks": [
            "net6.0-ios",
            "net7.0-ios"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/iniceice88/OxyPlot.Maui.Skia",
              "description": "Third-party library using SkiaSharp where the crash occurs"
            }
          ],
          "relatedIssues": [
            1129,
            1264,
            2410,
            2437
          ]
        },
        "versionAnalysis": {
          "reason": "SkiaSharp 2.88.3 was the latest stable at filing time (March 2023). The current version is 3.x which has significant packaging changes including revamped native asset packaging for iOS. The specific deployment issue may have been resolved.",
          "mentionedVersions": [
            "2.88.3"
          ],
          "currentRelevance": "unlikely",
          "migrationPath": "Upgrade to SkiaSharp 3.x (latest stable) which has revamped native asset packaging for .NET MAUI iOS."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.5,
          "reason": "SkiaSharp 3.x has overhauled native packaging. The specific Hot Restart / linker interaction may still be an issue as it\u0027s partly a MAUI/Xamarin tooling concern, not purely a SkiaSharp issue. Cannot confirm without testing on 3.x with Hot Restart."
        }
      },
      "analysis": {
        "summary": "Reporter experiences DllNotFoundException with message \u0027@rpath/libSkiaSharp.framework/libSkiaSharp\u0027 when creating SKPaint on a physical iOS device in .NET MAUI. Works on iOS simulator and Android. This is a well-known iOS native framework deployment issue \u2014 the libSkiaSharp.framework is not being deployed to the device, typically caused by Windows Hot Restart or iOS linker stripping the native framework. Multiple duplicate/related issues exist (#1129, #1264, #2410, #2437).",
        "keySignals": [
          {
            "text": "@rpath/libSkiaSharp.framework/libSkiaSharp",
            "source": "stack-trace",
            "interpretation": "iOS P/Invoke path for libSkiaSharp. The native .framework bundle is not present on the device at the expected rpath location."
          },
          {
            "text": "works in the emulator but not on a real device",
            "source": "body",
            "interpretation": "Classic Hot Restart or deployment issue \u2014 simulator uses local build artifacts differently than device deployment."
          },
          {
            "text": "The same for the example project",
            "source": "body",
            "interpretation": "Not specific to reporter\u0027s code \u2014 systematic deployment issue."
          },
          {
            "text": "I have built a release build since I saw one post claiming you need to build it in release mode for the DLL to show up",
            "source": "body",
            "interpretation": "Reporter tried release mode as workaround \u2014 suggests they\u0027re aware this is a deployment/packaging issue."
          },
          {
            "text": "SkiaSharp.Views.Maui.Controls version 2.88.3",
            "source": "body",
            "interpretation": "Using 2.88.3 which is known to have iOS deployment issues on certain configurations."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The native framework fails to load on physical iOS devices. While it may be caused by tooling (Hot Restart, linker), SkiaSharp should work out of the box on iOS physical devices. This is a deployment/packaging bug, not a user error.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they report a crash that prevents any SkiaSharp usage on iOS devices."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The issue is about the native libSkiaSharp.framework not being deployed to the iOS device. This is a native asset packaging issue, not a C# binding problem.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "Although MAUI is involved, the crash is in the core native library loading, not in the Views layer."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Complete failure to use SkiaSharp on iOS physical devices is severe, but workarounds exist (deploy via Mac, disable linker, upgrade SkiaSharp version). Simulator works fine for development."
          },
          {
            "field": "platforms",
            "chosen": "os/iOS",
            "expandedReason": "Crash is iOS-specific. Reporter explicitly states Android and iOS simulator work fine."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "This is a compatibility issue between SkiaSharp\u0027s iOS native packaging and certain deployment configurations (Hot Restart, Enterprise certificates, linker settings)."
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "Reporter is using .NET MAUI with SkiaSharp.Views.Maui.Controls. The issue is related to MAUI iOS deployment tooling."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "This is a known issue with multiple existing reports. #2410 is the primary open issue tracking the same problem (same version, same error, same scenario). Reporter cwilde123 even commented on #2410 before opening #2421, confirming they\u0027re the same issue."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "false",
            "expandedReason": "Cannot confirm without testing on SkiaSharp 3.x with Hot Restart. The root cause is partly in MAUI tooling, not purely SkiaSharp."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unlikely",
            "expandedReason": "SkiaSharp 3.x has revamped native asset packaging. The 2.88.3-specific packaging has been replaced entirely, making this specific issue unlikely to reproduce on current versions."
          }
        ],
        "uncertainties": [
          "Whether reporter is using Windows Hot Restart (most likely cause) or deploying via Mac",
          "Whether upgrading to SkiaSharp 3.x resolves the issue for this specific configuration",
          "Whether the linker is stripping the framework or it\u0027s never being included in the first place"
        ],
        "assumptions": [
          "Assumed reporter is likely using Windows Hot Restart based on the pattern matching other reports",
          "Reporter\u0027s mention of \u0027release build\u0027 suggests they tried multiple build configurations"
        ],
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaApi.cs",
            "lines": "9-11",
            "relevance": "On iOS/tvOS, the P/Invoke path is hardcoded to \u0027@rpath/libSkiaSharp.framework/libSkiaSharp\u0027. If the framework bundle is missing from the app package, this P/Invoke will fail with DllNotFoundException. This is expected behavior \u2014 the issue is in deployment, not in the binding code."
          },
          {
            "file": "binding/SkiaSharp/SKPaint.cs",
            "lines": "48-54",
            "relevance": "SKPaint constructor calls SkiaApi.sk_compatpaint_new() which triggers the P/Invoke into libSkiaSharp. This is the first native call in the reporter\u0027s code path, so it\u0027s where the DllNotFoundException surfaces."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.88,
          "reason": "This is a well-documented issue tracked in #2410 (same MAUI version, same error, same iOS-only crash pattern). Reporter cwilde123 also commented on #2410 confirming the same problem."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, native, iOS, compatibility, and MAUI partner labels",
            "reason": "Matches classification \u2014 iOS native loading failure in MAUI context",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/libSkiaSharp.native",
                "os/iOS",
                "tenet/compatibility",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "dup-1",
            "type": "link-duplicate",
            "risk": "medium",
            "description": "Mark as duplicate of #2410",
            "reason": "Same error (@rpath/libSkiaSharp.framework/libSkiaSharp), same version (2.88.3), same scenario (MAUI iOS physical device crash). Reporter cwilde123 also commented on #2410.",
            "confidence": 0.88,
            "payload": {
              "duplicateOf": 2410,
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Notify reporter of duplicate and provide workarounds",
            "reason": "Give reporter actionable workarounds while directing them to the tracked issue",
            "confidence": 0.85,
            "dependsOn": "dup-1",
            "payload": {
              "commentType": "duplicate-notice",
              "draftBody": "Thanks for the report. This appears to be the same iOS native framework deployment issue tracked in #2410.\n\nThe \u0060@rpath/libSkiaSharp.framework/libSkiaSharp\u0060 error means the native framework bundle isn\u0027t being included in the app package on physical iOS devices. A few things to try:\n\n1. **Deploy via Mac** \u2014 If you\u0027re using Windows Hot Restart, try connecting the iOS device directly to a Mac and deploying from there. Hot Restart has known issues with native framework deployment.\n2. **Disable linker** \u2014 Add \u0060\u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E\u0060 to your iOS \u0060.csproj\u0060 to prevent the linker from stripping the native framework. For release builds, configure linker exceptions instead.\n3. **Upgrade SkiaSharp** \u2014 Consider upgrading to the latest SkiaSharp version, which has revamped native asset packaging.\n\nClosing as a duplicate of #2410 \u2014 any updates will be posted there.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2421-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as duplicate of #2410",
            "reason": "Duplicate of #2410 with identical symptoms and root cause",
            "confidence": 0.88,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2421"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 2383,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [],
        "state": "open"
      },
      "summary": "Question about whether SkiaSharp supports 24-bit RGB pixel format (Format24bppRgb) without alpha channel",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        }
      },
      "evidence": {},
      "analysis": {
        "summary": "User is asking how to convert 24-bit RGB pixel data (System.Drawing.Imaging.PixelFormat.Format24bppRgb) to SKBitmap. This is a usage question about pixel format support \u2014 not a bug or feature request. Skia does not have a native 24bpp (3 bytes per pixel) color type, but SKColorType.Rgb888x provides 8 bits per RGB channel with an ignored padding byte at 4 bytes per pixel.",
        "keySignals": [
          {
            "text": "Does skia supports a 24-bit color type like System.Drawing.Imaging.PixelFormat.Format24bppRgb",
            "source": "title",
            "interpretation": "Phrased as a question about API capability \u2014 how-to, not a bug report"
          },
          {
            "text": "I want to convert an image which is in 24-bit color type to SKBitmap",
            "source": "body",
            "interpretation": "User has existing 24bpp pixel data and wants to load it into SkiaSharp"
          },
          {
            "text": "use 8 bits for each colors, no alpha, necessary to specify width, height and stride",
            "source": "body",
            "interpretation": "User understands the pixel format requirements and is looking for the SkiaSharp equivalent"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "The title is literally phrased as a question (\u0027Does skia supports...\u0027) and the body describes a goal the user wants to achieve, not broken behavior. No crash, no error, no incorrect output.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "User is asking if this already exists, not requesting a new feature. The functionality can be achieved with existing APIs via data conversion."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "Question is about core SKBitmap, SKColorType, and pixel data handling \u2014 all in the core SkiaSharp package.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "No mention of views, rendering, or UI frameworks."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The answer is straightforward: Skia has no native 24bpp format, but SKColorType.Rgb888x is 32bpp with ignored alpha, and users can convert 24bpp data to 32bpp then use SKBitmap.InstallPixels with custom stride. This can be answered directly."
          }
        ],
        "uncertainties": [
          "Whether the user has raw pixel byte arrays or encoded image files in 24bpp format",
          "What platform and SkiaSharp version the user is targeting"
        ],
        "assumptions": [
          "Assumed the user has raw 24-bit pixel data (byte arrays) rather than encoded image files, based on the mention of stride and per-channel bit depth",
          "Assumed any recent version of SkiaSharp since no version was mentioned"
        ],
        "resolution": {
          "hypothesis": "User wants to load raw 24-bit RGB pixel data into an SKBitmap. Skia does not support a native 3-byte-per-pixel format, so the data must be converted to a 4-byte-per-pixel format like Rgb888x or Rgba8888.",
          "proposals": [
            {
              "title": "Convert 24bpp to 32bpp and use SKBitmap.InstallPixels",
              "description": "Expand each 3-byte RGB pixel to 4 bytes (RGB \u002B 0xFF padding) then use SKBitmap.InstallPixels with SKColorType.Rgb888x or Rgba8888. This gives full control over width, height, and stride. Most direct approach.",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Use SKBitmap.Decode for encoded images",
              "description": "If the source is an encoded image file (PNG, JPEG, BMP) rather than raw pixels, use SKBitmap.Decode which handles format conversion automatically regardless of the source pixel format.",
              "confidence": 0.8,
              "effort": "low"
            },
            {
              "title": "Use SKPixmap with Rgb888x color type",
              "description": "Create an SKImageInfo with SKColorType.Rgb888x (32bpp, alpha ignored) and use SKPixmap to wrap pre-converted pixel data. Useful when working with SKImage.FromPixels for immutable image creation.",
              "confidence": 0.75,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Convert 24bpp to 32bpp and use SKBitmap.InstallPixels",
          "recommendedReason": "Most direct answer to the user\u0027s stated requirements (raw pixels, custom stride, no alpha). SKBitmap.InstallPixels accepts width, height, and rowBytes as requested."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.85,
          "reason": "Straightforward usage question answerable with existing API documentation for SKColorType and SKBitmap.InstallPixels"
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply question and SkiaSharp area labels",
            "reason": "Matches classification as a usage question about core SkiaSharp pixel format support",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "type/question",
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post answer explaining 24bpp handling with SKColorType.Rgb888x and InstallPixels",
            "reason": "Direct answer available from SkiaSharp API surface",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Skia doesn\u0027t have a native 24-bit (3 bytes per pixel) color type. The closest equivalent is \u0060SKColorType.Rgb888x\u0060, which uses 8 bits for each of R, G, B with an ignored 4th byte \u2014 so it\u0027s 32 bits per pixel rather than 24.\n\nTo load your 24bpp data into an \u0060SKBitmap\u0060, you\u0027d need to expand each pixel from 3 bytes to 4 bytes (inserting a padding byte), then use \u0060SKBitmap.InstallPixels\u0060 with an \u0060SKImageInfo\u0060 configured for \u0060SKColorType.Rgb888x\u0060:\n\n\u0060\u0060\u0060csharp\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x);\nvar bitmap = new SKBitmap();\nbitmap.InstallPixels(info, expandedPixelPtr, rowBytes);\n\u0060\u0060\u0060\n\nThe \u0060rowBytes\u0060 parameter lets you specify the stride of your expanded pixel data.\n\nAlternatively, if your source is an encoded image file (BMP, PNG, JPEG), \u0060SKBitmap.Decode\u0060 handles format conversion automatically \u2014 no manual pixel expansion needed.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2383-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as answered",
            "reason": "Question answered with API guidance and code example",
            "confidence": 0.8,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2383"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 1898,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [],
        "state": "open"
      },
      "summary": "SkiaSharp.Views.Forms 2.88.0-preview.179 NuGet package has an empty netcoreapp3.1 directory \u2014 DLLs missing despite netcore 3.1 support being added in preview.127",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.95
        },
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "severity": "medium",
          "severityReason": "NuGet package advertises netcoreapp3.1 support but ships empty directory \u2014 consumers targeting netcoreapp3.1 get no assemblies. Not a crash, but a broken package.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "netcoreapp3.1"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/compare/v2.88.0-preview.120...v2.88.0-preview.127",
              "description": "Release notes showing netcore 3.1 support added in preview.127"
            }
          ],
          "stepsToReproduce": [
            "Install SkiaSharp.Views.Forms 2.88.0-preview.179",
            "Open the package in NuGet Package Explorer",
            "Navigate to the netcoreapp3.1 directory",
            "Observe the directory is empty \u2014 no DLL files present"
          ]
        },
        "versionAnalysis": {
          "reason": ".NET Core 3.1 reached end-of-life in December 2022. SkiaSharp 2.88.0 stable and subsequent versions (2.88.1, 2.88.2, 2.88.3, 2.88.5, 2.88.6, 2.88.7, 2.88.8, 3.x) have all shipped since this preview. The issue is no longer relevant to any supported configuration.",
          "mentionedVersions": [
            "2.88.0-preview.120",
            "2.88.0-preview.127",
            "2.88.0-preview.179"
          ],
          "currentRelevance": "unlikely",
          "migrationPath": "Upgrade to .NET 6\u002B and SkiaSharp 2.88.8\u002B or 3.x"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.8,
          "reason": "Reporter states netcoreapp3.1 DLLs were present in preview.127 but missing in preview.179, indicating a regression between those preview builds.",
          "workedInVersion": "2.88.0-preview.127",
          "brokeInVersion": "2.88.0-preview.179"
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.85,
          "reason": "The 2.88.0 stable release and all subsequent releases have shipped. .NET Core 3.1 is EOL and no longer targeted. The preview series this bug affects is obsolete.",
          "verificationStatus": "inconclusive"
        }
      },
      "analysis": {
        "summary": "Packaging bug in a 2021-era preview build where netcoreapp3.1 assemblies were missing from the SkiaSharp.Views.Forms NuGet package. The affected preview version is long superseded and .NET Core 3.1 itself is EOL. This issue is no longer actionable.",
        "keySignals": [
          {
            "text": "netcoreapp3.1 directory is empty in Nuget Package Explorer",
            "source": "body",
            "interpretation": "Package structure exists but DLLs are missing \u2014 build/packaging issue, not a missing feature"
          },
          {
            "text": "Support for netcore 3.1 was added in 2.88.0-preview.127 version",
            "source": "body",
            "interpretation": "Confirms this is a regression from a prior preview that had the support"
          },
          {
            "text": "newest 2.88.0-preview.179 version of Views.Forms",
            "source": "body",
            "interpretation": "Affects only preview builds from December 2021 \u2014 long obsolete"
          },
          {
            "text": "5 thumbs-up reactions, 0 comments",
            "source": "metadata",
            "interpretation": "Others experienced the same issue but no maintainer response, suggesting it was resolved by subsequent releases"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter describes a concrete defect: a NuGet package that should contain netcoreapp3.1 assemblies has an empty directory. This is broken packaging behavior, not a feature request or question.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "netcoreapp3.1 support was already added in preview.127 \u2014 this is about it being broken in a later preview, not requesting new support."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Forms",
            "expandedReason": "The issue is specifically about the SkiaSharp.Views.Forms NuGet package having empty netcoreapp3.1 content. The package name is explicitly mentioned.",
            "alternatives": [
              {
                "value": "area/Build",
                "whyRejected": "While the root cause is likely a build/packaging issue, the area should reflect what the user observes \u2014 the Views.Forms package."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Missing assemblies means the package is broken for netcoreapp3.1 consumers, but it\u0027s not a crash or data loss \u2014 it\u0027s a packaging gap. Workaround exists by using an older preview or different TFM."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "This affects only obsolete preview builds (2.88.0-preview.179) and a now-EOL framework (.NET Core 3.1). The stable 2.88.0 release and all subsequent versions have shipped. No action is needed."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "Empty netcoreapp3.1 directory in the NuGet package is a framework compatibility issue \u2014 the package advertises support for a TFM but fails to deliver assemblies.",
            "alternatives": [
              {
                "value": "tenet/reliability",
                "whyRejected": "The package does not crash; it simply lacks assemblies for the advertised TFM, making this a compatibility gap rather than a reliability failure."
              }
            ]
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Reporter confirms netcoreapp3.1 DLLs were present in preview.127 but missing in preview.179, indicating assemblies were dropped between those preview builds."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "true",
            "expandedReason": "The 2.88.0 stable release and all subsequent versions have shipped since this preview. .NET Core 3.1 is EOL (December 2022), making the affected configuration obsolete."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unlikely",
            "expandedReason": ".NET Core 3.1 reached end-of-life in December 2022 and SkiaSharp 3.x is the current major version. The affected preview build is over 3 years old.",
            "alternatives": [
              {
                "value": "likely",
                "whyRejected": "Both the preview version and the target framework are obsolete \u2014 no supported configuration is affected."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the stable 2.88.0 release included netcoreapp3.1 assemblies in Views.Forms \u2014 unable to verify the exact package contents retroactively",
          "Whether the empty directory was intentional (dropped support) or accidental (build script bug)"
        ],
        "assumptions": [
          "Assumed that the issue was resolved in subsequent stable releases since no follow-up comments were posted and the preview series is obsolete",
          "Assumed .NET Core 3.1 targeting was eventually dropped intentionally as the framework reached EOL"
        ],
        "resolution": {
          "hypothesis": "The build pipeline for SkiaSharp.Views.Forms preview.179 failed to include netcoreapp3.1 assemblies despite the TFM being listed. This was likely a build script regression between preview.127 and preview.179.",
          "proposals": [
            {
              "title": "Close as obsolete",
              "description": "The affected preview version is from 2021, .NET Core 3.1 is EOL (December 2022), and SkiaSharp 3.x is the current major version. No fix needed \u2014 the issue is moot.",
              "confidence": 0.9,
              "effort": "low"
            },
            {
              "title": "Upgrade to current SkiaSharp",
              "description": "Users should migrate to .NET 6\u002B and SkiaSharp 2.88.8\u002B or 3.x which are actively supported and do not target EOL frameworks.",
              "confidence": 0.95,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Close as obsolete",
          "recommendedReason": "No code change is needed. The affected version is a 3\u002B year old preview, and the target framework is EOL."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.85,
          "reason": "Obsolete preview version (2.88.0-preview.179) and EOL framework (.NET Core 3.1). Stable releases have long since shipped. No action required."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, Views.Forms, and compatibility labels",
            "reason": "Matches classification \u2014 packaging bug in Views.Forms affecting framework compatibility",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/SkiaSharp.Views.Forms",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post close message explaining the issue is obsolete",
            "reason": "Inform reporter and watchers that the affected preview and TFM are both EOL",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "close-message",
              "draftBody": "Thanks for reporting this \u2014 the empty netcoreapp3.1 directory in the 2.88.0-preview.179 package was a real packaging gap and the thumbs-up reactions show others hit it too.\n\nSince then, the 2.88.0 stable series has shipped and .NET Core 3.1 itself reached end-of-life in December 2022. SkiaSharp 3.x is now the current major version targeting .NET 6\u002B.\n\nClosing this as the affected preview and target framework are both obsolete. If you\u0027re still using SkiaSharp, upgrading to 2.88.8\u002B or 3.x on .NET 6\u002B would be the recommended path forward.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-1898-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as completed \u2014 resolved by subsequent releases",
            "reason": "Preview version is obsolete and .NET Core 3.1 is EOL",
            "confidence": 0.85,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/1898"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 1773,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-22T12:00:00Z",
        "currentLabels": [],
        "state": "closed"
      },
      "summary": "Empty issue with no content \u2014 accidental creation, immediately closed by author",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.55
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.4
        }
      },
      "evidence": {},
      "analysis": {
        "summary": "Issue has no body, no comments, and a title of \u0027TO DELETE PLEASE\u0027. It was opened and closed within minutes on the same day. This is an accidental or test issue creation with zero actionable content.",
        "keySignals": [
          {
            "text": "TO DELETE PLEASE",
            "source": "title",
            "interpretation": "Author explicitly requests deletion \u2014 accidental issue creation"
          },
          {
            "text": "Empty body",
            "source": "body",
            "interpretation": "No description, no repro, no question \u2014 nothing to act on"
          },
          {
            "text": "Closed same day (2021-08-16)",
            "source": "body",
            "interpretation": "Author self-closed immediately, confirming this was unintentional"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "No bug, feature, enhancement, or documentation request is described. The issue is empty. \u0027type/question\u0027 is the least-wrong classification for an issue with no actionable content. Low confidence reflects that none of the types truly fit.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "No broken behavior described \u2014 no body at all."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "No feature requested."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "Issue is already closed with no content. No action is needed. \u0027close-as-fixed\u0027 reflects that the issue lifecycle is complete \u2014 there is nothing to investigate, answer, or fix."
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The issue has no content so no specific area can be determined. Defaulting to the core SkiaSharp area as the catch-all for unclassifiable issues.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "No evidence of UI/view-related content \u2014 the issue body is empty."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the author intended to file a real issue and accidentally submitted early"
        ],
        "assumptions": [
          "Assumed accidental creation since the issue was self-closed within minutes with no follow-up"
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.95,
          "reason": "Issue is already closed with no content \u2014 no action needed"
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply question label to empty issue",
            "reason": "Matches classification \u2014 no better type fits an empty issue",
            "confidence": 0.55,
            "payload": {
              "labelsToAdd": [
                "type/question"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/1773"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 911,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [],
        "state": "open"
      },
      "summary": "Feature request to add a \u0027Getting Started\u0027 section to README.md with links to tutorials, guides, and API documentation",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.85
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.92
        }
      },
      "evidence": {},
      "analysis": {
        "summary": "User requests a curated \u0027Getting Started\u0027 section in README.md with links to introduction guides, platform-specific tutorials, and API docs. The README has been improved since 2019 with badge links to API docs and guides, but still lacks a dedicated Getting Started section. The request remains partially valid \u2014 the README has docs/guide badges but no prominent onboarding section for new users.",
        "keySignals": [
          {
            "text": "I am just starting with using SkiaSharp and the first thing I noticed was it wasn\u0027t obvious as to where to go to get started",
            "source": "body",
            "interpretation": "New-user onboarding pain point \u2014 documentation discovery is poor"
          },
          {
            "text": "Could we add a \u0027Getting Started\u0027 to the readme.md?",
            "source": "body",
            "interpretation": "Concrete proposal for a specific README improvement"
          },
          {
            "text": "I\u0027d be happy to collaborate on this and help out",
            "source": "body",
            "interpretation": "Reporter offered to contribute \u2014 community engagement opportunity"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/documentation",
            "expandedReason": "The request is specifically about improving documentation \u2014 adding a Getting Started section to the README with links to tutorials, guides, and API docs. No code change or new functionality is requested.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "While it improves the README, the content is purely about documentation links and onboarding text, not a code or feature enhancement."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/Docs",
            "expandedReason": "The change targets README.md which is project documentation. The area/Docs label is the correct fit for documentation improvements."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "The request is still partially valid \u2014 while the README has been improved with badge links since 2019, it still lacks a dedicated Getting Started section. The reporter offered to contribute. This is a low-effort improvement that would help new users."
          }
        ],
        "uncertainties": [
          "Whether the maintainer considers the current badge links sufficient for new user onboarding",
          "Whether the Xamarin-era tutorial links from 2019 are still current or need MAUI equivalents"
        ],
        "assumptions": [
          "Assumed the request is still relevant despite being from 2019, since the README still lacks a dedicated Getting Started section"
        ],
        "resolution": {
          "hypothesis": "New users struggle to find getting-started resources because the README lacks a prominent onboarding section. The badge links exist but are not discoverable by users looking for a clear starting point.",
          "proposals": [
            {
              "title": "Add Getting Started section to README",
              "description": "Add a \u0027## Getting Started\u0027 section between the platform list and \u0027Using SkiaSharp\u0027 with links to the SkiaSharp guides, API docs, and samples directory. Low effort, high discoverability improvement.",
              "confidence": 0.85,
              "effort": "low",
              "category": "fix",
              "codeSnippet": "## Getting Started\n\nNew to SkiaSharp? Here are some resources to help you get started:\n\n- **[SkiaSharp Guides](https://docs.microsoft.com/xamarin/graphics-games/skiasharp/)** \u2014 Tutorials and walkthroughs\n- **[API Documentation](https://docs.microsoft.com/dotnet/api/SkiaSharp/)** \u2014 Complete API reference\n- **[Samples](samples/)** \u2014 Example projects for various platforms\n- **[Skia API Reference](https://skia.org/)** \u2014 Underlying Skia engine documentation",
              "validated": "untested"
            },
            {
              "title": "Create a dedicated getting-started.md",
              "description": "Create documentation/getting-started.md with step-by-step setup for each platform (MAUI, WPF, Console, Blazor) and link from README. More comprehensive but higher effort.",
              "confidence": 0.75,
              "effort": "medium",
              "category": "alternative"
            },
            {
              "title": "Enhance existing \u0027Using SkiaSharp\u0027 section",
              "description": "Instead of a new section, expand \u0027Using SkiaSharp\u0027 to include a minimal code example and links to guides alongside the NuGet install instructions.",
              "confidence": 0.7,
              "effort": "low",
              "category": "alternative"
            }
          ],
          "recommendedProposal": "Add Getting Started section to README",
          "recommendedReason": "Lowest effort, directly addresses the request, and follows the existing README pattern of linking to detailed docs."
        },
        "codeInvestigation": [
          {
            "file": "README.md",
            "lines": "10-13",
            "relevance": "README already has badge links to SkiaSharp API Docs, HarfBuzzSharp API Docs, and SkiaSharp Guides \u2014 partial coverage of what was requested, but badges are easy to miss and not organized as a \u0027Getting Started\u0027 section"
          },
          {
            "file": "README.md",
            "lines": "38-49",
            "relevance": "The \u0027Using SkiaSharp\u0027 section only covers NuGet install, not how to actually use the API. No code examples, no \u0027hello world\u0027, no tutorial links in the main text"
          },
          {
            "file": "README.md",
            "lines": "57-64",
            "relevance": "Building section links to documentation/building.md \u2014 shows pattern of linking to detailed docs, which could be replicated for a Getting Started section"
          },
          {
            "file": "documentation/",
            "lines": "N/A",
            "relevance": "15 documentation markdown files exist covering architecture, building, APIs, etc. \u2014 but no getting-started.md or introduction.md for new users"
          },
          {
            "file": "samples/",
            "lines": "N/A",
            "relevance": "Samples directory exists with Basic and Gallery projects, but README doesn\u0027t prominently link to these for new users"
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.8,
          "reason": "Valid documentation improvement request. README still lacks a dedicated Getting Started section despite having badge links. Low-effort change with high value for new users."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply documentation and docs labels",
            "reason": "Matches classification as a documentation request about project docs",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "type/documentation",
                "area/Docs"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge request and note partial progress since 2019",
            "reason": "Issue has had zero comments since 2019 \u2014 a response acknowledges the valid request and provides context on what already exists",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the suggestion. The README has gained some documentation links since this was filed (API docs and guides badges at the top), but a dedicated Getting Started section would make these more discoverable for new users.\n\nA section like this between the platform list and \u0022Using SkiaSharp\u0022 would address the gap:\n\n\u0060\u0060\u0060markdown\n## Getting Started\n\nNew to SkiaSharp? Here are some resources to help you get started:\n\n- **[SkiaSharp Guides](https://docs.microsoft.com/xamarin/graphics-games/skiasharp/)** \u2014 Tutorials and walkthroughs\n- **[API Documentation](https://docs.microsoft.com/dotnet/api/SkiaSharp/)** \u2014 Complete API reference\n- **[Samples](samples/)** \u2014 Example projects for various platforms\n\u0060\u0060\u0060\n\nContributions welcome if you\u0027d still like to help with this.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-911-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/911"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 607,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-22T12:00:00Z",
        "currentLabels": [
          "type/enhancement",
          "type/feature-request"
        ],
        "state": "open"
      },
      "summary": "SKTouchAction.Entered and Exited events are never fired on iOS/Android \u2014 only implemented on Windows (UWP/WinUI) and Tizen",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.8
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.92
        },
        "platforms": [
          {
            "value": "os/iOS",
            "confidence": 0.92
          },
          {
            "value": "os/Android",
            "confidence": 0.92
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.88
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            471,
            1048
          ],
          "codeSnippets": [
            {
              "code": "var touchType = e.ActionType;\nvar touchpt = e.Location.ToFormsPoint();\nvar viewScale = 2.0;\nvar touchIsInside = !(touchpt.X \u003C 0 || touchpt.Y \u003C 0 || touchpt.X \u003E Bounds.Width * viewScale || touchpt.Y \u003E Bounds.Height * viewScale);\nif (touchType.Equals(SKTouchAction.Moved) \u0026\u0026 TouchesAreInside != touchIsInside \u0026\u0026\n    Device.RuntimePlatform.Equals(Device.iOS) || Device.RuntimePlatform.Equals(Device.Android))\n{\n    if (TouchesAreInside)\n    {\n        TouchesAreInside = false;\n        touchType = SKTouchAction.Exited;\n    }\n    else\n    {\n        TouchesAreInside = true;\n        touchType = SKTouchAction.Entered;\n    }\n}",
              "language": "csharp",
              "context": "Reporter\u0027s workaround code from comment 3, manually synthesizing Entered/Exited from Moved events on iOS/Android"
            }
          ]
        },
        "versionAnalysis": {
          "reason": "Issue filed in 2018 against Xamarin.Forms-era SkiaSharp. The gap persists in current MAUI Views \u2014 Android and Apple SKTouchHandler still do not emit Entered/Exited.",
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "The SKTouchAction enum defines Entered and Exited values, but the Android and Apple (iOS) SKTouchHandler implementations never fire them. Windows wires PointerEntered/PointerExited events, and Tizen maps PointStateType.Leave to Exited. The original issue requests parity: iOS and Android should synthesize enter/exit from touch-move events by checking if the touch is inside view bounds. The reporter also noted a coordinate-scaling bug when doing manual bounds checks. Maintainer mattleibow acknowledged this as future work in Dec 2018.",
        "keySignals": [
          {
            "text": "Currently iOS is implemented only on UWP (because it is connected as a passthrough), but it would be useful to have this functionality connected on iOS/Android",
            "source": "body",
            "interpretation": "Reporter identifies that Entered/Exited only work on UWP, not iOS/Android"
          },
          {
            "text": "UWP already fires the entered/exited events, given that they exist in the enum, and there is no mention that they do not work on Android/iOS it is reasonable to assume that they will fire.",
            "source": "comment-2",
            "interpretation": "Inconsistency between platforms is confusing \u2014 the enum suggests cross-platform support but implementation is partial"
          },
          {
            "text": "the touch provided is not with reference to the bounds, e.g. I have a button at (450,500), but the point co-ordinates begin at 0",
            "source": "comment-3",
            "interpretation": "Reporter found coordinate-space issues when implementing manual enter/exit workaround"
          },
          {
            "text": "This is something that we will be looking at in the future.",
            "source": "comment-4",
            "interpretation": "Maintainer acknowledged and deferred \u2014 still open as of now"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "The Entered/Exited events were never implemented on iOS/Android \u2014 this is a missing feature, not broken behavior. The enum values exist but the platform handlers never emit them. Reporter explicitly titled this \u0027Feature Request\u0027.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "Could be argued as a bug since the enum implies cross-platform support, but the behavior was never implemented \u2014 it\u0027s a gap, not a regression."
              },
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement improves existing functionality; this is adding entirely new event-firing behavior to two platforms."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "SKTouchHandler is part of the SkiaSharp.Views layer (platform-specific touch handling for SKCanvasView). The Maui equivalent is in SkiaSharp.Views.Maui.Core but the area label covers both.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "Issue predates MAUI (filed 2018 for Xamarin.Forms), but the gap exists in both. area/SkiaSharp.Views is more general."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/iOS, os/Android",
            "expandedReason": "Reporter specifically identifies iOS and Android as the platforms missing Entered/Exited support. Windows/UWP works. Code investigation confirms the gap is in the Android and Apple platform handlers."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "The core issue is cross-platform inconsistency \u2014 the same SKTouchAction enum values produce events on Windows but are silently ignored on iOS/Android."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Code investigation of current MAUI-era handlers confirms the gap persists. Android and Apple SKTouchHandler still do not emit Entered/Exited."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "The feature request is valid and acknowledged by the maintainer. The gap persists in current code. No fix has been applied."
          }
        ],
        "uncertainties": [
          "Whether Android\u0027s HoverListener (MotionEventActions.HoverEnter/HoverExit) should be used instead of synthesizing from Move events \u2014 hover events are mouse/stylus-specific, not touch",
          "Whether the coordinate-scaling issue reported in comment 3 is a separate bug or specific to the reporter\u0027s workaround approach",
          "Whether macOS (non-touch, mouse-based) should also get Entered/Exited support via NSTrackingArea"
        ],
        "assumptions": [
          "Issue was filed against Xamarin.Forms but the gap is identical in current MAUI codebase \u2014 treating as still relevant",
          "Maintainer\u0027s 2018 acknowledgment has not been superseded by a decision to not implement"
        ],
        "resolution": {
          "hypothesis": "iOS and Android SKTouchHandler implementations need to synthesize Entered/Exited events. On Android, this can be done by tracking whether the touch is inside view bounds during Move events. On iOS, bounds-checking during TouchesMoved achieves the same. For mouse/stylus, Android\u0027s HoverListener provides native enter/exit events.",
          "proposals": [
            {
              "title": "Synthesize Entered/Exited from Move events",
              "description": "During touch Move events, check if the touch position has crossed the view bounds. Track an isInside boolean per pointer ID and fire Entered/Exited when the state changes. This matches the reporter\u0027s pseudocode and provides parity with Windows behavior for touch input.",
              "confidence": 0.75,
              "effort": "medium",
              "category": "fix"
            },
            {
              "title": "Use Android HoverListener for mouse/stylus enter/exit",
              "description": "On Android, use View.setOnHoverListener to capture MotionEventActions.HoverEnter and HoverExit for mouse and stylus devices. This provides native enter/exit for non-touch inputs without synthesis.",
              "confidence": 0.7,
              "effort": "medium",
              "category": "fix"
            },
            {
              "title": "User-side workaround: manual bounds check in Touch handler",
              "description": "Track touch state manually in the Touch event callback by checking if Location is within the view bounds during Moved events. Reporter provided working code (with scaling hack). This works today without SkiaSharp changes.",
              "confidence": 0.8,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "bool isInside = true;\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    if (e.ActionType == SKTouchAction.Pressed)\n        isInside = true;\n    else if (e.ActionType == SKTouchAction.Moved)\n    {\n        var view = (SKCanvasView)sender;\n        var inBounds = e.Location.X \u003E= 0 \u0026\u0026 e.Location.Y \u003E= 0 \u0026\u0026\n                       e.Location.X \u003C= view.CanvasSize.Width \u0026\u0026\n                       e.Location.Y \u003C= view.CanvasSize.Height;\n        if (isInside \u0026\u0026 !inBounds)\n        {\n            isInside = false;\n            // Handle as Exited\n        }\n        else if (!isInside \u0026\u0026 inBounds)\n        {\n            isInside = true;\n            // Handle as Entered\n        }\n    }\n    e.Handled = true;\n}",
              "validated": "untested"
            }
          ],
          "recommendedProposal": "Synthesize Entered/Exited from Move events",
          "recommendedReason": "Provides true cross-platform parity. The workaround requires every consumer to implement bounds-checking, while a framework-level fix handles it once."
        },
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/SKTouchEventArgs.cs",
            "lines": "60-69",
            "relevance": "SKTouchAction enum defines Entered (line 62) and Exited (line 67) values \u2014 these are part of the public API surface but only partially implemented across platforms"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "lines": "63-109",
            "relevance": "Android OnTouch switch handles Down/PointerDown, Move, Up/PointerUp, Cancel \u2014 no case for Entered or Exited. The MotionEventActions enum doesn\u0027t have direct equivalents; synthesis from Move events would be needed."
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "lines": "54-95",
            "relevance": "Apple handler overrides TouchesBegan/Moved/Ended/Cancelled \u2014 no support for enter/exit. UIKit doesn\u0027t have direct touch enter/exit events; would need bounds-checking during TouchesMoved."
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Windows/SKTouchHandler.cs",
            "lines": "29-66",
            "relevance": "Windows handler wires PointerEntered/PointerExited and maps them to SKTouchAction.Entered/Exited \u2014 confirms this IS implemented on Windows/WinUI."
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Tizen/SKTouchHandler.cs",
            "lines": "65-73",
            "relevance": "Tizen maps PointStateType.Leave to SKTouchAction.Exited \u2014 partial support exists on Tizen too, but no Entered mapping."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.88,
          "reason": "Valid feature request acknowledged by maintainer. Gap confirmed in current MAUI codebase. No fix has been applied."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply feature-request, views, iOS, Android, compatibility labels; remove redundant enhancement",
            "reason": "Matches classification. Currently has both type/enhancement and type/feature-request \u2014 should only have one type label.",
            "confidence": 0.88,
            "payload": {
              "labelsToAdd": [
                "type/feature-request",
                "area/SkiaSharp.Views",
                "os/iOS",
                "os/Android",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "type/enhancement"
              ]
            }
          },
          {
            "id": "link-1",
            "type": "link-related",
            "risk": "low",
            "description": "Cross-reference related touch issues #471 and #1048",
            "reason": "#471 reports the same iOS exit-event gap. #1048 reports missing Cancelled events on iOS in ScrollView \u2014 same SKTouchHandler code path.",
            "confidence": 0.8,
            "payload": {
              "relatedIssues": [
                471,
                1048
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis confirming the gap still exists in MAUI and provide workaround",
            "reason": "Issue is 7 years old with no update since maintainer acknowledgment. Confirming current status and providing a workaround helps the reporter and future visitors.",
            "confidence": 0.82,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "workaround",
              "draftBody": "This gap still exists in the current MAUI-era codebase. The Android and Apple \u0060SKTouchHandler\u0060 implementations handle Pressed, Moved, Released, and Cancelled \u2014 but never fire \u0060SKTouchAction.Entered\u0060 or \u0060SKTouchAction.Exited\u0060. Windows (WinUI) wires \u0060PointerEntered\u0060/\u0060PointerExited\u0060 and Tizen maps \u0060PointStateType.Leave\u0060, so those platforms do fire these events.\n\nHere\u0027s a workaround you can use in the meantime \u2014 track bounds crossings manually during Move events:\n\n\u0060\u0060\u0060csharp\nbool isInside = true;\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    if (e.ActionType == SKTouchAction.Pressed)\n        isInside = true;\n    else if (e.ActionType == SKTouchAction.Moved)\n    {\n        var view = (SKCanvasView)sender;\n        var inBounds = e.Location.X \u003E= 0 \u0026\u0026 e.Location.Y \u003E= 0 \u0026\u0026\n                       e.Location.X \u003C= view.CanvasSize.Width \u0026\u0026\n                       e.Location.Y \u003C= view.CanvasSize.Height;\n        if (isInside \u0026\u0026 !inBounds)\n        {\n            isInside = false;\n            // Handle as Exited\n        }\n        else if (!isInside \u0026\u0026 inBounds)\n        {\n            isInside = true;\n            // Handle as Entered\n        }\n    }\n    e.Handled = true;\n}\n\u0060\u0060\u0060\n\nNote: touch coordinates in \u0060e.Location\u0060 are in canvas pixel space (not view/layout space), so the bounds check uses \u0060CanvasSize\u0060 rather than the layout bounds.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-607-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/607"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 576,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp",
          "backend/OpenGL"
        ],
        "state": "open"
      },
      "summary": "User reports GPU memory leaks with SKSurface.Snapshot() on Intel HD Graphics \u2014 resolved as user error (not disposing SKImage before overwriting reference)",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.85
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.85
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://user-images.githubusercontent.com/41022806/42469527-fdefdc92-8385-11e8-96d5-cfa8b693ae34.png",
              "context": "Visual Studio memory usage showing 30-40MB step-ups",
              "source": "description"
            }
          ],
          "stepsToReproduce": [
            "Create a GPU-backed SKSurface using GRContext with OpenGL (Intel HD Graphics 520)",
            "Call surface.Snapshot() in a loop and store result in an array/dictionary",
            "Overwrite previous SKImage reference without calling Dispose() first",
            "Observe 30-40MB memory step-ups per iteration until crash"
          ],
          "codeSnippets": [
            {
              "code": "var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\nsurface.Dispose();\n_skiaMain.DisplayPlaneRecompose[plane] = false;",
              "language": "csharp",
              "context": "Code that leaks GPU memory \u2014 Snapshot() creates new SKImage each iteration without disposing the previous DisplayImages[plane] reference"
            }
          ],
          "environmentDetails": "Intel HD Graphics 520, Visual Studio, Windows (implied from VS usage)"
        },
        "versionAnalysis": {
          "reason": "No specific SkiaSharp version mentioned. Issue is from 2018 and relates to fundamental GPU resource management patterns that are unchanged.",
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "Reporter observed GPU memory leaks when repeatedly calling SKSurface.Snapshot() in a render loop. The root cause, confirmed by the reporter in comment 2, was overwriting the stored SKImage reference without disposing the previous one. Since SKImage is ISKReferenceCounted and GPU-backed, the finalizer alone cannot reliably reclaim GPU memory in a timely manner. This is expected behavior requiring explicit disposal, not a SkiaSharp bug.",
        "keySignals": [
          {
            "text": "Every time I run through this section of code visual studios shows 30-40MB step ups in memory usage until eventually it crashes",
            "source": "body",
            "interpretation": "Each Snapshot() creates a new GPU-backed SKImage (~30MB). Without disposing the old one, GPU memory grows unbounded."
          },
          {
            "text": "_skiaMain.DisplayImages[plane] = surface.Snapshot();",
            "source": "body",
            "interpretation": "Overwrites the previous SKImage reference without Dispose() \u2014 the GPU texture backing the old SKImage is leaked."
          },
          {
            "text": "The issue actually was appearing based on the snapshot() because when I would overwrite the SkImage without disposing first then the ref was getting lost",
            "source": "comment 2",
            "interpretation": "Reporter confirmed root cause is user error \u2014 not disposing SKImage before overwriting the reference."
          },
          {
            "text": "when it was getting lost in the GPU memory GC.Collect was not cleaning up the lost reference",
            "source": "comment 2",
            "interpretation": "GC finalizer cannot reliably release GPU resources on Intel integrated graphics. Explicit Dispose() is required."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "Reporter initially believed this was a SkiaSharp bug, but comment 2 confirms the root cause is user error \u2014 not disposing SKImage before overwriting the reference. The maintainer\u0027s guidance resolved the issue. This is a usage/understanding question about GPU resource management, not broken behavior in SkiaSharp.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "Reporter confirmed in comment 2 that the leak was caused by their own code not disposing SKImage. SkiaSharp\u0027s Snapshot() API works as designed \u2014 it returns a new reference-counted image that the caller must dispose."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The issue involves core SkiaSharp types SKSurface and SKImage, not view-layer components."
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "The issue is specific to GPU-backed surfaces created with a GRContext (OpenGL). The commented-out line in the code shows the user tried CPU surfaces without the leak, confirming the GPU-specific nature."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The underlying pattern \u2014 needing to explicitly dispose GPU-backed SKImage objects \u2014 remains true in current SkiaSharp. This is fundamental to how reference-counted GPU resources work."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The reporter confirmed the solution in comment 2. The maintainer provided correct diagnosis. The issue is resolved \u2014 the user needed to dispose SKImage before overwriting references. Can be closed as answered."
          }
        ],
        "uncertainties": [
          "Whether the issue was specific to Intel HD Graphics 520 or affects all GPU backends equally (likely all, since the root cause is missing Dispose())"
        ],
        "assumptions": [
          "Assumed Windows platform based on Visual Studio usage and Intel HD Graphics reference"
        ],
        "resolution": {
          "hypothesis": "The user was creating GPU-backed SKImage objects via Snapshot() in a loop and overwriting the stored reference without disposing the previous SKImage. GPU texture memory is not reclaimed by the GC finalizer in a timely manner, requiring explicit Dispose() calls.",
          "proposals": [
            {
              "title": "Dispose previous SKImage before overwriting",
              "description": "Dispose the existing SKImage in DisplayImages[plane] before assigning the new Snapshot() result. This is the correct pattern for managing GPU-backed resources.",
              "confidence": 0.95,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n\n// Dispose old image before overwriting\n_skiaMain.DisplayImages[plane]?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\n\nsurface.Dispose();",
              "validated": "untested"
            },
            {
              "title": "Use using statement with temporary variable",
              "description": "Swap with a temporary variable and dispose old reference using a using pattern for safety.",
              "confidence": 0.9,
              "effort": "low",
              "category": "alternative",
              "codeSnippet": "using var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n\nvar newImage = surface.Snapshot();\nvar oldImage = _skiaMain.DisplayImages[plane];\n_skiaMain.DisplayImages[plane] = newImage;\noldImage?.Dispose();",
              "validated": "untested"
            }
          ],
          "recommendedProposal": "Dispose previous SKImage before overwriting",
          "recommendedReason": "Simplest fix \u2014 one line addition. Directly addresses the confirmed root cause."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKSurface.cs",
            "lines": "274-275",
            "relevance": "Snapshot() creates a new SKImage via sk_surface_new_image_snapshot. Each call returns a new reference-counted object \u2014 caller is responsible for disposal."
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "lines": "16-24",
            "relevance": "SKImage implements ISKReferenceCounted and has a finalizer via SKNativeObject. However, GPU-backed images hold texture references that need timely release via explicit Dispose()."
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "lines": "94-98",
            "relevance": "DisposeNative() calls SafeUnRef() for ISKReferenceCounted objects. The finalizer (~SKNativeObject) at line 229 eventually calls this, but GC scheduling is non-deterministic \u2014 GPU resources may not be freed promptly."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.88,
          "reason": "Reporter confirmed the root cause and solution in comment 2. Maintainer provided correct diagnosis. The issue is fully resolved as a usage question."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Reclassify from type/bug to type/question \u2014 reporter confirmed user error",
            "reason": "Issue was filed as bug but reporter confirmed in comment 2 that the leak was caused by not disposing SKImage before overwriting reference. This is a usage question, not a SkiaSharp defect.",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "type/question"
              ],
              "labelsToRemove": [
                "type/bug"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post closing comment summarizing the resolution",
            "reason": "Issue has been idle since 2018 with the resolution confirmed. A closing comment documents the solution for future searchers.",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "close-message",
              "draftBody": "Thanks for following up with the root cause.\n\nFor anyone landing here: GPU-backed \u0060SKImage\u0060 objects returned by \u0060SKSurface.Snapshot()\u0060 hold texture references that must be explicitly disposed. If you overwrite a stored \u0060SKImage\u0060 reference without calling \u0060Dispose()\u0060 first, the GPU memory won\u0027t be reclaimed promptly (the GC finalizer is non-deterministic for GPU resources).\n\n\u0060\u0060\u0060csharp\n// Dispose the old image before overwriting\n_skiaMain.DisplayImages[plane]?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\n\u0060\u0060\u0060\n\nClosing as resolved \u2014 the reporter confirmed this was the fix.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-576-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as resolved \u2014 reporter confirmed the fix",
            "reason": "Reporter confirmed in comment 2 that disposing SKImage before overwriting resolved the memory leak. Issue has been idle since July 2018.",
            "confidence": 0.85,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/576"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 552,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-22T12:00:00Z",
        "currentLabels": [
          "type/enhancement",
          "area/SkiaSharp.Views"
        ],
        "state": "open"
      },
      "summary": "Investigate reusing SKSurface instances across draw calls in view implementations to improve performance",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "tenets": [
          {
            "value": "tenet/performance",
            "confidence": 0.92
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            534
          ],
          "codeSnippets": [
            {
              "code": "It appears the constructing a SKSurface is expensive, so we should see if we can reuse instances across draws.",
              "language": "text",
              "context": "Issue description \u2014 the core observation motivating this enhancement"
            }
          ]
        },
        "versionAnalysis": {
          "reason": "Filed against SkiaSharp 1.x era (June 2018). The underlying performance concern about SKSurface construction cost remains relevant in current SkiaSharp \u2014 some views still create new SKSurface each frame (WPF, WinUI, Blazor, Android) while GTK3 already reuses surfaces. The enhancement is still applicable.",
          "currentRelevance": "likely"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.8,
          "reason": "Partially addressed. GTK3 SKDrawingArea already reuses SKSurface across draws when size is unchanged. Apple SKCGSurfaceFactory reuses backing memory but still creates new SKSurface per draw. WPF SKElement, WinUI SKXamlCanvas, Blazor SKCanvasView, and Android SurfaceFactory all create new SKSurface each frame. The inconsistency across platforms means the enhancement is not fully implemented.",
          "verificationStatus": "inconclusive"
        }
      },
      "analysis": {
        "summary": "This is a self-filed enhancement by the maintainer (mattleibow) to investigate reusing SKSurface instances across draw calls in SkiaSharp view implementations. The concern is that SKSurface.Create() has non-trivial cost per frame. Code investigation shows inconsistent patterns across platforms \u2014 GTK3 already reuses surfaces, while WPF, WinUI, Blazor, and Android create new ones per frame.",
        "keySignals": [
          {
            "text": "It appears the constructing a SKSurface is expensive, so we should see if we can reuse instances across draws.",
            "source": "body",
            "interpretation": "Maintainer has profiled or observed that SKSurface construction is a hot path in view rendering."
          },
          {
            "text": "Here is PR that was created to improve drawing: #534",
            "source": "body",
            "interpretation": "References GTK rendering performance issue \u2014 suggests this enhancement was motivated by real-world slow rendering reports."
          },
          {
            "text": "Filed by mattleibow (maintainer)",
            "source": "labels",
            "interpretation": "Self-filed enhancement \u2014 high signal that this is a legitimate performance concern from someone who knows the codebase."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/enhancement",
            "expandedReason": "The issue explicitly asks to improve existing view implementations by reusing SKSurface instances. This is an optimization of existing functionality, not a new feature or a bug fix. The existing labels correctly classify this.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "Not requesting new functionality \u2014 the views already work, this is about making them faster."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The enhancement targets SKSurface usage in view implementations across platforms (WPF, Android, iOS, GTK, WinUI, Blazor). All affected code is in the SkiaSharp.Views package family."
          },
          {
            "field": "tenets",
            "chosen": "tenet/performance",
            "expandedReason": "The core concern is rendering performance \u2014 reducing per-frame allocation cost of SKSurface.Create(). This is a pure performance optimization."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "false",
            "expandedReason": "GTK3 SKDrawingArea already reuses surfaces (the desired pattern exists), but WPF, WinUI, Blazor, Apple, and Android views still create new SKSurface each frame. The enhancement is partially addressed but not systematically applied across all platforms."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The per-frame SKSurface.Create() pattern still exists in most view implementations. The performance concern about allocation cost is architecture-level and hasn\u0027t been obsoleted by any Skia or .NET changes."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a legitimate performance enhancement filed by the maintainer. The investigation is still valid \u2014 most view platforms haven\u0027t adopted the surface-reuse pattern that GTK3 already uses. No reason to close."
          }
        ],
        "uncertainties": [
          "Whether SKSurface.Create() wrapping an existing memory buffer is actually expensive enough to warrant the complexity of caching the surface object (vs just caching the backing buffer)",
          "Whether reusing SKSurface has correctness implications \u2014 the surface\u0027s internal state (canvas, dirty regions) may need resetting between frames",
          "Whether modern Skia versions have optimized SKSurface creation enough to make this enhancement low-priority"
        ],
        "assumptions": [
          "Assumed the performance concern in the 2018 issue remains relevant since the same SKSurface.Create() pattern is still used in most views",
          "Assumed GTK3 SKDrawingArea\u0027s surface reuse pattern is the reference implementation since it\u0027s the only view that caches the SKSurface object"
        ],
        "resolution": {
          "hypothesis": "SKSurface.Create() has non-trivial per-call overhead even when wrapping pre-allocated memory. Caching the surface object (as GTK3 does) and only recreating on size change would reduce per-frame allocation pressure across all view platforms.",
          "proposals": [
            {
              "title": "Adopt GTK3 surface-reuse pattern across all views",
              "description": "Refactor WPF, WinUI, Blazor, Apple, and Android view implementations to store SKSurface as a field and only recreate when the backing buffer size changes, matching the existing GTK3 SKDrawingArea pattern. Requires careful handling of surface disposal on size change and view teardown.",
              "confidence": 0.8,
              "effort": "medium",
              "category": "fix",
              "validated": "untested"
            },
            {
              "title": "Benchmark SKSurface.Create() to quantify the gain",
              "description": "Before refactoring all views, profile SKSurface.Create() with pre-allocated memory to measure actual per-call cost. If the cost is negligible in current Skia, the enhancement may be deprioritized. Use BenchmarkDotNet with varying surface sizes.",
              "confidence": 0.85,
              "effort": "low",
              "category": "investigation",
              "validated": "untested"
            },
            {
              "title": "Extract shared SurfaceCache utility",
              "description": "Create a shared internal SurfaceCache class (like SurfaceFactory but with surface reuse) that all view implementations can use. Centralizes the caching logic and ensures consistent behavior across platforms. Reduces per-platform maintenance.",
              "confidence": 0.7,
              "effort": "medium",
              "category": "fix",
              "validated": "untested"
            }
          ],
          "recommendedProposal": "Benchmark SKSurface.Create() to quantify the gain",
          "recommendedReason": "Before investing effort in refactoring all platform views, a quick benchmark would confirm whether the optimization is still worthwhile with current Skia versions. If significant, proceed with the shared SurfaceCache approach."
        },
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Gtk3/SKDrawingArea.cs",
            "lines": "12-88",
            "relevance": "GTK3 view ALREADY implements surface reuse \u2014 stores SKSurface as a field and only recreates when size changes (line 78-88). This is the target pattern the enhancement wants to adopt across all views."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Apple/SKCGSurfaceFactory.cs",
            "lines": "25-66",
            "relevance": "Apple factory reuses backing NSMutableData buffer when size unchanged (line 42-46), but still calls SKSurface.Create() each frame (line 66). Partial reuse \u2014 buffer allocated once, surface object recreated."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SurfaceFactory.cs",
            "lines": "30-57",
            "relevance": "Android factory reuses Bitmap but creates new SKSurface each frame (line 50) and explicitly disposes it in DrawSurface (line 57). No surface reuse."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "lines": "63-83",
            "relevance": "WPF creates new SKSurface each frame with \u0027using\u0027 statement (line 73). Reuses WriteableBitmap but not the surface. No surface reuse."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "lines": "195",
            "relevance": "WinUI creates new SKSurface each frame with \u0027using\u0027 statement. Same pattern as WPF \u2014 no surface reuse."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SKCanvasView.razor.cs",
            "lines": "95",
            "relevance": "Blazor creates new SKSurface each frame with \u0027using\u0027 statement. No surface reuse."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.88,
          "reason": "Legitimate performance enhancement filed by maintainer. Most view platforms still use per-frame SKSurface creation. The enhancement is partially implemented (GTK3) but not systematically applied."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add tenet/performance label to reflect the performance optimization nature of this enhancement",
            "reason": "Current labels correctly have type/enhancement and area/SkiaSharp.Views but miss the performance tenet which is the core concern",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "tenet/performance"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/552"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 533,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "status/help-wanted",
          "os/Android",
          "area/SkiaSharp.Views",
          "backend/OpenGL"
        ],
        "state": "open"
      },
      "summary": "SKGLView on Android runs at uncapped framerates (300-1000fps) after switch from GLSurfaceView to TextureView \u2014 no VSync or frame pacing in custom GL thread",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.82
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.95
          }
        ],
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/performance",
            "confidence": 0.9
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "severity": "medium",
          "severityReason": "Uncapped FPS wastes battery and CPU/GPU resources but does not crash. Frame-based animations break, but a time-based approach is the correct pattern anyway. Workaround exists.",
          "hasWorkaround": true,
          "workaroundSummary": "Use a time-based game loop instead of frame-based. Alternatively, use a Stopwatch-based frame limiter in the PaintSurface callback to throttle rendering to the desired FPS.",
          "targetFrameworks": [
            "net8.0-android"
          ]
        },
        "reproEvidence": {
          "relatedIssues": [
            2112,
            2555
          ],
          "stepsToReproduce": [
            "Create a Xamarin.Forms or MAUI project with an SKGLView",
            "Set HasRenderLoop to true",
            "In PaintSurface, measure elapsed time between calls",
            "Observe FPS exceeds 60 (often 300-1000fps depending on device)"
          ],
          "codeSnippets": [
            {
              "code": "Stopwatch sw = Stopwatch.StartNew();\nTimeSpan last;\n\nprivate void OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var c = sw.Elapsed;\n    var ts = c - last;\n    last = c;\n    var fps = 1.0 / (ts.TotalSeconds);\n    Log.Debug(\u0022FPS\u0022, fps.ToString(\u00220,000.00\u0022));\n}",
              "language": "csharp",
              "context": "FPS measurement code from maintainer comment"
            }
          ],
          "environmentDetails": "Android 7\u002B API 24, Samsung Galaxy S7 Edge. Also confirmed on Motorola Moto g6 (API 28), Galaxy Note 3 (API 21), and emulators."
        },
        "versionAnalysis": {
          "reason": "The root cause (GLTextureView lacks eglSwapInterval/VSync) is still present in the current codebase. The GLTextureView.cs custom GL thread has no frame pacing mechanism.",
          "mentionedVersions": [
            "1.59.3",
            "1.60.1"
          ],
          "currentRelevance": "likely"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Behavior changed when SkiaSharp switched from Android\u0027s GLSurfaceView (which has built-in VSync via eglSwapInterval) to a custom GLTextureView (which does not set eglSwapInterval). Maintainer confirmed this in comment 2.",
          "workedInVersion": "1.59.3",
          "brokeInVersion": "1.60.1"
        }
      },
      "analysis": {
        "summary": "The Android SKGLView renders at uncapped framerates because the custom GLTextureView implementation does not call eglSwapInterval to enable VSync. The old GLSurfaceView had VSync built-in. The maintainer acknowledged this is a real issue and investigated Choreographer as a potential fix, but no implementation was made.",
        "keySignals": [
          {
            "text": "Application framerate went from a capped 60fps to a ~300fps",
            "source": "body",
            "interpretation": "Clear regression in frame pacing after version upgrade"
          },
          {
            "text": "we are no longer using the old GLSurfaceView to render the content, but the new TextureView",
            "source": "comment 2",
            "interpretation": "Maintainer identifies root cause as the GLSurfaceView\u2192TextureView migration"
          },
          {
            "text": "Having uncapped is nice, but a heavy drain. Also, it is no point having the updates faster than the screen - that wastes resources.",
            "source": "comment 8",
            "interpretation": "Maintainer confirms uncapped FPS is a problem worth fixing"
          },
          {
            "text": "We might be able to look at Choreographer",
            "source": "comment 9",
            "interpretation": "Maintainer proposed Choreographer as potential solution but never implemented it"
          },
          {
            "text": "I really need to look at this. Noticing 1.2K FPS in some emulators.",
            "source": "comment 6",
            "interpretation": "Maintainer re-confirmed the problem persists 2 years later"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a behavioral regression: FPS was capped at 60 in 1.59.3 (GLSurfaceView with VSync) and became uncapped in 1.60.1 (GLTextureView without VSync). The maintainer acknowledged it as a real problem worth fixing. Frame-based animations break and battery is wasted.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "While adding Choreographer support would be an enhancement, the core issue is a regression \u2014 VSync was removed when switching to TextureView. Existing behavior broke."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The issue is in the Android platform view layer (GLTextureView, SKGLTextureView, SKGLViewHandler.Android), all part of SkiaSharp.Views."
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "The issue is specific to the OpenGL rendering path (GLTextureView, EGL). CPU-based SKCanvasView is not affected."
          },
          {
            "field": "platforms",
            "chosen": "os/Android",
            "expandedReason": "The GLTextureView custom implementation is Android-specific. iOS and other platforms have their own rendering pipelines."
          },
          {
            "field": "tenets",
            "chosen": "tenet/performance",
            "expandedReason": "Uncapped FPS wastes CPU/GPU cycles and drains battery. Rendering faster than the display refresh rate provides no visual benefit."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "No crash or data loss. Animations based on frame count break, and battery drains faster than necessary. However, a time-based animation loop is the recommended pattern anyway, and multiple users note the higher FPS is actually beneficial for responsive rendering."
          },
          {
            "field": "regression.isRegression",
            "chosen": "true",
            "expandedReason": "Maintainer confirmed in comment 2 that the switch from GLSurfaceView to TextureView caused the behavior change. Version 1.59.3 was capped, 1.60.1 is not."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The GLTextureView.cs code still does not call eglSwapInterval. The same uncapped render loop exists in the current codebase."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause is clear (missing eglSwapInterval/Choreographer), but the implementation approach needs investigation \u2014 adding eglSwapInterval(1) could cause issues with TextureView, and Choreographer integration is non-trivial. The maintainer explored options but never committed to an approach."
          }
        ],
        "uncertainties": [
          "Whether adding eglSwapInterval(1) to GLTextureView\u0027s EglHelper would work correctly with TextureView-based EGL surfaces",
          "Whether Choreographer-based frame pacing would introduce input latency or other side effects",
          "Whether some users depend on the uncapped behavior for non-display rendering (offscreen rendering, benchmarks)"
        ],
        "assumptions": [
          "Assumed the issue still reproduces on current SkiaSharp since the GLTextureView code has not added any frame pacing",
          "Assumed the reporter\u0027s target framework equivalent today would be net8.0-android since original was Xamarin.Android"
        ],
        "resolution": {
          "hypothesis": "The custom GLTextureView does not set eglSwapInterval(1) like Android\u0027s built-in GLSurfaceView does. This means eglSwapBuffers returns immediately instead of waiting for the next VSync, causing the render thread to loop as fast as possible.",
          "proposals": [
            {
              "title": "Add eglSwapInterval(1) to EglHelper",
              "description": "Add egl.EglSwapInterval(eglDisplay, 1) after creating the EGL surface in GLTextureView.EglHelper. This enables VSync, capping FPS to the display refresh rate. This is what Android\u0027s GLSurfaceView does internally.",
              "confidence": 0.7,
              "effort": "low",
              "category": "fix",
              "validated": "untested"
            },
            {
              "title": "Integrate Android Choreographer for frame pacing",
              "description": "Use Android\u0027s Choreographer API to schedule frame callbacks at the display refresh rate. This is the approach the maintainer proposed in comment 9. More robust than raw eglSwapInterval but requires significant refactoring of the GL thread loop.",
              "confidence": 0.65,
              "effort": "high",
              "category": "fix",
              "validated": "untested"
            },
            {
              "title": "Use time-based animation instead of frame-based",
              "description": "Users can work around the issue by measuring elapsed time between frames and using delta-time for animations instead of assuming a fixed frame rate. This is the correct game loop pattern regardless of frame rate.",
              "confidence": 0.9,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "private readonly Stopwatch _sw = Stopwatch.StartNew();\nprivate TimeSpan _last;\n\nprivate void OnPaintSurface(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = _sw.Elapsed;\n    var deltaTime = (now - _last).TotalSeconds;\n    _last = now;\n\n    // Use deltaTime for all animations instead of assuming fixed FPS\n    var speed = 100.0; // pixels per second\n    position \u002B= speed * deltaTime;\n}",
              "validated": "untested"
            }
          ],
          "recommendedProposal": "Use time-based animation instead of frame-based",
          "recommendedReason": "Immediate workaround for the reporter. Time-based animation is the correct pattern for any frame rate. The underlying fix (eglSwapInterval or Choreographer) should be implemented in SkiaSharp but requires investigation."
        },
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "lines": "634-641",
            "relevance": "The Swap() method calls EglSwapBuffers but does NOT call eglSwapInterval \u2014 this is the missing VSync. Android\u0027s GLSurfaceView sets eglSwapInterval(1) by default which caps FPS to display refresh rate."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "lines": "1081-1083",
            "relevance": "IsReadyToDraw() returns true continuously when renderMode == Rendermode.Continuously, causing the GL thread to loop as fast as possible with no throttle."
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.Android.cs",
            "lines": "61-68",
            "relevance": "MapHasRenderLoop sets RenderMode to Rendermode.Continuously when HasRenderLoop is true, triggering the uncapped render loop in GLTextureView."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLTextureView.cs",
            "lines": "36-43",
            "relevance": "SKGLTextureView extends GLTextureView \u2014 inherits the uncapped render loop. No frame pacing override."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLSurfaceView.cs",
            "lines": "9-10",
            "relevance": "SKGLSurfaceView extends Android\u0027s GLSurfaceView which has native VSync. This is the old implementation that capped FPS correctly."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.8,
          "reason": "Root cause is clear (missing VSync in GLTextureView) but the fix approach needs investigation. Adding eglSwapInterval may not work with TextureView surfaces. Choreographer integration is complex. Issue has been open since 2018 with maintainer acknowledgment.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels are already correct \u2014 no changes needed",
            "reason": "Current labels (type/bug, area/SkiaSharp.Views, os/Android, backend/OpenGL) match classification exactly. Adding tenet/performance.",
            "confidence": 0.95,
            "payload": {
              "labelsToAdd": [
                "tenet/performance"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post workaround with time-based animation pattern",
            "reason": "Issue has been open 6\u002B years with no fix. Providing a concrete workaround helps affected users.",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "workaround",
              "draftBody": "Thanks for the report \u2014 this is a known issue caused by the switch from \u0060GLSurfaceView\u0060 (which has built-in VSync) to a custom \u0060GLTextureView\u0060 that doesn\u0027t call \u0060eglSwapInterval\u0060.\n\nHere\u0027s a workaround you can use now: switch to time-based animation instead of frame-based. This is the correct pattern regardless of frame rate:\n\n\u0060\u0060\u0060csharp\nprivate readonly Stopwatch _sw = Stopwatch.StartNew();\nprivate TimeSpan _last;\n\nprivate void OnPaintSurface(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = _sw.Elapsed;\n    var deltaTime = (now - _last).TotalSeconds;\n    _last = now;\n\n    // Use deltaTime for all animations\n    var speed = 100.0; // pixels per second\n    position \u002B= speed * deltaTime;\n}\n\u0060\u0060\u0060\n\nThe underlying issue (adding \u0060eglSwapInterval\u0060 or Choreographer-based frame pacing to the TextureView render loop) is still open for investigation.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-533-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/533"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 528,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-23T12:00:00Z",
        "currentLabels": [],
        "state": "open"
      },
      "summary": "SKShaper.Shape() returns all-zero Codepoints on Android when typeface created via SKTypeface.FromStream \u2014 workaround is to use SKTypeface.FromData instead",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.9
        },
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.8
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "severity": "medium",
          "severityReason": "Functional breakage of HarfBuzz shaping on Android, but a known workaround exists (FromData instead of FromStream). Does not crash \u2014 produces incorrect output (all-zero codepoints).",
          "hasWorkaround": true,
          "workaroundSummary": "Use SKTypeface.FromData(SKData.Create(stream)) instead of SKTypeface.FromStream(stream). The FromData path produces a typeface whose OpenStream data is correctly read by HarfBuzz on Android.",
          "targetFrameworks": [
            "monoandroid"
          ]
        },
        "reproEvidence": {
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/2035982/HarfBuzzDemo.zip",
              "filename": "HarfBuzzDemo.zip",
              "type": "repro-project",
              "source": "description"
            }
          ],
          "stepsToReproduce": [
            "Load a TTF/OTF font via SKTypeface.FromStream(stream) on Android",
            "Create an SKShaper with the typeface",
            "Call shaper.Shape(\u0022Hello world!\u0022, x, y, paint)",
            "Observe that result.Codepoints are all 0"
          ],
          "codeSnippets": [
            {
              "code": "var shaper = new SKShaper(paint.Typeface);\nvar result = shaper.Shape(\u0022Hello world!\u0022, 10, 300, paint); // result.Codepoints are all 0",
              "language": "csharp",
              "context": "Demonstrates Shape() returning all-zero Codepoints on Android"
            }
          ],
          "environmentDetails": "Android (emulator x86 and LG G4 ARMv8); works on WPF and iOS"
        },
        "versionAnalysis": {
          "reason": "Current SKTypeface.FromStream now converts SKManagedStream to a memory stream before passing to native code (line 105-108 in SKTypeface.cs), which is functionally equivalent to the FromData workaround. The HarfBuzz version has also been updated significantly since 2018. Both changes likely resolve this issue.",
          "mentionedVersions": [
            "1.60.0"
          ],
          "currentRelevance": "unlikely",
          "migrationPath": "Upgrade to latest SkiaSharp (3.x). The FromStream implementation now copies data to memory, matching the FromData workaround behavior."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.8,
          "reason": "SKTypeface.FromStream now converts managed streams to memory streams (SKTypeface.cs:105-108), making it functionally equivalent to the FromData workaround. Additionally, HarfBuzz has been updated since 2018. Both changes address the likely root cause: the managed stream data not being fully materialized in memory when HarfBuzz tried to read the typeface blob on Android.",
          "verificationStatus": "unverified"
        }
      },
      "analysis": {
        "summary": "Android-specific bug where SKShaper.Shape() returned all-zero Codepoints when the typeface was created via SKTypeface.FromStream(). The reporter found that using SKTypeface.FromData() as a workaround fixed the issue. Current code in SKTypeface.FromStream now converts managed streams to memory streams before passing to native Skia, which is functionally the same as the FromData path and likely resolves this issue.",
        "keySignals": [
          {
            "text": "shaper.Shape result CodePoints are all 0",
            "source": "body",
            "interpretation": "HarfBuzz shaping fails silently on Android \u2014 returns zero codepoints instead of glyph IDs"
          },
          {
            "text": "When testing on WPF or iOS, everything seems ok",
            "source": "body",
            "interpretation": "Android-specific issue, suggesting platform-dependent stream/memory handling"
          },
          {
            "text": "Using SKData.Create(stream) and SKTypeface.FromData(data) instead of SKTypeface.FromStream(stream) \u2014 And it works!",
            "source": "comment 10",
            "interpretation": "The workaround confirms the issue is in how FromStream materializes font data \u2014 FromData forces full copy to memory"
          },
          {
            "text": "there is problem in cooperation between C\u002B\u002B/C# on Android with blobs/stream",
            "source": "comment 9",
            "interpretation": "Reporter suspects stream interop issue between managed and native code on Android"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a clear functional failure: Shape() returns all-zero codepoints on Android while working on iOS and WPF. This is broken behavior, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting incorrect output from a working API."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.HarfBuzz",
            "expandedReason": "The bug manifests in SKShaper.Shape() which is in the SkiaSharp.HarfBuzz package. The root cause involves the interaction between SKTypeface stream handling and HarfBuzz blob creation.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "While FromStream is in core SkiaSharp, the observable bug is specifically in HarfBuzz shaping output."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Functional breakage of text shaping on Android \u2014 HarfBuzz output is unusable. However, a clean workaround exists (FromData instead of FromStream) and the issue doesn\u0027t crash the app."
          },
          {
            "field": "platforms",
            "chosen": "os/Android",
            "expandedReason": "Reporter explicitly states the issue only occurs on Android (emulator x86 and phone ARMv8), while iOS and WPF work correctly."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "Cross-platform inconsistency: the same code works on iOS and WPF but fails on Android, indicating a platform compatibility issue in stream handling."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "SKTypeface.FromStream now converts managed streams to memory streams (equivalent to the FromData workaround). The issue is from 2018 and the root cause has been addressed in the current codebase."
          },
          {
            "field": "fixStatus.likelyFixed",
            "chosen": "true",
            "expandedReason": "The current FromStream implementation converts managed streams to memory streams before native handoff (SKTypeface.cs:105-108), matching the FromData workaround that resolved the issue."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unlikely",
            "expandedReason": "Issue filed against 1.60.x era SkiaSharp. Current code has the managed-to-memory stream conversion in FromStream and an updated HarfBuzz, both of which address the likely root cause."
          }
        ],
        "uncertainties": [
          "Cannot verify the fix on actual Android hardware from this environment",
          "The exact Skia/HarfBuzz version that introduced the memory stream conversion is unknown"
        ],
        "assumptions": [
          "Assumed the managed-to-memory stream conversion in FromStream was added after this issue was filed",
          "Assumed no regressions in Android stream handling since the conversion was added"
        ],
        "resolution": {
          "hypothesis": "SKTypeface.FromStream on Android did not fully materialize the font data in memory, causing HarfBuzz to receive invalid/incomplete blob data and fail to resolve glyph codepoints. The current code fixes this by converting managed streams to memory streams.",
          "proposals": [
            {
              "title": "Use SKTypeface.FromData instead of FromStream",
              "description": "The original workaround found by the reporter: create SKData from the stream first, then use SKTypeface.FromData(). This forces a full memory copy of the font data.",
              "confidence": 0.95,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "using var data = SKData.Create(stream);\nusing var typeface = SKTypeface.FromData(data);\nusing var shaper = new SKShaper(typeface);",
              "validated": "untested"
            },
            {
              "title": "Upgrade to latest SkiaSharp",
              "description": "Current SkiaSharp 3.x has the managed-to-memory stream conversion built into FromStream, making it functionally equivalent to the FromData workaround. Upgrading should resolve the issue without code changes.",
              "confidence": 0.8,
              "effort": "low",
              "category": "fix"
            },
            {
              "title": "Use SKTypeface.FromFamilyName for system fonts",
              "description": "For system fonts like Arial or Roboto, use SKTypeface.FromFamilyName() which avoids the stream path entirely. Maintainer mattleibow confirmed this approach works on Android.",
              "confidence": 0.85,
              "effort": "low",
              "category": "alternative"
            }
          ],
          "recommendedProposal": "Upgrade to latest SkiaSharp",
          "recommendedReason": "The root cause is addressed in the current codebase \u2014 FromStream now converts managed streams to memory streams. Upgrading is the cleanest fix."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "lines": "100-113",
            "relevance": "FromStream now converts SKManagedStream to memory stream (line 105-108) before passing to native code. This is functionally the same as the FromData workaround \u2014 the data is fully copied to memory. This change likely fixes the original bug."
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "lines": "115-121",
            "relevance": "FromData calls sk_typeface_create_from_data directly with an SKData handle. This path always worked because SKData holds a contiguous memory buffer \u2014 confirming the workaround."
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "lines": "15-33",
            "relevance": "SKShaper constructor calls Typeface.OpenStream() then ToHarfBuzzBlob(). If the typeface\u0027s internal stream data was incomplete (due to the old FromStream bug), HarfBuzz would receive garbled data and fail to resolve glyph codepoints."
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "lines": "10-38",
            "relevance": "ToHarfBuzzBlob reads the stream\u0027s memory base or copies data. If the stream asset\u0027s backing memory was invalid on Android, HarfBuzz would get bad font data, explaining the all-zero codepoints."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.8,
          "reason": "SKTypeface.FromStream now converts managed streams to memory streams (equivalent to the FromData workaround). The issue is from 2018 and the root cause has been addressed in the current codebase.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, HarfBuzz, Android, compatibility labels",
            "reason": "Matches classification",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/SkiaSharp.HarfBuzz",
                "os/Android",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post close message explaining the fix",
            "reason": "Inform reporter and community that the issue is addressed in current versions",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "close-message",
              "draftBody": "Thanks for the thorough investigation and the workaround using \u0060SKTypeface.FromData()\u0060 \u2014 that was exactly the right diagnosis.\n\nThe root cause was that \u0060SKTypeface.FromStream()\u0060 on Android didn\u0027t fully materialize the font data in memory before passing it to native Skia. HarfBuzz then received incomplete blob data and couldn\u0027t resolve glyph codepoints.\n\nThis has been addressed in current SkiaSharp \u2014 \u0060FromStream()\u0060 now converts managed streams to memory streams internally, which is functionally the same as the \u0060FromData()\u0060 workaround. Upgrading to the latest SkiaSharp should resolve this without any code changes.\n\nClosing as fixed. If anyone still sees this behavior on a recent version, please open a new issue.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-528-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as fixed",
            "reason": "Root cause addressed by managed-to-memory stream conversion in current SKTypeface.FromStream",
            "confidence": 0.8,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/528"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 425,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T17:00:00Z",
        "currentLabels": [
          "type/bug",
          "status/skia-update-required"
        ],
        "state": "open"
      },
      "summary": "SKCodec returns TopLeft origin for DNG files because Skia\u0027s SkRawCodec never reads EXIF orientation \u2014 hardcoded default in upstream.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.85
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "severity": "low",
          "severityReason": "Functional defect \u2014 DNG orientation metadata is silently ignored. Affects DNG photo workflows but has no crash or data loss.",
          "hasWorkaround": false,
          "targetFrameworks": [
            "SkiaSharp (version unspecified)"
          ]
        },
        "reproEvidence": {
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616452/APC_0316.zip",
              "filename": "APC_0316.zip",
              "type": "other"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616453/APC_0193.zip",
              "filename": "APC_0193.zip",
              "type": "other"
            }
          ],
          "relatedIssues": [
            736302
          ],
          "stepsToReproduce": [
            "1. Open a DNG file with non-TopLeft EXIF orientation",
            "2. Create SKCodec from the file stream",
            "3. Read codec.EncodedOrigin (was codec.Origin in old API)",
            "4. Result: always TopLeft regardless of actual EXIF orientation"
          ],
          "codeSnippets": [
            {
              "code": "using (var codec = SKCodec.Create(stream)) { origin = codec.Origin; }",
              "language": "csharp",
              "context": "Reporter\u0027s test code showing Origin returns TopLeft for DNG"
            }
          ]
        },
        "versionAnalysis": {
          "reason": "Source inspection of externals/skia/src/codec/SkRawCodec.cpp confirms the constructor still does not pass origin to base SkCodec. The default kTopLeft_SkEncodedOrigin is hardcoded in SkCodec.h:768. No EXIF orientation extraction exists in the raw codec path.",
          "mentionedVersions": [
            "SkiaSharp (2018 era, pre-MAUI)"
          ],
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "Confirmed upstream Skia limitation. SkRawCodec (handles DNG files) constructs the base SkCodec without passing an SkEncodedOrigin parameter. The base constructor defaults to kTopLeft_SkEncodedOrigin (SkCodec.h:768). The raw codec uses PIEX to extract a JPEG preview from DNG files but never reads or propagates the EXIF orientation tag. Contrast with SkJpegCodec which properly reads EXIF orientation. The existing label status/skia-update-required is correct \u2014 this requires a fix in upstream Skia\u0027s SkRawCodec.",
        "keySignals": [
          {
            "text": "The following sample code results in SKCodecOrigin.TopLeft, which is incorrect",
            "source": "body",
            "interpretation": "Reporter correctly identifies the return value is wrong for their DNG files"
          },
          {
            "text": "The chrome browser is able to auto-orient them as expected",
            "source": "body",
            "interpretation": "Chrome likely uses a different DNG decoder path that reads EXIF orientation, confirming the data IS in the file"
          },
          {
            "text": "status/skia-update-required label",
            "source": "label",
            "interpretation": "Maintainer already identified this as an upstream Skia issue"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "SKCodec.EncodedOrigin returns incorrect data for DNG files. The EXIF orientation exists in the file but is not read by Skia\u0027s raw codec.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "The Origin property exists and claims to return the encoded origin. Returning an incorrect default is a bug, not a missing feature."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "Core codec functionality in the SkiaSharp package. The root cause is in upstream Skia (SkRawCodec.cpp) but surfaces through SKCodec.EncodedOrigin."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "low",
            "expandedReason": "Functional defect with no crash or data loss. Affects a niche use case (DNG files with non-TopLeft orientation). JPEG orientation works correctly."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "Confirmed upstream Skia limitation with correct label (status/skia-update-required). The fix must happen in Skia\u0027s SkRawCodec. No SkiaSharp-side workaround is possible since EncodedOrigin is a direct pass-through to the native API.",
            "alternatives": [
              {
                "value": "close-with-docs",
                "whyRejected": "The bug is real and unfixed. Closing without a fix or viable workaround would be inappropriate."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Source inspection of current externals/skia/src/codec/SkRawCodec.cpp confirms no orientation handling exists. The constructor still omits the origin parameter."
          }
        ],
        "uncertainties": [
          "Whether upstream Skia has a tracking issue for DNG orientation support",
          "Whether PIEX\u0027s PreviewImageData struct contains orientation info that could be extracted",
          "Whether a SkiaSharp-side workaround could read DNG EXIF independently (e.g., via a third-party EXIF library) and apply rotation manually"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s SkRawCodec uses PIEX for DNG preview extraction but never reads the EXIF orientation tag. The base SkCodec constructor defaults origin to kTopLeft. The fix requires modifying SkRawCodec to extract and pass orientation from PIEX/EXIF data.",
          "proposals": [
            {
              "title": "Upstream Skia fix: Read EXIF orientation in SkRawCodec",
              "description": "Modify SkRawCodec::MakeFromStream to extract orientation from PIEX\u0027s PreviewImageData and pass it to the SkCodec constructor. This is the correct fix but requires an upstream Skia contribution.",
              "confidence": 0.85,
              "effort": "medium",
              "category": "fix"
            },
            {
              "title": "Workaround: Read DNG EXIF independently",
              "description": "Use a separate EXIF reading library (e.g., MetadataExtractor) to read orientation from the DNG file, then manually apply rotation after decode. Works around the Skia limitation at the application level.",
              "confidence": 0.8,
              "effort": "low",
              "category": "workaround"
            }
          ],
          "recommendedProposal": "Upstream Skia fix: Read EXIF orientation in SkRawCodec",
          "recommendedReason": "The existing label correctly identifies this as needing a Skia update. An application-level workaround is possible but doesn\u0027t fix the API returning wrong data."
        },
        "codeInvestigation": [
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "lines": "826-832",
            "relevance": "SkRawCodec constructor calls INHERITED (SkCodec) WITHOUT passing an origin parameter \u2014 defaults to kTopLeft"
          },
          {
            "file": "externals/skia/include/codec/SkCodec.h",
            "lines": "765-768",
            "relevance": "Base SkCodec constructor has default parameter SkEncodedOrigin = kTopLeft_SkEncodedOrigin \u2014 this is why DNG always reports TopLeft"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "lines": "584-687",
            "relevance": "PIEX integration extracts JPEG preview from DNG but has zero references to orientation/origin \u2014 the EXIF tag is never read"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "lines": "36-37",
            "relevance": "Managed EncodedOrigin property directly calls native sk_codec_get_origin \u2014 no SkiaSharp-side workaround possible"
          },
          {
            "file": "tests/Tests/SkiaSharp/SKCodecTest.cs",
            "lines": "28-36",
            "relevance": "Origin tests exist for JPEG (P8211052.JPG, PA010741.JPG) but no DNG test \u2014 the gap was never tested"
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Confirmed upstream Skia bug. SkRawCodec.cpp doesn\u0027t read EXIF orientation. Correctly labeled status/skia-update-required. No SkiaSharp-side fix possible."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area label",
            "reason": "Matches classification \u2014 core codec area",
            "confidence": 0.9,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/425"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 315,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [],
        "state": "open"
      },
      "summary": "Touch events on Android prevent Xamarin.Forms pinch/pan gesture recognizers from receiving events \u2014 architectural mismatch between Android and iOS touch handling",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.8
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.85
        },
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.8
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "severity": "medium",
          "severityReason": "Feature works on iOS but not Android. Not a crash, but prevents combined touch\u002Bgesture use on Android. Workaround exists (handle all gestures through SkiaSharp touch events directly).",
          "hasWorkaround": true,
          "workaroundSummary": "Avoid combining EnableTouchEvents with Xamarin.Forms PinchGestureRecognizer/PanGestureRecognizer on Android; handle multi-touch gestures directly via SKTouchEventArgs instead.",
          "targetFrameworks": [
            "xamarin.android"
          ]
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/JavedAppdevelopment/DrawTrackingForms",
              "description": "Reporter\u0027s Xamarin.Forms project demonstrating combined draw/pinch/pan"
            }
          ],
          "relatedIssues": [
            309
          ]
        },
        "versionAnalysis": {
          "reason": "No specific SkiaSharp version mentioned. Issue filed June 2017 shortly after #309 added touch events. Xamarin.Forms is now deprecated; same architectural pattern persists in MAUI handlers.",
          "currentRelevance": "likely",
          "migrationPath": "Xamarin.Forms is deprecated. If the same issue occurs in MAUI, a new issue should be filed against area/SkiaSharp.Views.Maui."
        }
      },
      "analysis": {
        "summary": "On Android, SKTouchHandler subscribes to view.Touch and sets e.Handled = args.Handled, which consumes the event and prevents Xamarin.Forms gesture recognizers (pinch/pan) from receiving it. On iOS, SKTouchHandler extends UIGestureRecognizer, which naturally coexists with other gesture recognizers. This architectural difference causes the same code to work on iOS but not Android. The Xamarin.Forms views have been removed, but the identical Android-vs-iOS touch handling pattern persists in the MAUI handlers.",
        "keySignals": [
          {
            "text": "Pinch and Pan with Touch works in iOS version but not work in Android version",
            "source": "body",
            "interpretation": "Platform-specific behavior \u2014 same code, different results. Points to architectural difference in touch handling."
          },
          {
            "text": "#309 introduces TouchEvents but somehow they interfere with Xamarin.Forms GestureRecognizers on Android",
            "source": "comment 1",
            "interpretation": "Confirms the issue is about touch event consumption preventing framework gesture propagation."
          },
          {
            "text": "project is in Xamarin.Forms, and uses same code for touch as in SkiaSharp FingerPrint demo",
            "source": "body",
            "interpretation": "Reporter followed official sample code \u2014 not a usage error."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a feature that works on iOS but not Android using the same code. This is broken platform parity, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "Touch events and gesture recognizers both exist \u2014 the issue is they don\u0027t coexist on Android, which is a bug in event propagation."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Forms",
            "expandedReason": "Issue was filed against Xamarin.Forms SKCanvasView with PinchGestureRecognizer/PanGestureRecognizer. The Xamarin.Forms views package is the affected area.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "Issue predates MAUI. Although the same pattern exists in MAUI, this specific report targets Forms."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Not a crash. Feature is broken on one platform. Workaround exists: handle pinch/pan via SKTouchEventArgs multi-touch data instead of using framework gesture recognizers."
          },
          {
            "field": "platforms",
            "chosen": "os/Android",
            "expandedReason": "Reporter explicitly states it works on iOS but fails on Android. Comment #1 confirms the Android-specific gesture interference."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "Cross-platform parity issue \u2014 same code behaves differently on iOS vs Android."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The Xamarin.Forms views are removed, but the same Android touch handling architecture persists in MAUI. A maintainer needs to decide: close as Forms-deprecated, or retarget to track the MAUI parallel.",
            "alternatives": [
              {
                "value": "close-as-fixed",
                "whyRejected": "The Forms views are gone, but the architectural gap persists in MAUI \u2014 closing would lose the signal."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The Android SKTouchHandler in MAUI still uses view.Touch with e.Handled, the same pattern that caused the original issue. The bug pattern persists even though the Forms views are gone."
          }
        ],
        "uncertainties": [
          "Whether MAUI\u0027s gesture system handles the Android touch event coexistence differently than Xamarin.Forms did",
          "Whether the reporter\u0027s linked GitHub repo still exists or is accessible",
          "Whether setting e.Handled = false on Android would cause other side effects (like duplicate events or touch tracking loss)"
        ],
        "assumptions": [
          "Assumed the Xamarin.Forms-era Android touch handler had the same pattern as the current MAUI handler, since #309 introduced the architecture"
        ],
        "resolution": {
          "hypothesis": "Android\u0027s view.Touch event handler in SKTouchHandler consumes events by setting e.Handled = true, preventing framework gesture recognizers from receiving them. iOS avoids this by using UIGestureRecognizer which coexists with other recognizers. The fix would be to change the Android handler to not consume events (or use a gesture recognizer pattern), or to handle multi-touch gestures entirely within SkiaSharp\u0027s touch events.",
          "proposals": [
            {
              "title": "Handle pinch/pan via SKTouchEventArgs multi-touch",
              "description": "Instead of using Xamarin.Forms/MAUI PinchGestureRecognizer and PanGestureRecognizer, handle all gesture detection directly from SKTouchEventArgs multi-touch data (multiple pointer IDs, coordinates). This avoids the framework gesture conflict entirely.",
              "confidence": 0.8,
              "effort": "medium",
              "category": "workaround",
              "codeSnippet": "// Track multiple touch points in your Touch handler\nprivate readonly Dictionary\u003Clong, SKPoint\u003E touchPoints = new();\n\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    switch (e.ActionType)\n    {\n        case SKTouchAction.Pressed:\n            touchPoints[e.Id] = e.Location;\n            break;\n        case SKTouchAction.Moved:\n            touchPoints[e.Id] = e.Location;\n            if (touchPoints.Count == 2)\n            {\n                // Calculate pinch/pan from the two points\n                var points = touchPoints.Values.ToArray();\n                var distance = SKPoint.Distance(points[0], points[1]);\n                var center = new SKPoint(\n                    (points[0].X \u002B points[1].X) / 2,\n                    (points[0].Y \u002B points[1].Y) / 2);\n                // Use distance for zoom, center for pan\n            }\n            break;\n        case SKTouchAction.Released:\n        case SKTouchAction.Cancelled:\n            touchPoints.Remove(e.Id);\n            break;\n    }\n    e.Handled = true;\n}",
              "validated": "untested"
            },
            {
              "title": "Set e.Handled = false to allow gesture propagation",
              "description": "Modify the Android SKTouchHandler to not set e.Handled = true, allowing framework gesture recognizers to also receive the events. Risk: may cause duplicate handling or lose touch tracking.",
              "confidence": 0.5,
              "effort": "low",
              "category": "investigation"
            },
            {
              "title": "Refactor Android touch to use GestureDetector",
              "description": "Replace Android\u0027s view.Touch event subscription with an Android GestureDetector-based approach that can coexist with other gesture recognizers, similar to how iOS uses UIGestureRecognizer.",
              "confidence": 0.65,
              "effort": "high",
              "category": "fix"
            }
          ],
          "recommendedProposal": "Handle pinch/pan via SKTouchEventArgs multi-touch",
          "recommendedReason": "Most practical immediate workaround. Avoids the framework gesture conflict entirely and gives full control over gesture interpretation. Works on both iOS and Android."
        },
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "lines": "41-109",
            "relevance": "Android SKTouchHandler hooks into view.Touch event and sets e.Handled = args.Handled (lines 71, 86, 97, 106). When Handled is true, Android stops propagating the event to parent views and framework gesture recognizers \u2014 this is the root cause."
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "lines": "10-110",
            "relevance": "iOS SKTouchHandler extends UIGestureRecognizer (line 10) and uses IgnoreTouch for unhandled events (line 62). UIGestureRecognizer coexists with other gesture recognizers by design \u2014 explains why iOS works correctly."
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKCanvasView/SKCanvasViewHandler.Android.cs",
            "lines": "45-52",
            "relevance": "MAUI Android handler creates SKTouchHandler with the same pattern \u2014 confirms the architectural gap persists beyond Xamarin.Forms."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.7,
          "reason": "The Xamarin.Forms views are removed, but the same Android touch handling architecture persists in MAUI. A maintainer needs to decide whether to close this Forms-era issue or retarget it for MAUI.",
          "requiresHumanReview": true,
          "missingInfo": [
            "platform"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, views.forms, android, compatibility labels",
            "reason": "Matches classification \u2014 bug in touch event handling affecting Android platform parity",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/SkiaSharp.Views.Forms",
                "os/Android",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "link-1",
            "type": "link-related",
            "risk": "low",
            "description": "Cross-reference #309 (touch events feature PR)",
            "reason": "Comment #1 explicitly references #309 as the source of the touch event interference",
            "confidence": 0.9,
            "payload": {
              "relatedIssues": [
                309
              ],
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis with workaround for handling gestures via SKTouchEventArgs",
            "reason": "Issue is 8 years old with no response. Provides actionable workaround and notes the Xamarin.Forms to MAUI migration context.",
            "confidence": 0.7,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "workaround",
              "draftBody": "Thanks for the report and the repro project.\n\nThe root cause is an architectural difference between iOS and Android touch handling in SkiaSharp. On iOS, SkiaSharp uses a \u0060UIGestureRecognizer\u0060 that naturally coexists with other gesture recognizers. On Android, it subscribes to the \u0060View.Touch\u0060 event and marks events as handled, which prevents framework gesture recognizers (pinch, pan) from receiving them.\n\nHere\u0027s a workaround \u2014 handle pinch/pan directly through SkiaSharp\u0027s multi-touch events instead of using framework gesture recognizers:\n\n\u0060\u0060\u0060csharp\nprivate readonly Dictionary\u003Clong, SKPoint\u003E touchPoints = new();\n\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    switch (e.ActionType)\n    {\n        case SKTouchAction.Pressed:\n            touchPoints[e.Id] = e.Location;\n            break;\n        case SKTouchAction.Moved:\n            touchPoints[e.Id] = e.Location;\n            if (touchPoints.Count == 2)\n            {\n                var points = touchPoints.Values.ToArray();\n                var distance = SKPoint.Distance(points[0], points[1]);\n                var center = new SKPoint(\n                    (points[0].X \u002B points[1].X) / 2,\n                    (points[0].Y \u002B points[1].Y) / 2);\n                // Use distance for zoom, center for pan\n            }\n            break;\n        case SKTouchAction.Released:\n        case SKTouchAction.Cancelled:\n            touchPoints.Remove(e.Id);\n            break;\n    }\n    e.Handled = true;\n}\n\u0060\u0060\u0060\n\nNote: Xamarin.Forms is now deprecated. If you experience the same issue in .NET MAUI, please open a new issue so we can track it specifically.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-315-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/315"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 310,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T06:00:00Z",
        "currentLabels": [
          "type/enhancement",
          "status/low-priority",
          "os/Windows-Classic",
          "area/SkiaSharp.Views"
        ],
        "state": "open"
      },
      "summary": "GDI\u002B error in SKControl.OnPaint when control is resized during PaintSurface event due to reentrant OnPaint and bitmap state corruption",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.9
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "steps-only",
          "severity": "medium",
          "severityReason": "GDI\u002B exception crash but user-identified workaround exists (don\u0027t resize during paint). Affects a specific usage pattern, not all SKControl users.",
          "hasWorkaround": true,
          "workaroundSummary": "Avoid resizing the SKControl from within the PaintSurface event handler. Perform layout calculations and control resizing outside the paint cycle, e.g. in a BeginInvoke callback."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Place SKControl inside a scrollable container (e.g. DevExpress XtraScrollableControl)",
            "In the PaintSurface event handler, change the SKControl.Height based on content",
            "Scroll down so the bottom of SKControl is visible but top is offscreen",
            "Trigger a content change that resizes the SKControl smaller, causing the view to go offscreen"
          ],
          "codeSnippets": [
            {
              "code": "System.Runtime.InteropServices.ExternalException (0x80004005): A generic error occurred in GDI\u002B.\n   at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata)\n   at SkiaSharp.Views.Desktop.SKControl.OnPaint(PaintEventArgs e)\n   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer)\n   at System.Windows.Forms.Control.WmPaint(Message\u0026 m)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)",
              "language": "text",
              "context": "Stack trace from the GDI\u002B error"
            }
          ],
          "environmentDetails": "Windows, WinForms (System.Windows.Forms), DevExpress XtraScrollableControl container"
        },
        "versionAnalysis": {
          "reason": "Issue filed in 2017 against an early SkiaSharp version. The SKControl.OnPaint code path is unchanged \u2014 no reentrancy guard has been added. The bug is still present in the current codebase.",
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "The reporter triggers a reentrant OnPaint by resizing SKControl from within the PaintSurface event. The reentrant call to CreateBitmap() disposes and replaces the bitmap while the outer OnPaint still holds a LockBits handle on the old bitmap. When the outer OnPaint resumes and calls UnlockBits(data), the bitmap is already disposed/replaced, causing the GDI\u002B error.",
        "keySignals": [
          {
            "text": "A generic error occurred in GDI\u002B. at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata) at SkiaSharp.Views.Desktop.SKControl.OnPaint",
            "source": "body",
            "interpretation": "Crash in UnlockBits indicates bitmap state was corrupted between LockBits and UnlockBits \u2014 consistent with reentrancy"
          },
          {
            "text": "the OnPaint event is being called from within the OnPaint event (due to my height resize code), but only in rare circumstances",
            "source": "comment 2",
            "interpretation": "Reporter confirmed reentrancy via debugging \u2014 resize triggers a second OnPaint while first is still running"
          },
          {
            "text": "I am changing the SKControl.Height value from within the PaintSurface event",
            "source": "comment 2",
            "interpretation": "Root cause: layout change during paint cycle triggers reentrant paint"
          },
          {
            "text": "This issue was the result of the paint operation also resizing the view - possibly invalidating the canvas or causing an infinite loop/stack overflow",
            "source": "comment 5",
            "interpretation": "Maintainer acknowledged the root cause and left issue open for investigation"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The issue describes a crash (ExternalException) with a stack trace during normal operation. The reporter and maintainer both confirmed reentrant OnPaint as the root cause. Currently labeled type/enhancement but this is a defect \u2014 the control should handle reentrancy gracefully rather than crashing.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Current label. While adding a reentrancy guard is an \u0027enhancement\u0027, the underlying problem is a crash \u2014 this is a bug, not a feature gap."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The crash occurs in SKControl.OnPaint, which is in the SkiaSharp.Views.WindowsForms package under the SkiaSharp.Views.Desktop namespace."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "GDI\u002B exception crashes the paint cycle, but a workaround exists (avoid resizing during paint). The pattern requires a specific trigger (resize from within PaintSurface) that is not the common usage path."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "SKControl is a WinForms control. WinForms is Windows-only, and the reentrancy behavior is specific to the WinForms message pump handling of WM_PAINT."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Unhandled GDI\u002B exception during paint is a reliability issue \u2014 the control should not crash even if user code triggers reentrancy."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "The SKControl.OnPaint code has not changed since the issue was filed. No reentrancy guard has been added. The bug is still present in current main."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause is well understood (reentrant OnPaint corrupts bitmap state), but a proper fix needs design consideration \u2014 a simple boolean guard vs. queueing the resize vs. making CreateBitmap idempotent during locks. The issue label should be corrected from type/enhancement to type/bug."
          }
        ],
        "uncertainties": [
          "Whether a simple boolean reentrancy guard (skip reentrant OnPaint) is sufficient, or if the resize should be deferred and replayed",
          "Whether other WinForms container controls besides DevExpress XtraScrollableControl can trigger this reentrancy"
        ],
        "assumptions": [
          "Assumed the issue is still reproducible since no code changes have been made to SKControl.OnPaint since filing",
          "Assumed the reporter was using a relatively recent SkiaSharp version at the time (mid-2017)"
        ],
        "resolution": {
          "hypothesis": "Reentrant OnPaint corrupts GDI\u002B bitmap state because CreateBitmap disposes the locked bitmap. A reentrancy guard would prevent the crash.",
          "proposals": [
            {
              "title": "Add reentrancy guard to OnPaint",
              "description": "Add a boolean field (e.g., isPainting) that skips reentrant OnPaint calls. Set it true before LockBits, false after UnlockBits. If already true when OnPaint is entered, call Invalidate() to schedule a deferred repaint and return early.",
              "confidence": 0.85,
              "effort": "low",
              "category": "fix",
              "codeSnippet": "private bool isPainting;\n\nprotected override void OnPaint(PaintEventArgs e)\n{\n    if (designMode || isPainting)\n    {\n        if (isPainting) Invalidate();\n        return;\n    }\n    isPainting = true;\n    try\n    {\n        base.OnPaint(e);\n        var info = CreateBitmap();\n        if (info.Width == 0 || info.Height == 0) return;\n        var data = bitmap.LockBits(new Rectangle(0, 0, Width, Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);\n        using (var surface = SKSurface.Create(info, data.Scan0, data.Stride))\n        {\n            OnPaintSurface(new SKPaintSurfaceEventArgs(surface, info));\n            surface.Canvas.Flush();\n        }\n        bitmap.UnlockBits(data);\n        e.Graphics.DrawImage(bitmap, 0, 0);\n    }\n    finally\n    {\n        isPainting = false;\n    }\n}",
              "validated": "untested"
            },
            {
              "title": "Move resize logic outside PaintSurface event",
              "description": "Reporter\u0027s own workaround: perform control resizing outside the PaintSurface handler. Use BeginInvoke to defer the resize to after the paint cycle completes.",
              "confidence": 0.9,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "private void OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    // Draw content...\n    int newHeight = CalculateContentHeight();\n    // Defer resize to after paint completes\n    BeginInvoke(new Action(() =\u003E skControl.Height = newHeight));\n}",
              "validated": "untested"
            },
            {
              "title": "Wrap bitmap operations in try-catch",
              "description": "Catch ExternalException from UnlockBits and schedule an Invalidate() to retry the paint. Defensive but does not prevent the underlying reentrancy \u2014 masks the symptom.",
              "confidence": 0.6,
              "effort": "low",
              "category": "workaround",
              "validated": "untested"
            }
          ],
          "recommendedProposal": "Add reentrancy guard to OnPaint",
          "recommendedReason": "Addresses root cause with minimal code change. Prevents crash and schedules deferred repaint so no visual frames are lost."
        },
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "lines": "30-57",
            "relevance": "OnPaint has no reentrancy guard. LockBits on line 43 acquires a handle on the bitmap, then OnPaintSurface on line 49 fires user code. If user code resizes the control, a reentrant OnPaint call will run CreateBitmap() which disposes and replaces the bitmap field. When the original OnPaint resumes at line 55, UnlockBits(data) operates on a disposed/replaced bitmap."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "lines": "72-85",
            "relevance": "CreateBitmap() disposes the old bitmap via FreeBitmap() (line 78) and creates a new one (line 81) whenever Width/Height changes. This is the mutation that corrupts the outer OnPaint\u0027s LockBits handle."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "lines": "17-20",
            "relevance": "Constructor sets ControlStyles.ResizeRedraw = true (line 20), meaning any resize immediately triggers a repaint \u2014 enabling the reentrant OnPaint when the user resizes from within PaintSurface."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "lines": "45-89",
            "relevance": "WPF SKElement.OnRender has same Lock/PaintSurface/Unlock pattern (lines 72-87) but WPF\u0027s rendering pipeline does not allow reentrant OnRender calls. WinForms\u0027 message pump does allow reentrant WM_PAINT handling, which is why only SKControl is affected."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.82,
          "reason": "Root cause is well understood from reporter\u0027s debugging and source analysis. Fix is straightforward (reentrancy guard) but needs testing and design review to ensure deferred repaints work correctly in all container scenarios."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Correct type label from enhancement to bug, add reliability tenet",
            "reason": "Issue describes a crash (ExternalException) with stack trace \u2014 this is a bug, not an enhancement. Reliability tenet applies.",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "tenet/reliability"
              ],
              "labelsToRemove": [
                "type/enhancement"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis with workaround and proposed fix",
            "reason": "Issue has been open since 2017 with no code fix. Providing a workaround and proposed fix helps the reporter and documents the root cause.",
            "confidence": 0.82,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "workaround",
              "draftBody": "Thanks for the thorough investigation and stack trace.\n\nThe root cause is reentrant \u0060OnPaint\u0060 \u2014 resizing the control from within \u0060PaintSurface\u0060 triggers a second \u0060OnPaint\u0060 call that disposes and recreates the bitmap while the first call still holds a \u0060LockBits\u0060 handle. When the original \u0060OnPaint\u0060 resumes, \u0060UnlockBits\u0060 fails on the replaced bitmap.\n\nHere\u0027s a workaround you can use now: defer the resize to after the paint completes using \u0060BeginInvoke\u0060:\n\n\u0060\u0060\u0060csharp\nprivate void OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    // Draw content...\n    int newHeight = CalculateContentHeight();\n    // Defer resize to after paint completes\n    BeginInvoke(new Action(() =\u003E skControl.Height = newHeight));\n}\n\u0060\u0060\u0060\n\nOn the SkiaSharp side, a reentrancy guard in \u0060SKControl.OnPaint\u0060 would prevent this class of crashes. We\u0027ll investigate adding one.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-310-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/310"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 243,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-23T12:00:00Z",
        "currentLabels": [
          "os/Windows-Classic",
          "area/Build",
          "type/feature-request"
        ],
        "state": "open"
      },
      "summary": "Request to bundle ANGLE native binaries for win7 runtimes to enable GPU-accelerated OpenGL ES rendering via DirectX on Windows 7",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/Build",
          "confidence": 0.85
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.8
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.92
          }
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://i.imgur.com/DZWkJdg.png",
              "context": "ANGLE rendering capabilities chart showing DX9 support",
              "source": "description"
            }
          ],
          "relatedIssues": [
            1158,
            1519,
            1521,
            2950,
            2970,
            3267
          ],
          "codeSnippets": [
            {
              "code": "https://www.dropbox.com/s/ayi8ill098jxh1d/angle-d3d9.zip?dl=0",
              "language": "text",
              "context": "OP provided pre-built ANGLE targeting D3D9, compatible with WinXP, from chromium/2550 branch"
            }
          ]
        },
        "versionAnalysis": {
          "reason": "Issue filed in 2017 against unspecified SkiaSharp version. Since then, ANGLE support was added for WinUI/UWP, Direct3D backend was added to Skia, and Win7 reached EOL in January 2020. The original Win7-specific request is no longer relevant, but the broader ANGLE-for-desktop-Windows topic persists in #1521.",
          "currentRelevance": "unlikely",
          "migrationPath": "For GPU rendering on Windows desktop, use Direct3D backend (GRBackend.Direct3D) via SkiaSharp.Direct3D.Vortice, or ANGLE via GRGlInterface.CreateAngle() if libEGL.dll/libGLESv2.dll are present. See #1521 for WPF-specific ANGLE work."
        }
      },
      "analysis": {
        "summary": "Feature request from 2017 to bundle ANGLE for Win7 GPU rendering. Since then, SkiaSharp added ANGLE support for WinUI, a Direct3D backend, and GRGlInterface.CreateAngle() for assembling ANGLE interfaces on Windows. Win7 reached EOL in 2020 and the OP themselves suggested closing. The broader desktop ANGLE integration (WPF) is tracked in #1521.",
        "keySignals": [
          {
            "text": "Angle has support even for DX9-based rendering which is preinstalled on Win7",
            "source": "body",
            "interpretation": "Original motivation was Win7 GPU support via ANGLE\u0027s DX9 backend \u2014 a platform now EOL"
          },
          {
            "text": "Is it OK to close this issue?",
            "source": "comment 6",
            "interpretation": "OP (kekekeks, Avalonia maintainer) themselves suggested closing in April 2020"
          },
          {
            "text": "We are shipping a patched version of ANGLE that is capable of running properly on top of Microsoft Basic Render Driver",
            "source": "comment 5",
            "interpretation": "Avalonia ships their own patched ANGLE \u2014 bundling SkiaSharp\u0027s would conflict"
          },
          {
            "text": "some graphics drivers (e. g. AMD) ship their own libEGL.dll in system32. So including ANGLE with Skia will break users who are using AMD EGL implementation",
            "source": "comment 14",
            "interpretation": "Significant DLL conflict risk identified \u2014 bundling ANGLE is architecturally problematic"
          },
          {
            "text": "Maybe skia will get a DX backend - I see some work on that now...",
            "source": "comment 7",
            "interpretation": "Maintainer anticipated Direct3D backend, which now exists as GRBackend.Direct3D"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "Reporter requests bundling a new native dependency (ANGLE) that isn\u0027t currently included. This is adding new capability, not fixing broken behavior.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "ANGLE bundling would be new functionality, not improving an existing feature."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/Build",
            "expandedReason": "The request is about including ANGLE native binaries in the build/packaging pipeline. The API support (GRGlInterface.CreateAngle) already exists \u2014 only the build-time bundling of libEGL.dll/libGLESv2.dll is missing.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "Not about libSkiaSharp itself; about adding a separate ANGLE native dependency to the package."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "ANGLE provides OpenGL ES over DirectX. The request enables GL-based rendering on Windows systems without native OpenGL support."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Explicitly about Windows desktop runtimes (originally Win7). ANGLE for UWP/WinUI is already handled."
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "unlikely",
            "expandedReason": "The specific Win7 use case is no longer relevant (EOL Jan 2020). The broader desktop ANGLE need is better tracked in #1521 (Angle WPF). SkiaSharp now has a Direct3D backend as an alternative. The OP themselves suggested closing."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The original Win7 motivation is obsolete, the OP requested closure, DLL conflict risks were identified, and the remaining desktop ANGLE work is tracked in #1521. The Direct3D backend and existing CreateAngle() API address the underlying GPU rendering need through different means."
          }
        ],
        "uncertainties": [
          "Whether any users still need ANGLE specifically for Win7 given its EOL status",
          "Whether #1521 (Angle WPF) fully supersedes the desktop ANGLE bundling need from this issue"
        ],
        "assumptions": [
          "Assumed Win7 EOL makes the original Win7-specific request obsolete",
          "Assumed #1521 tracks the remaining desktop ANGLE integration work"
        ],
        "resolution": {
          "hypothesis": "The original Win7 ANGLE request is obsolete. GPU rendering on Windows desktop is now achievable through the Direct3D backend or by manually providing ANGLE DLLs alongside the application.",
          "proposals": [
            {
              "title": "Use Direct3D backend instead of ANGLE",
              "description": "SkiaSharp now supports GRBackend.Direct3D with the SkiaSharp.Direct3D.Vortice package. This provides native DirectX rendering without ANGLE as a middleman.",
              "confidence": 0.8,
              "effort": "low",
              "category": "alternative",
              "validated": "untested"
            },
            {
              "title": "Manually bundle ANGLE DLLs with application",
              "description": "GRGlInterface.CreateAngle() already loads libEGL.dll and libGLESv2.dll if present. Users can include pre-built ANGLE binaries in their application output directory for Windows desktop GL rendering.",
              "confidence": 0.85,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "// 1. Place libEGL.dll and libGLESv2.dll in your app\u0027s output directory\n// 2. Create ANGLE-backed GL interface:\nvar glInterface = GRGlInterface.CreateAngle();\nif (glInterface != null)\n{\n    using var context = GRContext.CreateGl(glInterface);\n    // Use GPU-accelerated rendering\n}",
              "validated": "untested"
            },
            {
              "title": "Track WPF ANGLE integration in #1521",
              "description": "The broader need for ANGLE in WPF/WinForms views is tracked in issue #1521 which includes a working implementation approach. Close this Win7-specific issue and consolidate efforts there.",
              "confidence": 0.85,
              "effort": "low",
              "category": "alternative",
              "validated": "untested"
            }
          ],
          "recommendedProposal": "Track WPF ANGLE integration in #1521",
          "recommendedReason": "Consolidates the remaining desktop ANGLE work into a focused issue while acknowledging that the Win7-specific request is moot."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/GRGlInterface.cs",
            "lines": "27-48",
            "relevance": "GRGlInterface.Create() already falls back to CreateAngle() on Windows. CreateAngle() loads libEGL.dll and libGLESv2.dll if present. ANGLE interface assembly is supported \u2014 the issue is about bundling the DLLs, not adding API support."
          },
          {
            "file": "binding/SkiaSharp/GRGlInterface.cs",
            "lines": "125-198",
            "relevance": "AngleLoader class loads libEGL.dll and libGLESv2.dll via LoadLibrary on Windows. Already handles UWP (LoadPackagedLibrary) and desktop (LoadLibrary). The loader infrastructure exists; what\u0027s missing is bundling the binaries for desktop."
          },
          {
            "file": "binding/SkiaSharp/EnumMappings.cs",
            "lines": "8-16",
            "relevance": "GRBackend enum includes Direct3D = 4, confirming a native D3D backend now exists as an alternative to ANGLE for Windows GPU rendering."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "lines": "1-50",
            "relevance": "ANGLE is already used for WinUI rendering via AngleSwapChainPanel with GlesContext. Shows ANGLE integration exists for UWP/WinUI but not for WPF/WinForms desktop."
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKGLControl.cs",
            "lines": "1-50",
            "relevance": "WinForms GL control uses OpenTK (native OpenGL), not ANGLE. This is where ANGLE could help on systems without proper OpenGL drivers, but this is tracked in #1521."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.82,
          "reason": "Win7 is EOL, OP requested closure, DLL conflict risks make bundling problematic, Direct3D backend exists as alternative, and remaining desktop ANGLE work is tracked in #1521."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add backend/OpenGL label to reflect the rendering backend involved",
            "reason": "ANGLE provides OpenGL ES \u2014 the backend label was missing from current labels",
            "confidence": 0.85,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "link-1",
            "type": "link-related",
            "risk": "low",
            "description": "Cross-reference #1521 (Angle WPF) as the continuation of desktop ANGLE work",
            "reason": "The broader desktop ANGLE topic evolved from this issue into #1521",
            "confidence": 0.88,
            "payload": {
              "relatedIssues": [
                1521
              ],
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post closing comment explaining the current state of ANGLE and D3D support",
            "reason": "Explain why this specific request is being closed and where ongoing work is tracked",
            "confidence": 0.8,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "close-message",
              "draftBody": "Thanks for filing this and for the thorough discussion.\n\nSince this was filed, a few things have changed:\n\n- Windows 7 reached end of life in January 2020\n- SkiaSharp now has a native Direct3D backend (\u0060GRBackend.Direct3D\u0060) via \u0060SkiaSharp.Direct3D.Vortice\u0060\n- \u0060GRGlInterface.CreateAngle()\u0060 already supports assembling an ANGLE interface if \u0060libEGL.dll\u0060 and \u0060libGLESv2.dll\u0060 are present in the app directory\n- Bundling ANGLE has DLL conflict risks (AMD drivers ship \u0060libEGL.dll\u0060 in system32, as noted above)\n\nThe remaining need for ANGLE in WPF/WinForms views is tracked in #1521. Closing this Win7-specific request as the original use case is no longer applicable.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-243-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as completed \u2014 original Win7 use case is obsolete",
            "reason": "Win7 EOL, OP requested closure, and remaining work tracked in #1521",
            "confidence": 0.8,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/243"
    },
    {
      "meta": {
        "schemaVersion": "2.1",
        "number": 209,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-11T16:00:00Z",
        "currentLabels": [
          "type/bug"
        ],
        "state": "open"
      },
      "summary": "AccessViolationException in SKBitmap.Decode when decoding multiple images concurrently on IIS. SemaphoreSlim(1) workaround confirms native Skia thread safety issue.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.9
          }
        ]
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "severity": "high",
          "severityReason": "AccessViolationException crashes the IIS worker process (w3wp.exe) \u2014 unrecoverable, terminates all requests in the app pool.",
          "hasWorkaround": true,
          "workaroundSummary": "SemaphoreSlim(1) around SKBitmap.Decode calls serializes decoding, preventing the crash.",
          "targetFrameworks": [
            ".NETFramework,Version=v4.x"
          ]
        },
        "versionAnalysis": {
          "reason": "The managed code path (SKBitmap.Decode \u2192 SKCodec.Create \u2192 native sk_codec_new_from_stream) has no thread synchronization in the current codebase. The native Skia codec library has known thread safety limitations. This issue persists in the current version.",
          "mentionedVersions": [
            ".NETFramework 4.x (implied by IIS/w3wp.exe context)"
          ],
          "currentRelevance": "likely"
        }
      },
      "analysis": {
        "summary": "The managed SKBitmap.Decode path creates an SKCodec via SKCodec.Create which calls native sk_codec_new_from_stream. There is zero thread synchronization in the managed layer \u2014 no locks, no ConcurrentDictionary usage, no Interlocked operations on the decode path. SKCodec implements ISKSkipObjectRegistration, bypassing the HandleDictionary entirely. The crash occurs in native sk_codec_get_info, suggesting the native Skia codec layer is not thread-safe for concurrent decode operations. The reporter\u0027s SemaphoreSlim(1) workaround confirms this: serializing access prevents the crash.",
        "keySignals": [
          {
            "text": "System.AccessViolationException at SkiaSharp.SkiaApi.sk_codec_get_info(IntPtr, SkiaSharp.SKImageInfo ByRef)",
            "source": "body",
            "interpretation": "Crash in native P/Invoke call to Skia codec \u2014 native memory corruption from concurrent access"
          },
          {
            "text": "My workaround has been to add a SemaphoreSlim with a max count of 1",
            "source": "body",
            "interpretation": "Serializing decode calls prevents the crash \u2014 confirms concurrent access is the root cause"
          },
          {
            "text": "As soon as I increase the count, I start getting System.AccessViolationException errors",
            "source": "body",
            "interpretation": "Even 2 concurrent decode calls crash \u2014 the issue is in the native layer, not a managed race condition"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a crash (AccessViolationException) during normal concurrent usage. The SemaphoreSlim(1) workaround proves it\u0027s a real threading bug, not a usage error.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter understands the problem \u2014 asking if SkiaSharp is thread-safe is rhetorical given the crash evidence."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The crash is in core SKBitmap/SKCodec decode path via native P/Invoke, not in a specific view or platform binding."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "AccessViolationException crashes the entire IIS process \u2014 this is a reliability issue."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Process crash (w3wp.exe termination) with no way to catch or handle the AccessViolationException. Affects all concurrent image processing scenarios."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The root cause is in native Skia\u0027s thread safety characteristics. Need to determine if SkiaSharp should add managed-side locking, document the limitation, or if upstream Skia has since made codecs thread-safe.",
            "alternatives": [
              {
                "value": "close-with-docs",
                "whyRejected": "While the SemaphoreSlim workaround exists, the underlying issue is a real limitation that should be documented or fixed, not dismissed."
              }
            ]
          },
          {
            "field": "versionAnalysis.currentRelevance",
            "chosen": "likely",
            "expandedReason": "Code inspection confirms zero thread synchronization in the SKBitmap.Decode \u2192 SKCodec.Create \u2192 native path. No locks have been added since the issue was filed."
          }
        ],
        "uncertainties": [
          "Whether upstream Skia has since made codec operations thread-safe (would need to check Skia release notes)",
          "Whether the crash is in sk_codec_get_info specifically or in shared global state during codec initialization",
          "Whether SKImage.FromEncodedData has the same thread safety issue (uses different native path)"
        ],
        "assumptions": [
          "Assumed reporter was using a version roughly contemporary with the 2017 filing date (.NET Framework 4.x era)"
        ],
        "resolution": {
          "hypothesis": "Native Skia codec operations are not thread-safe for concurrent decode of multiple images. The managed SkiaSharp wrapper does not add any synchronization, so the crash propagates as an AccessViolationException.",
          "proposals": [
            {
              "title": "Document thread safety limitation",
              "description": "Add XML doc comments to SKBitmap.Decode and SKCodec.Create noting that concurrent decode operations are not thread-safe and callers must synchronize access.",
              "confidence": 0.9,
              "effort": "low",
              "category": "workaround"
            },
            {
              "title": "SemaphoreSlim workaround",
              "description": "Use SemaphoreSlim(1,1) around SKBitmap.Decode calls. Reporter has confirmed this works.",
              "confidence": 0.95,
              "effort": "low",
              "category": "workaround",
              "codeSnippet": "private static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try { return SKBitmap.Decode(data); }\n    finally { _decodeLock.Release(); }\n}",
              "validated": "untested"
            },
            {
              "title": "Add managed-side locking in SKCodec.Create",
              "description": "Add a static lock or SemaphoreSlim in SKCodec.Create to serialize native codec creation. Would fix all callers transparently but reduces throughput.",
              "confidence": 0.7,
              "effort": "medium",
              "category": "fix"
            }
          ],
          "recommendedProposal": "SemaphoreSlim workaround",
          "recommendedReason": "Reporter has already validated this approach. Documenting the limitation is the lowest-effort improvement."
        },
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "lines": "461-471",
            "relevance": "SKBitmap.Decode(Stream) creates SKCodec via SKCodec.Create(stream) then calls Decode(codec). No locking, no thread synchronization anywhere in this path."
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "lines": "252-264",
            "relevance": "SKCodec.Create calls native sk_codec_new_from_stream via SkiaApi. No locking. SKCodec implements ISKSkipObjectRegistration, so it bypasses HandleDictionary tracking entirely."
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "lines": "10-27",
            "relevance": "Base class uses ConcurrentDictionary for owned objects and lock for lazy init, but SKCodec skips registration (ISKSkipObjectRegistration). The only Interlocked usage is in Dispose (line 261)."
          },
          {
            "file": "binding/SkiaSharp/SkiaApi.generated.cs",
            "lines": "3579-3595",
            "relevance": "sk_codec_get_info is a direct P/Invoke to native Skia \u2014 no managed-side synchronization wrapper. This is the exact function in the reporter\u0027s crash stack trace."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Thread safety limitation in native Skia codec layer \u2014 needs determination of whether to add managed-side locking or document the limitation."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug and reliability labels",
            "reason": "Matches classification \u2014 real bug with crash, reliability tenet",
            "confidence": 0.92,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "tenet/reliability"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge thread safety issue and provide workaround",
            "reason": "Code investigation confirms the reporter\u0027s diagnosis is correct \u2014 the decode path has no synchronization",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "This is a real thread safety limitation. The \u0060SKBitmap.Decode\u0060 \u2192 \u0060SKCodec.Create\u0060 path calls into native Skia without any synchronization, and the native codec layer is not thread-safe for concurrent operations.\n\nYour \u0060SemaphoreSlim(1)\u0060 workaround is the correct approach. For server scenarios needing throughput, you could also consider:\n- Using \u0060SKImage.FromEncodedData()\u0060 instead (different native path, may have different threading characteristics)\n- Pooling decode operations per-thread rather than serializing globally\n\nThe long-term fix would be either adding managed-side locking in \u0060SKCodec.Create\u0060 or documenting this limitation in the API docs.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-209-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/209"
    }
  ]
}