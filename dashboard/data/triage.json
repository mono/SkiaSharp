{
  "generatedAt": "2026-02-10T02:41:56.7375617Z",
  "totalCount": 30,
  "summary": {
    "needsInvestigation": 14,
    "closeable": 6,
    "quickWins": 5,
    "needsHumanReview": 4,
    "regressions": 10
  },
  "byType": [
    {
      "label": "type/bug",
      "count": 22
    },
    {
      "label": "type/question",
      "count": 4
    },
    {
      "label": "type/feature-request",
      "count": 3
    },
    {
      "label": "type/documentation",
      "count": 1
    }
  ],
  "byArea": [
    {
      "label": "area/SkiaSharp",
      "count": 10
    },
    {
      "label": "area/libSkiaSharp.native",
      "count": 7
    },
    {
      "label": "area/SkiaSharp.Views",
      "count": 3
    },
    {
      "label": "area/SkiaSharp.Views.Maui",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.Views.Blazor",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.HarfBuzz",
      "count": 1
    },
    {
      "label": "area/Docs",
      "count": 1
    },
    {
      "label": "area/HarfBuzzSharp",
      "count": 1
    },
    {
      "label": "area/SkiaSharp.Views.Forms",
      "count": 1
    },
    {
      "label": "area/SkiaSharp.Views.Uno",
      "count": 1
    }
  ],
  "byAction": [
    {
      "label": "needs-investigation",
      "count": 14
    },
    {
      "label": "keep-open",
      "count": 5
    },
    {
      "label": "request-info",
      "count": 3
    },
    {
      "label": "close-with-docs",
      "count": 3
    },
    {
      "label": "close-as-fixed",
      "count": 2
    },
    {
      "label": "close-as-duplicate",
      "count": 2
    },
    {
      "label": "convert-to-discussion",
      "count": 1
    }
  ],
  "bySeverity": [
    {
      "label": "high",
      "count": 10
    },
    {
      "label": "medium",
      "count": 10
    },
    {
      "label": "low",
      "count": 1
    },
    {
      "label": "critical",
      "count": 1
    }
  ],
  "issues": [
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3509,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "Incomplete bug report \u2014 images not appearing on screen, but no actual code, repro steps, or error details provided (template placeholders only)",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.50
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.45
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/macOS",
            "confidence": 0.65
          }
        ],
        "tenets": null,
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "none",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "severity": "low",
          "severityReason": "No actual details provided \u2014 the issue body contains only the default template placeholders with no real code, no expected/actual behavior, and no error information. Cannot assess real severity."
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/user/repo/tree/bug-123",
              "description": "Template placeholder URL \u2014 not a real repro project"
            }
          ],
          "codeSnippets": [
            {
              "language": "cs",
              "code": "// some C# code here",
              "context": "Template placeholder \u2014 no real code provided"
            }
          ],
          "environmentDetails": "IDE: Visual Studio (Windows), Platform: macOS, SkiaSharp 3.116.0, Last Known Good: 2.88.9"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "unknown",
          "reason": "Reporter selected 3.116.0 as current and 2.88.9 as last known good, suggesting a possible regression across a major version boundary (v2 \u2192 v3). However, no details were provided to confirm whether the issue is real or if this was just default template selection."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.30,
          "reason": "Reporter selected 2.88.9 as last known good version, which could indicate regression from v2 to v3. However, the entire report is template placeholders, so this selection may not reflect actual testing."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "This issue contains only the default bug template with placeholder text \u2014 no actual code, no expected or actual behavior, no screenshots, no logs. The title mentions images not appearing but provides zero actionable information. Cannot determine root cause or even confirm a real bug exists.",
        "keySignals": [
          {
            "text": "My images are not appearing in the screen",
            "source": "title",
            "interpretation": "Vague description of visual output issue \u2014 could be rendering, loading, drawing, or display problem"
          },
          {
            "text": "// some C# code here",
            "source": "body",
            "interpretation": "Code section contains the template placeholder, not actual code \u2014 reporter did not fill in the template"
          },
          {
            "text": "Expected Behavior: _No response_",
            "source": "body",
            "interpretation": "No expected behavior described \u2014 cannot determine what the reporter expects to happen"
          },
          {
            "text": "Actual Behavior: _No response_",
            "source": "body",
            "interpretation": "No actual behavior described \u2014 cannot determine what is actually happening"
          },
          {
            "text": "Version: 3.116.0, Last Known Good: 2.88.9",
            "source": "body",
            "interpretation": "Version fields were filled in, suggesting possible v2-to-v3 migration issue, but could also be default selections"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter used the bug template and the title says \u0027[BUG]\u0027. While the content is empty, they claim something is not working (\u0027images not appearing\u0027). Keeping type/bug but with very low confidence since there is no actual evidence of broken behavior.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "The reporter chose the bug template and claims something is broken, not asking how to do something. However, with so little info, this could easily be a usage question."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "No specific component mentioned. \u0027Images not appearing\u0027 is too vague to narrow down \u2014 could be core SkiaSharp, Views, or MAUI. Defaulting to the broadest area.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "No mention of SKCanvasView, views, or any UI framework."
              },
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "No mention of MAUI, .NET MAUI, or any MAUI-specific types."
              }
            ]
          },
          {
            "field": "platforms[0]",
            "chosen": "os/macOS",
            "expandedReason": "Reporter selected \u0027macOS\u0027 as platform. However, they also say IDE is \u0027Visual Studio (Windows)\u0027 which is contradictory \u2014 they may be developing on Windows targeting macOS, or this may be a template selection error.",
            "alternatives": [
              {
                "value": "os/Windows-Classic",
                "whyRejected": "IDE says Visual Studio Windows but platform says macOS \u2014 trusting the explicit platform selection over IDE choice."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "low",
            "expandedReason": "Cannot assess severity without any actual details. No crash, no stack trace, no repro, no description of the problem beyond the title. Defaulting to low until more information is available."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "The issue is entirely template placeholders. We need actual code, expected behavior, actual behavior, and ideally a sample project before any investigation can begin."
          }
        ],
        "uncertainties": [
          "Whether this is a real bug report or an accidental submission of the empty template",
          "What kind of images \u2014 SKImage, SKBitmap, or UI framework image controls",
          "Whether the issue is in core SkiaSharp drawing, views rendering, or a platform-specific display problem",
          "Whether the v2.88.9 \u0027last known good\u0027 reflects actual testing or default selection",
          "Whether the macOS platform selection is accurate given the Windows IDE selection"
        ],
        "assumptions": [
          "Assumed this is an intentional (not accidental) submission based on title containing a specific complaint",
          "Assumed macOS is the target platform despite contradictory IDE selection"
        ],
        "resolution": {
          "hypothesis": "The reporter has code that should display images using SkiaSharp but nothing appears on screen. Without any details, the most common causes are: incorrect drawing coordinates, missing invalidation/refresh of the canvas view, image loading failures returning null, or v2-to-v3 API migration issues.",
          "proposals": [
            {
              "title": "Request complete bug report",
              "description": "Ask the reporter to fill in the template with actual code, expected behavior, actual behavior, and ideally a minimal repro project. This is a prerequisite for any investigation.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "Check for v2-to-v3 migration issues",
              "description": "If the reporter confirms this worked in v2.88.9, investigate common v3 migration pitfalls like API changes, namespace changes, or rendering pipeline differences.",
              "confidence": 0.40,
              "effort": "medium"
            },
            {
              "title": "Provide common image rendering checklist",
              "description": "Share a checklist of common reasons images don\u0027t appear: null image from loading, drawing at wrong coordinates, canvas not invalidated, view not sized correctly.",
              "confidence": 0.50,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Request complete bug report",
          "recommendedReason": "Cannot investigate without any actual information. The template is completely empty."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.92,
          "reason": "The issue body contains only template placeholders \u2014 no real code, no expected/actual behavior, no logs, no screenshots. Investigation is impossible without more details.",
          "requiresHumanReview": false,
          "missingInfo": [
            "reproduction-steps",
            "expected-behavior",
            "actual-behavior",
            "sample-project"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp and os/macOS labels",
            "reason": "Matches classification \u2014 generic SkiaSharp area and macOS platform",
            "confidence": 0.50,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "os/macOS"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Request the reporter to fill in the bug template with actual details",
            "reason": "Issue body contains only placeholder text \u2014 need real code and behavior description to investigate",
            "confidence": 0.90,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for opening this issue.\n\nIt looks like the bug template still has the placeholder text in the Code, Expected Behavior, and Actual Behavior sections. Without actual code or a description of what\u0027s happening, it\u0027s hard to investigate further.\n\nWould you be able to update the issue with:\n- The code you\u0027re using to load and display the images (even a short snippet helps)\n- What you expect to see vs. what actually happens\n\nIf you have a small repro project, that would be ideal \u2014 but even a code snippet and description of the behavior would help narrow this down.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3509-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3509"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3472,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "HarfBuzzSharp Blob.FromStream uses a pinned managed array pointer that becomes invalid after the fixed block exits, causing potential GC-related crashes",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/HarfBuzzSharp",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": null,
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "severity": "high",
          "severityReason": "Memory safety bug: the fixed block exits before the Blob is used, so GC can relocate the managed byte array causing use-after-move crashes. No workaround exists short of avoiding FromStream entirely."
        },
        "reproEvidence": {
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "public static unsafe Blob FromStream (Stream stream)\n{\n\tusing var ms = new MemoryStream ();\n\tstream.CopyTo (ms);\n\tvar data = ms.ToArray ();\n\n\tfixed (byte* dataPtr = data) {\n\t\treturn new Blob ((IntPtr)dataPtr, data.Length, MemoryMode.ReadOnly, () =\u003E ms.Dispose ());\n\t}\n}",
              "context": "Current buggy implementation in binding/HarfBuzzSharp/Blob.cs"
            },
            {
              "language": "csharp",
              "code": "public static unsafe Blob FromStream (Stream stream)\n{\n\tvar length = (int)(stream.Length - stream.Position);\n\n\tvar dataPtr = Marshal.AllocCoTaskMem (length);\n\n\tusing var ums = new UnmanagedMemoryStream ((byte*)dataPtr, length, length, FileAccess.ReadWrite);\n\tstream.CopyTo (ums);\n\n\treturn new Blob (dataPtr, length, MemoryMode.ReadOnly, () =\u003E Marshal.FreeCoTaskMem (dataPtr));\n}",
              "context": "Reporter\u0027s proposed fix using unmanaged memory allocation"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), affects all platforms"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "The buggy code pattern exists in the current source (binding/HarfBuzzSharp/Blob.cs lines 71-82). The issue was found by code inspection, not runtime testing, and the code has not changed."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.80,
          "reason": "The reporter lists 2.88.9 as \u0027Last Known Good Version\u0027 but this appears to be a latent bug present since the method was written \u2014 the fixed block has always exited before the Blob could be used. It likely manifests non-deterministically depending on GC timing."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Real memory safety bug in HarfBuzzSharp\u0027s Blob.FromStream. The fixed statement pins a managed byte array only for the duration of the block, but the resulting Blob holds the pointer beyond that scope. After the fixed block exits, the GC is free to relocate the managed array, leaving the Blob with a dangling pointer.",
        "keySignals": [
          {
            "text": "If GC runs after the blob is created, the managed array memory might be moved resulting in a crash",
            "source": "body",
            "interpretation": "Reporter correctly identifies the root cause: the fixed block scope is too narrow"
          },
          {
            "text": "fixed (byte* dataPtr = data) { return new Blob((IntPtr)dataPtr, ...); }",
            "source": "body",
            "interpretation": "The fixed block exits immediately after Blob construction, unpinning the managed array while the Blob still holds the pointer"
          },
          {
            "text": "Should copy via an UnmanagedMemoryStream",
            "source": "body",
            "interpretation": "Reporter provides a concrete fix using Marshal.AllocCoTaskMem for GC-safe unmanaged memory"
          },
          {
            "text": "TODO: check to see if we can avoid the second copy (the ToArray)",
            "source": "body",
            "interpretation": "Existing TODO comment in the code acknowledges the implementation is suboptimal"
          },
          {
            "text": "This should also improve performance since it removes the redundant copy",
            "source": "comment 2",
            "interpretation": "The proposed fix also eliminates an unnecessary buffer copy \u2014 stream \u2192 MemoryStream \u2192 byte[] becomes stream \u2192 unmanaged buffer"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a real memory safety defect found by code inspection. The fixed keyword only pins memory within its block scope, but the Blob outlives that scope. This is not a feature request or enhancement \u2014 it\u0027s broken code that can crash.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "While the fix also improves performance, the core issue is a use-after-unpin memory safety bug, not an optimization request."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/HarfBuzzSharp",
            "expandedReason": "The bug is in HarfBuzzSharp.Blob.FromStream (binding/HarfBuzzSharp/Blob.cs), not in the SkiaSharp core library. The existing label area/SkiaSharp is incorrect.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The Blob class is in the HarfBuzzSharp namespace and assembly, not SkiaSharp."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Memory safety bug with potential for hard crashes. No workaround other than avoiding the API entirely. The crash is non-deterministic (depends on GC timing), making it difficult to diagnose in production."
          },
          {
            "field": "platforms",
            "chosen": "null",
            "expandedReason": "The reporter selected \u0027All\u0027 for platform. The bug is in managed C# code and affects all platforms equally since GC behavior is a .NET runtime concern, not platform-specific."
          }
        ],
        "uncertainties": [
          "Whether this has been observed as an actual crash in production, or only identified by code inspection",
          "Whether SkiaSharp\u0027s SKData or other classes have similar fixed-block scope issues"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s version selection of 2.88.9 as \u0027Last Known Good\u0027 is likely a form field default rather than evidence of a regression, since the buggy pattern appears to have been present since the method was written"
        ],
        "resolution": {
          "hypothesis": "The fixed block in Blob.FromStream exits immediately after constructing the Blob, unpinning the managed byte array. The Blob holds a raw pointer to what was pinned memory, but after unpinning, the GC can relocate the array, leaving a dangling pointer. The fix is to use unmanaged memory that the GC cannot move.",
          "proposals": [
            {
              "title": "Use Marshal.AllocCoTaskMem with UnmanagedMemoryStream",
              "description": "Allocate unmanaged memory, copy stream data directly into it via UnmanagedMemoryStream, and pass the unmanaged pointer to Blob with a release delegate that calls Marshal.FreeCoTaskMem. This is the reporter\u0027s proposed fix. It eliminates the GC safety issue and removes one redundant buffer copy (stream \u2192 MemoryStream \u2192 ToArray becomes stream \u2192 unmanaged buffer).",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Use GCHandle.Alloc to pin the managed array",
              "description": "Instead of fixed, use GCHandle.Alloc(data, GCHandleType.Pinned) to pin the managed array for the lifetime of the Blob. Free the GCHandle in the release delegate. This is simpler but keeps the redundant copy and long-lived GC pinning can fragment the managed heap.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Use NativeMemory.Alloc (modern .NET)",
              "description": "Use System.Runtime.InteropServices.NativeMemory.Alloc instead of Marshal.AllocCoTaskMem for a more modern API. Functionally equivalent but uses the newer .NET API surface. May require conditional compilation for older target frameworks.",
              "confidence": 0.75,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Use Marshal.AllocCoTaskMem with UnmanagedMemoryStream",
          "recommendedReason": "Directly addresses the root cause, eliminates the redundant copy, uses well-established APIs available on all target frameworks, and matches the reporter\u0027s well-reasoned proposal."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The bug is clearly identified by code inspection with a concrete fix proposal. Needs brief investigation to check for similar patterns elsewhere (e.g., SkiaSharp\u0027s SKData) before applying the fix."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Correct area label from SkiaSharp to HarfBuzzSharp and remove incorrect Windows-Classic platform label",
            "reason": "Bug is in HarfBuzzSharp.Blob, not SkiaSharp core. Platform is All, not Windows-specific.",
            "confidence": 0.95,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/HarfBuzzSharp"
              ],
              "labelsToRemove": [
                "area/SkiaSharp",
                "os/Windows-Classic"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug report and confirm the analysis is correct",
            "reason": "Reporter provided excellent analysis with a concrete fix. Acknowledging and confirming encourages high-quality reports.",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the thorough analysis \u2014 you\u0027re right that the \u0060fixed\u0060 block scope is too narrow here. Once the block exits, the managed array is unpinned and the GC is free to relocate it, leaving the \u0060Blob\u0060 with a dangling pointer.\n\nYour proposed fix using \u0060Marshal.AllocCoTaskMem\u0060 with \u0060UnmanagedMemoryStream\u0060 looks correct and also has the nice side effect of eliminating the redundant \u0060ToArray()\u0060 copy.\n\nWe should also check whether similar patterns exist elsewhere in the codebase before applying the fix.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3472-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3472"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3440,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-10T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp.Views.Maui",
          "os/Windows-WinUI",
          "tenet/reliability"
        ]
      },
      "summary": "MAUI app crashes on certain Windows 11 systems with COMException in PropertySetExtensions WinRT activation during ANGLE surface creation",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.90
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.92
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-WinUI",
            "confidence": 0.97
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.97
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "steps-only",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "net8.0-windows",
            "net9.0-windows"
          ],
          "severity": "high",
          "severityReason": "Application crash with no known workaround during view initialization. Occurs on certain deployed systems, blocking production use on affected machines. The crash is unrecoverable \u2014 once the static initializer fails, all subsequent calls also fail."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a MAUI app with LiveCharts2 that uses SkiaSharp 3.119.1 for chart rendering",
            "Deploy the app to a Windows 11 system (reported: Lenovo 83C4, Windows 11 10.0.26100.7462)",
            "Launch the app \u2014 crashes when AngleSwapChainPanel loads and attempts to create the ANGLE render surface"
          ],
          "codeSnippets": [
            {
              "language": "xml",
              "code": "\u003CliveCharts:CartesianChart x:Name=\u0022Graph\u0022\n                                   AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022\n                                   AbsoluteLayout.LayoutFlags=\u0022PositionProportional,SizeProportional\u0022\n                                   ZoomMode=\u0022None\u0022\n                                   EasingFunction=\u0022{x:Null}\u0022\n                                   ... /\u003E",
              "context": "XAML markup for the LiveCharts2 CartesianChart that triggers the crash via SkiaSharp rendering"
            },
            {
              "language": "text",
              "code": "System.Runtime.InteropServices.COMException: Element not found.\n  at void Marshal.ThrowExceptionForHR(int errorCode)() in Marshal.cs:line 856\n  at new BaseActivationFactory(string typeNamespace, string typeFullName)()\n  at static PropertySetExtensions()()\n\nSystem.TypeInitializationException: The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception.\n  at IObjectReference PropertySetExtensions.get__objRef_global__SkiaSharp_Views_WinUI_Native_IPropertySetExtensionsStatics()()\n  at void PropertySetExtensions.AddSingle(PropertySet propertySet, string key, float value)()\n  at void GlesContext.CreateSurface(SwapChainPanel panel, Size? renderSurfaceSize, float? resolutionScale)()\n  at void AngleSwapChainPanel.EnsureRenderSurface()()\n  at void AngleSwapChainPanel.OnLoaded(object sender, RoutedEventArgs e)()\n  at int RoutedEventHandler.Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e)()",
              "context": "Full stack trace showing COMException during WinRT activation of PropertySetExtensions"
            }
          ],
          "environmentDetails": "Windows 11 (10.0.26100.7462), Lenovo 83C4, SkiaSharp 3.119.1, MAUI app with LiveCharts2. Tried with HA (Hardware Acceleration) enabled and disabled \u2014 same result."
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.1"
          ],
          "currentRelevance": "likely",
          "reason": "Version 3.119.1 is a current stable release. The WinRT activation issue with PropertySetExtensions has been reported across multiple 3.x versions, indicating a persistent architectural issue not yet resolved."
        },
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "MAUI app with LiveCharts2 crashes on certain Windows 11 systems during ANGLE render surface creation. The WinRT activation factory for SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails with COMException \u0027Element not found\u0027, a recurring pattern seen across multiple issues.",
        "keySignals": [
          {
            "text": "System.Runtime.InteropServices.COMException: Element not found.",
            "source": "stack-trace",
            "interpretation": "WinRT activation factory cannot locate the SkiaSharp.Views.WinUI.Native component DLL or its class registration. This occurs before any GPU interaction."
          },
          {
            "text": "The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception",
            "source": "stack-trace",
            "interpretation": "Static constructor failure in the WinRT projection class. Once this fails, it is permanently broken for the process lifetime."
          },
          {
            "text": "crashes on certain systems",
            "source": "body",
            "interpretation": "Environment-dependent failure \u2014 suggests deployment or system configuration issue (WinRT component registration, packaging mode, Windows App SDK runtime) rather than a universal code bug."
          },
          {
            "text": "tried both with HA enabled and disabled but the result is the same",
            "source": "body",
            "interpretation": "Hardware acceleration toggle does not affect the crash, confirming the issue is in WinRT component activation (before any GPU interaction), not in the rendering pipeline itself."
          },
          {
            "text": "MAUI app with LiveCharts2 that uses SkiaSharp 3.119.1",
            "source": "body",
            "interpretation": "Third-party library (LiveCharts2) uses SkiaSharp for rendering. User may not have direct control over which SkiaSharp view type (SKGLView vs SKCanvasView) is used."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The issue reports a crash with a full stack trace during normal rendering initialization. The app terminates with COMException/TypeInitializationException \u2014 clearly broken behavior, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they are reporting a crash."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Maui",
            "expandedReason": "The crash occurs in SkiaSharp.Views.WinUI components (PropertySetExtensions, GlesContext, AngleSwapChainPanel) used through a MAUI app. The reporter\u0027s context is MAUI and the existing label correctly scopes this.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "SkiaSharp.Views.Maui is more specific \u2014 the crash is in MAUI-deployed WinUI views."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "The crash path goes through AngleSwapChainPanel \u2192 GlesContext.CreateSurface, which is the ANGLE OpenGL ES backend. ANGLE translates OpenGL ES to Direct3D on Windows. PropertySetExtensions is only needed for GLES surface setup."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-WinUI",
            "expandedReason": "Explicitly Windows 11, WinUI 3 stack. The crash is in SkiaSharp.Views.WinUI.Native.PropertySetExtensions, a C\u002B\u002B/WinRT component specific to the WinUI rendering path."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Application crash during rendering initialization. The COMException causes a TypeInitializationException that terminates rendering entirely with no recovery path."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Crash with no known workaround for users who need GPU-accelerated rendering via SKGLView. The crash is unrecoverable and happens during initialization. It only affects \u0027certain systems\u0027 so it\u0027s not universal \u2014 hence high rather than critical.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "The crash is environment-specific, not universal. Apps using SKCanvasView are unaffected."
              },
              {
                "value": "medium",
                "whyRejected": "No confirmed workaround for affected users, and the crash prevents all rendering."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "This is part of a recurring pattern of WinRT activation failures for PropertySetExtensions. The root cause \u2014 the C\u002B\u002B/WinRT component failing to activate on certain system configurations \u2014 needs engineering investigation to find a robust solution, potentially replacing the WinRT component with managed code.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "While more info would help (packaged vs unpackaged, DLL presence), the stack trace and environment details are sufficient to classify and begin investigation."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the app is deployed as packaged (MSIX) or unpackaged \u2014 this significantly affects WinRT component discovery",
          "Whether SkiaSharp.Views.WinUI.Native.dll is present in the app output directory on the failing systems",
          "Whether the failing systems have Windows App SDK runtime installed or if the app is self-contained",
          "Which specific system configuration differences cause the failure on \u0027certain systems\u0027 but not others"
        ],
        "assumptions": [
          "Assumed the app uses SKGLView (via LiveCharts2) since the crash path is through AngleSwapChainPanel, the GPU-accelerated OpenGL ES view",
          "Assumed target framework is net8.0-windows or net9.0-windows based on SkiaSharp 3.119.1 being a modern version"
        ],
        "resolution": {
          "hypothesis": "The WinRT activation factory for SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails because the C\u002B\u002B/WinRT component DLL cannot be discovered by the WinRT activation system on certain Windows configurations. The \u0027Element not found\u0027 COMException suggests the activation catalog entry exists but the backing DLL or class cannot be located, likely due to deployment mode or Windows App SDK runtime state.",
          "proposals": [
            {
              "title": "Replace WinRT PropertySetExtensions with managed alternative",
              "description": "Eliminate the dependency on the C\u002B\u002B/WinRT component by implementing PropertySet manipulation in managed code using WinRT interop APIs directly. This removes the activation factory requirement entirely and fixes this class of issues across all deployment modes.",
              "confidence": 0.70,
              "effort": "high"
            },
            {
              "title": "Add try-catch fallback around PropertySetExtensions in GlesContext.CreateSurface",
              "description": "Wrap PropertySetExtensions calls with try-catch(COMException) and skip the optional resolution scale/surface size properties on failure, allowing ANGLE surface creation to proceed with defaults.",
              "confidence": 0.60,
              "effort": "medium"
            },
            {
              "title": "Use SKCanvasView instead of SKGLView as workaround",
              "description": "Configure LiveCharts2 to use SKCanvasView (CPU rendering) instead of SKGLView, bypassing the entire AngleSwapChainPanel/GlesContext/PropertySetExtensions code path. Workaround for end users, not a fix in SkiaSharp itself.",
              "confidence": 0.80,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Replace WinRT PropertySetExtensions with managed alternative",
          "recommendedReason": "This is the root-cause fix that eliminates the entire class of WinRT activation failures. The C\u002B\u002B/WinRT component exists solely to add typed values to a PropertySet, which should be achievable in managed code. While higher effort, it permanently solves the recurring deployment and activation issues."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "This is a recurring WinRT activation failure pattern affecting multiple users across versions. The root cause needs engineering investigation \u2014 specifically whether PropertySetExtensions can be replaced with managed code to eliminate the C\u002B\u002B/WinRT dependency."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add backend/OpenGL and partner/maui labels to existing labels",
            "reason": "The crash is in the ANGLE OpenGL ES path and the reporter uses MAUI \u2014 these labels are missing from the current set",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis response with diagnostic questions and workaround suggestion",
            "reason": "Provide useful context from related issues and suggest diagnostic steps to narrow down the deployment configuration causing the failure",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the detailed stack trace \u2014 that\u0027s very helpful for diagnosing this.\n\nThis is a known issue pattern where the WinRT activation factory for \u0060SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0060 fails on certain Windows configurations. The \u0060COMException: Element not found\u0060 during \u0060BaseActivationFactory\u0060 construction suggests the WinRT component DLL either isn\u0027t deployed alongside the app or can\u0027t be found by the WinRT activation system on that particular machine.\n\nA couple of questions that would help narrow this down:\n\n1. Is the app deployed as packaged (MSIX) or unpackaged (\u0060WindowsPackageType=None\u0060)?\n2. Can you confirm whether \u0060SkiaSharp.Views.WinUI.Native.dll\u0060 exists in the app\u0027s output directory on the failing system?\n\nAs a potential workaround, if LiveCharts2 supports it, using \u0060SKCanvasView\u0060 instead of \u0060SKGLView\u0060 would bypass the ANGLE/OpenGL path entirely \u2014 though with CPU rendering instead of GPU-accelerated.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3440-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3440"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3437,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability",
          "backend/SVG"
        ]
      },
      "summary": "SKSvgCanvas produces \u003Ctext\u003E elements with missing text values and x/y attributes when used concurrently in parallel tasks on Windows \u2014 regression from 2.88.9",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.90
        },
        "backends": [
          {
            "value": "backend/SVG",
            "confidence": 0.98
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "hasWorkaround": true,
          "workaroundSummary": "Avoid parallel usage of SKSvgCanvas \u2014 serialize SVG generation to a single thread, or downgrade to SkiaSharp 2.88.9.",
          "targetFrameworks": [
            "net8.0-windows"
          ],
          "severity": "high",
          "severityReason": "Data corruption in SVG output with no simple workaround besides removing parallelism. Regression from 2.x."
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/jankurianski/skiasharp-svg-text-missing-bug",
              "description": "Full reproduction project demonstrating parallel SKSvgCanvas text corruption on Windows"
            }
          ],
          "stepsToReproduce": [
            "Create multiple parallel tasks using Task.Run()",
            "In each task, create an independent SKSvgCanvas writing to a MemoryStream",
            "Draw multiple text elements using canvas.DrawText()",
            "Dispose canvas to flush SVG output",
            "Inspect resulting SVG \u2014 \u003Ctext\u003E elements will have empty x/y attributes and missing text content"
          ],
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "await Task.WhenAll(\n    Enumerable.Range(0, 5)\n    .Select(i =\u003E Task.Run(() =\u003E drawSvgFunc(i)))\n    ).ConfigureAwait(false);",
              "context": "Parallel SVG generation triggering the bug \u2014 each task creates its own independent SKSvgCanvas"
            }
          ],
          "environmentDetails": "Windows 11, Visual Studio Code, SkiaSharp 3.116.0 / 3.119.1 / 3.119.2-preview.1. Linux (Ubuntu 22.04.2 LTS via WSL) is unaffected."
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "3.119.2-preview.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Bug affects all SkiaSharp 3.x versions tested including the latest preview. Confirmed working in 2.88.9.",
          "migrationPath": null
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.92,
          "reason": "Reporter explicitly states 2.88.9 does not have the bug and all 3.x versions do. This aligns with the major Skia engine upgrade between 2.x and 3.x.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Thread-safety bug in the SVG canvas backend on Windows. Independent SKSvgCanvas instances used in parallel tasks produce corrupted \u003Ctext\u003E elements with missing content and attributes. This is a regression from 2.88.9, suggesting the Skia 3.x SVG module introduced shared mutable global state.",
        "keySignals": [
          {
            "text": "text elements will sometimes have their text value and x/y attribute values removed",
            "source": "body",
            "interpretation": "Data corruption in SVG output \u2014 not a crash but silent data loss"
          },
          {
            "text": "The more text elements being drawn and the more threads running the same task, the more likely the problem is to occur",
            "source": "body",
            "interpretation": "Classic race condition symptom \u2014 probability increases with concurrency"
          },
          {
            "text": "This affects all SkiaSharp 3.x versions on Windows. Linux is unaffected.",
            "source": "body",
            "interpretation": "Windows-specific thread-safety issue, possibly related to platform-specific string formatting or locale handling"
          },
          {
            "text": "This is a regression from SkiaSharp 2.88.9 which does not have the bug.",
            "source": "body",
            "interpretation": "Regression tied to the Skia engine upgrade from 2.x to 3.x"
          },
          {
            "text": "I tested the bug on Ubuntu 22.04.2 LTS (using WSL) and the bug does not occur there",
            "source": "comment 1",
            "interpretation": "Reporter confirmed Linux is unaffected even with 100 elements and 50 parallel tasks \u2014 strongly platform-specific"
          },
          {
            "text": "GitHub repository with full source code to reproduce",
            "source": "body",
            "interpretation": "Complete reproduction project available \u2014 high-quality bug report"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Clear broken behavior: SVG output data corruption where text elements lose their content and attributes. The reporter provides expected vs actual output showing the defect.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to use threading \u2014 reporting data corruption in independent canvas instances."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKSvgCanvas is part of the core SkiaSharp API surface (binding/SkiaSharp/). While it targets SVG output, the code path goes through the main SkiaSharp library.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the root cause is likely in native Skia SVG code, the entry point is through the managed SkiaSharp API."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/SVG",
            "expandedReason": "The bug is specific to SKSvgCanvas \u2014 the SVG rendering backend. Standard raster canvas drawing is not affected."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Reporter confirmed the bug only occurs on Windows 11. Ubuntu 22.04 via WSL is unaffected even with significantly more parallelism."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Silent data corruption in output \u2014 text elements lose their content without any error or warning. The only workaround is to serialize work or downgrade to 2.x. This is a regression affecting all 3.x versions."
          }
        ],
        "uncertainties": [
          "Whether the root cause is in Skia\u0027s C\u002B\u002B SVG module or in the C API/P/Invoke layer \u2014 needs native debugging",
          "Whether the issue affects other SVG element types beyond \u003Ctext\u003E or if it\u0027s specific to text rendering",
          "Whether Windows-specific locale or string formatting functions used in SVG serialization are the source of the race condition",
          "The exact shared mutable state causing the race \u2014 could be global buffers, static formatters, or locale-dependent number-to-string conversion"
        ],
        "assumptions": [
          "Assumed net8.0-windows target framework since reporter uses Windows 11 with VS Code but doesn\u0027t specify exact TFM",
          "Assumed the race condition is in native Skia code rather than the managed wrapper since each thread creates fully independent managed objects"
        ],
        "resolution": {
          "hypothesis": "The Skia 3.x SVG serialization module likely uses shared global state (possibly a string formatting buffer or locale-dependent number conversion function) that is not thread-safe on Windows. Linux uses different formatting functions (e.g., POSIX locale-independent formatting) that happen to be thread-safe, explaining the platform difference.",
          "proposals": [
            {
              "title": "Add thread-safety documentation for SKSvgCanvas",
              "description": "Document that Skia is not thread-safe and SKSvgCanvas instances should not be used concurrently, even if they are independent instances. This is the quickest mitigation but doesn\u0027t fix the underlying defect.",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Investigate and fix shared state in Skia SVG module",
              "description": "Debug the native Skia SVG serialization to identify the shared mutable state causing the race condition on Windows. This likely involves SkSVGDevice or related classes. May require an upstream Skia fix or a SkiaSharp-specific patch in the fork.",
              "confidence": 0.65,
              "effort": "high"
            },
            {
              "title": "Add per-thread locking around SVG canvas operations",
              "description": "Add a global lock in the managed SKSvgCanvas wrapper to serialize access to the SVG backend. This would fix the corruption but eliminate parallelism benefits for SVG generation.",
              "confidence": 0.80,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Investigate and fix shared state in Skia SVG module",
          "recommendedReason": "The root cause fix is the right long-term solution. Each independent canvas instance should be fully thread-safe. The regression from 2.x suggests a specific change that can be identified and fixed."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.90,
          "reason": "Well-documented regression with complete repro project. Needs native-level debugging to identify the shared global state in Skia\u0027s SVG module causing the Windows-specific race condition."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add tenet/compatibility label to reflect this is a 2.x to 3.x regression",
            "reason": "The regression from 2.88.9 to 3.x is a key signal \u2014 compatibility tenet captures this",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the high-quality report and confirm investigation is needed",
            "reason": "Reporter provided excellent reproduction material and cross-platform testing. Acknowledge the regression and signal that native-level investigation is the next step.",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the thorough report and the cross-platform testing \u2014 confirming Linux is unaffected is really helpful for narrowing this down.\n\nThis looks like a thread-safety issue in Skia\u0027s SVG serialization that\u0027s specific to Windows. Even though each task creates its own independent SKSvgCanvas, there may be shared global state in the native SVG module (possibly related to Windows string formatting or number-to-string conversion) that isn\u0027t safe to access concurrently.\n\nThe regression from 2.88.9 is a strong signal \u2014 the Skia engine was upgraded significantly between 2.x and 3.x, which likely changed how SVG text serialization works internally.\n\nThis needs investigation at the native Skia level to identify the shared state. In the meantime, serializing SVG generation to a single thread would be the safest workaround.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3437-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3437"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3435,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "DllNotFoundException for libSkiaSharp in Blazor WASM after upgrading from .NET 9 to .NET 10 \u2014 duplicate of #3422",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.90
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.92
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.88
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "none",
          "hasWorkaround": true,
          "workaroundSummary": "Downgrade to .NET 9 which works with SkiaSharp 3.116.1. Also, \u0027dotnet workload restore\u0027 may help per #3422 comments, though results are inconsistent.",
          "targetFrameworks": [
            "net10.0"
          ],
          "severity": "high",
          "severityReason": "Complete failure to load libSkiaSharp in Blazor WASM on .NET 10. SkiaSharp is entirely unusable in this scenario. Multiple users affected across #3422."
        },
        "reproEvidence": {
          "relatedIssues": [
            3422
          ],
          "environmentDetails": "Blazor WASM targeting .NET 10. Tried SkiaSharp 3.116.1 and 3.119.2-preview.1. Previously worked on .NET 9 with 3.116.1."
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.1",
            "3.119.2-preview.1"
          ],
          "currentRelevance": "likely",
          "reason": "Issue affects all SkiaSharp versions on .NET 10 WASM. The root cause is a .NET 10 WASM toolchain change, not a SkiaSharp version-specific regression. Confirmed by #3422 where even 2.88.x versions fail."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "SkiaSharp Blazor WASM worked on .NET 9 but fails on .NET 10. The regression is in the .NET platform\u0027s WASM toolchain, not in SkiaSharp itself \u2014 rolling back SkiaSharp versions does not fix it.",
          "workedInVersion": "3.116.1",
          "brokeInVersion": "3.116.1"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Duplicate of #3422. DllNotFoundException for libSkiaSharp in Blazor WASM on .NET 10. The .NET 10 WASM toolchain changed how native static linking works, breaking SkiaSharp\u0027s NativeAssets.WebAssembly integration. All SkiaSharp versions are affected.",
        "keySignals": [
          {
            "text": "System.DllNotFoundException: libSkiaSharp",
            "source": "title",
            "interpretation": "Native library not found \u2014 on WASM this means the .a file was not statically linked into dotnet.wasm during build."
          },
          {
            "text": "Started getting this runtime error after upgrading Blazor app from .Net 9 to .Net 10",
            "source": "body",
            "interpretation": "Clearly identifies .NET 10 upgrade as the trigger, matching #3422 pattern exactly."
          },
          {
            "text": ".Net 9 app worked with 3.116.1",
            "source": "body",
            "interpretation": "Confirms this is a .NET 10 regression, not a SkiaSharp version issue."
          },
          {
            "text": "Platform: Blazor, WASM",
            "source": "body",
            "interpretation": "This is a WASM issue, not Windows-Classic as currently labeled."
          },
          {
            "text": "Duplicate of https://github.com/mono/SkiaSharp/issues/3422",
            "source": "comment 2",
            "interpretation": "Community member identifies this as a duplicate of the canonical .NET 10 Blazor WASM issue."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "DllNotFoundException is a clear runtime crash. The reporter describes something that previously worked (Blazor WASM with .NET 9) now failing after upgrading to .NET 10. This is broken behavior, not a usage question.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they are reporting a crash that occurred after a .NET version upgrade."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Blazor",
            "expandedReason": "The issue is in a Blazor WASM app using SkiaSharp. The root cause is the WASM static linking pipeline managed by SkiaSharp.Views.Blazor and NativeAssets.WebAssembly packages. The current label area/libSkiaSharp.native is less specific \u2014 the native binary itself is fine, it\u0027s the WASM linking integration that\u0027s broken.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the native library fails to load, the root cause is in the WASM static linking pipeline, not the native binary itself. area/SkiaSharp.Views.Blazor better captures where the fix needs to happen."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM",
            "expandedReason": "Reporter explicitly states platform is \u0027Blazor, WASM\u0027. The current os/Windows-Classic label is incorrect \u2014 the issue is about WebAssembly execution in the browser, not Windows desktop. Windows is merely the development machine OS."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "tenet/reliability: DllNotFoundException causes complete failure. tenet/compatibility: This is a cross-version compatibility issue \u2014 SkiaSharp doesn\u0027t work with .NET 10\u0027s WASM toolchain."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Complete inability to use SkiaSharp in Blazor WASM on .NET 10. Workaround is to stay on .NET 9, which is viable but limits adoption.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": ".NET 10 is still in preview and users can stay on .NET 9. Not a data-loss or security issue."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "A community member identified this as a duplicate of #3422, which tracks the exact same issue (DllNotFoundException/TypeInitializationException for SkiaSharp in Blazor WASM on .NET 10). The symptoms, platform, and root cause are identical. #3422 has more detailed reproduction and community discussion."
          }
        ],
        "uncertainties": [
          "Whether the reporter tried \u0027dotnet workload restore\u0027 as suggested in #3422",
          "Whether the reporter\u0027s development environment is Windows or another OS \u2014 they selected \u0027Blazor, WASM\u0027 as platform but the previous triage labeled it Windows-Classic"
        ],
        "assumptions": [
          "Assumed this is the same root cause as #3422 based on identical symptoms (DllNotFoundException: libSkiaSharp in Blazor WASM on .NET 10) and the community duplicate identification",
          "Assumed the reporter\u0027s platform selection of \u0027Blazor, WASM\u0027 is accurate and os/Windows-Classic was a triage error"
        ],
        "resolution": null
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.90,
          "reason": "Identical symptoms to #3422: DllNotFoundException for libSkiaSharp in Blazor WASM on .NET 10. Community member confirms duplicate. #3422 is the canonical issue with more detail and discussion."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Fix platform and area labels: replace incorrect Windows-Classic with WASM, replace libSkiaSharp.native with Views.Blazor, add compatibility tenet",
            "reason": "Current labels have incorrect platform (Windows-Classic instead of WASM) and less specific area. This is a Blazor WASM issue, not a Windows desktop issue.",
            "confidence": 0.92,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "os/WASM",
                "area/SkiaSharp.Views.Blazor",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "os/Windows-Classic",
                "area/libSkiaSharp.native"
              ]
            }
          },
          {
            "id": "dup-1",
            "type": "link-duplicate",
            "risk": "medium",
            "description": "Mark as duplicate of #3422",
            "reason": "Identical issue: DllNotFoundException for libSkiaSharp in Blazor WASM on .NET 10. Confirmed by community member and matching symptoms.",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "duplicateOf": 3422,
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Notify reporter of duplicate and suggest workaround",
            "reason": "Let reporter know this is tracked in #3422 and provide interim guidance",
            "confidence": 0.88,
            "dependsOn": "dup-1",
            "payload": {
              "commentType": "duplicate-notice",
              "draftBody": "Thanks for reporting this. This is the same .NET 10 Blazor WASM compatibility issue tracked in #3422 \u2014 the \u0060DllNotFoundException\u0060 happens because the .NET 10 WASM toolchain changed how native libraries are statically linked, which affects all SkiaSharp versions.\n\nAs an interim workaround, some users have had success running \u0060dotnet workload restore\u0060 to ensure the WASM workload is properly installed for .NET 10. If that doesn\u0027t help, staying on .NET 9 is a reliable fallback until this is resolved.\n\nClosing in favor of #3422 where the investigation is being tracked.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3435-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as duplicate of #3422",
            "reason": "Duplicate of #3422 \u2014 same root cause and symptoms",
            "confidence": 0.90,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3435"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3430,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/WASM",
          "area/SkiaSharp.Views.Uno",
          "os/Windows-WinUI",
          "tenet/reliability"
        ]
      },
      "summary": "NullReferenceException in SKXamlCanvas.Skia when canvas resizes because FreeBitmap destroys the bitmap that CreateBitmap just allocated",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.Views.Uno",
          "confidence": 0.97
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.85
          },
          {
            "value": "os/Windows-WinUI",
            "confidence": 0.85
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": {
          "value": "partner/unoplatform",
          "confidence": 0.95
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "severity": "medium",
          "severityReason": "NRE crash when canvas resizes, but only affects the Uno Skia variant and requires a size change to trigger. No workaround provided, but the trigger condition is specific."
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/blob/fbd27f7ec2e2ad8bd0f0f0484dd467c5d8395ae1/source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs#L72",
              "description": "Line 72 where bitmap.PixelBuffer throws NRE because bitmap was set to null by FreeBitmap"
            }
          ],
          "stepsToReproduce": [
            "Use SKXamlCanvas in an Uno Platform Skia-based app",
            "Trigger a canvas size change (e.g. window resize)",
            "DoInvalidate is called, which calls CreateBitmap",
            "CreateBitmap calls FreeBitmap at line 87 (size changed), then creates new bitmap at line 91",
            "CreateBitmap calls FreeBitmap again at line 106 (pixels null), which sets bitmap=null",
            "Back in DoInvalidate, line 72 accesses bitmap.PixelBuffer \u2014 NRE"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), Uno Platform Skia targets"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "The bug is in current source code (SKXamlCanvas.Skia.cs). The reporter lists 2.88.9 as the last known good version, but the Skia-specific variant of SKXamlCanvas may not have existed in that version, making the regression claim uncertain."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.55,
          "reason": "Reporter selected 2.88.9 as last good version from a form dropdown, but the SKXamlCanvas.Skia.cs file (Uno Skia variant) likely did not exist in 2.88.9. This may be a latent bug rather than a regression."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "The reporter identified a real race condition in SKXamlCanvas.Skia.cs where CreateBitmap calls FreeBitmap twice during a size change, destroying the WriteableBitmap before DoInvalidate can use it. The code path is clear from reading the source.",
        "keySignals": [
          {
            "text": "FreeBitmap method may have reset bitmap field to null",
            "source": "body",
            "interpretation": "Reporter correctly identified the root cause: FreeBitmap nulls the bitmap field, and it is accessed after that"
          },
          {
            "text": "This line of code may throw NRE if the canvas changed its size",
            "source": "body",
            "interpretation": "The trigger is a canvas size change, which causes CreateBitmap to call FreeBitmap twice \u2014 once for size mismatch (line 87) and once for pixels mismatch (line 106)"
          },
          {
            "text": "Link to SKXamlCanvas.Skia.cs line 72",
            "source": "body",
            "interpretation": "Points to bitmap.PixelBuffer.AsStream() where NRE occurs because bitmap is null after the double-FreeBitmap sequence"
          },
          {
            "text": "Version: 3.116.0, Last Known Good: 2.88.9",
            "source": "body",
            "interpretation": "May be a latent bug rather than a regression since the Skia variant of this file is relatively new"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter describes a NullReferenceException caused by a logic error in resource management code. The bitmap field is set to null by FreeBitmap and then accessed without a null check. This is clearly broken behavior.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "This is not an improvement request \u2014 it\u0027s a crash caused by a logic error."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Uno",
            "expandedReason": "The bug is in SKXamlCanvas.Skia.cs, which is part of the SkiaSharp.Views.Uno.WinUI.Skia project. This is specific to the Uno Platform Skia rendering path.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "The more specific area/SkiaSharp.Views.Uno label exists and the bug is Uno-specific."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "NRE crash with no workaround, but the trigger is specific (canvas resize on Uno Skia targets). Not critical because it doesn\u0027t cause data loss and only affects one platform variant."
          },
          {
            "field": "partner",
            "chosen": "partner/unoplatform",
            "expandedReason": "The bug is in the Uno Platform-specific view layer (SKXamlCanvas.Skia.cs). The reporter MartinZikmund is a well-known Uno Platform contributor. The fix may need coordination with Uno Platform."
          }
        ],
        "uncertainties": [
          "Whether this bug also exists in the non-Skia variants of SKXamlCanvas (UWP/WinUI native paths)",
          "Whether the 2.88.9 last-known-good version claim is accurate or just a form default selection",
          "Whether there are other callers or code paths that can trigger the same double-FreeBitmap issue"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s code analysis is correct based on source code inspection confirming the double-FreeBitmap path",
          "Assumed \u0027All\u0027 platforms means all Uno Skia targets (WASM, WinUI desktop), not all SkiaSharp platforms"
        ],
        "resolution": {
          "hypothesis": "CreateBitmap calls FreeBitmap at line 106 to free the old pixel buffer, but this also nulls the bitmap that was just created at line 91. The second FreeBitmap destroys the bitmap unnecessarily because it conflates pixel buffer management with bitmap management.",
          "proposals": [
            {
              "title": "Add null check before accessing bitmap in DoInvalidate",
              "description": "Guard line 72 with \u0060if (bitmap != null)\u0060 before accessing bitmap.PixelBuffer. Simple defensive fix that prevents the NRE, but doesn\u0027t address the underlying logic issue where CreateBitmap returns with bitmap=null.",
              "confidence": 0.70,
              "effort": "low"
            },
            {
              "title": "Separate pixel buffer freeing from bitmap freeing in CreateBitmap",
              "description": "Split FreeBitmap into two concerns: one that frees pixels/handle only, and one that frees the bitmap. The second FreeBitmap call at line 106 only needs to free the pixel buffer, not the bitmap. This addresses the root cause by ensuring the bitmap created at line 91 survives the pixel reallocation.",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Restructure CreateBitmap to handle bitmap and pixels independently",
              "description": "Refactor CreateBitmap so that bitmap creation and pixel buffer allocation are managed separately with their own lifecycle. The bitmap should only be recreated when its dimensions change, and pixels should be reallocated independently. This is the cleanest fix but involves more refactoring.",
              "confidence": 0.85,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Separate pixel buffer freeing from bitmap freeing in CreateBitmap",
          "recommendedReason": "Addresses the root cause directly with minimal code change. The second FreeBitmap call only needs to free the GCHandle and pixel array, not the WriteableBitmap."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The bug report identifies a real logic error confirmed by source code inspection. The fix approach is clear but should be verified with a test to ensure the bitmap lifecycle is correct across all size-change scenarios."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add partner/unoplatform label \u2014 existing labels are already correct",
            "reason": "The bug is in the Uno Platform-specific view layer and the reporter is an Uno Platform contributor",
            "confidence": 0.92,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "partner/unoplatform"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis confirming the bug and describing the root cause",
            "reason": "Acknowledge the well-analyzed report and confirm the double-FreeBitmap root cause",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the clear analysis and the direct pointer to the problematic line.\n\nConfirmed \u2014 the issue is in \u0060CreateBitmap()\u0060 where \u0060FreeBitmap()\u0060 is called twice during a size change. The first call (line 87) correctly frees the old bitmap when dimensions change, and then a new \u0060WriteableBitmap\u0060 is created (line 91). But the second call (line 106) frees the pixel buffer *and* nulls the bitmap that was just created, because \u0060FreeBitmap()\u0060 doesn\u0027t distinguish between the two resources.\n\nThe fix would be to separate pixel buffer management from bitmap management in that second code path, so that reallocating the pixel array doesn\u0027t destroy the freshly created bitmap.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3430-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3430"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3429,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "Memory leak in WPF on Windows with Nvidia Quadro GPU drivers when drawing patterns on high-resolution monitors; mitigated by WPF software-only rendering mode",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.75
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.90
          },
          {
            "value": "tenet/performance",
            "confidence": 0.85
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "hasWorkaround": true,
          "workaroundSummary": "Set RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly in App.OnStartup to disable WPF hardware acceleration. Not practical for production due to performance impact on other application features.",
          "severity": "medium",
          "severityReason": "Memory leak in production use with a workaround that is impractical due to performance degradation. Only affects Nvidia Quadro series GPUs."
        },
        "reproEvidence": {
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "protected override void OnStartup(StartupEventArgs e)\n{\n    RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly;\n    base.OnStartup(e);\n}",
              "context": "Workaround that disables WPF hardware acceleration to avoid the memory leak"
            }
          ],
          "relatedIssues": [
            3309,
            2660,
            2848
          ],
          "environmentDetails": "Windows, WPF, Nvidia Quadro series GPU, high resolution monitor, Visual Studio, SkiaSharp 3.116.0"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Issue reported on 3.116.0 which was current at time of filing. Last known good version is 2.88.9 (v2 series), suggesting the issue may have been introduced in the v3 rewrite.",
          "migrationPath": null
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.70,
          "reason": "Reporter states last known good version is 2.88.9. However, the gap between v2.88.9 and v3.116.0 is a major version jump spanning the v3 rewrite, so this is a broad regression claim rather than a pinpointed version.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "GPU-driver-specific memory leak in WPF when drawing patterns with SkiaSharp, isolated to Nvidia Quadro series. The WPF SoftwareOnly workaround points to an interaction between SkiaSharp rendering and WPF\u0027s hardware-accelerated compositing layer. Related to other GPU memory leak reports (#3309, #2660, #2848) but distinct due to Quadro-specific trigger.",
        "keySignals": [
          {
            "text": "Memory Leak on Window with Nvidia GPU driver",
            "source": "title",
            "interpretation": "GPU-driver-specific memory leak, not a general SkiaSharp issue"
          },
          {
            "text": "only occurred in the Nvidia Quadro series",
            "source": "body",
            "interpretation": "Highly specific to professional GPU line \u2014 suggests driver-level interaction, not a generic SkiaSharp bug"
          },
          {
            "text": "doesn\u0027t happen with Nvidia Geforce or AMD",
            "source": "body",
            "interpretation": "Reporter did thorough cross-GPU testing, narrowing to Quadro-specific driver behavior"
          },
          {
            "text": "RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly",
            "source": "body",
            "interpretation": "Disabling WPF hardware acceleration eliminates the leak, pointing to GPU compositing interaction as the root cause"
          },
          {
            "text": "drawing patterns in wpf, a memory leak issue was encountered on the high resolution monitor",
            "source": "body",
            "interpretation": "High-DPI display may amplify the leak due to larger backing buffers or scaling operations"
          },
          {
            "text": "Version 3.116.0, Last Known Good 2.88.9",
            "source": "body",
            "interpretation": "Possible regression from v2 to v3 series, though this is a large version gap"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a memory leak that grows over time during normal drawing operations. This is broken behavior \u2014 memory should not leak during repeated draw calls.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they are reporting broken behavior with a specific workaround they already found."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The issue occurs when drawing patterns in WPF, which uses SkiaSharp.Views.WPF controls. The workaround is a WPF-level rendering setting, further pointing to the views integration layer. Could also be area/libSkiaSharp.native if the native library leaks GPU memory on Quadro drivers.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "Possible, but the WPF SoftwareOnly workaround suggests the leak is in the compositing/presentation layer rather than core native rendering."
              },
              {
                "value": "area/SkiaSharp",
                "whyRejected": "Too broad \u2014 the issue is specific to WPF rendering integration, not core SkiaSharp API."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Memory leak that worsens over time, but has a workaround (software rendering). The workaround is impractical for production, but the issue is limited to Nvidia Quadro GPUs, reducing the affected population."
          },
          {
            "field": "regression",
            "chosen": "true",
            "expandedReason": "Reporter claims last known good version is 2.88.9. The v2-to-v3 jump involved a major rewrite of the native layer and views, making regression plausible but the specific breaking change hard to pinpoint."
          }
        ],
        "uncertainties": [
          "Which WPF SkiaSharp control is being used (SKElement, SKGLElement, or SKXamlCanvas)?",
          "Whether the leak is in SkiaSharp\u0027s rendering, WPF\u0027s compositing, or the Nvidia Quadro driver itself",
          "Specific Nvidia Quadro model and driver version",
          "Whether the issue is specific to high-DPI or also occurs on standard resolution monitors",
          "Whether #3309 (SKGLElement OpenTK memory leak fix) resolves this issue as well"
        ],
        "assumptions": [
          "Assumed the reporter is using a WPF SkiaSharp view control (SKElement or SKGLElement) since they mention \u0027drawing patterns in WPF\u0027",
          "Assumed the memory leak is reproducible and not a measurement artifact, based on the reporter\u0027s cross-GPU validation"
        ],
        "resolution": {
          "hypothesis": "The Nvidia Quadro driver handles GPU resource management differently from GeForce and AMD drivers, causing SkiaSharp-rendered surfaces to leak GPU memory when composited through WPF\u0027s hardware-accelerated pipeline. The v3 rewrite may have changed how surfaces are allocated or recycled, exposing a Quadro-specific driver bug or resource management issue.",
          "proposals": [
            {
              "title": "Check if SKGLElement OpenTK fix (#3309/#3311) resolves the issue",
              "description": "Issue #3309 identified a memory leak in SKGLElement due to OpenTK not being disposed. If the reporter is using SKGLElement, the fix in #3311 (updating OpenTK dependency) may resolve this. Ask reporter which control they use.",
              "confidence": 0.50,
              "effort": "low"
            },
            {
              "title": "Switch to SKElement (software-rendered) for the SkiaSharp control",
              "description": "If using SKGLElement (GPU-accelerated), switching to SKElement (CPU-rendered) would avoid the GPU driver interaction while keeping WPF hardware acceleration for other UI elements. Better targeted than the full SoftwareOnly workaround.",
              "confidence": 0.65,
              "effort": "low"
            },
            {
              "title": "Investigate GPU resource cache management on Quadro drivers",
              "description": "Profile GPU memory allocation during pattern drawing to identify whether SkiaSharp\u0027s GrDirectContext resource cache behaves differently on Quadro. May need to explicitly flush or limit the GPU resource cache (GrDirectContext.SetResourceCacheLimit).",
              "confidence": 0.55,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Check if SKGLElement OpenTK fix (#3309/#3311) resolves the issue",
          "recommendedReason": "Lowest effort \u2014 an existing fix for WPF memory leaks may already address this. Determining the control type will immediately narrow the diagnosis."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.85,
          "reason": "Real bug with validated workaround, but missing critical details: which SkiaSharp WPF control is used, specific GPU model/driver version, and minimal reproduction project. Need this info to investigate effectively.",
          "missingInfo": [
            "reproduction-steps",
            "sample-project",
            "device-info"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp.Views and tenet/performance labels",
            "reason": "WPF views integration is the affected component. Memory leak is both a reliability and performance concern.",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp.Views",
                "tenet/performance"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Request details about WPF control type, GPU model, and ask for minimal repro",
            "reason": "Cannot investigate without knowing which SkiaSharp WPF control is in use and whether the existing SKGLElement fix applies",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the thorough GPU testing \u2014 narrowing it to Nvidia Quadro specifically is really valuable information.\n\nThe fact that WPF\u0027s SoftwareOnly mode eliminates the leak is an important clue. It suggests the memory leak is in the interaction between the SkiaSharp rendering surface and WPF\u0027s hardware-accelerated compositing, rather than in SkiaSharp\u0027s drawing operations themselves.\n\nA couple of questions that would help narrow this down:\n\n1. Which SkiaSharp WPF control are you using \u2014 \u0060SKElement\u0060 or \u0060SKGLElement\u0060? If it\u0027s \u0060SKGLElement\u0060, there\u0027s a known memory leak fix in #3309 / #3311 related to OpenTK disposal that might address this.\n\n2. Would you be able to share the Nvidia Quadro model and driver version? Some Quadro driver versions have known issues with GPU resource management under certain compositing scenarios.\n\nIf it\u0027s not too much trouble, a minimal reproduction project would make it much easier to investigate the specific interaction between SkiaSharp, WPF compositing, and the Quadro driver.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3429-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3429"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3428,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/iOS",
          "area/SkiaSharp.Views.Maui",
          "tenet/reliability"
        ]
      },
      "summary": "SKGLView fails to bind EAGLDrawable on .NET 10 MAUI iOS, rendering white canvas instead of content",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.92
          }
        ],
        "platforms": [
          {
            "value": "os/iOS",
            "confidence": 0.98
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.90
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.85
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "net10.0-ios"
          ],
          "severity": "high",
          "severityReason": "GL rendering is completely broken on iOS with .NET 10 \u2014 white canvas with no content. No workaround provided. Affects all SKGLView users targeting .NET 10 on iOS."
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/Mapsui/Mapsui/blob/main/Mapsui.UI.Maui/MapControl.cs",
              "description": "Mapsui MapControl source showing the GL paint surface handler code that triggers the issue."
            }
          ],
          "stepsToReproduce": [
            "Create a MAUI app targeting .NET 10 for iOS",
            "Add SkiaSharp 3.116.0 with SKGLView (GL-accelerated rendering)",
            "Run on an iOS device or simulator",
            "Observe white canvas and \u0027Failed to bind EAGLDrawable\u0027 in device logs"
          ],
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "private void OnGLPaintSurface(object? sender, SKPaintGLSurfaceEventArgs args)\n{\n    if (_glView?.GRContext is null)\n    {\n        Logger.Log(LogLevel.Warning, \u0022Refresh can not be called because GRContext is null\u0022);\n        return;\n    }\n    PaintSurface(args.Surface.Canvas);\n}",
              "context": "Mapsui MapControl GL paint handler \u2014 the callback that should render content but results in white canvas."
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, .NET 10, MAUI, iOS, Visual Studio macOS. Works on .NET 9, broken on .NET 10. Last known good SkiaSharp version: 2.88.9."
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Issue is on latest SkiaSharp 3.116.0 with bleeding-edge .NET 10. The problem is likely related to .NET 10\u0027s iOS runtime changes rather than SkiaSharp version, since 3.116.0 works on .NET 9. Apple has deprecated OpenGL ES (EAGL) since iOS 12, and .NET 10 may have removed or changed EAGL support."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "Reporter states it works on .NET 9 but not .NET 10. Same SkiaSharp version (3.116.0) works on .NET 9 but fails on .NET 10, indicating a regression introduced by .NET 10 runtime or iOS SDK changes rather than by SkiaSharp itself.",
          "workedInVersion": "3.116.0 on .NET 9",
          "brokeInVersion": "3.116.0 on .NET 10"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "SKGLView fails to render on iOS when targeting .NET 10, producing a white canvas and \u0027Failed to bind EAGLDrawable\u0027 error. The root cause is likely .NET 10\u0027s handling of the deprecated OpenGL ES (EAGL) APIs on iOS, since SKGLView depends on GLKView/EAGLContext which Apple deprecated in iOS 12.",
        "keySignals": [
          {
            "text": "Failed to bind EAGLDrawable on .NET 10 in MAUI iOS",
            "source": "title",
            "interpretation": "EAGLDrawable is the iOS OpenGL ES rendering surface. Failure to bind it means the GL framebuffer cannot be created, resulting in no rendering output."
          },
          {
            "text": "not in .NET 9",
            "source": "body",
            "interpretation": "Explicitly a .NET 10-specific regression. Same SkiaSharp version works on .NET 9, pointing to a runtime or SDK change."
          },
          {
            "text": "Failed to bind EAGLDrawable: \u003CCAEAGLLayer: 0x600001767a40\u003E to GL_RENDERBUFFER 1",
            "source": "comment 2 (charlenni)",
            "interpretation": "Actual iOS system error confirming EAGL layer binding failure and incomplete framebuffer objects \u2014 the OpenGL ES rendering pipeline is broken."
          },
          {
            "text": "No error and a white canvas",
            "source": "body",
            "interpretation": "The GL view silently fails to render \u2014 no crash, just blank output. This is a silent rendering failure."
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9 (Previous)",
            "source": "body",
            "interpretation": "Reporter considers 2.88.9 the last good version, but the issue is .NET 10 specific so the SkiaSharp version may be less relevant than the .NET target framework change."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a rendering failure \u2014 expected content but gets white canvas with \u0027Failed to bind EAGLDrawable\u0027 error. This is clearly broken behavior in a previously working scenario, not a question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something \u2014 they have working code that broke on .NET 10."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Maui",
            "expandedReason": "The issue is in the MAUI SKGLView rendering pipeline. The code uses SKPaintGLSurfaceEventArgs in a MAUI context. The underlying SKGLView is consumed through MAUI controls.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "While SKGLView lives in SkiaSharp.Views, the user is consuming it through MAUI, making SkiaSharp.Views.Maui the more specific and accurate label."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "EAGLDrawable and EAGLContext are the iOS-specific OpenGL ES rendering infrastructure. SKGLView explicitly creates EAGLContext(OpenGLES2). The failure is in GL framebuffer binding."
          },
          {
            "field": "platforms",
            "chosen": "os/iOS",
            "expandedReason": "Reporter explicitly states iOS. EAGL is iOS-only infrastructure. No mention of other platforms being affected."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "Reliability: the GL view fails silently (white canvas) rather than rendering content. Compatibility: the issue is specific to .NET 10 \u2014 same code works on .NET 9, indicating a cross-version compatibility problem."
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "Issue is in the MAUI rendering pipeline. The .NET 10 target framework change may be a MAUI or .NET runtime-level change affecting EAGL context initialization."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "GL rendering is completely broken on iOS with .NET 10 \u2014 no content rendered at all, no workaround provided. Not critical because the app does not crash and SKCanvasView (CPU rendering) is likely a viable fallback.",
            "alternatives": [
              {
                "value": "critical",
                "whyRejected": "No crash or data loss. The app still runs, just shows white canvas."
              },
              {
                "value": "medium",
                "whyRejected": "Complete rendering failure with no confirmed workaround warrants high, not medium."
              }
            ]
          }
        ],
        "uncertainties": [
          "Exact .NET 10 preview version not specified \u2014 different previews may have different EAGL support levels",
          "Unknown whether Apple fully removed EAGL support in a recent iOS SDK or if .NET 10 changed its OpenGL ES bindings",
          "Unknown whether SKCanvasView (CPU rendering) works as a workaround on .NET 10",
          "Device model and iOS version not specified \u2014 could be relevant if newer hardware dropped EAGL support"
        ],
        "assumptions": [
          "Assumed the reporter is using a recent .NET 10 preview since they mention .NET 10 specifically",
          "Assumed EAGLDrawable error from charlenni\u0027s comment is the same error the original reporter sees, since they are both Mapsui contributors reporting the same problem"
        ],
        "resolution": {
          "hypothesis": ".NET 10\u0027s iOS runtime or Apple\u0027s latest SDK has changed how EAGLContext/EAGLDrawable binding works, breaking the deprecated OpenGL ES rendering path used by SKGLView. Apple deprecated OpenGL ES in iOS 12 (2018) and has been progressively removing support. SKGLView\u0027s GLKView\u002BEAGLContext approach may no longer function correctly under .NET 10\u0027s updated iOS bindings.",
          "proposals": [
            {
              "title": "Switch to SKCanvasView (CPU rendering) as workaround",
              "description": "Replace SKGLView with SKCanvasView which uses CPU-based raster rendering instead of OpenGL ES. Avoids the deprecated EAGL path entirely. Immediate workaround but loses GPU acceleration.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Implement Metal backend for iOS GPU rendering",
              "description": "Replace the OpenGL ES (EAGL) backend with Metal for iOS GPU rendering. This follows Apple\u0027s recommended migration path. Long-term correct solution but significant engineering effort.",
              "confidence": 0.90,
              "effort": "high"
            },
            {
              "title": "Investigate and patch .NET 10 EAGL context initialization",
              "description": "Debug why EAGLDrawable binding fails specifically on .NET 10. Create minimal repro, compare EAGL context state between .NET 9 and .NET 10, check if .NET 10 bindings removed or changed GLKit/EAGLContext APIs.",
              "confidence": 0.50,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Implement Metal backend for iOS GPU rendering",
          "recommendedReason": "Apple deprecated OpenGL ES in 2018 and has been progressively removing support. Patching EAGL is fighting a losing battle. SKCanvasView workaround can be recommended to users immediately while Metal support is implemented."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real rendering failure on .NET 10 iOS that needs investigation. Root cause is likely .NET 10 or Apple\u0027s continued deprecation of OpenGL ES (EAGL). Need to determine if this is fixable in SkiaSharp or requires .NET runtime changes.",
          "missingInfo": [
            "device-info"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add OpenGL backend, compatibility tenet, and MAUI partner labels",
            "reason": "Issue is specific to OpenGL backend on iOS, is a .NET 10 compatibility issue, and involves MAUI rendering pipeline",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL",
                "tenet/compatibility",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis noting EAGL deprecation and requesting .NET 10 preview version details",
            "reason": "Need to confirm .NET 10 preview version and offer SKCanvasView as interim workaround",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for reporting this \u2014 the EAGLDrawable binding failure is a significant signal.\n\nThe \u0060SKGLView\u0060 on iOS uses \u0060GLKView\u0060 with \u0060EAGLContext\u0060 (OpenGL ES 2), which Apple deprecated back in iOS 12 in favor of Metal. The fact that this works on .NET 9 but not .NET 10 suggests that .NET 10\u0027s iOS runtime or the underlying Apple SDK may have changed how EAGL contexts are initialized or bound.\n\nA couple of questions that would help narrow this down:\n\n1. Which .NET 10 preview version are you using?\n2. Does switching from \u0060SKGLView\u0060 to \u0060SKCanvasView\u0060 (CPU rendering) work as a temporary workaround?\n\nLonger term, the path forward for iOS GPU rendering is likely Metal rather than OpenGL ES, given Apple\u0027s deprecation timeline. But we need to understand what specifically changed in .NET 10 first.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3428-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3428"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3423,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-07-17T18:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "ClickOnce deployment of .NET Framework 4.7.2 WinForms app fails to include libSkiaSharp.dll, causing DllNotFoundException",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.97
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.90
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "hasWorkaround": true,
          "workaroundSummary": "Manually add libSkiaSharp.dll from the NativeAssets.Win32 NuGet package (runtimes/win-x64/native/) as an existing item in the VS project, set Build Action to Content and Copy to Output Directory to \u0027Copy if newer\u0027, then verify it appears in ClickOnce Application Files as Include/Required.",
          "targetFrameworks": [
            "net472"
          ],
          "severity": "medium",
          "severityReason": "Hard crash via DllNotFoundException, but a community-confirmed workaround exists and the issue is specific to ClickOnce deployment \u2014 MSIX works correctly."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET Framework 4.7.2 WinForms application",
            "Add SkiaSharp and SkiaSharp.NativeAssets.Win32 NuGet packages",
            "Use SKBitmap.Decode() or any SkiaSharp API",
            "Publish the application using ClickOnce deployment from Visual Studio",
            "Run the published ClickOnce application \u2014 DllNotFoundException occurs"
          ],
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "var image = SKBitmap.Decode(imageData ?? throw new ArgumentNullException(nameof(imageData)))",
              "context": "Code that triggers the DllNotFoundException when run in a ClickOnce-deployed application"
            }
          ],
          "environmentDetails": ".NET Framework 4.7.2, WinForms, Visual Studio 2022 (Windows), SkiaSharp 3.119.1 (description) / 3.116.0 (version dropdown), Windows 10 and Windows 11, Dell workstations, ClickOnce deployment"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.1",
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "reason": "SkiaSharp 3.x is the current major version. The issue is about ClickOnce deployment not handling the runtimes/ folder structure from NuGet NativeAssets packages, which persists across versions."
        },
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "ClickOnce deployment of a .NET Framework 4.7.2 WinForms app fails to include the native libSkiaSharp.dll from the NativeAssets.Win32 NuGet package, causing DllNotFoundException at runtime. This is a well-understood ClickOnce limitation with NuGet runtimes/ directory native assets, not a SkiaSharp code defect. A community workaround exists and is confirmed working by both the reporter and another user.",
        "keySignals": [
          {
            "text": "System.DllNotFoundException: Unable to load library \u0027libSkiaSharp\u0027",
            "source": "stack-trace",
            "interpretation": "Native binary not found at runtime \u2014 the DLL was not deployed to the ClickOnce application directory"
          },
          {
            "text": "Our MSIX version of the app does not however, and I think its because libSkiaSharp.dylib is not being included in the ClickOnce publish",
            "source": "body",
            "interpretation": "User correctly identifies that ClickOnce is not including the native binary, while MSIX does. Points to a deployment mechanism issue, not a missing package."
          },
          {
            "text": ".net winforms app (framework 4.7.2)",
            "source": "body",
            "interpretation": ".NET Framework 4.7.2 WinForms \u2014 maps to Windows-Classic platform. Old-style project format may compound ClickOnce native asset issues."
          },
          {
            "text": "manually add libSkiaSharp.dll from NativeAssets.Win32 package as Content with Copy if newer",
            "source": "comment 2",
            "interpretation": "Community-confirmed workaround that addresses the deployment gap by forcing the native DLL into the ClickOnce output"
          },
          {
            "text": "That was how if I fixed it too. Had a similar issue with the native DLLs that are supposed to be part of Microsoft.Data.SqlClient",
            "source": "comment 3",
            "interpretation": "OP confirms the workaround and notes this is a broader ClickOnce issue affecting multiple NuGet packages with native assets"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The native binary fails to deploy in ClickOnce, causing a DllNotFoundException crash. While this is arguably a ClickOnce tooling limitation rather than a SkiaSharp code defect, the user\u0027s app breaks when using SkiaSharp with ClickOnce, which qualifies as a bug from the user\u0027s perspective.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting a hard crash in a deployment scenario."
              },
              {
                "value": "type/enhancement",
                "whyRejected": "Could argue SkiaSharp should add ClickOnce-friendly packaging, but the immediate issue is broken behavior, not a feature gap."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "DllNotFoundException for the native library. The issue is about native binary deployment, not the managed C# API.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The managed SkiaSharp code works correctly \u2014 the issue is the native binary not being present at runtime."
              },
              {
                "value": "area/Build",
                "whyRejected": "The build succeeds. The issue is in the ClickOnce publish/deployment step, which is outside SkiaSharp\u0027s build system."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": ".NET Framework 4.7.2 WinForms is definitively Windows-Classic (Win32 APIs). ClickOnce is a Windows-Classic deployment mechanism."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "The application crashes with an unhandled TypeInitializationException/DllNotFoundException. The app fails to function at all when deployed via ClickOnce."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash (DllNotFoundException) but a workaround exists and is confirmed by multiple users. The issue is specific to one deployment method (ClickOnce) while others (MSIX) work.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Workaround exists and is confirmed by OP. Other deployment methods work."
              },
              {
                "value": "critical",
                "whyRejected": "Not data loss or security. Deployment-specific with a known workaround."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The root cause is a ClickOnce limitation, not a SkiaSharp defect. A confirmed workaround exists. The issue could be closed with the documented workaround. However, human review is recommended because SkiaSharp might want to keep this open to track potential packaging improvements.",
            "alternatives": [
              {
                "value": "keep-open",
                "whyRejected": "Valid option if the team wants to investigate ClickOnce-friendly packaging. Marked requiresHumanReview for this reason."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "The root cause and workaround are already known. No further investigation needed."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp\u0027s NuGet packaging could be improved to better support ClickOnce (e.g., including native DLLs outside the runtimes/ folder for .NET Framework targets)",
          "Whether the user\u0027s project uses packages.config or PackageReference \u2014 this affects how NuGet native assets are handled",
          "The user mentions libSkiaSharp.dylib (macOS binary name) in the description but is on Windows \u2014 likely a terminology confusion"
        ],
        "assumptions": [
          "Assumed the user has SkiaSharp.NativeAssets.Win32 correctly referenced, since MSIX deployment works and the issue is ClickOnce-specific",
          "Assumed .NET Framework project format (not SDK-style) since it\u0027s .NET Framework 4.7.2 WinForms \u2014 this affects NuGet asset handling"
        ],
        "resolution": {
          "hypothesis": "ClickOnce deployment does not automatically include native binaries from NuGet packages that use the runtimes/{rid}/native/ directory convention. The SkiaSharp.NativeAssets.Win32 package places libSkiaSharp.dll in runtimes/win-x64/native/ (and win-x86), but ClickOnce\u0027s Application Files mechanism doesn\u0027t discover files in this path structure. MSIX handles this correctly because it processes the full output directory layout.",
          "proposals": [
            {
              "title": "Manual DLL inclusion as Content (confirmed workaround)",
              "description": "Manually add libSkiaSharp.dll from the NativeAssets.Win32 package to the project as Content with \u0027Copy if newer\u0027. This forces ClickOnce to include the native binary. Confirmed working by multiple users, but must be repeated when updating SkiaSharp version.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "MSBuild targets for ClickOnce-compatible native asset deployment",
              "description": "Add MSBuild targets to SkiaSharp.NativeAssets.Win32 that detect ClickOnce/.NET Framework projects and copy native DLLs to the output directory as content files, bypassing the runtimes/ directory structure. Permanent fix but requires ClickOnce MSBuild integration work.",
              "confidence": 0.60,
              "effort": "medium"
            },
            {
              "title": "Switch to MSIX deployment",
              "description": "Migrate the application from ClickOnce to MSIX deployment, which correctly handles the runtimes/ native asset structure. User confirmed MSIX already works, but this is a significant deployment infrastructure change.",
              "confidence": 0.85,
              "effort": "high"
            }
          ],
          "recommendedProposal": "Manual DLL inclusion as Content (confirmed workaround)",
          "recommendedReason": "Already confirmed working by both the reporter and another community member. Zero risk, low effort, and immediately actionable."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.75,
          "reason": "The root cause is a ClickOnce limitation with NuGet runtimes/ native assets, not a SkiaSharp defect. A community-confirmed workaround exists. However, human review is recommended \u2014 the team may want to keep this open to track packaging improvements.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels already match classification \u2014 no changes needed",
            "reason": "Current labels (type/bug, area/libSkiaSharp.native, os/Windows-Classic, tenet/reliability) already match the triage classification exactly",
            "confidence": 0.97,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post response acknowledging the workaround and explaining root cause",
            "reason": "The workaround is confirmed by multiple users and root cause is well-understood. A closing comment would document the resolution for future visitors.",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed report and stack trace \u2014 and @ERPCG, thanks for documenting the workaround so thoroughly.\n\nThis is a known limitation of ClickOnce deployment with NuGet packages that use the \u0060runtimes/\u0060 folder convention for native assets. ClickOnce doesn\u0027t automatically pick up files from the \u0060runtimes/{rid}/native/\u0060 directory structure that \u0060SkiaSharp.NativeAssets.Win32\u0060 uses. MSIX handles this correctly because it processes the full NuGet output layout.\n\nThe workaround @ERPCG described is the right approach for ClickOnce:\n1. Locate \u0060libSkiaSharp.dll\u0060 in \u0060packages\\SkiaSharp.NativeAssets.Win32.{version}\\runtimes\\win-x64\\native\\\u0060 (or \u0060win-x86\u0060 for 32-bit)\n2. Add it to your project as an existing item\n3. Set **Build Action = Content** and **Copy to Output = Copy if newer**\n4. Verify it appears in **Project \u2192 Properties \u2192 Publish \u2192 Application Files** as Include/Required\n\nThis isn\u0027t specific to SkiaSharp \u2014 other packages with native assets (like Microsoft.Data.SqlClient, as @ajohnstone-ks noted) hit the same ClickOnce limitation.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3423-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as answered with workaround documented",
            "reason": "Root cause is a ClickOnce tooling limitation, not a SkiaSharp defect. Workaround confirmed by reporter.",
            "confidence": 0.70,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3423"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3422,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Universal-UWP",
          "os/WASM",
          "area/SkiaSharp.Views.Blazor",
          "tenet/reliability"
        ]
      },
      "summary": "SkiaSharp fails to load in Blazor WASM on .NET 10 with TypeInitializationException and DllNotFoundException for libSkiaSharp",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.82
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.97
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.92
          },
          {
            "value": "tenet/reliability",
            "confidence": 0.85
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "hasWorkaround": true,
          "workaroundSummary": "Running \u0027dotnet workload restore\u0027 resolved the issue for some users (EngstromJimmy, jahnotto) but not for others (Webreaper on macOS/Linux).",
          "targetFrameworks": [
            "net10.0"
          ],
          "severity": "high",
          "severityReason": "Complete failure to load native library in Blazor WASM on .NET 10. Workaround is inconsistent \u2014 works for some users but not others. Multiple users affected."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Blazor WebAssembly project targeting net10.0",
            "Add SkiaSharp.Views.Blazor NuGet package (any version: 3.119.x, 3.118.x, or even 2.88.x)",
            "Add an SKCanvasView component to a Razor page",
            "Navigate to the page in the browser"
          ],
          "codeSnippets": [
            {
              "language": "xml",
              "code": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk.BlazorWebAssembly\u0022\u003E\n\t\u003CPropertyGroup\u003E\n\t\t\u003CTargetFramework\u003Enet10.0\u003C/TargetFramework\u003E\n\t\u003C/PropertyGroup\u003E\n\t\u003CItemGroup\u003E\n\t\t\u003CPackageReference Include=\u0022SkiaSharp.Views.Blazor\u0022 Version=\u00223.119.2-preview.1\u0022 /\u003E\n\t\u003C/ItemGroup\u003E\n\u003C/Project\u003E",
              "context": "Project file from issue body"
            },
            {
              "language": "csharp",
              "code": "@using SkiaSharp\n@using SkiaSharp.Views.Blazor\n\n\u003CSKCanvasView OnPaintSurface=\u0022OnPaintSurface\u0022 IgnorePixelScaling=\u0022true\u0022 /\u003E\n\n@code {\n    private void OnPaintSurface(SKPaintSurfaceEventArgs args)\n    {\n        var canvas = args.Surface.Canvas;\n        canvas.Clear(SkiaSharp.SKColors.White);\n    }\n}",
              "context": "Razor component from issue body"
            }
          ],
          "environmentDetails": "Windows 11 Pro, VS 2026, .NET 10, Edge/Chrome. Also reproduced on macOS (Rider) and Linux production deployments."
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.2-preview.1",
            "3.118.0-preview.2.3",
            "3.119.1",
            "2.88.9",
            "2.88.0"
          ],
          "currentRelevance": "likely",
          "reason": "Issue persists across all tested SkiaSharp versions (2.88.0 through 3.119.2-preview.1), indicating this is a .NET 10 WASM platform issue rather than a SkiaSharp version regression. The reporter explicitly notes there is no last known good SkiaSharp version for .NET 10 WASM."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.80,
          "reason": "Not a SkiaSharp regression \u2014 the issue occurs with all SkiaSharp versions on .NET 10 WASM. It appears to be caused by changes in .NET 10\u0027s WASM workload or native dependency handling. Rolling back SkiaSharp to 2.88.x does not help."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "SkiaSharp\u0027s native library (libSkiaSharp) fails to load in Blazor WASM projects targeting .NET 10. The error manifests as TypeInitializationException on SKImageInfo or DllNotFoundException for libSkiaSharp. The issue spans all SkiaSharp versions, suggesting a breaking change in .NET 10\u0027s WASM workload or native asset resolution pipeline.",
        "keySignals": [
          {
            "text": "ManagedError: TypeInitialization_Type, SkiaSharp.SKImageInfo",
            "source": "body",
            "interpretation": "Native library failed to load during static initialization of SKImageInfo, which depends on P/Invoke into libSkiaSharp"
          },
          {
            "text": "DllNotFoundException: libSkiaSharp",
            "source": "comment 3",
            "interpretation": "Confirms the root cause is native library loading failure, not a managed code issue"
          },
          {
            "text": "it wouldn\u0027t let me clear the Last Known Good Version...there is no last known good version in this regard as it seems more related to .net 10 WASM projects",
            "source": "comment 2",
            "interpretation": "Reporter confirms this is .NET 10-specific, not a SkiaSharp version regression"
          },
          {
            "text": "I tried rolling back to 2.88.9 but the same issue occurs, so it\u0027s something specific to .Net 10",
            "source": "comment 4",
            "interpretation": "Confirmed across multiple SkiaSharp versions \u2014 issue is in .NET 10 platform"
          },
          {
            "text": "Restoring the .NET 10 wasm workload helped me. dotnet workload restore",
            "source": "comment 6",
            "interpretation": "Partial workaround \u2014 suggests missing or misconfigured WASM workload components"
          },
          {
            "text": "dotnet workload restore didn\u0027t have any effect for me - I\u0027m still seeing the same issue on MacOS",
            "source": "comment 8",
            "interpretation": "Workaround is unreliable, particularly on non-Windows platforms"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Users encounter TypeInitializationException and DllNotFoundException when using SkiaSharp in Blazor WASM on .NET 10. This is clearly broken behavior \u2014 the native library cannot be loaded at all.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not a usage question \u2014 the code follows the documented pattern and fails with an infrastructure error."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Blazor",
            "expandedReason": "The issue occurs specifically when using SKCanvasView in Blazor WASM. While the root cause is native library loading, the affected component is SkiaSharp.Views.Blazor and the fix likely involves WASM-specific packaging or workload integration.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "The native library itself isn\u0027t broken \u2014 the WASM packaging/deployment pipeline is failing to include it properly for .NET 10."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM",
            "expandedReason": "This is a Blazor WebAssembly issue. The reporter\u0027s development machine is Windows but the runtime target is WASM. The os/Windows-Universal-UWP label currently on the issue is incorrect.",
            "alternatives": [
              {
                "value": "os/Windows-Universal-UWP",
                "whyRejected": "Windows is only the dev machine OS \u2014 the issue is in the WASM runtime, not UWP."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "The core issue is compatibility with .NET 10\u0027s WASM workload. SkiaSharp works on older .NET versions but fails on .NET 10."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Complete failure to load the native library \u2014 SkiaSharp is entirely unusable in Blazor WASM on .NET 10. Workaround is inconsistent across platforms. Multiple users affected with community engagement."
          }
        ],
        "uncertainties": [
          "Whether the root cause is a .NET 10 WASM workload packaging change or a SkiaSharp build/packaging issue for the WASM target",
          "Why \u0027dotnet workload restore\u0027 fixes the issue for some users but not others \u2014 could be OS-specific workload behavior",
          "Whether the issue also affects Blazor Server or is strictly WASM-only",
          "Whether .NET 10 preview vs stable makes a difference"
        ],
        "assumptions": [
          "Assumed the issue affects all browsers since both Edge and Chrome are mentioned and it\u0027s a native loading issue",
          "Assumed .NET 10 refers to preview/RC builds available at the time of reporting (November 2025)"
        ],
        "resolution": {
          "hypothesis": ".NET 10 changed how WASM native dependencies are resolved or packaged, and SkiaSharp\u0027s WASM native assets are not being included in the final output. The \u0027dotnet workload restore\u0027 fix suggests that the wasm-tools workload has updated components that affect native library linking, and some environments have stale or missing workload installations.",
          "proposals": [
            {
              "title": "Investigate .NET 10 WASM native dependency changes",
              "description": "Compare how libSkiaSharp.wasm is packaged and linked in .NET 9 vs .NET 10 Blazor WASM projects. Check if NativeFileReference or WasmNativeAssets handling changed. May require updating SkiaSharp.Views.Blazor packaging.",
              "confidence": 0.70,
              "effort": "medium"
            },
            {
              "title": "Update SkiaSharp WASM packaging for .NET 10",
              "description": "If .NET 10 changed the WASM native asset pipeline (e.g., new MSBuild props, different file layout), update SkiaSharp.Views.Blazor to conform. This is the definitive fix.",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "title": "Document workaround: dotnet workload restore",
              "description": "As an interim measure, document that users should run \u0027dotnet workload restore\u0027 after installing .NET 10. Note the limitation that this does not work for all users/platforms.",
              "confidence": 0.50,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Investigate .NET 10 WASM native dependency changes",
          "recommendedReason": "Need to understand the root cause before applying a fix. The inconsistent workaround suggests a platform-level change that needs proper investigation before SkiaSharp can adapt."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.88,
          "reason": "Real bug affecting multiple users with .NET 10 WASM. Root cause is likely a .NET 10 platform change in native dependency handling. Needs investigation into what changed and how SkiaSharp\u0027s WASM packaging should adapt."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Fix labels: add tenet/compatibility, remove incorrect os/Windows-Universal-UWP",
            "reason": "os/Windows-Universal-UWP is wrong \u2014 the issue is WASM not UWP. Adding tenet/compatibility since this is a .NET 10 compat issue.",
            "confidence": 0.92,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "os/Windows-Universal-UWP"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging the .NET 10 WASM issue and partial workaround",
            "reason": "Multiple users are affected and need acknowledgment. The workaround is partial and should be noted with caveats.",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the detailed report and the reproduction steps.\n\nThis looks like a .NET 10 WASM platform change affecting how native dependencies are loaded \u2014 the fact that rolling back to SkiaSharp 2.88.x doesn\u0027t help confirms it\u0027s not a SkiaSharp regression.\n\nThe \u0060dotnet workload restore\u0060 workaround from @EngstromJimmy is helpful but clearly isn\u0027t consistent across platforms, as @Webreaper is still seeing the issue on macOS and Linux.\n\nTo help narrow this down: for those still experiencing the issue after \u0060dotnet workload restore\u0060, would you be able to check what version of the \u0060microsoft-net-sdk-emscripten\u0060 workload pack is installed? You can check with \u0060dotnet workload list\u0060. That would help determine if this is a workload version mismatch or something deeper in the native asset pipeline.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3422-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3422"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3421,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "User loading a .lottie (dotLottie) file with Skottie.Animation.Create gets null because .lottie is a zip archive, not raw Lottie JSON",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.82
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.90
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.92
          }
        ],
        "tenets": null,
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": {
          "codeSnippets": [
            {
              "language": "cs",
              "code": "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);",
              "context": "Loading a .lottie file by path, returns null"
            }
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/9ca27c18-536b-4403-a41d-44e907329001",
              "context": "LottieFiles download page showing the .lottie file being downloaded",
              "source": "body"
            },
            {
              "url": "https://github.com/user-attachments/assets/0fe1691c-82ee-462a-a110-f53b0682833f",
              "context": "Debugger showing animation variable is null after Create call",
              "source": "body"
            }
          ],
          "stepsToReproduce": [
            "Download a .lottie file from LottieFiles (dotLottie format, which is a zip archive)",
            "Call SkiaSharp.Skottie.Animation.Create(path) with the .lottie file path",
            "Observe that the returned Animation is null"
          ],
          "environmentDetails": "Windows 11, Visual Studio (Windows), SkiaSharp 3.116.0"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "reason": "Issue is about format support, not a version-specific regression. The .lottie (dotLottie) zip format has never been supported by Skottie."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.95,
          "reason": "Skottie has never supported the dotLottie (.lottie) zip archive format. It only parses raw Lottie JSON. This is not a regression."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "The user is loading a .lottie file (dotLottie format), which is a zip archive containing Lottie JSON and assets. Skottie\u0027s Animation.Create() expects raw Lottie JSON data, not a zip archive, so it correctly returns null when it cannot parse the zip bytes as JSON. This is a format misunderstanding, not a defect.",
        "keySignals": [
          {
            "text": "Loading .lottie file results in null SkiaSharp.Skottie.Animation",
            "source": "title",
            "interpretation": "The .lottie extension indicates the dotLottie format (zip archive), which is distinct from raw Lottie JSON (.json)"
          },
          {
            "text": "No exception is thrown, so it fails silently",
            "source": "body",
            "interpretation": "This is expected SkiaSharp factory method behavior \u2014 Create() returns null on failure rather than throwing. Not a bug."
          },
          {
            "text": "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);",
            "source": "body",
            "interpretation": "Animation.Create reads file bytes and passes to Skottie parser, which expects JSON. A zip file will fail parsing."
          },
          {
            "text": "https://app.lottiefiles.com/animation/...",
            "source": "body",
            "interpretation": "LottieFiles offers downloads in both .json and .lottie formats. The user downloaded the .lottie (dotLottie) variant."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "The user expects Animation.Create to handle .lottie files, but the dotLottie format (a zip archive) is fundamentally different from raw Lottie JSON. The API is working as designed \u2014 it returns null for data it cannot parse. This is a format confusion, not broken behavior.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "The API correctly returns null for unparseable input. Silent null return is the documented factory method pattern in SkiaSharp."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "While dotLottie support could be a valid feature request, the user is not requesting new functionality \u2014 they are confused about why their file doesn\u0027t work."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SkiaSharp.Skottie.Animation is part of the SkiaSharp.Skottie package which wraps Skia\u0027s Skottie module. The issue is in the Skottie animation loading API.",
            "alternatives": []
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "User explicitly states Windows 11 with Visual Studio (Windows). However, this is not a platform-specific issue \u2014 the format incompatibility exists on all platforms."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The answer is clear: .lottie files are zip archives that must be extracted to get the raw Lottie JSON before passing to Skottie. The user can re-download the animation as .json from LottieFiles instead."
          }
        ],
        "uncertainties": [
          "Whether the user has tried downloading the same animation in .json format from LottieFiles (which would work)",
          "Whether there is demand for native dotLottie format support in SkiaSharp.Skottie"
        ],
        "assumptions": [
          "Assumed the file is a dotLottie (.lottie) zip archive based on the title and LottieFiles download link, since LottieFiles defaults to .lottie format",
          "Assumed no prior version of SkiaSharp supported .lottie format since Skottie has always only parsed JSON"
        ],
        "resolution": {
          "hypothesis": "The user downloaded a .lottie file (dotLottie format) which is a zip archive. Skottie only supports raw Lottie JSON, so the zip bytes fail to parse and Create() returns null.",
          "proposals": [
            {
              "title": "Re-download as .json from LottieFiles",
              "description": "LottieFiles provides both .lottie and .json download options. The user should download the .json variant, which contains the raw Lottie JSON that Skottie can parse directly.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "Extract JSON from .lottie zip at runtime",
              "description": "Use System.IO.Compression.ZipArchive to open the .lottie file, read the animations/[name].json entry from inside the archive, and pass the extracted JSON string to Animation.Parse().",
              "confidence": 0.85,
              "effort": "low"
            },
            {
              "title": "Add dotLottie format support to SkiaSharp.Skottie",
              "description": "Enhance Animation.Create to detect zip magic bytes and automatically extract the Lottie JSON from dotLottie archives. This would be a new feature requiring changes to the C# wrapper layer.",
              "confidence": 0.70,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Re-download as .json from LottieFiles",
          "recommendedReason": "Simplest and most immediate solution. No code changes needed \u2014 just download the correct format."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.82,
          "reason": "The .lottie format is not supported by Skottie \u2014 the user needs to use raw Lottie JSON instead. Clear answer available."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Reclassify as question, remove bug and reliability labels",
            "reason": "This is a format misunderstanding, not a bug or reliability issue. The API works correctly for its supported input format.",
            "confidence": 0.82,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/question"
              ],
              "labelsToRemove": [
                "type/bug",
                "tenet/reliability"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Explain .lottie vs Lottie JSON format difference and provide workaround",
            "reason": "User needs to understand why their file doesn\u0027t load and what to do instead",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the clear reproduction steps and screenshots.\n\nThe \u0060.lottie\u0060 format (sometimes called \u0022dotLottie\u0022) is actually a zip archive that contains the raw Lottie JSON animation along with optional assets. SkiaSharp\u0027s Skottie module expects raw Lottie JSON data, so when it tries to parse the zip bytes as JSON, it fails and \u0060Animation.Create()\u0060 returns null.\n\nThe simplest fix is to re-download the animation from LottieFiles in \u0060.json\u0060 format instead of \u0060.lottie\u0060 \u2014 LottieFiles offers both options on the download panel.\n\nIf you need to work with \u0060.lottie\u0060 files directly, you can extract the JSON at runtime:\n\n\u0060\u0060\u0060csharp\nusing System.IO.Compression;\n\nusing var zip = ZipFile.OpenRead(sourceFileAbsolute);\nvar entry = zip.Entries.FirstOrDefault(e =\u003E e.FullName.EndsWith(\u0022.json\u0022));\nif (entry != null)\n{\n    using var stream = entry.Open();\n    var animation = SkiaSharp.Skottie.Animation.Create(stream);\n}\n\u0060\u0060\u0060",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3421-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as answered",
            "reason": "Question answered with explanation and workaround",
            "confidence": 0.78,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3421"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3420,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Android",
          "area/libSkiaSharp.native",
          "tenet/compatibility"
        ]
      },
      "summary": "libSkiaSharp.so is built with 4 KB page size, blocking Android 16\u002B deployment which requires 16 KB page alignment",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.98
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.95
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "net8.0-android"
          ],
          "severity": "high",
          "severityReason": "Google Play will reject apps with 4 KB page-aligned .so files for Android 16\u002B targets. No workaround exists short of rebuilding the native library. 5 thumbs-up reactions and community follow-ups indicate broad impact."
        },
        "reproEvidence": {
          "attachments": [
            {
              "url": "https://github.com/user-attachments/files/23669684/16KB_PageSize_Report.txt",
              "filename": "16KB_PageSize_Report.txt",
              "type": "log-file",
              "source": "body"
            },
            {
              "url": "https://github.com/user-attachments/files/23547442/Android16_PageSize_Issue.pdf",
              "filename": "Android16_PageSize_Issue.pdf",
              "type": "other",
              "source": "body"
            }
          ],
          "stepsToReproduce": [
            "Create a .NET MAUI Android app targeting Android 16",
            "Build AAB using current SkiaSharp (v2.88.6) or MAUI workload",
            "Run page size check on .so files (e.g. readelf -l libSkiaSharp.so)",
            "Observe libSkiaSharp.so shows 4 KB page size instead of required 16 KB"
          ],
          "environmentDetails": "SkiaSharp.NativeAssets.Android v2.88.6 (description) / v3.116.0 (form field), .NET MAUI 9.0, Android 16\u002B target, Visual Studio (Windows)"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.6",
            "2.88.9",
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "reason": "The reporter\u0027s description references v2.88.6 but the form field says 3.116.0 (Current). Maintainer mattleibow asked if 3.x was tried, suggesting the fix may need to be in the native build pipeline for both 2.x and 3.x. The 16 KB page alignment is a build-time linker flag, so all current native binaries are likely affected regardless of version.",
          "migrationPath": "Rebuild libSkiaSharp.so with -Wl,-z,max-page-size=16384 linker flag"
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "This is not a regression in SkiaSharp behavior \u2014 the library never supported 16 KB page alignment. It is a new platform requirement from Google for Android 16\u002B."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Google\u0027s Android 16\u002B requires 64-bit native libraries to be built with 16 KB page alignment. libSkiaSharp.so is currently built with 4 KB page alignment, which will cause Google Play rejection for apps targeting Android 16. This is a native build configuration issue, not a code bug.",
        "keySignals": [
          {
            "text": "Google Play now requires all 64-bit native libraries to use 16 KB memory page size starting with Android 16\u002B",
            "source": "body",
            "interpretation": "External platform requirement forcing a build configuration change"
          },
          {
            "text": "libSkiaSharp.so included in SkiaSharp.NativeAssets.Android v2.88.6 has a 4 KB page size",
            "source": "body",
            "interpretation": "The native binary does not meet the new requirement \u2014 this is verifiable via readelf"
          },
          {
            "text": "Have you tried the 3.x series of SkiaSharp? The 2.x series is not really supported",
            "source": "comment 3",
            "interpretation": "Maintainer mattleibow redirecting to 3.x, implying 2.x will not be fixed. But 3.x may also need the fix."
          },
          {
            "text": "5 thumbs-up reactions on issue, 7 thumbs-up on \u0027Any update on this?\u0027 comment",
            "source": "reactions",
            "interpretation": "Significant community interest \u2014 this blocks real-world Android 16 deployments"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "While this is technically a new platform requirement rather than a regression, the practical effect is that SkiaSharp\u0027s native library prevents apps from targeting Android 16\u002B. The library is built incorrectly for the target platform, which is a defect in the build configuration. The existing type/bug label is appropriate.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "This is not optional \u2014 Google Play will reject non-compliant apps. It\u0027s a hard blocker, not an improvement."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "16 KB page alignment is not new functionality \u2014 it\u0027s a build flag. The library should work on the target platform."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The issue is entirely in the native binary build configuration of libSkiaSharp.so. The fix is a linker flag change in the native build pipeline, not in C# code.",
            "alternatives": [
              {
                "value": "area/Build",
                "whyRejected": "area/Build is for C#/NuGet build issues. This is specifically about the native .so binary\u0027s ELF alignment."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/Android",
            "expandedReason": "The 16 KB page size requirement is Android-specific (Android 16\u002B). No other platforms are affected."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "This is a forward-compatibility issue with Android 16\u002B. The library must be updated to remain compatible with the evolving platform requirements."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Apps using SkiaSharp cannot target Android 16\u002B at all. No user-side workaround exists \u2014 the fix must come from rebuilding the native library. High community engagement confirms broad impact."
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp 3.x native binaries also have 4 KB page alignment (reporter\u0027s version fields are contradictory \u2014 body says 2.88.6, form says 3.116.0)",
          "Whether the Skia build system (GN/Ninja) already supports the 16 KB page alignment flag or if additional upstream work is needed",
          "Exact timeline for Google Play enforcement \u2014 whether it\u0027s Android 16 launch or a later deadline"
        ],
        "assumptions": [
          "Assumed both 2.x and 3.x native binaries are affected since this is a build-time linker flag that likely hasn\u0027t been set for either version",
          "Assumed the reporter tested with 2.88.6 (as described in the body) despite the form field listing 3.116.0"
        ],
        "resolution": {
          "hypothesis": "libSkiaSharp.so is linked with the default 4 KB max-page-size. The fix is to add -Wl,-z,max-page-size=16384 to the Android NDK linker flags in the native build configuration.",
          "proposals": [
            {
              "title": "Add 16 KB page alignment linker flag",
              "description": "Add -Wl,-z,max-page-size=16384 to the Android arm64 build configuration in the native build scripts (GN args or CMake). This is the standard fix recommended by Google\u0027s migration guide. Low risk \u2014 only affects ELF segment alignment, no behavioral change.",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Update Android NDK version",
              "description": "Newer NDK versions (r27\u002B) default to 16 KB page alignment. Updating the NDK used for building could automatically resolve this without explicit linker flags. However, NDK version bumps can introduce other changes.",
              "confidence": 0.75,
              "effort": "medium"
            },
            {
              "title": "Verify with readelf and add CI check",
              "description": "After applying the fix, add a CI step that runs readelf -l on the output .so to verify max page size is 16384. Prevents future regressions if build tooling changes.",
              "confidence": 0.85,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Add 16 KB page alignment linker flag",
          "recommendedReason": "Simplest and most targeted fix. Directly addresses the requirement with no side effects. Google\u0027s own documentation recommends this approach."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.82,
          "reason": "The fix direction is clear (linker flag), but needs verification of whether 3.x is also affected and where exactly in the build pipeline to add the flag. Maintainer already engaged."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels already correct \u2014 no changes needed",
            "reason": "Current labels (type/bug, os/Android, area/libSkiaSharp.native, tenet/compatibility) exactly match classification",
            "confidence": 0.95,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis with 16 KB page alignment fix guidance and ask about 3.x testing",
            "reason": "Maintainer already asked about 3.x but no resolution posted. A technical summary would help move the issue forward.",
            "confidence": 0.78,
            "dependsOn": null,
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for filing this with the detailed report and PDF \u2014 the 16 KB page alignment requirement is going to affect a lot of Android apps.\n\nThe fix on the SkiaSharp side would be adding \u0060-Wl,-z,max-page-size=16384\u0060 to the linker flags when building \u0060libSkiaSharp.so\u0060 for Android arm64. Google\u0027s migration guide covers this: https://developer.android.com/guide/practices/page-sizes\n\nAs @mattleibow mentioned, the 2.x series isn\u0027t actively maintained. Could you confirm whether you\u0027re also seeing the 4 KB page size with the 3.x native assets? Running \u0060readelf -l libSkiaSharp.so | grep -i align\u0060 on the .so from the 3.116.0 NuGet would help clarify if both branches need the fix.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3420-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3420"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3402,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/feature-request"
        ]
      },
      "summary": "Feature request for 1bpp, 2bpp, and 4bpp indexed color bitmap support to minimize memory for retro game tile graphics",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.90
        },
        "backends": null,
        "platforms": null,
        "tenets": [
          {
            "value": "tenet/performance",
            "confidence": 0.80
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": null,
        "versionAnalysis": null,
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "User requests sub-byte indexed color formats (1bpp, 2bpp, 4bpp) with native pixel operations for NES/SNES-style tile graphics in Avalonia UI. This requires functionality that upstream Skia explicitly removed (indexed color types) and would need significant new infrastructure.",
        "keySignals": [
          {
            "text": "[FEATURE] Drawing to and from compressed indexed color bitmaps",
            "source": "title",
            "interpretation": "Explicit feature request for new pixel format support"
          },
          {
            "text": "I wanted to make a nes/snes graphics system in avalonia ui",
            "source": "body",
            "interpretation": "Use case is retro game console graphics emulation \u2014 very niche, tile-based rendering"
          },
          {
            "text": "8 * 8 * 32 * 30 * 65536 pixels which in 4bpp color would be 1.87 GiB",
            "source": "body",
            "interpretation": "Large tile atlas requiring sub-byte pixel formats for memory efficiency"
          },
          {
            "text": "Pixel operations should work on multiple pixels at a time with these formats without expanding them in memory",
            "source": "body",
            "interpretation": "Requires native bitwise operations on packed formats \u2014 not just storage but computation"
          },
          {
            "text": "Please support drawing to and from compressed 1bpp 2bpp and 4bpp indexed color graphics",
            "source": "body",
            "interpretation": "Core request: three new pixel formats plus drawing primitives for each"
          },
          {
            "text": "Writing my own blitter",
            "source": "body",
            "interpretation": "User has considered alternatives but lacks implementation experience"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "User explicitly requests new functionality that does not exist in SkiaSharp. Uses the feature request template. No broken behavior described \u2014 this is entirely new capability.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement improves existing functionality. Indexed color formats don\u0027t exist at all in SkiaSharp \u2014 this is new capability."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The request is for new pixel format types and drawing operations in the core SkiaSharp library (SKBitmap, SKColorType, pixel manipulation). Not views-specific or platform-specific.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While implementation would require native changes, the feature surface is in the managed API layer."
              }
            ]
          },
          {
            "field": "tenets",
            "chosen": "tenet/performance",
            "expandedReason": "The entire motivation is memory efficiency \u2014 storing tile graphics in sub-byte formats to reduce memory from 15 GiB (32bpp) to 1.87 GiB (4bpp). Performance/memory is the core driver."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a valid feature request but requires upstream Skia support that was intentionally removed. It should remain open for maintainer consideration, but the probability of implementation is low given Skia\u0027s direction away from indexed colors."
          }
        ],
        "uncertainties": [
          "Whether the user specifically needs SkiaSharp integration or would accept a separate pixel buffer library for indexed formats",
          "Whether partial support (e.g., converting indexed bitmaps to/from SKBitmap) would satisfy the requirement versus full native operations on packed formats"
        ],
        "assumptions": [
          "Assumed the user is using a recent version of SkiaSharp since no version was mentioned",
          "Assumed \u0027compressed\u0027 refers to indexed/paletted color with sub-byte pixel packing, not image compression codecs like PNG or JPEG"
        ],
        "resolution": {
          "hypothesis": "User wants to build a retro game tile graphics system with sub-byte indexed color formats. Skia removed kIndex_8_SkColorType years ago and does not support sub-byte pixel formats natively. SkiaSharp cannot expose what Skia doesn\u0027t provide without building an entirely separate pixel processing layer.",
          "proposals": [
            {
              "title": "Use SKBitmap with manual palette conversion",
              "description": "Store indexed color data in custom byte arrays and convert to 32bpp SKBitmap only when rendering. Keeps storage compact while using SkiaSharp for final display. User manages palette lookup in C# code.",
              "confidence": 0.75,
              "effort": "medium"
            },
            {
              "title": "Use ImageSharp for indexed color processing",
              "description": "SixLabors.ImageSharp supports indexed/paletted formats natively. Use it for pixel manipulation on indexed buffers, then convert to SKBitmap for Avalonia rendering. Combines strengths of both libraries.",
              "confidence": 0.70,
              "effort": "medium"
            },
            {
              "title": "Custom packed pixel buffer with Span\u003Cbyte\u003E",
              "description": "Implement a lightweight PackedPixelBuffer class using Span\u003Cbyte\u003E for bitwise operations on 1/2/4bpp data. Convert to SKBitmap via SKBitmap.InstallPixels when rendering. No external dependencies.",
              "confidence": 0.65,
              "effort": "high"
            }
          ],
          "recommendedProposal": "Use SKBitmap with manual palette conversion",
          "recommendedReason": "Simplest approach that stays within the SkiaSharp ecosystem. Storage remains compact in custom arrays; conversion to SKBitmap happens only at render time. Matches how retro game emulators typically handle tile rendering."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.75,
          "reason": "Valid feature request but requires upstream Skia support for indexed color types, which Skia intentionally removed. Low probability of implementation. Maintainer should decide whether to keep open or close as out-of-scope."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area and performance tenet labels",
            "reason": "Feature request already labeled correctly for type. Adding area/SkiaSharp and tenet/performance to match classification.",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp",
                "tenet/performance"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post response explaining Skia\u0027s lack of indexed color support and suggesting workarounds",
            "reason": "User needs to understand why this is difficult to implement and what alternatives exist",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed write-up on what you\u0027re trying to achieve \u2014 the NES/SNES tile graphics use case helps a lot in understanding the requirements.\n\nThe challenge here is that Skia (the underlying C\u002B\u002B library SkiaSharp wraps) removed support for indexed color types several years ago. There\u0027s no \u0060kIndex_8_SkColorType\u0060 or sub-byte format in modern Skia, so SkiaSharp can\u0027t expose what doesn\u0027t exist upstream. Adding 1/2/4bpp indexed formats with native pixel operations would essentially mean building a separate pixel processing engine outside of Skia.\n\nFor the tile atlas approach you\u0027re describing, a practical workaround would be to keep your indexed color data in custom \u0060byte[]\u0060 arrays (packed at 1/2/4bpp) and only convert to a 32bpp \u0060SKBitmap\u0060 at render time using a palette lookup. This is actually how most retro game emulators handle it \u2014 the compact storage stays in your own format, and the graphics library only sees the final expanded pixels. The conversion cost for a single screen\u0027s worth of tiles is minimal.\n\nAnother option worth considering is SixLabors.ImageSharp, which does support indexed/paletted pixel formats natively. You could use it for the pixel manipulation side and convert to \u0060SKBitmap\u0060 when handing off to Avalonia for display.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3402-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3402"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3400,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "backend/PDF",
          "tenet/reliability",
          "backend/Xps"
        ]
      },
      "summary": "SKDocument.CreateXps() renders embedded SVG \u003Cimage\u003E elements at ~30-40% of correct size, while CreatePdf() renders them correctly",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.90
        },
        "backends": [
          {
            "value": "backend/XPS",
            "confidence": 0.95
          },
          {
            "value": "backend/PDF",
            "confidence": 0.80
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.92
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.88
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "hasWorkaround": true,
          "workaroundSummary": "Use SKDocument.CreatePdf() instead of CreateXps() for correct image rendering, though this does not help users who require XPS output for Windows print pipeline.",
          "targetFrameworks": [
            "net9.0"
          ],
          "severity": "medium",
          "severityReason": "Incorrect visual output (images significantly undersized) with no XPS-specific workaround. PDF workaround exists but does not satisfy XPS-dependent workflows like Windows label printing."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Load an SVG document containing \u003Cimage\u003E elements with Base64-encoded images using SKSvg.Load()",
            "Generate XPS using SKDocument.CreateXps() with DPI scaling (72/96 = 0.75)",
            "Generate PDF using SKDocument.CreatePdf() with the same SVG and scaling",
            "Compare image dimensions in XPS vs PDF output"
          ],
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "var skSvg = new SKSvg();\nvar picture = skSvg.Load(ms);\nconst float DPI = 72f;\nconst float SVG_DPI = 96f;\nconst float contentScale = DPI / SVG_DPI;\nvar pageWidth = bounds.Width * contentScale;\nvar pageHeight = bounds.Height * contentScale;\n\nusing (var xpsStream = File.OpenWrite(\u0022output.xps\u0022))\n{\n    using var document = SKDocument.CreateXps(xpsStream);\n    using var canvas = document.BeginPage(pageWidth, pageHeight);\n    canvas.Clear(SKColors.White);\n    canvas.Scale(contentScale);\n    canvas.DrawPicture(picture);\n    document.EndPage();\n    document.Close();\n}",
              "context": "Reproduction code showing XPS generation with DPI-scaled canvas"
            }
          ],
          "environmentDetails": "Windows 10/11, .NET 9.0, Visual Studio, SkiaSharp 3.116.0 (form) / 3.119.1 (description), Svg.Skia 3.2.1"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Reporter lists 3.116.0 as current version in the form field but 3.119.1 in description body. The discrepancy is minor and both are recent v3 releases. Issue likely persists in latest.",
          "migrationPath": null
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.65,
          "reason": "Reporter states last known good version is 2.88.9 (v2 series). This is a major version boundary (v2 to v3) with significant Skia upstream changes, so the regression is plausible but the large version gap makes pinpointing difficult.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Clear rendering bug in the XPS backend where embedded raster images in SVG are scaled incorrectly (~30-40% of expected size). The same SKPicture renders correctly to PDF and raster, isolating the problem to how the XPS document backend handles image drawing operations from recorded picture playback. The ~30-40% reduction is close to 0.75\u00B2 = 0.5625, suggesting a DPI scale factor may be applied twice to images.",
        "keySignals": [
          {
            "text": "Images are significantly smaller (approximately 30-40% of correct size)",
            "source": "body",
            "interpretation": "Quantified rendering error; the ~0.56x factor is suspiciously close to 0.75\u00B2 suggesting double-application of the 72/96 DPI scale"
          },
          {
            "text": "All other SVG elements (text, barcodes, rectangles, shapes) render correctly in both formats",
            "source": "body",
            "interpretation": "Bug is isolated to raster image handling in XPS backend, not a general scaling issue"
          },
          {
            "text": "The same SKPicture object produces correct output with CreatePdf() and CreateImage()",
            "source": "body",
            "interpretation": "Problem is in XPS backend specifically, not in SKPicture recording or SVG parsing"
          },
          {
            "text": "This severely impacts label printing applications that require XPS output for Windows print pipeline",
            "source": "body",
            "interpretation": "Real-world impact for Windows printing workflows that depend on XPS"
          },
          {
            "text": "SkiaSharp Version: 3.119.1 / Version of SkiaSharp: 3.116.0",
            "source": "body",
            "interpretation": "Version discrepancy between description and form field \u2014 unclear which version was actually tested"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes incorrect rendering output (images undersized by ~60%) in XPS compared to PDF. This is clearly broken behavior, not a usage question or feature request. The [BUG] prefix matches the content.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting measurably wrong output."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKDocument.CreateXps() is in the core SkiaSharp package (binding/SkiaSharp/SKDocument.cs). The bug is in document generation, not views or HarfBuzz.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the root cause is likely in native Skia XPS code, the surface-level API is in SkiaSharp core."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/XPS, backend/PDF",
            "expandedReason": "XPS is the primary affected backend. PDF is included because the bug is defined by the discrepancy between the two backends rendering the same SKPicture."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Incorrect visual output with no XPS-specific workaround. PDF workaround exists but doesn\u0027t help XPS-dependent workflows. Not a crash or data loss, but renders XPS output unusable for the reporter\u0027s label printing use case."
          }
        ],
        "uncertainties": [
          "Which exact version was tested \u2014 3.116.0 or 3.119.1? The description and form field disagree.",
          "Whether the issue exists without the DPI scaling (contentScale = 0.75) \u2014 the scaling factor may be the trigger.",
          "Whether this is a Skia upstream XPS backend bug or specific to the SkiaSharp C API layer.",
          "Whether the 2.88.9 \u0027last known good\u0027 means it was specifically tested with XPS or is just the previous version used."
        ],
        "assumptions": [
          "Assumed the bug is in the Skia XPS backend\u0027s handling of DrawImage operations during picture playback, since all other primitives render correctly.",
          "Assumed the Svg.Skia library is not the source of the bug since the same SKPicture works correctly with CreatePdf().",
          "Assumed net9.0 target framework based on description mention of .NET 9.0, though the form field does not specify."
        ],
        "resolution": {
          "hypothesis": "The Skia XPS backend applies an additional DPI-based scaling to raster images drawn from SKPicture playback that the PDF backend does not. When the canvas already has a scale transform (0.75 for 72/96 DPI conversion), images get double-scaled while vector primitives (text, shapes) are only scaled once. The ~30-40% size reduction aligns with 0.75\u00B2 \u2248 0.5625.",
          "proposals": [
            {
              "title": "Investigate XPS backend DPI handling in Skia",
              "description": "Examine how SkXPSDevice handles DrawImage vs DrawPath operations in picture playback. Compare with SkPDFDevice to find where the additional scale is applied to images. This is likely in upstream Skia\u0027s XPS device code.",
              "confidence": 0.70,
              "effort": "medium"
            },
            {
              "title": "Test without DPI scaling as diagnostic",
              "description": "Ask reporter to test with contentScale=1.0 (no DPI conversion) to confirm whether the scaling factor triggers the bug. If images render correctly at 1.0x, this confirms the double-scaling hypothesis.",
              "confidence": 0.65,
              "effort": "low"
            },
            {
              "title": "Pre-render images to bitmap before XPS generation",
              "description": "As a workaround, rasterize the SVG to an SKImage first, then draw the rasterized image to the XPS canvas. This bypasses the SKPicture playback path in the XPS backend.",
              "confidence": 0.50,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Test without DPI scaling as diagnostic",
          "recommendedReason": "Low effort first step that would confirm the double-scaling hypothesis and narrow down the root cause before diving into Skia XPS backend code."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real rendering bug with partial reproduction code. Root cause likely in Skia\u0027s XPS backend DPI handling. Needs confirmation of the double-scaling hypothesis and version clarification."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Labels already match classification \u2014 no changes needed",
            "reason": "Current labels (type/bug, area/SkiaSharp, backend/PDF, backend/Xps, os/Windows-Classic, tenet/reliability) already match the classification",
            "confidence": 0.95,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge report and request diagnostic test without DPI scaling",
            "reason": "Need to clarify version discrepancy and test the double-scaling hypothesis",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the detailed reproduction code and clear comparison between PDF and XPS output \u2014 that makes this much easier to investigate.\n\nThe scaling numbers are interesting: images at ~30-40% of expected size with a 0.75 content scale factor could suggest the XPS backend is applying the DPI scale twice to raster images (0.75\u00B2 \u2248 0.56), while vector elements only get scaled once.\n\nTo help narrow this down:\n\n1. Could you confirm which SkiaSharp version you\u0027re testing with? The description mentions 3.119.1 but the form field says 3.116.0.\n2. Would you be able to test with \u0060contentScale = 1.0f\u0060 (removing the DPI conversion) to see if images render at the correct size in XPS? That would confirm whether the scale factor is triggering the issue.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3400-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3400"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3398,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "Intermittent crash in SKCanvas.DrawPath during Mapsui rendering in Avalonia desktop app on Windows 11, likely caused by threading violation in Mapsui",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.85
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.90
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "steps-only",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "net9.0"
          ],
          "severity": "medium",
          "severityReason": "Hard crash but intermittent, and strong evidence points to a threading violation in the third-party Mapsui library rather than a SkiaSharp defect."
        },
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/cf361924-61d3-4773-9689-b4c36b927b71",
              "context": "Crash-related screenshot shown in description alongside text about crash when drawing graphics",
              "source": "description"
            },
            {
              "url": "https://github.com/user-attachments/assets/40e7de45-62b9-42bf-9c05-7073203d9258",
              "context": "Crash-related screenshot shown in description alongside text about crash when drawing graphics",
              "source": "description"
            }
          ],
          "stepsToReproduce": [
            "Create an Avalonia desktop application using Mapsui for map rendering (Avalonia 11.3.7, SkiaSharp 2.88.8.0)",
            "Subscribe to the PointerMoved event on the MapControl",
            "In the PointerMoved handler, call GetMapInfo() to query map features",
            "Interact with the map by moving the pointer \u2014 crash occurs intermittently but frequently"
          ],
          "codeSnippets": [
            {
              "language": "text",
              "code": "at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr)\n   at SkiaSharp.SKCanvas.DrawPath(SkiaSharp.SKPath, SkiaSharp.SKPaint)\n   at Mapsui.Rendering.Skia.Extensions.SkCanvasExtensions.DrawPath(...)\n   at Mapsui.Rendering.Skia.LineStringRenderer.Draw(...)\n   at Mapsui.Rendering.Skia.MapRenderer.GetMapInfo(...)\n   at Mapsui.UI.Avalonia.MapControl.GetMapInfo(...)\n   at AeroSpirit.ViewModels.TaskMonitor.FlightControlViewModel.MapControl_PointerMoved(...)",
              "context": "Stack trace from comment 3 showing crash in sk_canvas_draw_path called through Mapsui rendering pipeline during PointerMoved event"
            }
          ],
          "environmentDetails": "Windows 11, .NET 9.0.7, Avalonia 11.3.7, SkiaSharp DLL version 2.88.8.0 (form says 3.116.0 but comment corrects to 2.88.8), Visual Studio (Windows)"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9",
            "2.88.8"
          ],
          "currentRelevance": "unknown",
          "reason": "Reporter selected 3.116.0 in the form but corrected to 2.88.8.0 in a comment. The threading crash pattern would likely occur in any SkiaSharp version since SkiaSharp objects are inherently not thread-safe."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.60,
          "reason": "Reporter selected 2.88.9 as last known good and 3.116.0 as current, but then stated the actual DLL version is 2.88.8.0. The version information is contradictory and unreliable. The intermittent threading crash pattern could exist in any version."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Intermittent crash in SKCanvas.DrawPath when Mapsui renders map features during concurrent GetMapInfo() queries triggered by PointerMoved. The crash pattern and stack trace strongly suggest a threading violation in Mapsui, not a SkiaSharp defect. SkiaSharp objects are not thread-safe and concurrent access causes exactly this type of intermittent native crash.",
        "keySignals": [
          {
            "text": "always collapse when drawing graphics, Occasionally, it does not necessarily appear, but it appears frequently",
            "source": "body",
            "interpretation": "Intermittent nature is a classic sign of a race condition or threading violation rather than a deterministic bug"
          },
          {
            "text": "The crash indeed occurred during the process of using MapInfo\u0027s query GetMapInfo(). It was retrieving MapInfo in the PointerMoved event.",
            "source": "body",
            "interpretation": "GetMapInfo() in PointerMoved likely triggers concurrent access to SkiaSharp objects while Mapsui is rendering, causing a threading violation"
          },
          {
            "text": "at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr) ... at Mapsui.Rendering.Skia.LineStringRenderer.Draw",
            "source": "comment 3",
            "interpretation": "Stack trace shows the crash path is entirely through Mapsui\u0027s rendering pipeline calling into SkiaSharp. No SkiaSharp-internal bug is evident."
          },
          {
            "text": "Looks more like a Mapsui issue? There\u0027s doesn\u0027t look like there\u0027s anything here that suggests that SkiaSharp is at fault...",
            "source": "comment 4",
            "interpretation": "Community member independently identified this as likely a Mapsui issue, corroborating the threading violation hypothesis"
          },
          {
            "text": "the SkiaSharp.dll version is 2.88.8.0",
            "source": "comment 2",
            "interpretation": "Contradicts the form selection of 3.116.0. Actual version is 2.88.8.0, making the regression claim unreliable."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter describes a hard crash (process termination) with a full stack trace. Even though the root cause is likely in Mapsui\u0027s threading, the crash manifests in SkiaSharp\u0027s native code, so classifying as bug is appropriate for tracking. Confidence is lower (0.75) because this is likely an upstream issue.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "This is a real crash with a stack trace, not a how-to question. Even if the root cause is usage, the symptom is broken behavior."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The crash occurs in the core SKCanvas.DrawPath API (sk_canvas_draw_path P/Invoke). This is the core SkiaSharp library, not Views, HarfBuzz, or native loading. Avalonia manages its own Skia surface.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "The crash is in the core SKCanvas API, not in any View control. Avalonia uses its own view layer."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash is typically high/critical, but downgraded to medium because: (1) it\u0027s intermittent, (2) it\u0027s almost certainly caused by threading misuse in Mapsui rather than a SkiaSharp defect, and (3) throttling GetMapInfo calls is a viable workaround.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "Would be appropriate if this were a confirmed SkiaSharp defect, but evidence strongly points to upstream misuse."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "request-info",
            "expandedReason": "Before closing, we should confirm the version confusion and gently redirect the reporter to Mapsui. Asking for a minimal reproduction without Mapsui would confirm whether SkiaSharp is at fault.",
            "alternatives": [
              {
                "value": "convert-to-discussion",
                "whyRejected": "There is a real crash occurring, which merits a proper issue response rather than a discussion redirect."
              },
              {
                "value": "needs-investigation",
                "whyRejected": "The stack trace is clear enough \u2014 investigation would just confirm the threading hypothesis. Better to request info and redirect upstream."
              }
            ]
          }
        ],
        "uncertainties": [
          "Cannot view the screenshots in the issue body \u2014 they may contain additional diagnostic information",
          "Exact SkiaSharp version is uncertain: form says 3.116.0, comment says 2.88.8.0",
          "Whether the crash can be reproduced without Mapsui (with just concurrent SKCanvas.DrawPath calls) is unknown",
          "Whether Mapsui has documented thread-safety requirements for GetMapInfo() is unknown"
        ],
        "assumptions": [
          "Assumed the crash is a threading violation based on the intermittent nature and the concurrent GetMapInfo/PointerMoved pattern",
          "Assumed SkiaSharp DLL version 2.88.8.0 (from comment) is more accurate than the 3.116.0 form selection",
          "Assumed .NET 9.0 based on the stack trace showing CoreCLR Version: 9.0.725.31616"
        ],
        "resolution": {
          "hypothesis": "Mapsui is accessing SkiaSharp objects (SKCanvas, SKPath, SKPaint) concurrently from its rendering thread and the UI thread handling GetMapInfo() in PointerMoved. SkiaSharp objects are not thread-safe, and this concurrent access causes an intermittent native crash in sk_canvas_draw_path.",
          "proposals": [
            {
              "title": "Redirect to Mapsui project",
              "description": "Guide the reporter to file this issue with the Mapsui project, as the threading violation is in their rendering code. Mapsui needs to add synchronization around their SkiaSharp calls.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Suggest workaround: throttle GetMapInfo calls",
              "description": "Advise the reporter to debounce or throttle GetMapInfo() calls in PointerMoved to reduce concurrent access to SkiaSharp objects. This treats the symptom but provides an immediate fix.",
              "confidence": 0.70,
              "effort": "low"
            },
            {
              "title": "Request minimal reproduction without Mapsui",
              "description": "Ask the reporter to reproduce the crash with plain SkiaSharp code (concurrent DrawPath calls from two threads) to definitively confirm whether SkiaSharp itself has a bug or this is purely a Mapsui concurrency issue.",
              "confidence": 0.60,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Redirect to Mapsui project",
          "recommendedReason": "The stack trace clearly shows Mapsui\u0027s rendering pipeline as the call site, and the intermittent crash pattern matches a threading violation. The most effective resolution is for Mapsui to add proper synchronization. A workaround suggestion should also be included."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.80,
          "reason": "The stack trace shows the crash originates from Mapsui\u0027s rendering pipeline calling SkiaSharp, with the intermittent nature strongly suggesting a threading violation. A community member also flagged this as likely a Mapsui issue. Should confirm version confusion and redirect to Mapsui before closing.",
          "missingInfo": [
            "sample-project",
            "version-number"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp label to match classification",
            "reason": "Issue crashes in core SKCanvas.DrawPath API; area label is missing from current labels",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis explaining likely threading violation and redirect to Mapsui",
            "reason": "Reporter needs version clarification, threading explanation, and upstream redirect to Mapsui project",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the stack trace in your follow-up comment \u2014 that\u0027s really helpful for narrowing this down.\n\nLooking at the stack, the crash is inside \u0060Mapsui.Rendering.Skia.LineStringRenderer.Draw\u0060 \u2192 \u0060SKCanvas.DrawPath\u0060. The intermittent nature combined with the fact that you\u0027re calling \u0060GetMapInfo()\u0060 inside \u0060PointerMoved\u0060 suggests this may be a concurrency issue \u2014 Mapsui\u0027s rendering and your query call may be accessing the same SkiaSharp objects (SKCanvas, SKPath, SKPaint) simultaneously. SkiaSharp objects are not thread-safe, and concurrent access causes exactly this kind of intermittent crash.\n\nA couple of things that would help clarify:\n\n1. **Version**: You selected 3.116.0 in the form but mentioned 2.88.8.0 in a comment \u2014 could you confirm which version you\u0027re actually using? (\u0060dotnet list package\u0060 in your project directory would show the exact NuGet version.)\n\n2. **Mapsui**: This crash pattern is very likely a threading bug in Mapsui rather than in SkiaSharp itself. Would you be able to report this to the [Mapsui project](https://github.com/Mapsui/Mapsui/issues) as well? They would be best positioned to add the necessary synchronization.\n\nAs an immediate workaround, you could try debouncing or throttling your \u0060GetMapInfo()\u0060 calls in \u0060PointerMoved\u0060, or ensuring they don\u0027t run concurrently with map rendering.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3398-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3398"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3396,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/feature-request",
          "os/WASM",
          "area/SkiaSharp.Views.Uno"
        ]
      },
      "summary": "User unable to load libSkiaSharp native library in Unity WebGL \u2014 gets DllNotFoundException despite trying multiple NativeAssets packages",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.80
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.90
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/WASM",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.80
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": {
          "stepsToReproduce": [
            "Download managed SkiaSharp NuGet and NativeAssets.Windows, NativeAssets.Android, NativeAssets.WebAssembly",
            "Set up Unity project targeting WebGL",
            "Place libSkiaSharp.a files in Unity project",
            "Build and run \u2014 browser console shows DllNotFoundException for libSkiaSharp"
          ],
          "environmentDetails": "Unity 2021.2 and 2022.3, targeting WebGL/WebAssembly"
        },
        "versionAnalysis": {
          "reason": "No specific SkiaSharp version mentioned. User references NativeAssets.Windows, NativeAssets.Android, and NativeAssets.WebAssembly NuGet packages but no version numbers."
        },
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "User is trying to use SkiaSharp in Unity WebGL, which is not an officially supported scenario. Unity\u0027s native plugin system differs from .NET\u0027s standard P/Invoke, and the NativeAssets.WebAssembly package is designed for Blazor/browser WASM via Emscripten, not Unity\u0027s WebGL build pipeline. The DllNotFoundException indicates the native library is not being linked into the Unity WebGL build correctly.",
        "keySignals": [
          {
            "text": "[FEATURE] Can\u0027t get it to work on Unity WebGL",
            "source": "title",
            "interpretation": "Filed as feature request but content is a how-to question about unsupported platform"
          },
          {
            "text": "DLLNotFound libSkiaSharp",
            "source": "body",
            "interpretation": "Native library not loading \u2014 Unity WebGL requires static linking via Emscripten, not dynamic loading"
          },
          {
            "text": "I have downloaded the managed SkiaSharp nuget and the Native.Windows and Native.Android and Native.WebAssemebly nugets",
            "source": "body",
            "interpretation": "User tried NativeAssets.WebAssembly but it is designed for Blazor WASM, not Unity WebGL"
          },
          {
            "text": "I have so far got it to run on Windows and Android",
            "source": "body",
            "interpretation": "SkiaSharp works in Unity for desktop/Android where dynamic linking is possible"
          },
          {
            "text": "I am not sure if this is because the managed C# dll is expecting a dynamic linked library instead of a static one",
            "source": "body",
            "interpretation": "User correctly suspects the static vs dynamic linking mismatch"
          },
          {
            "text": "Has anyone got this working on Unity for WebGL?",
            "source": "body",
            "interpretation": "Asking for community help \u2014 this is a question, not a feature request"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "Despite the [FEATURE] template prefix, the actual content is asking how to get SkiaSharp working in Unity WebGL. The user says \u0027Has anyone got this working?\u0027 and \u0027I have been trying for about 5 hours\u0027. This is a support/how-to question about an unsupported platform, not a request for new API functionality.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "User is not requesting a new API or capability \u2014 they are asking how to make existing functionality work in Unity WebGL. The [FEATURE] prefix comes from the issue template, but the content is a usage question."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The core error is DllNotFoundException for libSkiaSharp, which is a native library loading issue. The previous label area/SkiaSharp.Views.Uno was incorrect \u2014 Unity and Uno Platform are entirely different frameworks.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Uno",
                "whyRejected": "Unity is NOT Uno Platform. These are completely different technologies. The previous automated triage incorrectly conflated them."
              }
            ]
          },
          {
            "field": "platforms",
            "chosen": "os/WASM",
            "expandedReason": "Unity WebGL compiles to WebAssembly. The os/WASM label is the correct platform classification."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility",
            "expandedReason": "This is fundamentally a cross-platform compatibility question \u2014 SkiaSharp works on Windows and Android in Unity but not in the WebGL/WASM target."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "convert-to-discussion",
            "expandedReason": "Unity is not an officially supported platform. This is a community support question better suited to a Q\u0026A discussion where other Unity users can share their experiences."
          }
        ],
        "uncertainties": [
          "Whether SkiaSharp can technically work in Unity WebGL at all given the static linking requirement",
          "Which exact SkiaSharp version the user is trying to use",
          "Whether the user has tried building libSkiaSharp from source with Emscripten for Unity\u0027s WebGL target"
        ],
        "assumptions": [
          "Assumed the user is using the latest stable SkiaSharp since no version was specified",
          "Assumed Unity WebGL requires static linking of native plugins based on Unity documentation reference in the issue"
        ],
        "resolution": {
          "hypothesis": "Unity WebGL requires native plugins to be statically linked .a files compiled with Emscripten, but the NativeAssets.WebAssembly package provides binaries built for the Blazor/browser WASM runtime, not for Unity\u0027s build pipeline. The P/Invoke mechanism in Unity WebGL also works differently from standard .NET.",
          "proposals": [
            {
              "title": "Build libSkiaSharp from source for Unity WebGL",
              "description": "Compile libSkiaSharp using Emscripten with Unity-compatible settings. This would produce a .a static library that Unity can link into its WebGL build. Requires knowledge of Skia\u0027s build system (GN/Ninja) and Unity\u0027s native plugin requirements.",
              "confidence": 0.50,
              "effort": "high"
            },
            {
              "title": "Use SkiaSharp.Views.Blazor approach as reference",
              "description": "Study how SkiaSharp.Views.Blazor integrates with WebAssembly and adapt the approach for Unity WebGL. The Blazor integration already solves WASM compilation but uses a different hosting model.",
              "confidence": 0.35,
              "effort": "high"
            },
            {
              "title": "Use alternative 2D graphics for Unity WebGL",
              "description": "Consider Unity\u0027s built-in Vector Graphics package or other Unity-native solutions for vector art rendering in WebGL, since SkiaSharp does not officially support Unity as a host platform.",
              "confidence": 0.70,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Use alternative 2D graphics for Unity WebGL",
          "recommendedReason": "Unity is not an officially supported platform for SkiaSharp. Getting it to work in WebGL would require significant custom build work with no guarantee of success or ongoing support. Unity\u0027s own vector graphics tools are a more sustainable path."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "convert-to-discussion",
          "confidence": 0.75,
          "reason": "Unity is not an officially supported platform for SkiaSharp. This is a community support question better suited to a Q\u0026A discussion where Unity users can share experiences and workarounds.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Fix area label (Uno \u2192 native) and change type to question",
            "reason": "Unity is not Uno Platform \u2014 previous triage incorrectly applied area/SkiaSharp.Views.Uno. Content is a question, not a feature request.",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/question",
                "area/libSkiaSharp.native",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "type/feature-request",
                "area/SkiaSharp.Views.Uno"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Explain Unity WebGL limitations and suggest alternatives",
            "reason": "User has been struggling for hours and deserves a clear explanation of why NativeAssets.WebAssembly does not work in Unity WebGL",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed write-up of what you\u0027ve tried \u2014 that\u0027s helpful context.\n\nThe \u0060NativeAssets.WebAssembly\u0060 package is built for the Blazor/browser WASM runtime, not for Unity\u0027s WebGL pipeline. Unity WebGL requires native plugins to be statically linked \u0060.a\u0060 files compiled with Emscripten using Unity-compatible settings, which is a different build target than what the NuGet package provides.\n\nYour intuition about static vs dynamic linking is on the right track \u2014 Unity WebGL can\u0027t dynamically load \u0060.dll\u0060 or \u0060.so\u0060 files the way desktop and Android can. The native library needs to be compiled specifically for Unity\u0027s Emscripten toolchain and placed in a \u0060Plugins/WebGL\u0060 folder.\n\nUnity is not an officially supported host platform for SkiaSharp, so getting this working would require building libSkiaSharp from source targeting Unity\u0027s Emscripten environment \u2014 which is a significant undertaking. You might want to explore Unity\u0027s built-in Vector Graphics package or other Unity-native solutions for vector art in WebGL as a more sustainable alternative.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3396-comment-1"
            }
          },
          {
            "id": "convert-1",
            "type": "convert-to-discussion",
            "risk": "high",
            "description": "Convert to Q\u0026A discussion for community input",
            "reason": "This is a support question about an unsupported platform \u2014 better suited to discussion format where Unity users can share experiences",
            "confidence": 0.65,
            "dependsOn": "comment-1",
            "payload": {
              "categorySlug": "q-a",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3396"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3393,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Android",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "All P/Invoke wrapper methods lack GC.KeepAlive calls, allowing premature collection of managed objects while native code is using their handles",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": null,
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": {
          "value": "partner/unoplatform",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "hasWorkaround": true,
          "workaroundSummary": "Callers can manually add GC.KeepAlive() after SkiaSharp API calls, but this is fragile and shifts the burden to every consumer.",
          "targetFrameworks": [
            "net8.0-android"
          ],
          "severity": "high",
          "severityReason": "Race condition between GC and native code can cause use-after-free crashes on any platform. Non-deterministic and hard to diagnose. Affects all P/Invoke wrappers across the entire binding surface."
        },
        "reproEvidence": {
          "relatedIssues": [
            3393
          ],
          "repoLinks": [
            {
              "url": "https://github.com/unoplatform/uno/pull/21660",
              "description": "Uno Platform PR demonstrating the GC race with SkiaSharp canvas.DrawPicture"
            },
            {
              "url": "https://github.com/dotnet/java-interop/issues/719",
              "description": "Related .NET java-interop issue showing same GC.KeepAlive problem"
            }
          ],
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "var canvas = \u2026\nvar picture = \u2026\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point.",
              "context": "Demonstration of the GC race: after extracting picture.Handle, nothing keeps picture alive during the native call"
            },
            {
              "language": "csharp",
              "code": "public void DrawPicture (SKPicture picture, SKPaint paint = null)\n{\n\tif (picture == null)\n\t\tthrow new ArgumentNullException (nameof (picture));\n\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n\tGC.KeepAlive (picture);\n\tGC.KeepAlive (paint);\n}",
              "context": "Proposed fix: add GC.KeepAlive for all reference type parameters after the P/Invoke call"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, VS Code macOS, Android and all platforms affected"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "reason": "This is a latent bug present since the inception of the P/Invoke wrappers. It has never been systematically addressed \u2014 only a handful of methods (SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) have GC.KeepAlive calls."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.95,
          "reason": "This has always been the case. The GC race exists in every version of SkiaSharp \u2014 it was never systematically protected."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Well-documented GC race condition bug. When a managed SkiaSharp object\u0027s Handle is passed to a P/Invoke method, the .NET GC can collect the managed object (and run its finalizer, freeing native memory) before the native call completes. The reporter provides authoritative Microsoft documentation, a concrete Uno Platform reproduction, and a clear fix pattern.",
        "keySignals": [
          {
            "text": "[BUG] P/Invokes should protect parameters across invocations",
            "source": "title",
            "interpretation": "Clearly identifies a systematic bug in P/Invoke parameter lifetime management"
          },
          {
            "text": "this can be collected even while you are executing an instance method on that object",
            "source": "body",
            "interpretation": "Quotes Microsoft documentation confirming the GC behavior that causes the race"
          },
          {
            "text": "once execution hits SkiaApi.sk_canvas_draw_picture(), nothing ensures that picture is kept alive",
            "source": "body",
            "interpretation": "Identifies the exact point where the race can occur in SkiaSharp"
          },
          {
            "text": "The fix: audit the code (is there a generator?) such that all reference type parameters are explicitly kept alive across P/Invoke boundaries",
            "source": "body",
            "interpretation": "Reporter proposes systematic fix via GC.KeepAlive and asks about generator support"
          },
          {
            "text": "unoplatform/uno#21660 is a Skia-related example of this",
            "source": "body",
            "interpretation": "Real-world evidence from Uno Platform where this race was observed"
          },
          {
            "text": "Platform: Android, All",
            "source": "body",
            "interpretation": "Affects all platforms, not just Android \u2014 the GC race is a .NET runtime behavior"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a real bug \u2014 a GC race condition that can cause use-after-free crashes. The reporter provides Microsoft documentation, a concrete reproduction scenario via Uno Platform, and a clear fix. This is not a feature request or question.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "While the fix involves adding code, the underlying behavior (potential crash due to premature GC) is broken, not just suboptimal."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The bug is in the core SkiaSharp binding layer where P/Invoke wrapper methods extract Handle properties without protecting the managed objects from GC. This spans all of binding/SkiaSharp/.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "The Views layer is not the source of the problem \u2014 it\u0027s the core P/Invoke wrappers in SKCanvas, etc."
              }
            ]
          },
          {
            "field": "classification.platforms",
            "chosen": "null",
            "expandedReason": "While Android is mentioned in the form, the reporter explicitly says \u0027All\u0027 platforms are affected. The GC race is a .NET runtime behavior, not platform-specific. Removing os/Android is appropriate since this is cross-platform."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability",
            "expandedReason": "Use-after-free due to GC racing with native code causes crashes, data corruption, or undefined behavior. This is a reliability concern."
          },
          {
            "field": "partner",
            "chosen": "partner/unoplatform",
            "expandedReason": "The Uno Platform team discovered this in practice (uno#21660) and the reporter (jonpryor) references their PR as evidence. Flagging for partner visibility."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Non-deterministic use-after-free crash affecting the entire public API surface. The race is hard to reproduce but real, as demonstrated by the Uno Platform team. No easy workaround for consumers."
          }
        ],
        "uncertainties": [
          "How many of the ~hundreds of P/Invoke wrapper methods need GC.KeepAlive added \u2014 a full audit is needed",
          "Whether the code generator (utils/generate.ps1) can be extended to automatically emit GC.KeepAlive calls, or if hand-written wrappers must be individually patched",
          "Whether GC.KeepAlive(this) should also be added to instance methods, or if callers are expected to keep \u0060this\u0060 alive"
        ],
        "assumptions": [
          "Assumed the handful of existing GC.KeepAlive calls (in SKData, SKImage, SKSurface, etc.) were added ad-hoc, not as part of a systematic effort",
          "Assumed the bug affects all .NET runtimes (CoreCLR, Mono, NativeAOT) since the GC behavior is specified by the ECMA CLI standard"
        ],
        "resolution": {
          "hypothesis": "The .NET GC can collect managed SkiaSharp objects after their Handle property is read but before the P/Invoke call completes, because the runtime cannot see into native code. If the finalizer runs during this window, it frees the native handle, causing use-after-free in Skia.",
          "proposals": [
            {
              "title": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
              "description": "Audit all public methods in binding/SkiaSharp/ that call SkiaApi.* and add GC.KeepAlive() for every reference-type parameter (including \u0060this\u0060 for instance methods) after the P/Invoke call. This is the approach the reporter suggests and is the most thorough fix.",
              "confidence": 0.90,
              "effort": "high"
            },
            {
              "title": "Extend code generator to emit GC.KeepAlive",
              "description": "Modify the binding generator (utils/generate.ps1 or the underlying tool) to automatically emit GC.KeepAlive calls in generated P/Invoke wrappers. This prevents future regressions and reduces manual effort, but requires understanding the generator\u0027s architecture.",
              "confidence": 0.80,
              "effort": "high"
            },
            {
              "title": "Targeted fix for highest-risk methods first",
              "description": "Add GC.KeepAlive to the most commonly used methods (SKCanvas.Draw*, SKPaint, SKPath operations) as an incremental first step, with a follow-up for the full audit. Lower effort but leaves long-tail risk.",
              "confidence": 0.85,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
          "recommendedReason": "The reporter is an experienced .NET runtime engineer (jonpryor) who clearly understands the problem. A systematic fix is the only way to fully address this \u2014 partial fixes leave the same class of bug in less-used code paths."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.90,
          "reason": "Valid bug with clear fix pattern, but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add partner/unoplatform label and remove os/Android since issue affects all platforms",
            "reason": "Issue is cross-platform (reporter selected \u0027All\u0027), and Uno Platform is directly involved via their PR #21660",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "partner/unoplatform"
              ],
              "labelsToRemove": [
                "os/Android"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug report and outline investigation plan",
            "reason": "High-quality report from a knowledgeable contributor deserves a substantive response confirming the issue is understood",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the thorough write-up and the Microsoft documentation references \u2014 this is a well-documented GC race that we need to address systematically.\n\nA quick audit shows that only a handful of methods (in SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) currently have \u0060GC.KeepAlive\u0060 calls, so the vast majority of P/Invoke wrappers are unprotected.\n\nThe main question is whether to extend the code generator to emit these automatically, or do a manual audit. Do you have a sense of whether the Uno Platform team has hit this in practice beyond the \u0060DrawPicture\u0060 case, or if that\u0027s been the primary trigger?",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3393-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3393"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3386,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Linux",
          "area/libSkiaSharp.native",
          "tenet/compatibility"
        ]
      },
      "summary": "DllNotFoundException for libSkiaSharp when deploying to Azure Container App via .NET Aspire \u2014 NoDependencies package binary not deployed, wrong variant loaded",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Linux",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          },
          {
            "value": "tenet/reliability",
            "confidence": 0.80
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "hasWorkaround": true,
          "workaroundSummary": "Switch from NativeAssets.Linux.NoDependencies to NativeAssets.Linux and use a custom Docker image (ghcr.io/avantipoint/aspnet-skia) with fontconfig and other native dependencies pre-installed. Also add System.Memory.Data as a direct PackageReference to prevent trimming.",
          "targetFrameworks": [
            "net9.0"
          ],
          "severity": "medium",
          "severityReason": "Application crashes on startup in container deployment, but a workaround exists using a custom Docker image with NativeAssets.Linux."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET 9 Web API project using .NET Aspire",
            "Add SkiaSharp 3.116.0 and SkiaSharp.NativeAssets.Linux.NoDependencies package references",
            "Deploy to Azure Container App via Aspire",
            "Invoke an endpoint that uses SkiaSharp (e.g., SKBitmap.Decode)"
          ],
          "codeSnippets": [
            {
              "language": "xml",
              "code": "\u003CPackageReference Include=\u0022SkiaSharp\u0022 /\u003E\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022 /\u003E",
              "context": "Package references used in the project"
            }
          ],
          "repoLinks": [
            {
              "url": "https://github.com/AvantiPoint/aspnet-skia",
              "description": "Custom Docker image repo created by reporter as a workaround \u2014 based on mcr.microsoft.com/dotnet/aspnet with SkiaSharp native dependencies installed"
            }
          ],
          "environmentDetails": "Linux Azure Container App deployed via .NET Aspire, .NET 9.0.10 runtime, Visual Studio (Windows) IDE"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Issue reported on 3.116.0 (current at time of filing). The user reports 2.88.9 as the last known good version. This suggests a regression or packaging change between the 2.x and 3.x major versions that affects native asset deployment in containerized environments.",
          "migrationPath": null
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.70,
          "reason": "User reports 2.88.9 as last known good version. However, the NoDependencies package may not have existed in 2.x, so this may be a new issue with the 3.x packaging rather than a true regression of previously-working functionality.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "The user references SkiaSharp.NativeAssets.Linux.NoDependencies but the DllNotFoundException error shows libfontconfig.so.1 as the first missing dependency. NoDependencies has zero fontconfig dependency, so the deployed binary is NOT from the NoDependencies package \u2014 it is from NativeAssets.Linux or another source. This is a known failure mode documented in packages.md, likely caused by .NET Aspire\u0027s container deployment deploying the wrong native binary variant.",
        "keySignals": [
          {
            "text": "libfontconfig.so.1: cannot open shared object file: No such file or directory",
            "source": "stack-trace",
            "interpretation": "The NoDependencies variant has zero fontconfig dependency. Seeing this error means the deployed binary is NOT from NoDependencies \u2014 the wrong native binary variant was deployed."
          },
          {
            "text": "SkiaSharp.NativeAssets.Linux.NoDependencies",
            "source": "body",
            "interpretation": "User explicitly added NoDependencies package, but the deployed binary still requires fontconfig, indicating a package selection or deployment conflict."
          },
          {
            "text": "deployed with .NET Aspire",
            "source": "body",
            "interpretation": "Aspire uses container deployment which may interfere with NativeAssets resolution. The container build tooling may select or override the wrong RID variant."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "body",
            "interpretation": "Suggests something changed between 2.x and 3.x in how native assets are packaged or resolved in container scenarios."
          },
          {
            "text": "I switched to SkiaSharp.NativeAssets.Linux",
            "source": "comment 2",
            "interpretation": "User\u0027s workaround confirms the NoDependencies binary was not being deployed. Switching to the full Linux variant with fontconfig installed in a custom image resolved it."
          },
          {
            "text": "System.Memory.Data was not found... trimming is enabled",
            "source": "comment 2",
            "interpretation": "Secondary issue: Aspire\u0027s container deployment enables trimming which strips transitive dependencies. This compounds the native loading issue."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The application crashes with a TypeInitializationException wrapping a DllNotFoundException. The user correctly added the NoDependencies package but the wrong native binary was deployed, causing a crash. This is broken deployment behavior, not a usage error.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "User is not asking how to do something \u2014 the application crashes despite following documented package references."
              },
              {
                "value": "type/documentation",
                "whyRejected": "While the troubleshooting section of packages.md documents this exact scenario, the underlying issue is a real packaging/deployment bug, not a documentation gap."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The error is a DllNotFoundException for libSkiaSharp, which is a native library loading failure. The root cause is in how native assets are packaged and deployed, making area/libSkiaSharp.native the correct classification.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "Not a managed API issue \u2014 the failure is in native binary resolution/deployment."
              },
              {
                "value": "area/Build",
                "whyRejected": "Not a build issue per se \u2014 the project builds successfully. The failure is in runtime native binary selection during container deployment."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Application crashes on any SkiaSharp API call in the container, which is high impact. However, the user found a complete workaround (custom Docker image with fontconfig \u002B NativeAssets.Linux), dropping severity from high to medium."
          },
          {
            "field": "tenets",
            "chosen": "tenet/compatibility, tenet/reliability",
            "expandedReason": "Compatibility: worked in 2.88.9 but not in 3.116.0 in container deployments. Reliability: results in a hard crash (TypeInitializationException) on the first SkiaSharp API call."
          }
        ],
        "uncertainties": [
          "Whether the user had a conflicting transitive NativeAssets.Linux reference that overrode NoDependencies",
          "Whether .NET Aspire specifically selects the wrong RID variant during container image build, or if this is a general dotnet publish issue",
          "Whether NoDependencies package existed in 2.88.9 or if the user used a different package configuration with the older version"
        ],
        "assumptions": [
          "Assumed the user correctly added NoDependencies to the executable project, not just a library project",
          "Assumed this is specific to .NET Aspire container deployment since local development works fine",
          "Assumed net9.0 target framework based on the .NET 9.0.10 runtime path in the stack trace"
        ],
        "resolution": {
          "hypothesis": ".NET Aspire\u0027s container deployment pipeline resolves or deploys the wrong native binary variant for SkiaSharp. The NoDependencies binary should have no fontconfig dependency, but the deployed binary does, indicating the standard NativeAssets.Linux binary (or none) ends up in the container instead.",
          "proposals": [
            {
              "title": "Use custom Docker image with NativeAssets.Linux",
              "description": "The reporter\u0027s own workaround: switch to NativeAssets.Linux, use a custom base image with fontconfig installed, and set ContainerBaseImage in the csproj. This is a complete workaround available now.",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Investigate NoDependencies package selection in Aspire",
              "description": "Determine why .NET Aspire\u0027s container build doesn\u0027t deploy the NoDependencies binary. May require adding MSBuild diagnostics to trace which native assets are selected during publish. Could result in documentation improvement or MSBuild targets fix.",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "title": "Add Aspire-specific guidance to documentation",
              "description": "Document the .NET Aspire container deployment scenario in packages.md or a dedicated troubleshooting guide. Include the ContainerBaseImage workaround and the trimming fix for System.Memory.Data.",
              "confidence": 0.85,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Add Aspire-specific guidance to documentation",
          "recommendedReason": "The reporter\u0027s workaround is already complete and shared in the issue. Adding this to official documentation prevents others from hitting the same problem. Investigation into the root MSBuild/Aspire interaction can proceed separately."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The workaround exists but the root cause \u2014 why NoDependencies binary isn\u0027t deployed in Aspire container builds \u2014 is not determined. This could be a SkiaSharp packaging issue or an Aspire tooling bug.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add tenet/reliability label to reflect the hard crash behavior",
            "reason": "The issue causes a TypeInitializationException crash. Current labels cover type/bug, area, os, and tenet/compatibility but miss tenet/reliability.",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "tenet/reliability"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging workaround and explaining the fontconfig diagnostic signal",
            "reason": "The reporter and future visitors would benefit from understanding why the fontconfig error appears with NoDependencies, and official acknowledgment of the Aspire deployment gap.",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the thorough write-up and the workaround \u2014 that custom image approach is solid and will help others hitting this.\n\nThe fontconfig error with \u0060NoDependencies\u0060 is a tell: that package ships a binary with zero fontconfig dependency (only libc/libm/libpthread/libdl), so seeing \u0060libfontconfig.so.1: cannot open\u0060 means the deployed binary isn\u0027t actually from the NoDependencies package. Something in the Aspire container build pipeline is either selecting the wrong variant or not deploying the NoDependencies binary at all.\n\nWe\u0027ll look into what\u0027s happening with native asset selection in Aspire container deployments. In the meantime, your approach of using \u0060NativeAssets.Linux\u0060 with a custom base image that has fontconfig installed is the right call for this scenario.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3386-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3386"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3385,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": [
          "type/feature-request"
        ]
      },
      "summary": "Request to add SkColorType.Gray16 for 16-bit grayscale PNG support, but upstream Skia lacks Gray16",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.90
        },
        "backends": null,
        "platforms": null,
        "tenets": null,
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": null,
        "versionAnalysis": null,
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "User requests adding SkColorType.Gray16 for 16-bit grayscale PNG support. However, upstream Skia does not define a kGray_16 color type \u2014 confirmed by both the Skia API header (SkColorType.h) and a community comment. Since SkiaSharp wraps Skia, this cannot be implemented without upstream support.",
        "keySignals": [
          {
            "text": "[FEATURE] Gray16 support",
            "source": "title",
            "interpretation": "Explicitly tagged as a feature request"
          },
          {
            "text": "i want to use 16bit grayscale pngs but it looks like it doesnt exist in skiasharp",
            "source": "body",
            "interpretation": "User identified a missing color type in SkiaSharp\u0027s SKColorType enum"
          },
          {
            "text": "add SkColorType.Gray16",
            "source": "body",
            "interpretation": "Clear request for a specific new enum value"
          },
          {
            "text": "There\u0027s no Gray16 support upstream: https://api.skia.org/SkColorType_8h.html",
            "source": "comment 2",
            "interpretation": "Community member confirmed the limitation is in upstream Skia, not just a missing SkiaSharp wrapper"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "The user explicitly asks for new functionality (a new SKColorType value) that does not currently exist in SkiaSharp or upstream Skia. The title is prefixed with [FEATURE] and the issue uses the feature request template.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement implies improving something that exists. Gray16 support doesn\u0027t exist at all \u2014 this is new capability."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "SKColorType is a core SkiaSharp enum in the main binding library. It\u0027s not specific to views, HarfBuzz, or native loading.",
            "alternatives": [
              {
                "value": "area/libSkiaSharp.native",
                "whyRejected": "While the limitation is in the native layer, the requested API surface change is in the managed SKColorType enum."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is a legitimate feature request, but it\u0027s blocked on upstream Skia adding kGray_16_SkColorType first. A community member has already provided the key information. The issue should stay open to track demand, but no immediate action is possible."
          }
        ],
        "uncertainties": [
          "Whether the user\u0027s use case could be served by an alternative approach such as converting 16-bit grayscale data to a supported format like RGBA_F16 or R16G16_unorm"
        ],
        "assumptions": [
          "Assumed the user specifically needs native Gray16 pixel format support, not just the ability to decode 16-bit grayscale PNGs into a wider format"
        ],
        "resolution": {
          "hypothesis": "The user wants to work with 16-bit grayscale images natively in SkiaSharp, but the underlying Skia C\u002B\u002B library does not define a kGray_16 color type, making direct support impossible without upstream changes.",
          "proposals": [
            {
              "title": "Wait for upstream Skia to add kGray_16_SkColorType",
              "description": "Monitor Skia\u0027s development for the addition of a 16-bit grayscale color type. Once added upstream, SkiaSharp can expose it as SKColorType.Gray16. This is the only path to native support.",
              "confidence": 0.40,
              "effort": "low"
            },
            {
              "title": "Use A16_unorm as a workaround for single-channel 16-bit data",
              "description": "SkColorType.A16Unorm (kA16_unorm_SkColorType) stores a single 16-bit channel. While semantically it represents alpha, the user could repurpose it for grayscale data if they only need the raw pixel storage. Rendering would require custom shader logic.",
              "confidence": 0.50,
              "effort": "low"
            },
            {
              "title": "Decode 16-bit grayscale PNGs into RGBA_F16",
              "description": "Load the PNG and convert pixel data into SKColorType.RgbaF16, mapping the 16-bit grayscale value to all RGB channels. This preserves precision but uses 4x the memory and requires manual conversion.",
              "confidence": 0.60,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Decode 16-bit grayscale PNGs into RGBA_F16",
          "recommendedReason": "Most practical workaround available today. Preserves 16-bit precision while using supported Skia color types."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.80,
          "reason": "Legitimate feature request blocked on upstream Skia. Community has already clarified the upstream limitation. Keep open to track demand."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/SkiaSharp label to the feature request",
            "reason": "Issue is about the core SKColorType enum in the main SkiaSharp binding",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post comment explaining upstream dependency and suggesting workarounds",
            "reason": "While a community member noted the upstream gap, an official response with workarounds would add value",
            "confidence": 0.70,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the request. As noted in the comments, upstream Skia doesn\u0027t currently define a \u0060kGray_16\u0060 color type, so SkiaSharp can\u0027t expose \u0060SKColorType.Gray16\u0060 without that support landing in Skia first.\n\nIf you need to work with 16-bit grayscale PNG data in the meantime, one approach is to decode the pixel data and map it into \u0060SKColorType.RgbaF16\u0060 \u2014 this preserves 16-bit precision, though at the cost of higher memory usage. Another option is \u0060SKColorType.A16Unorm\u0060, which stores a single 16-bit channel (semantically alpha, but usable for raw grayscale storage if rendering isn\u0027t the primary goal).\n\nWe\u0027ll keep this open to track demand for native Gray16 support.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3385-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3385"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3379,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-25T12:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp.Views",
          "tenet/compatibility"
        ]
      },
      "summary": "SkiaSharp.Views.WPF references OpenTK.GLWpfControl 3.3.0 which lacks strong-naming, breaking strong-named .NET Framework applications with FileLoadException",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/OpenGL",
            "confidence": 0.80
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.95
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": true,
          "reproQuality": "partial",
          "hasWorkaround": true,
          "workaroundSummary": "Downgrade to SkiaSharp 2.88.x which did not have the OpenTK.GLWpfControl dependency, or avoid strong-naming the consuming application.",
          "targetFrameworks": [
            "net48"
          ],
          "severity": "medium",
          "severityReason": "Runtime FileLoadException blocks usage entirely for strong-named apps, but workaround exists by downgrading to 2.88.x or not strong-naming."
        },
        "reproEvidence": {
          "codeSnippets": [
            {
              "language": "xml",
              "code": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EWinExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet48\u003C/TargetFramework\u003E\n    \u003CSignAssembly\u003Etrue\u003C/SignAssembly\u003E\n    \u003CAssemblyOriginatorKeyFile\u003EMyStrongNameKey.snk\u003C/AssemblyOriginatorKeyFile\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp.Views.WPF\u0022 Version=\u00223.119.1\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E",
              "context": "Minimal csproj demonstrating strong-named WPF app with SkiaSharp.Views.WPF"
            }
          ],
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/blob/c38c6820b05fb2538afdd5a2f6662c5aff1d07e0/source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj#L15",
              "description": "Line in csproj referencing OpenTK.GLWpfControl 3.3.0 for net4x"
            }
          ],
          "stepsToReproduce": [
            "Create a .NET Framework 4.8 WPF application",
            "Enable strong-naming with SignAssembly and an .snk key file",
            "Add PackageReference to SkiaSharp.Views.WPF 3.119.1",
            "Build and run \u2014 FileLoadException on GLWpfControl assembly"
          ],
          "environmentDetails": "Windows, Visual Studio, .NET Framework 4.8, SkiaSharp 3.116.0\u002B"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "The csproj on main still references OpenTK.GLWpfControl 3.3.0 for net4x targets. Issue is present in all SkiaSharp 3.x releases.",
          "migrationPath": "Bump OpenTK.GLWpfControl from 3.3.0 to 3.3.1 in SkiaSharp.Views.WPF.csproj"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "User reports last known good version was 2.88.9 which did not have the OpenTK.GLWpfControl dependency. The SkiaSharp 3.x series introduced this dependency, and version 3.3.0 lacks strong-naming.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.90,
          "reason": "PR #3380 is open and proposes bumping OpenTK.GLWpfControl from 3.3.0 to 3.3.1. The fix has not been merged yet.",
          "relatedPRs": [
            3380
          ],
          "fixedInVersion": null,
          "verificationStatus": "unverified"
        }
      },
      "analysis": {
        "summary": "SkiaSharp.Views.WPF packages OpenTK.GLWpfControl 3.3.0 for .NET Framework targets. That version is not strong-named, so any strong-named consuming application gets a FileLoadException at runtime. The fix is a one-line version bump to 3.3.1 where strong-naming was added upstream.",
        "keySignals": [
          {
            "text": "OpenTK.GLWpfControl version 3.3.0 for .NET Framework... the GLWpfControl assembly is not strong-named",
            "source": "body",
            "interpretation": "Root cause identified by reporter \u2014 upstream dependency lacks strong name"
          },
          {
            "text": "Strong-naming was added in OpenTK.GLWpfControl 3.3.1",
            "source": "body",
            "interpretation": "Reporter has already identified the fix version"
          },
          {
            "text": "FileLoadException: Could not load file or assembly \u0027GLWpfControl, Version=3.3.0.0... A strongly-named assembly is required (0x80131044)\u0027",
            "source": "body",
            "interpretation": "Runtime error confirming strong-name enforcement failure"
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "body",
            "interpretation": "Regression from SkiaSharp 2.x to 3.x which introduced the OpenTK.GLWpfControl dependency"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "This is a runtime failure \u2014 FileLoadException prevents the application from running. The dependency on a non-strong-named assembly is a defect in the package configuration, not a feature request or question.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Not an improvement request \u2014 the application fails to load entirely."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The issue is in the SkiaSharp.Views.WPF csproj which references OpenTK.GLWpfControl. This is the Views package, specifically the WPF variant.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "Core SkiaSharp is unaffected \u2014 only the WPF views package has this dependency."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/OpenGL",
            "expandedReason": "GLWpfControl is the OpenGL rendering control for WPF. The issue is specific to this OpenGL integration dependency."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "The error completely blocks strong-named applications from using SkiaSharp.Views.WPF 3.x. However, a workaround exists (downgrade to 2.88.x or remove strong-naming), and the fix is a trivial version bump with an open PR."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "PR #3380 is already open with the fix (version bump to 3.3.1). The issue should remain open until the PR is merged and released."
          }
        ],
        "uncertainties": [
          "Whether bumping OpenTK.GLWpfControl from 3.3.0 to 3.3.1 introduces any behavioral changes beyond the strong-naming fix",
          "Whether the net4x OpenTK dependency (also at 3.3.1) is similarly affected by strong-naming requirements"
        ],
        "assumptions": [
          "Assumed the reporter is using .NET Framework 4.8 based on the csproj TargetFramework of net48",
          "Assumed the issue only affects net4x targets since the non-net4x ItemGroup uses OpenTK.GLWpfControl 4.2.3 which may already be strong-named"
        ],
        "resolution": {
          "hypothesis": "The SkiaSharp.Views.WPF.csproj pins OpenTK.GLWpfControl to 3.3.0 for net4x targets. That version is not strong-named, which breaks the CLR\u0027s strong-name validation chain when the consuming app is strong-named. Version 3.3.1 added strong-naming.",
          "proposals": [
            {
              "title": "Bump OpenTK.GLWpfControl to 3.3.1",
              "description": "Change the PackageReference version from 3.3.0 to 3.3.1 in SkiaSharp.Views.WPF.csproj for the net4x condition. This is the minimal change \u2014 3.3.1 added strong-naming with no other breaking changes. PR #3380 already implements this.",
              "confidence": 0.95,
              "effort": "low"
            },
            {
              "title": "Bump OpenTK.GLWpfControl to latest 3.x",
              "description": "Update to the latest 3.x release rather than just 3.3.1. This would pick up any additional bug fixes since 3.3.1, but carries slightly more risk of behavioral changes.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Disable SignAssembly for net4x WPF targets",
              "description": "Set SignAssembly to false for net4x targets in the SkiaSharp.Views.WPF csproj, matching the non-net4x behavior. However this would break SkiaSharp\u0027s own strong-naming contract for .NET Framework consumers.",
              "confidence": 0.30,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Bump OpenTK.GLWpfControl to 3.3.1",
          "recommendedReason": "Minimal, targeted fix that resolves the strong-naming gap. PR #3380 already implements exactly this change. No behavioral changes expected."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.90,
          "reason": "PR #3380 is open with the fix. Issue should remain open until merged and released."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add OpenGL backend label to existing correct labels",
            "reason": "The issue involves the OpenGL WPF control dependency. Current labels are correct but missing the backend classification.",
            "confidence": 0.80,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "backend/OpenGL"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the issue and note the existing PR",
            "reason": "Reporter should know their diagnosis is correct and a fix PR exists",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the clear write-up and for pinpointing the exact version where strong-naming was added.\n\nYou\u0027re right \u2014 the net4x target in SkiaSharp.Views.WPF pins OpenTK.GLWpfControl to 3.3.0, which isn\u0027t strong-named. PR #3380 bumps this to 3.3.1 to resolve the issue.\n\nIn the meantime, if you need a workaround, you could try adding a binding redirect in your app.config to force-load the 3.3.1 package manually, though ideally this will be resolved once the PR is merged.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3379-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3379"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3378,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T19:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "os/Android",
          "area/SkiaSharp",
          "backend/Metal",
          "tenet/reliability"
        ]
      },
      "summary": "Memory leak in ToHarfBuzzBlob() \u2014 SKStreamAsset not disposed in the non-memory-mapped code path",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Android",
            "confidence": 0.80
          },
          {
            "value": "os/Windows-Classic",
            "confidence": 0.75
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.90
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "partial",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "net8.0-android"
          ],
          "severity": "medium",
          "severityReason": "Memory leak that grows with each SKShaper instantiation. No crash, but can degrade application performance over time and eventually cause OOM on resource-constrained devices like Android."
        },
        "reproEvidence": {
          "codeSnippets": [
            {
              "language": "csharp",
              "code": "class TextSegmentShaper : IDisposable\n{\n    public SKPaint Paint { get; set; }\n    public SKShaper Shaper { get; set; }\n    ...\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposedValue)\n        {\n            Paint?.Dispose();\n            Shaper?.Dispose();\n            ...\n        }\n    }\n}",
              "context": "User\u0027s wrapper class that properly disposes SKShaper, but the underlying leak is in ToHarfBuzzBlob()"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), first observed on Android but also reproduces on Windows"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "reason": "The leak exists in BlobExtensions.ToHarfBuzzBlob() which has not changed in recent versions. The else branch at line 28-30 copies data from SKStreamAsset but never disposes it."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "The code in BlobExtensions.cs has had this pattern since the extension was introduced. The else branch has never disposed the SKStreamAsset. This is a latent bug, not a regression."
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Confirmed memory leak in BlobExtensions.ToHarfBuzzBlob(). When the SKStreamAsset has no memory base (the else branch), data is copied to unmanaged memory but the SKStreamAsset is never disposed. The if branch correctly disposes via the Blob\u0027s destroy callback, but the else branch only frees the copied CoTaskMem allocation. Title says SKShader but the actual issue is about SKShaper (HarfBuzz).",
        "keySignals": [
          {
            "text": "I think the bug is in ToHarfBuzzBlob() extension - it doesn\u0027t dispose SKStreamAsset in all paths",
            "source": "body",
            "interpretation": "User correctly identified the root cause. The else branch in ToHarfBuzzBlob() copies data but never disposes the source SKStreamAsset."
          },
          {
            "text": "SKShaper Shaper = new SKShaper(typeface)",
            "source": "body",
            "interpretation": "SKShaper constructor calls Typeface.OpenStream().ToHarfBuzzBlob(), creating the leak on every instantiation."
          },
          {
            "text": "First observed bug on Android, but seems to be a problem also on Windows",
            "source": "body",
            "interpretation": "Cross-platform code bug \u2014 affects all platforms, more visible on memory-constrained Android devices."
          },
          {
            "text": "Title says SKShader but code references SKShaper",
            "source": "title",
            "interpretation": "Typo in title \u2014 the actual issue is about SKShaper in the HarfBuzz package, not SKShader."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes a memory leak with code evidence pointing to a specific disposal path bug. This is broken behavior in the library, not a usage question.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting a code defect with specific root cause analysis."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.HarfBuzz",
            "expandedReason": "The leak is in BlobExtensions.ToHarfBuzzBlob() which is in the SkiaSharp.HarfBuzz package. SKShaper is also in this package. The current label area/SkiaSharp is incorrect.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The bug is not in core SkiaSharp. BlobExtensions and SKShaper are in the SkiaSharp.HarfBuzz package."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "null",
            "expandedReason": "This is a managed code memory leak in a HarfBuzz extension method. It has nothing to do with rendering backends. The existing backend/Metal label is incorrect."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Memory leak that grows with each SKShaper creation. Not a crash, but can cause OOM on constrained devices over time. The leak is in library code, not user code, so there is no straightforward workaround."
          }
        ],
        "uncertainties": [
          "Whether the else branch (non-memory-mapped path) is commonly hit in practice \u2014 if most streams have a memory base, the leak may be rare",
          "Exact memory footprint per leak \u2014 depends on font file size, could be significant for large fonts",
          "Whether the title typo (SKShader vs SKShaper) has caused confusion in previous triage"
        ],
        "assumptions": [
          "Assumed net8.0-android as target framework since user mentions Android and SkiaSharp 3.116.0",
          "Assumed the leak is cross-platform based on code analysis, not limited to Android and Windows"
        ],
        "resolution": {
          "hypothesis": "In BlobExtensions.ToHarfBuzzBlob(), the else branch copies font data from the SKStreamAsset into unmanaged memory but never disposes the SKStreamAsset. The if branch correctly passes asset.Dispose() as the Blob destroy callback, but the else branch only frees the CoTaskMem copy.",
          "proposals": [
            {
              "title": "Dispose SKStreamAsset in else branch",
              "description": "Add asset.Dispose() in the else branch of ToHarfBuzzBlob() after reading data, mirroring how the if branch handles disposal via the Blob callback. This is a one-line fix in BlobExtensions.cs.",
              "confidence": 0.92,
              "effort": "low"
            },
            {
              "title": "Always dispose SKStreamAsset after use in SKShaper constructor",
              "description": "Capture the SKStreamAsset in a variable in the SKShaper constructor and wrap it in a using statement, rather than relying on ToHarfBuzzBlob() to manage its lifetime. Decouples disposal responsibility from the extension method.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Unify both paths to always copy data",
              "description": "Simplify ToHarfBuzzBlob() to always copy data and always dispose the asset, removing the memory-mapped optimization. Trades minor performance for simpler, less error-prone code.",
              "confidence": 0.70,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Dispose SKStreamAsset in else branch",
          "recommendedReason": "Minimal change, directly fixes the root cause. The if branch already correctly manages disposal via the Blob callback, so adding disposal in the else branch makes both paths consistent."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.88,
          "reason": "Code-level bug confirmed by source analysis. The fix is straightforward but should be verified with a memory profiling test to confirm the leak and validate the fix.",
          "requiresHumanReview": true
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Correct area to SkiaSharp.HarfBuzz and remove incorrect Metal backend label",
            "reason": "The bug is in BlobExtensions.ToHarfBuzzBlob() in the SkiaSharp.HarfBuzz package, not core SkiaSharp. No rendering backend is involved.",
            "confidence": 0.95,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/SkiaSharp.HarfBuzz"
              ],
              "labelsToRemove": [
                "area/SkiaSharp",
                "backend/Metal"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge the bug report and confirm the root cause analysis",
            "reason": "User correctly identified the root cause \u2014 confirm their analysis and outline the likely fix",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed analysis \u2014 you\u0027re right that \u0060ToHarfBuzzBlob()\u0060 in \u0060BlobExtensions.cs\u0060 doesn\u0027t dispose the \u0060SKStreamAsset\u0060 in all paths.\n\nWhen the stream has a memory base, disposal is handled via the \u0060Blob\u0060 destroy callback. But when it falls through to the \u0060else\u0060 branch (data is copied to unmanaged memory), the \u0060SKStreamAsset\u0060 is never disposed.\n\nThis would leak one \u0060SKStreamAsset\u0060 per \u0060SKShaper\u0060 instantiation, which lines up with what you\u0027re seeing. The fix should be straightforward \u2014 disposing the asset after reading in the else branch.\n\n(Note: the issue title mentions SKShader, but the actual bug is in SKShaper/HarfBuzz \u2014 just flagging in case it causes confusion.)",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3378-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3378"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3375,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "SkiaSharp 3.116\u002B crashes on Windows x86 (.NET 8/9) with stack overflow at P/Invoke boundary; works on x64 and on older v2.88.9",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.85
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "steps-only",
          "hasWorkaround": true,
          "workaroundSummary": "Use x64 instead of x86, copy native DLLs to application root directory, or downgrade to SkiaSharp 2.88.9",
          "targetFrameworks": [
            "net9.0",
            "net8.0",
            "netstandard2.0"
          ],
          "severity": "high",
          "severityReason": "Hard crash (stack overflow) on x86 with no clean fix. Workarounds exist but require architecture change or version downgrade, which may not be viable for all users."
        },
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET 8 or 9 application referencing SkiaSharp 3.116\u002B (or 3.119.1)",
            "Compile and publish for x86 (win-x86)",
            "Run the application on Windows and invoke any SkiaSharp API (e.g., sk_bitmap_get_pixel_color)",
            "Observe stack overflow crash"
          ],
          "environmentDetails": "Windows 11 Pro (ARM CPU) 23H2 build 22631; also reproduced on standard x86 Windows with .NET 8.0"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Issue reported against 3.116.0 and confirmed still present in 3.119.1. No indication of a fix in later versions.",
          "migrationPath": null
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.90,
          "reason": "Original reporter states 2.88.9 works correctly with x86. Second commenter confirms x86 works with net472 (implying older SkiaSharp or same v3 but different runtime). The v2-to-v3 transition changed native library structure significantly.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "Two independent reporters confirm SkiaSharp 3.x crashes on x86 Windows with .NET 8/9. The second reporter\u0027s stack trace shows a stack overflow originating at the P/Invoke boundary (sk_bitmap_get_pixel_color), which strongly suggests a calling convention mismatch in the x86 native binary or P/Invoke declarations. The issue does not affect x64, and the second reporter confirms x86 works under .NET Framework 4.7.2, pointing to an interaction between the new .NET runtime\u0027s x86 marshalling and SkiaSharp 3.x\u0027s native layer.",
        "keySignals": [
          {
            "text": "when we compile the application for x86 then we are getting app crash (no event log, no dump)",
            "source": "body",
            "interpretation": "Silent crash on x86 suggests native-level failure before managed exception handling can capture it"
          },
          {
            "text": "Stack overflow at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color",
            "source": "comment 2",
            "interpretation": "Stack overflow at P/Invoke boundary is a classic symptom of calling convention mismatch on x86 (cdecl vs stdcall stack cleanup disagreement)"
          },
          {
            "text": "x86 \u002B net472: working / x86 \u002B Net8.0: ISSUE",
            "source": "comment 2",
            "interpretation": ".NET 8 changed default P/Invoke behavior; combined with x86 calling convention, this may trigger the mismatch"
          },
          {
            "text": "when we copy the DLLs from subdirectory to application root directory then the app crash is gone",
            "source": "body",
            "interpretation": "DLL loading path affects which native binary is loaded; a different binary in root may have correct calling convention or architecture"
          },
          {
            "text": "When we rollback the SkiaSharp nuget to version 2.88.9 then DLLs loading from subdirectory also work as expected",
            "source": "body",
            "interpretation": "Confirms regression \u2014 v2 native binaries work on x86, v3 do not"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Application crashes with stack overflow when using SkiaSharp on x86. This is clearly broken behavior \u2014 a hard crash, not a usage question or feature request.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Reporter is not asking how to do something; they are reporting a crash that blocks their x86 builds."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The crash occurs at the P/Invoke boundary to the native library. The stack overflow at sk_bitmap_get_pixel_color indicates the native binary or its calling convention is the root cause, not the managed C# wrapper. The DLL loading path workaround also points to native binary issues.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "While the P/Invoke declarations are in SkiaSharp, the root cause is more likely in the native binary\u0027s x86 compilation (calling convention or architecture mismatch)."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "Hard crash (stack overflow) with no clean workaround \u2014 all workarounds require significant changes (switch architecture, restructure DLL deployment, or downgrade to v2). Two independent reporters confirm the issue."
          },
          {
            "field": "regression",
            "chosen": "true",
            "expandedReason": "Explicitly stated: v2.88.9 works on x86, v3.116.0\u002B does not. The v2-to-v3 native library restructuring is the likely point where x86 support broke."
          }
        ],
        "uncertainties": [
          "Whether the root cause is a calling convention mismatch in P/Invoke declarations or in the native binary compilation",
          "Whether the issue is specific to Windows on ARM (original reporter) or affects all Windows x86 scenarios",
          "Whether the DLL-copy workaround from the first reporter applies to the second reporter\u0027s scenario (they say it doesn\u0027t help)",
          "Whether this affects all SkiaSharp APIs or only specific P/Invoke calls"
        ],
        "assumptions": [
          "Assumed the stack overflow in comment 2 is the same underlying issue as the silent crash in the original report, given both are x86-specific with SkiaSharp 3.x",
          "Assumed no fix has been released since 3.119.1 based on no follow-up comments indicating resolution"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp 3.x native binaries or P/Invoke declarations have a calling convention mismatch on x86. On x86 Windows, cdecl and stdcall differ in stack cleanup responsibility. If the native library uses cdecl but the P/Invoke declaration defaults to stdcall (or vice versa), each call leaks stack space, leading to stack overflow. .NET 8\u002B may have changed default marshalling behavior that surfaces this issue where .NET Framework 4.7.2 tolerated it.",
          "proposals": [
            {
              "title": "Audit and fix x86 calling conventions in P/Invoke declarations",
              "description": "Review all DllImport/LibraryImport declarations in SkiaSharp for explicit CallingConvention specification. Ensure they match the native library\u0027s actual calling convention (likely cdecl). On x86, mismatched conventions cause stack corruption on every call.",
              "confidence": 0.70,
              "effort": "medium"
            },
            {
              "title": "Verify x86 native binary compilation flags",
              "description": "Check the build configuration for win-x86 native binaries to ensure correct calling convention (__cdecl vs __stdcall) is specified consistently. The v2-to-v3 build system change may have altered defaults.",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "title": "Test with explicit NativeLibrary.SetDllImportResolver",
              "description": "As a diagnostic step, use NativeLibrary.SetDllImportResolver to control exactly which native binary is loaded on x86. This would help isolate whether the issue is DLL resolution (wrong binary loaded) or a genuine calling convention problem.",
              "confidence": 0.50,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Audit and fix x86 calling conventions in P/Invoke declarations",
          "recommendedReason": "Stack overflow at P/Invoke boundary is the strongest signal. Calling convention audit is the most direct path to root cause and fix."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real bug confirmed by two reporters with stack trace evidence. Root cause hypothesis is strong but needs verification through code inspection of P/Invoke declarations and native build configuration for x86.",
          "missingInfo": [
            "sample-project"
          ]
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Update area label to libSkiaSharp.native and add compatibility tenet",
            "reason": "Crash is in native layer at P/Invoke boundary, and this is a v2\u2192v3 regression affecting compatibility",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/libSkiaSharp.native",
                "tenet/compatibility"
              ],
              "labelsToRemove": [
                "area/SkiaSharp"
              ]
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging the bug and asking for a minimal repro project",
            "reason": "Two reporters confirm the issue but neither provides a minimal reproduction. A repro project would accelerate investigation of the x86 calling convention hypothesis.",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "request-info",
              "draftBody": "Thanks for the report and for the additional confirmation from @TomPMoleman \u2014 the stack trace showing a stack overflow at \u0060sk_bitmap_get_pixel_color\u0060 is very helpful.\n\nThe pattern here (x86 \u002B .NET 8/9 = crash, while x64 and .NET Framework 4.7.2 work fine) suggests a possible calling convention mismatch at the P/Invoke boundary that only manifests on x86.\n\nWould either of you be able to share a minimal reproduction project? Even a small console app that references SkiaSharp and calls a single API when built for x86 would be enough to narrow this down.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3375-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3375"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3372,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-09-22T00:00:00Z",
        "currentLabels": [
          "area/SkiaSharp.Views",
          "type/feature-request",
          "os/Windows-WinUI"
        ]
      },
      "summary": "Upgrade SkiaSharp.Views.WinUI to use Microsoft.WindowsAppSDK.WinUI 1.8 instead of the full metapackage to reduce transitive dependency bloat for MAUI and other consumers.",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-WinUI",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.80
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": null,
        "versionAnalysis": {
          "mentionedVersions": [
            "1.8"
          ],
          "currentRelevance": "likely",
          "reason": "WinAppSDK 1.8 is the version that introduced split packages. The request is to target this version specifically.",
          "migrationPath": null
        },
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "Feature request to change SkiaSharp.Views.WinUI\u0027s NuGet dependency from the Microsoft.WindowsAppSDK metapackage to the narrower Microsoft.WindowsAppSDK.WinUI 1.8 package. The metapackage currently forces all downstream consumers (including MAUI) to pull in the entire WinAppSDK. Active discussion between dotMorten (requester, advocating for the change to unblock MAUI RC2) and jeromelaban (Uno Platform, cautioning about forcing version upgrades). Maintainer has not yet weighed in.",
        "keySignals": [
          {
            "text": "[FEATURE] Upgrade SkiaSharp.Views.WinUI to 1.8",
            "source": "title",
            "interpretation": "Feature request to bump WinUI dependency version"
          },
          {
            "text": "it no longer relies on the Microsoft.WindowsAppSDK metapackage that\u0027ll force you and any other library that depends on Skia (like .NET MAUI) to pull in the entire metapackage",
            "source": "body",
            "interpretation": "Core problem: metapackage dependency causes transitive bloat"
          },
          {
            "text": "1.8 upgrade is planned for RC2, but it can\u0027t be done right without this",
            "source": "comment",
            "interpretation": "MAUI RC2 is blocked on this change; creates urgency"
          },
          {
            "text": "requires all consumers to upgrade to the latest",
            "source": "comment",
            "interpretation": "Counter-argument: bumping minimum version may break existing consumers"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/feature-request",
            "expandedReason": "This is a request to change package dependency targeting, not a bug or enhancement to existing drawing/rendering behavior. The feature (split packages) is new in WinAppSDK 1.8.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Enhancement implies improving existing behavior. This is about adopting a new packaging model."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views",
            "expandedReason": "The change targets SkiaSharp.Views.WinUI specifically \u2014 its NuGet package dependency declarations.",
            "alternatives": [
              {
                "value": "area/Build",
                "whyRejected": "While it involves NuGet packaging, the primary affected component is the Views.WinUI package."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "dotMorten explicitly states MAUI RC2 is blocked on this change. MAUI is a key downstream consumer.",
            "alternatives": [
              {
                "value": "partner/unoplatform",
                "whyRejected": "jeromelaban participates in discussion but Uno Platform is not requesting this change."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "Legitimate feature request with active community discussion. Labels are already correct. Maintainer needs to weigh in on the version bump tradeoff."
          }
        ],
        "uncertainties": [
          "Whether bumping to WinAppSDK 1.8 minimum would break existing consumers on older WinAppSDK versions",
          "Whether maintainer considers the MAUI RC2 urgency sufficient justification for the version bump",
          "Impact on Uno Platform and other downstream consumers"
        ],
        "assumptions": [
          "WinAppSDK 1.8 has stable split packages available on NuGet",
          "The change would involve modifying the .csproj or .nuspec for SkiaSharp.Views.WinUI"
        ],
        "resolution": {
          "hypothesis": "Switching from the Microsoft.WindowsAppSDK metapackage to Microsoft.WindowsAppSDK.WinUI 1.8 would reduce transitive dependency bloat and unblock downstream consumers like MAUI from cleanly adopting WinAppSDK 1.8.",
          "proposals": [
            {
              "title": "Switch to Microsoft.WindowsAppSDK.WinUI 1.8",
              "description": "Replace the Microsoft.WindowsAppSDK metapackage reference with Microsoft.WindowsAppSDK.WinUI 1.8 in the SkiaSharp.Views.WinUI project. This directly addresses the request but raises the minimum WinAppSDK version.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Conditional package references by TFM",
              "description": "Use conditional PackageReference elements to target WinUI-only package on newer TFMs while keeping metapackage compatibility for older ones. More complex but avoids breaking existing consumers.",
              "confidence": 0.55,
              "effort": "medium"
            },
            {
              "title": "Document metapackage workaround",
              "description": "Document how downstream consumers can use PackageReference overrides to avoid pulling the full metapackage, without changing SkiaSharp itself. Preserves backward compatibility but doesn\u0027t fix the root cause.",
              "confidence": 0.40,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Switch to Microsoft.WindowsAppSDK.WinUI 1.8",
          "recommendedReason": "Simplest change, directly addresses the request, and aligns with the ecosystem direction. The version bump tradeoff is acceptable given WinAppSDK 1.8 is the current stable release."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Legitimate feature request with active community discussion and MAUI ecosystem impact. Labels are already correct. Maintainer decision needed on version bump tradeoff."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add compatibility tenet and MAUI partner labels",
            "reason": "Issue impacts dependency compatibility and explicitly mentions MAUI as blocked downstream consumer",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "tenet/compatibility",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3372"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3365,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-08T15:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "libSkiaSharp.dll has hard link-time dependency on d3d12.dll causing crashes on Windows 10 systems without DX12",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "backends": [
          {
            "value": "backend/Direct3D",
            "confidence": 0.92
          }
        ],
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          },
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "net8.0-windows"
          ],
          "severity": "critical",
          "severityReason": "Hard crash at DLL load time with no managed-code workaround. Affects 0.1% of a 1 million user base (~1000 users). The crash occurs before any SkiaSharp API is called, making it impossible to catch or handle in application code."
        },
        "reproEvidence": {
          "relatedIssues": [
            3267
          ],
          "stepsToReproduce": [
            "Install SkiaSharp 3.116.0 or later in a Win32 application",
            "Deploy to a Windows 10 system that does not have d3d12.dll (systems without DX12 support or missing Windows updates)",
            "Launch the application \u2014 it crashes on native library load due to missing d3d12.dll dependency"
          ],
          "environmentDetails": "Windows 10 (not fully updated, lacking DX12 support). SkiaSharp 3.116.0. Legacy Win32 application. Sample of ~1 million installations with 0.1% crash rate."
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "reason": "Issue is reported on version 3.116.0 and the D3D12 dependency is still present in the latest builds. The root cause (static linking of d3d12.dll) has not been addressed."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.90,
          "reason": "Reporter states last known good version is 2.88.9 and the issue appeared in 3.116.0. Related issue #3267 pinpoints the regression to when D3D12 support was added.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": null
      },
      "analysis": {
        "summary": "This is a bug where libSkiaSharp.dll has a hard link-time dependency on d3d12.dll introduced when Direct3D 12 rendering support was added in SkiaSharp 3.x. Systems without DX12 (certain Windows 10 configurations lacking updates) crash on DLL load. Closely related to #3267 which reports the identical root cause on Windows 7.",
        "keySignals": [
          {
            "text": "There is a hard dependency on DX12 in the latest versions of SkiaSharp",
            "source": "body",
            "interpretation": "Reporter identifies the root cause as a static/link-time dependency on d3d12.dll rather than a dynamic/runtime load, pointing to a native build configuration issue."
          },
          {
            "text": "out of a sample of 1 million installations around 0.1% are crashing because their systems don\u0027t have DX12",
            "source": "body",
            "interpretation": "Quantified real-world impact: ~1000 affected users. This elevates severity to critical \u2014 it\u0027s a hard crash affecting a measurable production user base."
          },
          {
            "text": "porting one of our legacy Win32 apps to use SkiaSharp",
            "source": "body",
            "interpretation": "Confirms Windows-Classic platform (Win32/WPF/WinForms), not WinUI or UWP."
          },
          {
            "text": "Last Known Good Version of SkiaSharp: 2.88.9",
            "source": "body",
            "interpretation": "Confirms this is a regression from the 2.x to 3.x transition, when D3D12 support was added to the Skia build."
          },
          {
            "text": "While this is in reference to Windows 7, all of our crashes occur on Windows 10",
            "source": "comment 3",
            "interpretation": "Reporter distinguishes their issue from #3267 by noting it affects Windows 10, not just Win7. Same root cause but broader impact than originally thought."
          },
          {
            "text": "the common theme is that they\u0027re on systems that don\u0027t support DX12... and the resolution would be the same. So this is still a duplicate.",
            "source": "comment 4",
            "interpretation": "Community member confirms same root cause as #3267. While technically a duplicate, #3365 adds valuable scale data about Windows 10 impact."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The issue describes a hard crash caused by a static dependency on d3d12.dll in the native binary. This is clearly broken behavior \u2014 the library should gracefully handle missing DX12 support rather than failing to load entirely.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "Not requesting new functionality \u2014 reporting a crash in existing functionality."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The issue is in the native binary build configuration \u2014 d3d12.dll is a link-time import in libSkiaSharp.dll. This is a native build/linking issue, not a managed code or views issue.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "The core managed library is not the problem \u2014 it\u0027s the native binary\u0027s link-time dependency."
              }
            ]
          },
          {
            "field": "backends",
            "chosen": "backend/Direct3D",
            "expandedReason": "The d3d12.dll dependency exists because Skia added Direct3D 12 rendering backend support. The fix involves making this backend\u0027s dependency optional at the native level."
          },
          {
            "field": "platforms",
            "chosen": "os/Windows-Classic",
            "expandedReason": "Reporter explicitly describes a legacy Win32 app on Windows 10. The os/Windows-Classic label was already applied by the automated triage."
          },
          {
            "field": "tenets",
            "chosen": "tenet/reliability, tenet/compatibility",
            "expandedReason": "Reliability: hard crashes on systems without DX12 support with quantified 0.1% of 1M impact. Compatibility: regression from 2.x to 3.x breaks backward compatibility with Windows 10 systems that lack DX12 drivers."
          },
          {
            "field": "bugSignals.severity",
            "chosen": "critical",
            "expandedReason": "Hard crash at DLL load time with no managed-code workaround. Quantified impact of ~1000 affected users (0.1% of 1M). The crash prevents any SkiaSharp functionality from being used, and there is no way to catch or handle it in application code.",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "The inability to work around the crash in managed code and the quantified production impact elevate this beyond \u0027high\u0027 to \u0027critical\u0027."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "While closely related to #3267, the fix requires engineering work in the Skia build configuration to change d3d12.dll from a static import to a dynamic load. This hasn\u0027t been addressed yet and the issue remains open.",
            "alternatives": [
              {
                "value": "close-as-duplicate",
                "whyRejected": "While the root cause is identical to #3267, this issue adds significant value with real-world scale data (1M installations, 0.1% affected on Win10). A community member suggested closing as duplicate, but the additional context is worth preserving."
              }
            ]
          }
        ],
        "uncertainties": [
          "Exact Windows 10 build numbers affected \u2014 likely systems missing specific Windows Updates that provide d3d12.dll",
          "Whether the Skia upstream has already addressed this with delayed/dynamic loading of D3D12, or if this requires a SkiaSharp-specific build change",
          "Whether the version discrepancy matters \u2014 reporter says 3.116.0 but #3267 pinpoints 3.119.0-preview.1.2 as the introduction point"
        ],
        "assumptions": [
          "Assumed the reporter\u0027s version 3.116.0 is correct and that D3D12 support may have been present since that version",
          "Assumed targetFramework is net8.0-windows based on \u0027legacy Win32 app\u0027 and modern SkiaSharp 3.x usage, though reporter did not explicitly state this"
        ],
        "resolution": {
          "hypothesis": "The Skia build configuration statically imports d3d12.dll, causing the Windows loader to fail when that DLL is absent. The fix requires changing the D3D12 dependency from a load-time import to a runtime dynamic load (LoadLibrary/GetProcAddress or /DELAYLOAD pattern), allowing Skia to gracefully fall back when D3D12 is unavailable.",
          "proposals": [
            {
              "title": "Dynamic-load d3d12.dll in Skia build",
              "description": "Modify the Skia GN build to use delayed/dynamic loading of d3d12.dll instead of static imports. This is the proper fix \u2014 Skia should probe for DX12 availability at runtime and fall back gracefully. Involves adding /DELAYLOAD:d3d12.dll linker flag or using LoadLibrary/GetProcAddress pattern.",
              "confidence": 0.85,
              "effort": "medium"
            },
            {
              "title": "Disable D3D12 backend in SkiaSharp build",
              "description": "Set skia_use_direct3d=false in the GN build args for Windows, removing the d3d12.dll dependency entirely. Simple change but removes D3D12 rendering capability for all users.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Ship separate NativeAssets packages with and without D3D12",
              "description": "Provide two Windows native asset variants \u2014 one with D3D12 support and one without \u2014 allowing users to choose based on their target environment. Does not fix the root cause for the default package.",
              "confidence": 0.60,
              "effort": "high"
            }
          ],
          "recommendedProposal": "Dynamic-load d3d12.dll in Skia build",
          "recommendedReason": "Addresses root cause without removing functionality. Delay-loading d3d12.dll lets the library probe for DX12 at runtime and fall back gracefully, which is exactly what the reporter expects. Preserves D3D12 acceleration where available while being safe on systems without it."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The fix requires engineering work in the Skia build configuration to change d3d12.dll from a static import to a dynamic load. Closely related to #3267 but provides additional Windows 10 scale data."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add backend/Direct3D and tenet/compatibility labels",
            "reason": "Classification identifies Direct3D backend involvement and compatibility regression from 2.x to 3.x. These labels are not yet on the issue.",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "backend/Direct3D",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "related-1",
            "type": "link-related",
            "risk": "low",
            "description": "Link to related issue #3267 (same d3d12.dll root cause on Win7)",
            "reason": "Issue #3267 reports the identical root cause on Windows 7. Linking preserves cross-reference for the engineering fix.",
            "confidence": 0.95,
            "dependsOn": null,
            "payload": {
              "relatedIssues": [
                3267
              ],
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post analysis acknowledging the issue and linking to #3267",
            "reason": "Reporter asked for updates and the issue has been open without maintainer response. A response acknowledging the problem and linking to the existing tracking issue is appropriate.",
            "confidence": 0.80,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for the detailed report and the deployment scale data \u2014 knowing this affects ~0.1% of 1M installations on Windows 10 specifically is valuable context.\n\nThis is the same root cause as #3267: \u0060libSkiaSharp.dll\u0060 has a static (link-time) dependency on \u0060d3d12.dll\u0060 since D3D12 rendering support was added in SkiaSharp 3.x. On systems where \u0060d3d12.dll\u0060 isn\u0027t present \u2014 whether Win7 or Windows 10 without the necessary updates \u2014 the DLL fails to load entirely.\n\nThe fix would need to happen at the Skia build level, changing the D3D12 dependency from a static import to a runtime \u0060LoadLibrary\u0060/\u0060GetProcAddress\u0060 pattern so Skia can gracefully fall back when D3D12 isn\u0027t available.\n\nLinking this to #3267 as the canonical tracking issue since the resolution would be the same. Your data about Windows 10 impact is a helpful addition to that issue.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3365-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3365"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3357,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-09-04T20:00:00Z",
        "currentLabels": [
          "area/Docs"
        ]
      },
      "summary": "Maintainer request to migrate XML API documentation from docs folder into inline C# source code triple-slash comments",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.95
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": null,
        "tenets": null,
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": null,
        "versionAnalysis": null,
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "This is a documentation migration task filed by the maintainer (mattleibow). The issue requests migrating API documentation from a separate docs folder into inline C# source code comments. It references a migration guide and checklist, with specific rules about committing each type separately.",
        "keySignals": [
          {
            "text": "Can you help migrate my docs from the docs folder into the c# source",
            "source": "body",
            "interpretation": "Explicit documentation migration request \u2014 not a bug, question, or feature"
          },
          {
            "text": "There is a guide here: ~/API.Docs.Migration.Guide.md",
            "source": "body",
            "interpretation": "Structured migration task with existing tooling and guidelines"
          },
          {
            "text": "Each type should be migrated and commited separately",
            "source": "body",
            "interpretation": "Operational constraint for the migration process, indicates incremental work"
          },
          {
            "text": "Assigned to Copilot bot",
            "source": "labels",
            "interpretation": "This is an automation/agent task, not a user-reported issue"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/documentation",
            "expandedReason": "The issue is entirely about migrating documentation from one location to another. No broken behavior, no new functionality, no question being asked. The maintainer is requesting a docs migration task.",
            "alternatives": [
              {
                "value": "type/enhancement",
                "whyRejected": "Not improving existing functionality \u2014 purely a documentation format/location change."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "No new capability is being requested. The docs already exist and need to be moved."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/Docs",
            "expandedReason": "The issue is about documentation files and their migration into source code. The area/Docs label is already applied and is the correct classification.",
            "alternatives": [
              {
                "value": "area/SkiaSharp",
                "whyRejected": "While the target is C# source files in SkiaSharp, the work itself is documentation migration, not code changes."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "keep-open",
            "expandedReason": "This is an active task assigned to the Copilot bot. The maintainer filed it as a work item to be executed. It should remain open until the migration is complete."
          }
        ],
        "uncertainties": [
          "Whether the referenced migration guide and checklist files exist and are up to date",
          "How many types remain to be migrated from the checklist"
        ],
        "assumptions": [
          "Assumed this is a legitimate maintainer-filed work item since the author is mattleibow (project maintainer)",
          "Assumed the migration guide contains sufficient instructions for the assigned bot to execute"
        ],
        "resolution": {
          "hypothesis": "The maintainer wants all API documentation migrated from standalone docs files into inline triple-slash XML comments in the C# source, with each type committed separately for review purposes.",
          "proposals": [
            {
              "title": "Execute migration per checklist",
              "description": "Follow the API.Docs.Migration.Guide.md and API.Docs.Migration.Checklist.md to migrate each type one at a time, committing separately. This is the approach requested in the issue.",
              "confidence": 0.95,
              "effort": "high"
            },
            {
              "title": "Batch migration with squash commits",
              "description": "Migrate all types at once and use git interactive rebase to create per-type commits. Faster execution but riskier if conflicts arise.",
              "confidence": 0.60,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Execute migration per checklist",
          "recommendedReason": "The maintainer explicitly requested one-type-at-a-time commits. Following the stated process ensures reviewability and matches the team\u0027s workflow."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.90,
          "reason": "Active work item assigned to Copilot bot. Migration task is in progress or pending execution."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add type/documentation label to classify the issue type",
            "reason": "Issue is a documentation migration task. area/Docs is already applied; adding the type label completes classification.",
            "confidence": 0.95,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/documentation"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3357"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 3346,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-09-08T00:00:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "MAUI app crashes on Windows ARM64 when published as MSIX; installing VC\u002B\u002B Redistributable resolves it",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.85
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.95
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": {
          "value": "partner/maui",
          "confidence": 0.75
        }
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": false,
          "reproQuality": "complete",
          "hasWorkaround": true,
          "workaroundSummary": "Install Microsoft Visual C\u002B\u002B Redistributable on the target ARM64 Windows machine before running the published app.",
          "targetFrameworks": [
            "net9.0-windows10.0.19041.0"
          ],
          "severity": "medium",
          "severityReason": "Crash on published builds is severe (app won\u0027t start), but a workaround exists (install VC\u002B\u002B Redistributable) and the affected audience is narrow (ARM64 Windows published deployments only)."
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/riccardomartins/ArmDemoTryout",
              "description": ".NET MAUI app demonstrating the ARM64 Windows crash. Uses SkiaSharp.Views.Maui.Controls 3.119.0 and Svg.Skia 3.0.6 with MSIX packaging."
            }
          ],
          "relatedIssues": [
            3155,
            136
          ],
          "stepsToReproduce": [
            "Clone https://github.com/riccardomartins/ArmDemoTryout",
            "Open in Visual Studio on a Windows ARM64 machine",
            "Build and run in Debug or Release mode \u2014 works fine",
            "Publish the app as MSIX for Windows ARM64",
            "Run the published executable on a fresh ARM64 Windows machine without VC\u002B\u002B Redistributable installed",
            "App starts and crashes immediately"
          ],
          "codeSnippets": [
            {
              "language": "xml",
              "code": "\u003CPackageReference Include=\u0022SkiaSharp.Views.Maui.Controls\u0022 Version=\u00223.119.0\u0022 /\u003E\n\u003CPackageReference Include=\u0022Svg.Skia\u0022 Version=\u00223.0.6\u0022 /\u003E",
              "context": "Project dependencies from the repro csproj. Uses MAUI with MSIX packaging (WindowsPackageType=MSIX)."
            }
          ],
          "environmentDetails": "Windows 10 and 11 ARM64, Visual Studio (Windows), SkiaSharp 3.116.0 (reported) / 3.119.0 (in repro csproj), .NET 9, MSIX packaging"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.0"
          ],
          "currentRelevance": "likely",
          "reason": "Issue reported against 3.116.0 but repro project references 3.119.0, indicating it persists across recent versions. The VC\u002B\u002B Redistributable dependency on ARM64 is a build configuration issue that likely still exists."
        },
        "regression": null,
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.55,
          "reason": "Maintainer mattleibow asked if GPU rendering was being used, noting \u0027I am trying to release a fix for that\u0027. However, the repro uses SKCanvasView (CPU rendering), so the GPU fix may not fully address this issue. The VC\u002B\u002B Redistributable dependency suggests a native build configuration issue that may require separate attention."
        }
      },
      "analysis": {
        "summary": "A .NET MAUI app using SkiaSharp crashes on Windows ARM64 when published as MSIX, but works in Debug/Release modes. The reporter discovered that installing VC\u002B\u002B Redistributable resolves the crash, indicating the native binaries have a dynamic C\u002B\u002B runtime dependency not satisfied on fresh ARM64 deployments. The repro uses CPU rendering (SKCanvasView), so the maintainer\u0027s in-progress GPU fix may not fully address this.",
        "keySignals": [
          {
            "text": "installing Microsoft Visual C\u002B\u002B Redistributable that app works correctly in a fresh arm64 windows",
            "source": "comment 2",
            "interpretation": "The native binary (libSkiaSharp.dll or ANGLE libraries) dynamically links to the C\u002B\u002B runtime rather than statically linking it. This is the root cause of the crash on fresh ARM64 systems."
          },
          {
            "text": "runs correctly in Debug and Release modes on Windows ARM64, but when creating a Publish build for Windows ARM64, the app starts but crashes immediately",
            "source": "body",
            "interpretation": "Debug/Release work because Visual Studio installs VC\u002B\u002B runtime. Published MSIX on a fresh system lacks it. The difference is deployment context, not code."
          },
          {
            "text": "Were you using the GPU rendering? If so, I am trying to release a fix for that.",
            "source": "comment 3",
            "interpretation": "Maintainer is aware of a related ARM64 GPU issue and has a fix in progress. However, the repro uses SKCanvasView (CPU), so the GPU fix may not fully resolve this."
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes an app crash on published ARM64 builds. This is clearly broken behavior \u2014 a published app should not crash on a supported platform. Debug/Release builds work fine, confirming it\u0027s a deployment issue, not user error.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "Not asking how to do something \u2014 reporting a crash with clear expected vs actual behavior and a repro project."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/libSkiaSharp.native",
            "expandedReason": "The crash is resolved by installing VC\u002B\u002B Redistributable, which points to the native binary build configuration. Either libSkiaSharp.dll ARM64 or the ANGLE libraries from NativeAssets.WinUI are dynamically linking the C\u002B\u002B runtime instead of statically linking it. The skia-patterns.md reference confirms this as a known pattern.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views.Maui",
                "whyRejected": "While the repro uses MAUI, the root cause is in the native binary packaging, not the managed MAUI view layer."
              },
              {
                "value": "area/Build",
                "whyRejected": "Build area would suggest a build system issue, but this is specifically about native library linking configuration for ARM64."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Hard crash preventing the app from starting is severe, but a straightforward workaround exists (install VC\u002B\u002B Redistributable) and the affected audience is narrow (ARM64 Windows published deployments only).",
            "alternatives": [
              {
                "value": "high",
                "whyRejected": "A workaround exists (VC\u002B\u002B Redistributable installation), which lowers severity from high to medium."
              },
              {
                "value": "low",
                "whyRejected": "An app crash preventing all functionality is more than cosmetic/minor, even with a workaround."
              }
            ]
          },
          {
            "field": "partner",
            "chosen": "partner/maui",
            "expandedReason": "The repro is a MAUI app with MSIX packaging. The ANGLE libraries from NativeAssets.WinUI are part of the MAUI/WinUI rendering pipeline and may contribute to the VC\u002B\u002B dependency."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "needs-investigation",
            "expandedReason": "The VC\u002B\u002B Redistributable dependency on ARM64 needs investigation. Is it libSkiaSharp.dll or the ANGLE libraries? Was static linking intentionally omitted for ARM64? Static CRT linking was fixed for x86/x64 in issue #136 but may not cover ARM64.",
            "alternatives": [
              {
                "value": "request-info",
                "whyRejected": "The reporter provided a full repro project and identified the root cause (VC\u002B\u002B Redistributable). There\u0027s enough info to investigate without additional reporter input."
              },
              {
                "value": "close-as-fixed",
                "whyRejected": "No fix has been released. The maintainer mentioned a fix in progress but hasn\u0027t confirmed it addresses this specific issue."
              }
            ]
          }
        ],
        "uncertainties": [
          "Whether the crash is in libSkiaSharp.dll or the ANGLE libraries (libEGL.dll/libGLESv2.dll) from NativeAssets.WinUI \u2014 both could require VC\u002B\u002B runtime",
          "Whether the maintainer\u0027s in-progress GPU fix also addresses the VC\u002B\u002B runtime linking for CPU rendering scenarios",
          "The reporter says version 3.116.0 but the repro csproj shows 3.119.0 \u2014 unclear if the version discrepancy matters"
        ],
        "assumptions": [
          "Assumed the SKCanvasView usage in the repro code represents the reporter\u0027s actual usage pattern, making this a CPU rendering issue not a GPU one",
          "Assumed the ARM64 native build configuration is the root cause since the same app works in Debug/Release (where VC\u002B\u002B runtime is available from VS)"
        ],
        "resolution": {
          "hypothesis": "The ARM64 Windows build of libSkiaSharp.dll (or the ANGLE libraries from NativeAssets.WinUI) dynamically links the C\u002B\u002B runtime instead of statically linking it. When deployed via MSIX to a fresh ARM64 system, the C\u002B\u002B runtime isn\u0027t present, causing an immediate crash. Debug/Release from VS works because VS installs the VC\u002B\u002B runtime.",
          "proposals": [
            {
              "title": "Statically link C\u002B\u002B runtime for ARM64 Windows builds",
              "description": "Update the native build configuration to statically link the C\u002B\u002B runtime (/MT instead of /MD) for the ARM64 Windows target, matching what was done for x86/x64 in issue #136 (v1.68.0). This eliminates the dependency for all users.",
              "confidence": 0.80,
              "effort": "medium"
            },
            {
              "title": "Include VC\u002B\u002B Redistributable in MSIX package",
              "description": "Configure the MSIX packaging to include the VC\u002B\u002B Redistributable merge modules or declare a dependency on the VC\u002B\u002B runtime framework package. Doesn\u0027t require rebuilding native libraries but pushes the fix to app developers.",
              "confidence": 0.60,
              "effort": "low"
            },
            {
              "title": "Document VC\u002B\u002B Redistributable requirement for ARM64",
              "description": "Document that ARM64 Windows deployments require the VC\u002B\u002B Redistributable, and recommend including it in deployment scripts or installation prerequisites. Immediate workaround for affected users.",
              "confidence": 0.90,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Statically link C\u002B\u002B runtime for ARM64 Windows builds",
          "recommendedReason": "This is the proper fix that eliminates the dependency for all users. It\u0027s consistent with how x86/x64 builds were fixed in issue #136 and ensures ARM64 published apps work without additional prerequisites."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The VC\u002B\u002B Redistributable dependency on ARM64 Windows suggests the native library is not statically linking the C\u002B\u002B runtime for ARM64 builds. This was fixed for x86/x64 in issue #136 but may not have been applied to ARM64. The repro uses CPU rendering, so the maintainer\u0027s GPU fix may not fully address this."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Add area/libSkiaSharp.native and partner/maui labels",
            "reason": "Crash caused by missing VC\u002B\u002B Redistributable is a native library deployment issue. Repro is a MAUI app with MSIX packaging.",
            "confidence": 0.85,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "area/libSkiaSharp.native",
                "partner/maui"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "related-1",
            "type": "link-related",
            "risk": "low",
            "description": "Cross-reference related ARM64 and CRT linking issues",
            "reason": "Issue #3155 is a related ARM64 Windows GPU issue. Issue #136 is where static CRT linking was implemented for x86/x64 \u2014 the same fix may need to be applied for ARM64.",
            "confidence": 0.80,
            "dependsOn": null,
            "payload": {
              "relatedIssues": [
                3155,
                136
              ],
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Acknowledge workaround and explain the ARM64 VC\u002B\u002B dependency",
            "reason": "Reporter found a workaround but asked if it\u0027s expected. The maintainer\u0027s GPU question is also unanswered. A response would clarify the situation and provide context.",
            "confidence": 0.75,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Thanks for tracking that down \u2014 the VC\u002B\u002B Redistributable dependency is a really useful finding.\n\nTo answer your question: ideally, no, you shouldn\u0027t need to install the VC\u002B\u002B Redistributable separately. The native libraries should either statically link the C\u002B\u002B runtime or the MSIX package should include it.\n\nThis looks like it could be specific to the ARM64 build of the native libraries \u2014 the x64 builds have had static C\u002B\u002B runtime linking since v1.68.0, but the ARM64 build may not have the same configuration.\n\nLooking at your repro code, it appears you\u0027re using \u0060SKCanvasView\u0060 (CPU rendering). Would you be able to confirm? That would help clarify whether the GPU rendering fix @mattleibow mentioned would also cover this scenario.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-3346-comment-1"
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/3346"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 2511,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": []
      },
      "summary": "AccessViolationException in finalizer thread when closing WinForms app \u2014 duplicate of #2194, fixed in v2.88.1",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.92
        },
        "backends": null,
        "platforms": [
          {
            "value": "os/Windows-Classic",
            "confidence": 0.93
          }
        ],
        "tenets": [
          {
            "value": "tenet/reliability",
            "confidence": 0.95
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": true,
          "hasStackTrace": true,
          "reproQuality": "none",
          "hasWorkaround": true,
          "workaroundSummary": "Explicitly dispose all SkiaSharp objects before application exit instead of relying on finalizers, or upgrade to SkiaSharp v2.88.1\u002B which includes the fix from PR #2195.",
          "severity": "high",
          "severityReason": "Uncatchable AccessViolationException crashes the application during shutdown. However, a fix already exists in v2.88.1."
        },
        "reproEvidence": {
          "relatedIssues": [
            2194,
            1817
          ],
          "stepsToReproduce": [
            "Use SkiaSharp in a WinForms application on Windows (version prior to v2.88.1)",
            "Create and use SKObject-derived instances without explicit disposal",
            "Close the application, allowing finalizers to run"
          ],
          "environmentDetails": "Windows, WinForms application. No SkiaSharp version specified by reporter."
        },
        "versionAnalysis": {
          "currentRelevance": "unlikely",
          "reason": "The exact crash (AccessViolationException in NonAlertableWin32Lock.EnterCriticalSection during finalization) was fixed in PR #2195, released in v2.88.1. The current code has null guards on the critical section pointer before calling EnterCriticalSection. Reporter did not specify a version, but the identical stack trace to #2194 strongly suggests they were running a version before the fix."
        },
        "regression": null,
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.90,
          "reason": "PR #2195 added null checks to NonAlertableWin32Lock.Enter() and Leave() methods, preventing AccessViolationException when the critical section has already been finalized. This fix shipped in v2.88.1. The stack trace in #2511 is identical to #2194.",
          "relatedPRs": [
            2195
          ],
          "fixedInVersion": "2.88.1",
          "verificationStatus": "unverified"
        }
      },
      "analysis": {
        "summary": "This is a duplicate of #2194. The crash occurs because .NET finalizer ordering is non-deterministic \u2014 during app shutdown, the NonAlertableWin32Lock\u0027s finalizer can destroy the Win32 CRITICAL_SECTION before other SKNativeObject finalizers finish deregistering their handles. PR #2195 fixed this by adding null guards on the critical section pointer. The reporter provided no version info but the stack trace is byte-for-byte identical to the fixed issue.",
        "keySignals": [
          {
            "text": "System.AccessViolationException at NonAlertableWin32Lock.EnterCriticalSection",
            "source": "stack-trace",
            "interpretation": "Identical crash signature to #2194 \u2014 critical section accessed after finalization"
          },
          {
            "text": "SKNativeObject.Finalize() at bottom of stack",
            "source": "stack-trace",
            "interpretation": "Crash happens during GC finalization, not during normal usage \u2014 classic finalizer ordering problem"
          },
          {
            "text": "When I close my winform program",
            "source": "body",
            "interpretation": "App shutdown triggers GC finalization of all remaining objects, exposing the race condition"
          },
          {
            "text": "what is the problem?",
            "source": "body",
            "interpretation": "Reporter is asking for diagnosis, not reporting a specific repro \u2014 minimal information provided"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "Reporter describes an AccessViolationException crash during normal app shutdown. This is clearly broken behavior \u2014 finalizer cleanup should not crash.",
            "alternatives": [
              {
                "value": "type/question",
                "whyRejected": "While phrased as a question (\u0027what is the problem?\u0027), the core content is a crash report with a stack trace."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "The crash is in SkiaSharp\u0027s core HandleDictionary and PlatformLock infrastructure, not in any specific view or platform package.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "Stack trace does not involve any Views components \u2014 the crash is in core object disposal."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "high",
            "expandedReason": "AccessViolationException is uncatchable and terminates the process. However, it only occurs during app shutdown and a fix exists, which prevents it from being critical."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-duplicate",
            "expandedReason": "The stack trace is identical to #2194. PR #2195 fixed this exact issue in v2.88.1. The issue was already closed with zero comments, confirming it was recognized as a known/fixed issue."
          }
        ],
        "uncertainties": [
          "Reporter did not specify SkiaSharp version \u2014 cannot confirm they were on a pre-fix version",
          "No .NET framework version specified \u2014 unclear if .NET Framework or .NET Core"
        ],
        "assumptions": [
          "Reporter was using a SkiaSharp version prior to v2.88.1 based on the identical stack trace to the fixed issue #2194"
        ],
        "resolution": null
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.90,
          "reason": "Identical stack trace to #2194, which was fixed in PR #2195 (v2.88.1). Issue was already closed with no comments."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, core SkiaSharp, Windows, and reliability labels",
            "reason": "Matches classification \u2014 crash in core SkiaSharp on Windows during finalization",
            "confidence": 0.92,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/SkiaSharp",
                "os/Windows-Classic",
                "tenet/reliability"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "dup-1",
            "type": "link-duplicate",
            "risk": "medium",
            "description": "Mark as duplicate of #2194",
            "reason": "Byte-for-byte identical stack trace \u2014 same finalizer ordering crash in NonAlertableWin32Lock",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "duplicateOf": 2194,
              "comment": null
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post duplicate notice with upgrade guidance",
            "reason": "Let reporter know the issue is tracked and fixed",
            "confidence": 0.85,
            "dependsOn": "dup-1",
            "payload": {
              "commentType": "duplicate-notice",
              "draftBody": "Thanks for the stack trace \u2014 this is a known finalizer ordering issue on Windows that was tracked in #2194 and fixed in PR #2195.\n\nThe crash happens because the Win32 critical section used by SkiaSharp\u0027s handle dictionary can be finalized before other SkiaSharp objects during app shutdown. This was fixed in SkiaSharp v2.88.1 by adding null guards on the critical section pointer.\n\nIf you\u0027re able to upgrade to v2.88.1 or later, this should be resolved. Closing as a duplicate of #2194.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2511-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as duplicate of #2194",
            "reason": "Fixed in v2.88.1, identical to tracked issue",
            "confidence": 0.90,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "not_planned",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2511"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 2383,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": []
      },
      "summary": "Question about whether SkiaSharp supports 24-bit RGB pixel format (Format24bppRgb) without alpha channel",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.90
        },
        "backends": null,
        "platforms": null,
        "tenets": null,
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": null,
        "versionAnalysis": null,
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "User is asking how to convert 24-bit RGB pixel data (System.Drawing.Imaging.PixelFormat.Format24bppRgb) to SKBitmap. This is a usage question about pixel format support \u2014 not a bug or feature request. Skia does not have a native 24bpp (3 bytes per pixel) color type, but SKColorType.Rgb888x provides 8 bits per RGB channel with an ignored padding byte at 4 bytes per pixel.",
        "keySignals": [
          {
            "text": "Does skia supports a 24-bit color type like System.Drawing.Imaging.PixelFormat.Format24bppRgb",
            "source": "title",
            "interpretation": "Phrased as a question about API capability \u2014 how-to, not a bug report"
          },
          {
            "text": "I want to convert an image which is in 24-bit color type to SKBitmap",
            "source": "body",
            "interpretation": "User has existing 24bpp pixel data and wants to load it into SkiaSharp"
          },
          {
            "text": "use 8 bits for each colors, no alpha, necessary to specify width, height and stride",
            "source": "body",
            "interpretation": "User understands the pixel format requirements and is looking for the SkiaSharp equivalent"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "The title is literally phrased as a question (\u0027Does skia supports...\u0027) and the body describes a goal the user wants to achieve, not broken behavior. No crash, no error, no incorrect output.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "User is asking if this already exists, not requesting a new feature. The functionality can be achieved with existing APIs via data conversion."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp",
            "expandedReason": "Question is about core SKBitmap, SKColorType, and pixel data handling \u2014 all in the core SkiaSharp package.",
            "alternatives": [
              {
                "value": "area/SkiaSharp.Views",
                "whyRejected": "No mention of views, rendering, or UI frameworks."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-with-docs",
            "expandedReason": "The answer is straightforward: Skia has no native 24bpp format, but SKColorType.Rgb888x is 32bpp with ignored alpha, and users can convert 24bpp data to 32bpp then use SKBitmap.InstallPixels with custom stride. This can be answered directly."
          }
        ],
        "uncertainties": [
          "Whether the user has raw pixel byte arrays or encoded image files in 24bpp format",
          "What platform and SkiaSharp version the user is targeting"
        ],
        "assumptions": [
          "Assumed the user has raw 24-bit pixel data (byte arrays) rather than encoded image files, based on the mention of stride and per-channel bit depth",
          "Assumed any recent version of SkiaSharp since no version was mentioned"
        ],
        "resolution": {
          "hypothesis": "User wants to load raw 24-bit RGB pixel data into an SKBitmap. Skia does not support a native 3-byte-per-pixel format, so the data must be converted to a 4-byte-per-pixel format like Rgb888x or Rgba8888.",
          "proposals": [
            {
              "title": "Convert 24bpp to 32bpp and use SKBitmap.InstallPixels",
              "description": "Expand each 3-byte RGB pixel to 4 bytes (RGB \u002B 0xFF padding) then use SKBitmap.InstallPixels with SKColorType.Rgb888x or Rgba8888. This gives full control over width, height, and stride. Most direct approach.",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Use SKBitmap.Decode for encoded images",
              "description": "If the source is an encoded image file (PNG, JPEG, BMP) rather than raw pixels, use SKBitmap.Decode which handles format conversion automatically regardless of the source pixel format.",
              "confidence": 0.80,
              "effort": "low"
            },
            {
              "title": "Use SKPixmap with Rgb888x color type",
              "description": "Create an SKImageInfo with SKColorType.Rgb888x (32bpp, alpha ignored) and use SKPixmap to wrap pre-converted pixel data. Useful when working with SKImage.FromPixels for immutable image creation.",
              "confidence": 0.75,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Convert 24bpp to 32bpp and use SKBitmap.InstallPixels",
          "recommendedReason": "Most direct answer to the user\u0027s stated requirements (raw pixels, custom stride, no alpha). SKBitmap.InstallPixels accepts width, height, and rowBytes as requested."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.85,
          "reason": "Straightforward usage question answerable with existing API documentation for SKColorType and SKBitmap.InstallPixels"
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply question and SkiaSharp area labels",
            "reason": "Matches classification as a usage question about core SkiaSharp pixel format support",
            "confidence": 0.92,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/question",
                "area/SkiaSharp"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post answer explaining 24bpp handling with SKColorType.Rgb888x and InstallPixels",
            "reason": "Direct answer available from SkiaSharp API surface",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "answer",
              "draftBody": "Skia doesn\u0027t have a native 24-bit (3 bytes per pixel) color type. The closest equivalent is \u0060SKColorType.Rgb888x\u0060, which uses 8 bits for each of R, G, B with an ignored 4th byte \u2014 so it\u0027s 32 bits per pixel rather than 24.\n\nTo load your 24bpp data into an \u0060SKBitmap\u0060, you\u0027d need to expand each pixel from 3 bytes to 4 bytes (inserting a padding byte), then use \u0060SKBitmap.InstallPixels\u0060 with an \u0060SKImageInfo\u0060 configured for \u0060SKColorType.Rgb888x\u0060:\n\n\u0060\u0060\u0060csharp\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x);\nvar bitmap = new SKBitmap();\nbitmap.InstallPixels(info, expandedPixelPtr, rowBytes);\n\u0060\u0060\u0060\n\nThe \u0060rowBytes\u0060 parameter lets you specify the stride of your expanded pixel data.\n\nAlternatively, if your source is an encoded image file (BMP, PNG, JPEG), \u0060SKBitmap.Decode\u0060 handles format conversion automatically \u2014 no manual pixel expansion needed.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-2383-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as answered",
            "reason": "Question answered with API guidance and code example",
            "confidence": 0.80,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/2383"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 1898,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-24T12:00:00Z",
        "currentLabels": []
      },
      "summary": "SkiaSharp.Views.Forms 2.88.0-preview.179 NuGet package has an empty netcoreapp3.1 directory \u2014 DLLs missing despite netcore 3.1 support being added in preview.127",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.95
        },
        "backends": null,
        "platforms": null,
        "tenets": [
          {
            "value": "tenet/compatibility",
            "confidence": 0.85
          }
        ],
        "partner": null
      },
      "evidence": {
        "bugSignals": {
          "hasCrash": false,
          "hasStackTrace": false,
          "reproQuality": "steps-only",
          "hasWorkaround": false,
          "workaroundSummary": null,
          "targetFrameworks": [
            "netcoreapp3.1"
          ],
          "severity": "medium",
          "severityReason": "NuGet package advertises netcoreapp3.1 support but ships empty directory \u2014 consumers targeting netcoreapp3.1 get no assemblies. Not a crash, but a broken package."
        },
        "reproEvidence": {
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/compare/v2.88.0-preview.120...v2.88.0-preview.127",
              "description": "Release notes showing netcore 3.1 support added in preview.127"
            }
          ],
          "stepsToReproduce": [
            "Install SkiaSharp.Views.Forms 2.88.0-preview.179",
            "Open the package in NuGet Package Explorer",
            "Navigate to the netcoreapp3.1 directory",
            "Observe the directory is empty \u2014 no DLL files present"
          ],
          "environmentDetails": null
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.0-preview.120",
            "2.88.0-preview.127",
            "2.88.0-preview.179"
          ],
          "currentRelevance": "unlikely",
          "reason": ".NET Core 3.1 reached end-of-life in December 2022. SkiaSharp 2.88.0 stable and subsequent versions (2.88.1, 2.88.2, 2.88.3, 2.88.5, 2.88.6, 2.88.7, 2.88.8, 3.x) have all shipped since this preview. The issue is no longer relevant to any supported configuration.",
          "migrationPath": "Upgrade to .NET 6\u002B and SkiaSharp 2.88.8\u002B or 3.x"
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.80,
          "reason": "Reporter states netcoreapp3.1 DLLs were present in preview.127 but missing in preview.179, indicating a regression between those preview builds.",
          "workedInVersion": "2.88.0-preview.127",
          "brokeInVersion": "2.88.0-preview.179"
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.85,
          "reason": "The 2.88.0 stable release and all subsequent releases have shipped. .NET Core 3.1 is EOL and no longer targeted. The preview series this bug affects is obsolete.",
          "fixedInVersion": null,
          "verificationStatus": "inconclusive"
        }
      },
      "analysis": {
        "summary": "Packaging bug in a 2021-era preview build where netcoreapp3.1 assemblies were missing from the SkiaSharp.Views.Forms NuGet package. The affected preview version is long superseded and .NET Core 3.1 itself is EOL. This issue is no longer actionable.",
        "keySignals": [
          {
            "text": "netcoreapp3.1 directory is empty in Nuget Package Explorer",
            "source": "body",
            "interpretation": "Package structure exists but DLLs are missing \u2014 build/packaging issue, not a missing feature"
          },
          {
            "text": "Support for netcore 3.1 was added in 2.88.0-preview.127 version",
            "source": "body",
            "interpretation": "Confirms this is a regression from a prior preview that had the support"
          },
          {
            "text": "newest 2.88.0-preview.179 version of Views.Forms",
            "source": "body",
            "interpretation": "Affects only preview builds from December 2021 \u2014 long obsolete"
          },
          {
            "text": "5 thumbs-up reactions, 0 comments",
            "source": "metadata",
            "interpretation": "Others experienced the same issue but no maintainer response, suggesting it was resolved by subsequent releases"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/bug",
            "expandedReason": "The reporter describes a concrete defect: a NuGet package that should contain netcoreapp3.1 assemblies has an empty directory. This is broken packaging behavior, not a feature request or question.",
            "alternatives": [
              {
                "value": "type/feature-request",
                "whyRejected": "netcoreapp3.1 support was already added in preview.127 \u2014 this is about it being broken in a later preview, not requesting new support."
              }
            ]
          },
          {
            "field": "area",
            "chosen": "area/SkiaSharp.Views.Forms",
            "expandedReason": "The issue is specifically about the SkiaSharp.Views.Forms NuGet package having empty netcoreapp3.1 content. The package name is explicitly mentioned.",
            "alternatives": [
              {
                "value": "area/Build",
                "whyRejected": "While the root cause is likely a build/packaging issue, the area should reflect what the user observes \u2014 the Views.Forms package."
              }
            ]
          },
          {
            "field": "bugSignals.severity",
            "chosen": "medium",
            "expandedReason": "Missing assemblies means the package is broken for netcoreapp3.1 consumers, but it\u0027s not a crash or data loss \u2014 it\u0027s a packaging gap. Workaround exists by using an older preview or different TFM."
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "This affects only obsolete preview builds (2.88.0-preview.179) and a now-EOL framework (.NET Core 3.1). The stable 2.88.0 release and all subsequent versions have shipped. No action is needed."
          }
        ],
        "uncertainties": [
          "Whether the stable 2.88.0 release included netcoreapp3.1 assemblies in Views.Forms \u2014 unable to verify the exact package contents retroactively",
          "Whether the empty directory was intentional (dropped support) or accidental (build script bug)"
        ],
        "assumptions": [
          "Assumed that the issue was resolved in subsequent stable releases since no follow-up comments were posted and the preview series is obsolete",
          "Assumed .NET Core 3.1 targeting was eventually dropped intentionally as the framework reached EOL"
        ],
        "resolution": {
          "hypothesis": "The build pipeline for SkiaSharp.Views.Forms preview.179 failed to include netcoreapp3.1 assemblies despite the TFM being listed. This was likely a build script regression between preview.127 and preview.179.",
          "proposals": [
            {
              "title": "Close as obsolete",
              "description": "The affected preview version is from 2021, .NET Core 3.1 is EOL (December 2022), and SkiaSharp 3.x is the current major version. No fix needed \u2014 the issue is moot.",
              "confidence": 0.90,
              "effort": "low"
            },
            {
              "title": "Upgrade to current SkiaSharp",
              "description": "Users should migrate to .NET 6\u002B and SkiaSharp 2.88.8\u002B or 3.x which are actively supported and do not target EOL frameworks.",
              "confidence": 0.95,
              "effort": "low"
            }
          ],
          "recommendedProposal": "Close as obsolete",
          "recommendedReason": "No code change is needed. The affected version is a 3\u002B year old preview, and the target framework is EOL."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.85,
          "reason": "Obsolete preview version (2.88.0-preview.179) and EOL framework (.NET Core 3.1). Stable releases have long since shipped. No action required."
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply bug, Views.Forms, and compatibility labels",
            "reason": "Matches classification \u2014 packaging bug in Views.Forms affecting framework compatibility",
            "confidence": 0.90,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/bug",
                "area/SkiaSharp.Views.Forms",
                "tenet/compatibility"
              ],
              "labelsToRemove": []
            }
          },
          {
            "id": "comment-1",
            "type": "add-comment",
            "risk": "high",
            "description": "Post close message explaining the issue is obsolete",
            "reason": "Inform reporter and watchers that the affected preview and TFM are both EOL",
            "confidence": 0.85,
            "dependsOn": "labels-1",
            "payload": {
              "commentType": "close-message",
              "draftBody": "Thanks for reporting this \u2014 the empty netcoreapp3.1 directory in the 2.88.0-preview.179 package was a real packaging gap and the thumbs-up reactions show others hit it too.\n\nSince then, the 2.88.0 stable series has shipped and .NET Core 3.1 itself reached end-of-life in December 2022. SkiaSharp 3.x is now the current major version targeting .NET 6\u002B.\n\nClosing this as the affected preview and target framework are both obsolete. If you\u0027re still using SkiaSharp, upgrading to 2.88.8\u002B or 3.x on .NET 6\u002B would be the recommended path forward.",
              "requiresHumanEdit": true,
              "finalBody": null,
              "dedupeToken": "triage-1898-comment-1"
            }
          },
          {
            "id": "close-1",
            "type": "close-issue",
            "risk": "medium",
            "description": "Close as completed \u2014 resolved by subsequent releases",
            "reason": "Preview version is obsolete and .NET Core 3.1 is EOL",
            "confidence": 0.85,
            "dependsOn": "comment-1",
            "payload": {
              "reason": "completed",
              "comment": null
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/1898"
    },
    {
      "meta": {
        "schemaVersion": "2.0",
        "number": 1773,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2025-07-22T12:00:00Z",
        "currentLabels": []
      },
      "summary": "Empty issue with no content \u2014 accidental creation, immediately closed by author",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.55
        },
        "area": null,
        "backends": null,
        "platforms": null,
        "tenets": null,
        "partner": null
      },
      "evidence": {
        "bugSignals": null,
        "reproEvidence": null,
        "versionAnalysis": null,
        "regression": null,
        "fixStatus": null
      },
      "analysis": {
        "summary": "Issue has no body, no comments, and a title of \u0027TO DELETE PLEASE\u0027. It was opened and closed within minutes on the same day. This is an accidental or test issue creation with zero actionable content.",
        "keySignals": [
          {
            "text": "TO DELETE PLEASE",
            "source": "title",
            "interpretation": "Author explicitly requests deletion \u2014 accidental issue creation"
          },
          {
            "text": "Empty body",
            "source": "body",
            "interpretation": "No description, no repro, no question \u2014 nothing to act on"
          },
          {
            "text": "Closed same day (2021-08-16)",
            "source": "body",
            "interpretation": "Author self-closed immediately, confirming this was unintentional"
          }
        ],
        "fieldRationales": [
          {
            "field": "type",
            "chosen": "type/question",
            "expandedReason": "No bug, feature, enhancement, or documentation request is described. The issue is empty. \u0027type/question\u0027 is the least-wrong classification for an issue with no actionable content. Low confidence reflects that none of the types truly fit.",
            "alternatives": [
              {
                "value": "type/bug",
                "whyRejected": "No broken behavior described \u2014 no body at all."
              },
              {
                "value": "type/feature-request",
                "whyRejected": "No feature requested."
              }
            ]
          },
          {
            "field": "actionability.suggestedAction",
            "chosen": "close-as-fixed",
            "expandedReason": "Issue is already closed with no content. No action is needed. \u0027close-as-fixed\u0027 reflects that the issue lifecycle is complete \u2014 there is nothing to investigate, answer, or fix."
          }
        ],
        "uncertainties": [
          "Whether the author intended to file a real issue and accidentally submitted early"
        ],
        "assumptions": [
          "Assumed accidental creation since the issue was self-closed within minutes with no follow-up"
        ],
        "resolution": null
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.95,
          "reason": "Issue is already closed with no content \u2014 no action needed"
        },
        "actions": [
          {
            "id": "labels-1",
            "type": "update-labels",
            "risk": "low",
            "description": "Apply question label to empty issue",
            "reason": "Matches classification \u2014 no better type fits an empty issue",
            "confidence": 0.55,
            "dependsOn": null,
            "payload": {
              "labelsToAdd": [
                "type/question"
              ],
              "labelsToRemove": []
            }
          }
        ]
      },
      "url": "https://github.com/mono/SkiaSharp/issues/1773"
    }
  ]
}