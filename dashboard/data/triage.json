{
  "generatedAt": "2026-02-12T15:33:48.1803664Z",
  "totalCount": 7,
  "summary": {
    "needsInvestigation": 4,
    "closeable": 1,
    "quickWins": 1,
    "regressions": 1
  },
  "byType": [
    {
      "label": "type/bug",
      "count": 5
    },
    {
      "label": "type/enhancement",
      "count": 1
    },
    {
      "label": "type/feature-request",
      "count": 1
    }
  ],
  "byArea": [
    {
      "label": "area/SkiaSharp.Views",
      "count": 3
    },
    {
      "label": "area/libSkiaSharp.native",
      "count": 1
    },
    {
      "label": "area/SkiaSharp.HarfBuzz",
      "count": 1
    },
    {
      "label": "area/SkiaSharp.Views.Forms",
      "count": 1
    },
    {
      "label": "area/SkiaSharp",
      "count": 1
    }
  ],
  "byAction": [
    {
      "label": "needs-investigation",
      "count": 4
    },
    {
      "label": "keep-open",
      "count": 2
    },
    {
      "label": "close-as-fixed",
      "count": 1
    }
  ],
  "bySeverity": [
    {
      "label": "medium",
      "count": 3
    },
    {
      "label": "low",
      "count": 2
    },
    {
      "label": "critical",
      "count": 1
    }
  ],
  "issues": [
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 533,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:25:36Z",
        "currentLabels": [
          "type/bug",
          "type/enhancement",
          "status/help-wanted",
          "os/Android",
          "area/SkiaSharp.Views",
          "backend/OpenGL"
        ]
      },
      "summary": "Android SKGLView renders at uncapped framerate (300\u002B FPS) after switch from GLSurfaceView to GLTextureView in v1.60.1. The custom GLTextureView does not call eglSwapInterval, so VSync is not enforced, causing excessive CPU/GPU/battery drain when HasRenderLoop is enabled.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.85
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Android"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an Android app with SKGLView (or SKGLTextureView)",
            "Set HasRenderLoop = true (or RenderMode = Rendermode.Continuously)",
            "Measure FPS using Stopwatch in PaintSurface handler",
            "Observe FPS of 300-1200\u002B instead of display-capped 60 FPS"
          ],
          "environmentDetails": "Originally reported on Samsung Galaxy S7 Edge, Android 7 API 24, SkiaSharp 1.60.1. Confirmed on emulators (1200 FPS) and Motorola Moto g6 (140 FPS), Galaxy Note 3 (230 FPS).",
          "relatedIssues": [
            729
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "performance",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net7.0-android",
            "net8.0-android"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.59.3",
            "1.60.1"
          ],
          "workedIn": "1.59.3",
          "brokeIn": "1.60.1",
          "currentRelevance": "likely",
          "relevanceReason": "The GLTextureView code is still in the current codebase and still does not call eglSwapInterval. The same Rendermode.Continuously loop runs without any frame pacing. SKGLTextureView is the default GL view for Android in both Xamarin.Forms and MAUI."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "GLSurfaceView (used in v1.59.3) internally calls eglSwapInterval(1) which enforces VSync. The replacement GLTextureView (v1.60.1\u002B) does not, so the render loop runs uncapped.",
          "workedInVersion": "1.59.3",
          "brokeInVersion": "1.60.1"
        }
      },
      "analysis": {
        "summary": "When SkiaSharp switched from Android\u0027s GLSurfaceView to a custom GLTextureView in v1.60.1, VSync-based frame pacing was lost. GLSurfaceView internally uses eglSwapInterval(1), capping rendering to the display\u0027s refresh rate. The custom GLTextureView never calls eglSwapInterval, so Rendermode.Continuously loops as fast as the GPU can render \u2014 300-1200\u002B FPS, wasting battery and CPU/GPU resources.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "finding": "EglHelper.Swap() calls egl.EglSwapBuffers but never calls eglSwapInterval. Without eglSwapInterval(1), EGL swap does not block on VSync, so the render loop runs uncapped.",
            "relevance": "direct",
            "lines": "634-641"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "finding": "IsReadyToDraw() returns true continuously when renderMode == Rendermode.Continuously, with no frame-pacing delay. The while loop in GuardedRun spins as fast as swap\u002Brender allows.",
            "relevance": "direct",
            "lines": "1081-1083"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLTextureView.cs",
            "finding": "SKGLTextureView.Initialize() does not set any frame pacing \u2014 just sets EGL version, config, and renderer. No Choreographer or eglSwapInterval setup.",
            "relevance": "direct",
            "lines": "36-43"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLSurfaceView.cs",
            "finding": "SKGLSurfaceView extends Android.Opengl.GLSurfaceView which internally manages eglSwapInterval. This was the previous implementation that DID have VSync.",
            "relevance": "related",
            "lines": "9"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.Android.cs",
            "finding": "MAUI handler maps HasRenderLoop to Rendermode.Continuously/WhenDirty on the same SKGLTextureView \u2014 confirming MAUI apps are also affected by the uncapped framerate.",
            "relevance": "related",
            "lines": "61-68"
          }
        ],
        "rationale": "Classified as enhancement rather than bug because the maintainer explicitly stated \u0027SkiaSharp will always render as fast as possible\u0027 and that frame-rate limiting was never an intentional feature. However, this is a regression in practical behavior (VSync was inherited from GLSurfaceView) and causes real resource waste. The area is SkiaSharp.Views (Android GL view layer), with performance tenet due to battery drain. Medium severity \u2014 not a crash but a significant resource problem for render-loop apps.",
        "keySignals": [
          {
            "text": "Application framerate went from a capped 60fps to a ~300fps",
            "source": "issue body",
            "interpretation": "Clear regression in frame pacing behavior after the GLSurfaceView to TextureView switch."
          },
          {
            "text": "I _see_ the change, and I think it has to do with the fact that we are no longer using the old GLSurfaceView but the new TextureView",
            "source": "comment #2 (mattleibow)",
            "interpretation": "Maintainer confirmed root cause is the view type change."
          },
          {
            "text": "Having uncapped is nice, but a heavy drain. Also, it is no point having the updates faster than the screen - that wastes resources.",
            "source": "comment #8 (mattleibow)",
            "interpretation": "Maintainer agrees this should be fixed \u2014 rendering faster than display refresh is wasteful."
          },
          {
            "text": "We might be able to look at Choreographer",
            "source": "comment #9 (mattleibow)",
            "interpretation": "Maintainer identified Android Choreographer as the proper fix approach for display-synced rendering."
          },
          {
            "text": "Noticing 1.2K FPS in some emulators",
            "source": "comment #6 (mattleibow)",
            "interpretation": "Problem persists and is extreme in some environments."
          }
        ],
        "workarounds": [
          "Use time-based animation (delta-time) instead of frame-based animation to decouple logic from frame rate",
          "Implement a manual frame limiter using Stopwatch to skip rendering when elapsed time is less than target interval (e.g., 1000/60 ms)",
          "Use RenderMode = Rendermode.WhenDirty and call RequestRender() from a timer at the desired interval"
        ],
        "nextQuestions": [
          "Would adding eglSwapInterval(1) to the EglHelper.CreateSurface path be sufficient, or would it break apps that want uncapped rendering?",
          "Should frame pacing be opt-in (new property like TargetFrameRate) or opt-out (VSync by default with an option to disable)?",
          "Is Android Choreographer the right approach, or is eglSwapInterval(1) simpler and sufficient for most use cases?"
        ],
        "resolution": {
          "hypothesis": "The GLTextureView never calls eglSwapInterval(1), so EGL swap buffers returns immediately instead of blocking until VSync. Adding eglSwapInterval or integrating Android Choreographer would cap rendering to the display refresh rate.",
          "proposals": [
            {
              "description": "Call eglSwapInterval(display, 1) in the EglHelper after creating the EGL surface. This is the simplest fix and mirrors what GLSurfaceView does internally. It caps rendering to the display\u0027s refresh rate via VSync.",
              "title": "Add eglSwapInterval(1) to EglHelper",
              "confidence": 0.75,
              "effort": "small"
            },
            {
              "description": "Use Android\u0027s Choreographer.postFrameCallback to schedule rendering at the display\u0027s refresh rate. This is the approach recommended by the maintainer and provides better frame pacing than eglSwapInterval alone. The Frame Pacing Library (games SDK) is an even more sophisticated option but harder to integrate.",
              "title": "Integrate Android Choreographer for frame pacing",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "As a workaround, set RenderMode to WhenDirty and use a timer to call RequestRender() at the desired frame rate. Note: System.Timers.Timer may not be ideal on Android \u2014 consider using Android.OS.Handler or View.PostDelayed() instead. Be sure to dispose the timer when the view is destroyed, and call OnPause/OnResume for proper lifecycle management.",
              "title": "Use WhenDirty mode with timer-based invalidation",
              "codeSnippet": "// Set the view to only render on demand\nskglView.RenderMode = Rendermode.WhenDirty;\n\n// Timer-based invalidation at ~60 FPS\n// Note: store timer as a field and dispose on cleanup\nvar timer = new System.Timers.Timer(16.67);\ntimer.Elapsed \u002B= (s, e) =\u003E skglView.RequestRender();\ntimer.Start();\n\n// In cleanup/Dispose:\n// timer.Stop();\n// timer.Dispose();",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Decouple animation from frame rate by using elapsed time between frames. This doesn\u0027t reduce GPU usage but makes animations correct regardless of FPS. Initialize lastFrame before first use to avoid a large delta on the first frame.",
              "title": "Use delta-time for animation logic",
              "codeSnippet": "Stopwatch sw = Stopwatch.StartNew();\nTimeSpan lastFrame = sw.Elapsed; // Initialize to avoid large first-frame delta\n\nvoid OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = sw.Elapsed;\n    var deltaTime = (now - lastFrame).TotalSeconds;\n    lastFrame = now;\n    \n    // Use deltaTime for all animation:\n    position \u002B= velocity * (float)deltaTime;\n}",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Use WhenDirty mode with timer-based invalidation",
          "recommendedReason": "Gives immediate relief with no engine changes needed. Users can control exact frame rate. The proper fix (eglSwapInterval or Choreographer) requires engine-level changes and design decisions about opt-in vs opt-out."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.8,
          "reason": "Root cause is well-understood (missing eglSwapInterval/Choreographer in GLTextureView), but the fix requires a design decision: should VSync be default, opt-in, or configurable? The maintainer has been tracking this since 2018 and identified Choreographer as the approach."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Normalize labels to single type (enhancement, not bug \u2014 maintainer confirmed uncapped was by design)",
            "risk": "low",
            "confidence": 0.85,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "os/Android",
              "backend/OpenGL",
              "tenet/performance"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround for frame pacing",
            "risk": "high",
            "confidence": 0.75,
            "comment": "This issue is still relevant in the current codebase. The root cause is confirmed: \u0060GLTextureView\u0060 (which replaced \u0060GLSurfaceView\u0060 in v1.60.1) does not call \u0060eglSwapInterval\u0060, so the render loop runs uncapped when using \u0060Rendermode.Continuously\u0060.\n\nHere\u0027s a workaround you can use: switch to \u0060Rendermode.WhenDirty\u0060 and drive rendering from a timer at your target frame rate:\n\n\u0060\u0060\u0060csharp\n// Set the view to only render on demand\nskglView.RenderMode = Rendermode.WhenDirty;\n\n// Timer-based invalidation at ~60 FPS\n// Store timer as a field and dispose on cleanup\nvar timer = new System.Timers.Timer(16.67);\ntimer.Elapsed \u002B= (s, e) =\u003E skglView.RequestRender();\ntimer.Start();\n\n// In cleanup/Dispose:\n// timer.Stop();\n// timer.Dispose();\n\u0060\u0060\u0060\n\n**Note:** On Android, \u0060Android.OS.Handler\u0060 or \u0060View.PostDelayed()\u0060 may be more reliable than \u0060System.Timers.Timer\u0060 for frame timing. Be sure to call \u0060OnPause()\u0060/\u0060OnResume()\u0060 for proper lifecycle management.\n\nFor animation correctness regardless of frame rate, use delta-time (initialize \u0060lastFrame\u0060 to avoid a large first-frame delta):\n\n\u0060\u0060\u0060csharp\nvar sw = Stopwatch.StartNew();\nvar lastFrame = sw.Elapsed;\n\nvoid OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = sw.Elapsed;\n    var deltaTime = (now - lastFrame).TotalSeconds;\n    lastFrame = now;\n    position \u002B= velocity * (float)deltaTime;\n}\n\u0060\u0060\u0060\n\nA proper engine-level fix would involve either adding \u0060eglSwapInterval(1)\u0060 to the EGL setup, or integrating Android\u0027s Choreographer API for display-synced rendering. Both approaches have tradeoffs around whether VSync should be default or opt-in."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 528,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:18:16Z",
        "currentLabels": [
          "status/help-wanted",
          "os/Android"
        ]
      },
      "summary": "SKShaper.Shape() returns all-zero Codepoints on Android when the typeface is loaded via SKTypeface.FromStream(). The issue is Android-specific \u2014 WPF and iOS work correctly with the same code. The reporter discovered that switching to SKTypeface.FromData(SKData.Create(stream)) resolves the problem, suggesting a bug in how stream-based typefaces interact with HarfBuzz\u0027s font table reading on Android.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.92
        },
        "platforms": [
          "os/Android"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Load a custom font via SKTypeface.FromStream(stream) on Android",
            "Create an SKShaper with that typeface",
            "Call shaper.Shape(text, x, y, paint)",
            "Observe that result.Codepoints are all 0 (works on WPF and iOS)"
          ],
          "codeSnippets": [
            "var shaper = new SKShaper(paint.Typeface);\nvar result = shaper.Shape(\u0022Hello world!\u0022, 10, 300, paint); // result.Codepoints are all 0"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/2035982/HarfBuzzDemo.zip",
              "filename": "HarfBuzzDemo.zip",
              "description": "Complete repro project demonstrating the issue"
            }
          ],
          "environmentDetails": "Android emulator (x86) and LG G4 (ARMv8), tested with arial/Roboto/SF-UI-Display fonts in otf and ttf"
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "wrong-output",
          "errorMessage": "SKShaper.Result.Codepoints are all 0 on Android",
          "reproQuality": "complete",
          "targetFrameworks": [
            "monoandroid"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.60.x"
          ],
          "currentRelevance": "unknown",
          "relevanceReason": "Issue is from 2018 (SkiaSharp 1.x era). HarfBuzz has been updated significantly since then, but the core code path (SKShaper constructor calling Typeface.OpenStream().ToHarfBuzzBlob()) hasn\u0027t fundamentally changed. Needs verification with SkiaSharp 3.x."
        }
      },
      "analysis": {
        "summary": "The SKShaper constructor calls Typeface.OpenStream() to get font data, then converts it to a HarfBuzz blob via ToHarfBuzzBlob(). When a typeface is created via FromStream() on Android, the subsequent OpenStream() call may return invalid or empty data, causing HarfBuzz\u0027s hb_shape() to fail silently \u2014 it produces zero codepoints because it can\u0027t read the font tables. FromData() avoids this by keeping the font data fully in memory as an SKData object, which OpenStream() can reliably return.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "Constructor calls Typeface.OpenStream(out index).ToHarfBuzzBlob() to create the HarfBuzz font. If OpenStream returns invalid data on Android for stream-created typefaces, HarfBuzz gets an empty/bad blob.",
            "relevance": "direct",
            "lines": "19-30"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob() first checks GetMemoryBase() \u2014 if non-null, wraps that pointer directly. Otherwise allocates and reads. If the stream asset from OpenStream is empty/invalid, this produces a zero-length or garbage blob.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "FromStream converts SKManagedStream to memory stream, calls sk_typeface_create_from_stream which takes ownership of the stream. The native Skia code may not preserve the stream data for later OpenStream calls on some platforms.",
            "relevance": "direct",
            "lines": "100-113"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "FromData calls sk_typeface_create_from_data which keeps the data in memory via native reference counting. OpenStream on this typeface reliably returns the font data because it\u0027s backed by an SKData (in-memory buffer), not a consumed stream.",
            "relevance": "related",
            "lines": "115-121"
          }
        ],
        "rationale": "This is clearly a bug: the same code produces correct output on WPF/iOS but all-zero codepoints on Android. The area is SkiaSharp.HarfBuzz because the problem manifests in SKShaper.Shape() and traces back to the SKShaper constructor\u0027s interaction with typeface streams. The root cause is in the FromStream/OpenStream code path on Android, not in HarfBuzz itself. Severity is medium because there\u0027s a reliable workaround (FromData) and it\u0027s not a crash.",
        "keySignals": [
          {
            "text": "result.Codepoints are all 0 on Android",
            "source": "issue body",
            "interpretation": "HarfBuzz shaping silently fails \u2014 returns placeholder zeros instead of glyph IDs, indicating it can\u0027t read the font tables."
          },
          {
            "text": "When testing on WPF or iOS, everything seems ok",
            "source": "issue body",
            "interpretation": "Android-specific. The typeface data is valid (works elsewhere), so the problem is in how Android handles the stream-based typeface."
          },
          {
            "text": "hb_shape(Handle, buffer.Handle, IntPtr.Zero, 0) set all buffer.GlipInfo.CodePoints from utf8 to 0",
            "source": "comment #2",
            "interpretation": "Confirms the HarfBuzz C\u002B\u002B hb_shape call itself is the point of failure. The HB font blob must be empty or invalid."
          },
          {
            "text": "Using SKData.Create(stream) then SKTypeface.FromData(data) works",
            "source": "comment #10",
            "interpretation": "Confirms the stream data is valid. The bug is specifically in FromStream\u0027s interaction with OpenStream on Android."
          },
          {
            "text": "SKTypeface.FromFamilyName(\u0027Times New Roman\u0027) works",
            "source": "comment #5 (mattleibow)",
            "interpretation": "System-installed fonts work \u2014 the issue is limited to fonts loaded from streams/files."
          }
        ],
        "errorFingerprint": "HarfBuzz-Shape-ZeroCodes-Android-FromStream",
        "workarounds": [
          "Use SKTypeface.FromData(SKData.Create(stream)) instead of SKTypeface.FromStream(stream)"
        ],
        "nextQuestions": [
          "Is this still reproducible with SkiaSharp 3.x and the updated HarfBuzz?",
          "Does OpenStream() on a FromStream-created typeface actually return different data on Android vs other platforms?",
          "Was this partially addressed by HarfBuzz updates (issue #904)?"
        ],
        "resolution": {
          "hypothesis": "SKTypeface.FromStream() on Android creates a typeface where the native stream data is consumed/released after typeface construction. When SKShaper later calls OpenStream() to extract font data for HarfBuzz, the returned stream is empty or invalid on Android. FromData() avoids this because SKData keeps the font bytes in memory indefinitely via reference counting.",
          "proposals": [
            {
              "description": "Replace SKTypeface.FromStream(stream) with SKTypeface.FromData(SKData.Create(stream)) to ensure font data persists for HarfBuzz. Validated: reporter and another user confirmed this works.",
              "title": "Use FromData workaround",
              "codeSnippet": "using var data = SKData.Create(stream);\nvar typeface = SKTypeface.FromData(data);\nif (typeface == null)\n    throw new InvalidOperationException(\u0022Failed to load typeface\u0022);\nusing var shaper = new SKShaper(typeface);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Modify SKTypeface.FromStream to internally convert to SKData before creating the typeface, ensuring OpenStream always has valid data. This would make FromStream behave identically to FromData on all platforms.",
              "title": "Fix FromStream to preserve data for OpenStream",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "Test whether the issue persists in SkiaSharp 3.x, which includes significant HarfBuzz updates and internal changes to stream handling.",
              "title": "Verify with SkiaSharp 3.x",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Use FromData workaround",
          "recommendedReason": "Confirmed working by the reporter and another user. Trivial code change with no side effects."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The workaround is well-established, but the underlying bug in FromStream\u002BOpenStream on Android has never been root-caused or fixed. The issue is also very old (2018) and needs verification with SkiaSharp 3.x before deciding whether to fix or close."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and HarfBuzz area labels, keep Android platform label",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz",
              "os/Android"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the long-standing bug, confirm the workaround, and ask whether it still reproduces on SkiaSharp 3.x",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the thorough investigation on this, and apologies it\u0027s been open so long.\n\nThe workaround @michaldobrodenka found is the right approach \u2014 use \u0060SKTypeface.FromData\u0060 instead of \u0060SKTypeface.FromStream\u0060:\n\n\u0060\u0060\u0060csharp\nusing var data = SKData.Create(stream);\nvar typeface = SKTypeface.FromData(data);\nif (typeface == null)\n    throw new InvalidOperationException(\u0022Failed to load typeface\u0022);\nusing var shaper = new SKShaper(typeface);\n\u0060\u0060\u0060\n\nThe underlying cause appears to be that \u0060SKTypeface.FromStream()\u0060 on Android doesn\u0027t reliably preserve the font data for later \u0060OpenStream()\u0060 calls \u2014 which \u0060SKShaper\u0060 depends on to extract font tables for HarfBuzz. \u0060FromData()\u0060 keeps the bytes in memory via reference counting, so \u0060OpenStream()\u0060 always returns valid data.\n\nA lot has changed since 2018 \u2014 both SkiaSharp and HarfBuzz have had major updates. Would anyone be able to confirm whether this still reproduces with SkiaSharp 3.x? If the issue persists, we should look at having \u0060FromStream\u0060 internally use \u0060FromData\u0060 to avoid this class of bug."
          },
          {
            "type": "link-related",
            "description": "Link to RTL text support issue which motivated the original report",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 272
          }
        ],
        "missingInfo": [
          "Whether this issue still reproduces with SkiaSharp 3.x on modern Android"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 425,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:09:01Z",
        "currentLabels": [
          "type/bug",
          "status/skia-update-required"
        ]
      },
      "summary": "SKCodecOrigin (now SKEncodedOrigin) returns TopLeft for DNG and CR2 RAW files instead of their actual EXIF orientation",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.9
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Open a DNG or CR2 file with SKCodec.Create()",
            "Read codec.EncodedOrigin (formerly codec.Origin)",
            "Observe it returns TopLeft regardless of actual EXIF orientation",
            "Compare with Chrome browser which correctly auto-orients these files"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616452/APC_0316.zip",
              "filename": "APC_0316.zip",
              "description": "DNG sample with incorrect orientation"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616453/APC_0193.zip",
              "filename": "APC_0193.zip",
              "description": "DNG sample with incorrect orientation"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1645431/IMG_1361.zip",
              "filename": "IMG_1361.zip",
              "description": "CR2 sample reported as TopLeft but should be LeftBottom"
            }
          ],
          "environmentDetails": "Cross-platform, all SkiaSharp versions",
          "relatedIssues": [
            836
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "wrong-output",
          "errorMessage": "SKCodecOrigin reports TopLeft for DNG/CR2 files that have non-TopLeft EXIF orientation",
          "reproQuality": "complete",
          "targetFrameworks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "likely",
          "relevanceReason": "The SkRawCodec constructor still does not pass EXIF orientation to the base SkCodec class. The default kTopLeft_SkEncodedOrigin is hardcoded in the SkCodec base constructor signature."
        }
      },
      "analysis": {
        "summary": "Skia\u0027s SkRawCodec constructor does not extract or pass EXIF orientation data from DNG/CR2 files. The base SkCodec constructor defaults the origin parameter to kTopLeft_SkEncodedOrigin when not provided. Only JPEG and WebP codecs parse and pass EXIF orientation.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.EncodedOrigin directly wraps sk_codec_get_origin(). The C# binding is correct \u2014 it faithfully returns whatever Skia reports.",
            "relevance": "context",
            "lines": "36-37"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "SkRawCodec constructor calls INHERITED(SkEncodedInfo::Make(...), skcms_PixelFormat_RGBA_8888, nullptr) \u2014 only 3 args. The 4th param (SkEncodedOrigin) defaults to kTopLeft_SkEncodedOrigin. This is the root cause.",
            "relevance": "direct",
            "lines": "826-831"
          },
          {
            "file": "externals/skia/include/codec/SkCodec.h",
            "finding": "SkCodec constructor has default parameter SkEncodedOrigin = kTopLeft_SkEncodedOrigin, confirming RAW codec never provides orientation.",
            "relevance": "direct",
            "lines": "765-768"
          },
          {
            "file": "externals/skia/src/codec/SkJpegCodec.cpp",
            "finding": "SkJpegCodec correctly parses EXIF orientation via SkParseEncodedOrigin and passes it to the base SkCodec constructor. This is the model for how RAW should work.",
            "relevance": "related",
            "lines": "245-250"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "SkDngImage class has access to dng_negative (fNegative) which contains EXIF metadata after SynchronizeMetadata(). The orientation could potentially be extracted from fNegative but is not implemented.",
            "relevance": "direct",
            "lines": "456-642"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "MakeFromStream has a PIEX fast path that returns SkJpegCodec for JPEG-compressed previews (which WOULD have correct orientation). The bug only manifests when the full DNG decode path is used (line 714).",
            "relevance": "related",
            "lines": "649-715"
          }
        ],
        "rationale": "This is confirmed as a bug by the maintainer. The reporter provides sample DNG and CR2 files and demonstrates that SKCodecOrigin always returns TopLeft. The root cause is in upstream Skia\u0027s SkRawCodec, not in SkiaSharp\u0027s C# bindings \u2014 the C# wrapper correctly exposes whatever value Skia returns. The existing label status/skia-update-required is accurate. Severity is low because RAW file orientation is a niche use case and workarounds exist (read EXIF manually).",
        "keySignals": [
          {
            "text": "The following sample code results in SKCodecOrigin.TopLeft, which is incorrect",
            "source": "issue body",
            "interpretation": "Reporter confirms the origin value is wrong for DNG files."
          },
          {
            "text": "not limited to just dng. Here\u0027s a sample cr2 that is also affected. It is reported as TopLeft but it should be LeftBottom",
            "source": "comment 1 by OP",
            "interpretation": "Bug affects multiple RAW formats, not just DNG. Confirms expected value (LeftBottom vs TopLeft)."
          },
          {
            "text": "the DNG codec ignores this. The only ones that appear to respect this are jpeg and webp",
            "source": "comment 2 by mattleibow",
            "interpretation": "Maintainer confirms this is an upstream Skia limitation in the RAW codec."
          }
        ],
        "workarounds": [
          "Use a separate EXIF library (e.g., MetadataExtractor for .NET) to read orientation from DNG/CR2 files, then apply the rotation transform manually using SKCanvas",
          "For DNG files with embedded JPEG previews, extract the preview JPEG and decode that instead \u2014 it will report correct orientation via the JPEG codec path"
        ],
        "nextQuestions": [
          "Does the DNG SDK expose orientation metadata via dng_negative that could be passed to the SkCodec base constructor?",
          "Would an upstream Skia patch be accepted to extract orientation in SkRawCodec?",
          "Does the PIEX fast path (returning SkJpegCodec) correctly handle orientation for the reporter\u0027s specific files?"
        ],
        "resolution": {
          "hypothesis": "SkRawCodec in Skia does not extract EXIF orientation from DNG/CR2 metadata and does not pass it to the base SkCodec constructor, causing it to default to TopLeft for all RAW files.",
          "proposals": [
            {
              "description": "Install the MetadataExtractor NuGet package to read EXIF orientation from RAW files independently, then use the orientation value to transform the decoded image.",
              "title": "Use MetadataExtractor to read EXIF orientation",
              "codeSnippet": "// NuGet: MetadataExtractor\nusing MetadataExtractor;\nusing MetadataExtractor.Formats.Exif;\n\nvar directories = ImageMetadataReader.ReadMetadata(path);\nvar ifd0 = directories.OfType\u003CExifIfd0Directory\u003E().FirstOrDefault();\nif (ifd0 != null \u0026\u0026 ifd0.TryGetUInt16(ExifDirectoryBase.TagOrientation, out var orientation))\n{\n    var origin = (SKEncodedOrigin)orientation;\n    // Use origin to apply the correct rotation transform\n}",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Modify SkRawCodec to extract EXIF orientation from the DNG SDK\u0027s dng_negative metadata after SynchronizeMetadata(), then pass it to the SkCodec base constructor. This matches the pattern used by SkJpegCodec.",
              "title": "Upstream Skia fix to SkRawCodec",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Use MetadataExtractor to read EXIF orientation",
          "recommendedReason": "This workaround is independent of the upstream Skia fix and gives the reporter a solution today. The upstream fix requires changes to Skia\u0027s SkRawCodec which is outside SkiaSharp\u0027s direct control."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Confirmed bug in Skia\u0027s SkRawCodec \u2014 the orientation is never extracted from DNG/CR2 EXIF metadata. Requires changes in upstream Skia code. The existing status/skia-update-required label is already correct."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add area/libSkiaSharp.native to existing labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "status/skia-update-required"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround using MetadataExtractor for EXIF orientation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the detailed report and sample files.\n\nThis is a limitation in Skia\u0027s RAW codec (\u0060SkRawCodec\u0060). The codec does not extract EXIF orientation from DNG or CR2 metadata \u2014 it always defaults to \u0060TopLeft\u0060. By contrast, the JPEG and WebP codecs do parse EXIF orientation correctly.\n\nAs a workaround, you can use a .NET EXIF library like [MetadataExtractor](https://www.nuget.org/packages/MetadataExtractor) to read the orientation independently:\n\n\u0060\u0060\u0060csharp\nusing MetadataExtractor;\nusing MetadataExtractor.Formats.Exif;\n\nvar directories = ImageMetadataReader.ReadMetadata(path);\nvar ifd0 = directories.OfType\u003CExifIfd0Directory\u003E().FirstOrDefault();\nif (ifd0 != null \u0026\u0026 ifd0.TryGetUInt16(ExifDirectoryBase.TagOrientation, out var orientation))\n{\n    var origin = (SKEncodedOrigin)orientation;\n    // Use origin to apply the correct rotation transform\n}\n\u0060\u0060\u0060\n\nA proper fix would require changes to Skia\u0027s \u0060SkRawCodec\u0060 to extract orientation from the DNG SDK metadata and pass it to the base codec constructor."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #836 (Image auto orientation method) \u2014 related feature request for auto-orient",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 836
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 315,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:03:53Z",
        "currentLabels": []
      },
      "summary": "Pinch and pan gestures conflict with SkiaSharp touch events on Android in Xamarin.Forms",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.7
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.9
        },
        "platforms": [
          "os/Android"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Xamarin.Forms app with SKCanvasView and touch events enabled",
            "Add PinchGestureRecognizer and PanGestureRecognizer to the containing view",
            "Attempt to draw (finger paint) on Android while using pinch/pan gestures",
            "Observe that touch events do not work correctly on Android (works on iOS)"
          ],
          "environmentDetails": "Xamarin.Forms, Android, SkiaSharp circa 2017 (pre-1.x era)",
          "relatedIssues": [
            309,
            909,
            1048
          ],
          "repoLinks": [
            {
              "url": "https://github.com/JavedAppdevelopment/DrawTrackingForms",
              "description": "Reporter\u0027s Xamarin.Forms finger-paint sample with pinch/pan"
            }
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "incorrect-behavior",
          "reproQuality": "partial",
          "targetFrameworks": [
            "xamarinandroid"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "Xamarin.Forms is end-of-life. SkiaSharp.Views.Forms has been removed from the codebase, replaced by SkiaSharp.Views.Maui. The Android touch handler has been rewritten for MAUI with a different architecture. The underlying gesture conflict between native touch handling and framework gesture recognizers is an inherent platform integration challenge that may still exist in MAUI, but the specific code paths are entirely different."
        }
      },
      "analysis": {
        "summary": "Reporter describes Xamarin.Forms pinch/pan gesture recognizers interfering with SkiaSharp touch events on Android. Drawing with touch works on iOS but not Android when combined with gesture recognizers. Issue #909 describes the identical problem from the iOS perspective. This is a known limitation of mixing native touch handling with framework-level gesture recognizers \u2014 Android\u0027s View.Touch event and Xamarin.Forms gesture recognizers compete for touch ownership via the Handled flag.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "finding": "Current MAUI Android SKTouchHandler hooks into View.Touch and sets e.Handled = args.Handled. When Handled is true, the parent gesture recognizers (pan/pinch) are starved of touch events. When false, SkiaSharp doesn\u0027t track the touch. This mutual exclusion is the root of the gesture conflict \u2014 it exists in both the old Forms and new MAUI implementations.",
            "relevance": "direct",
            "lines": "41-109"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "finding": "iOS SKTouchHandler extends UIGestureRecognizer directly, which participates in iOS gesture recognition system and can coexist with other recognizers. This architectural difference explains why iOS handles the combination better than Android.",
            "relevance": "related",
            "lines": "10-111"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKCanvasView.cs",
            "finding": "Legacy Android SKCanvasView (non-Forms) extends android.view.View directly. No touch handling built in \u2014 the Xamarin.Forms renderer layer would have added touch support. SkiaSharp.Views.Forms source has been fully removed from the codebase.",
            "relevance": "context",
            "lines": "1-156"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes behavior that works on iOS but not Android \u2014 a platform-specific defect in gesture handling, not a usage question. Area is SkiaSharp.Views.Forms since the issue is specifically about the Xamarin.Forms SKCanvasView and gesture recognizer interaction. Severity is low because (1) SkiaSharp.Views.Forms has been removed from the codebase in favor of MAUI, (2) the issue is from 2017 with only one follow-up comment from 2019, and (3) Xamarin.Forms itself is end-of-life.",
        "keySignals": [
          {
            "text": "Pinch and Pan with Touch works in iOS version but not work in Android version",
            "source": "issue body",
            "interpretation": "Platform-specific behavior difference in how Android dispatches touch events when gesture recognizers are attached. On Android, View.Touch handler and gesture recognizers compete for touch ownership."
          },
          {
            "text": "#309 introduces TouchEvents but somehow they interfere with Xamarin.Forms GestureRecognizers on Android",
            "source": "comment #1 (nor0x)",
            "interpretation": "Confirms this is a known interaction issue between SkiaSharp\u0027s touch event system (added in #309) and Xamarin.Forms gesture recognizers."
          },
          {
            "text": "Issue filed 2017-06-16, last community comment 2019-03-26, no maintainer response",
            "source": "issue metadata",
            "interpretation": "Nearly 9 years old with no maintainer engagement. The underlying platform (Xamarin.Forms) is now end-of-life."
          }
        ],
        "nextQuestions": [
          "Does the same gesture conflict still exist in MAUI with the new SKTouchHandler?",
          "Could Android\u0027s requestDisallowInterceptTouchEvent() help coordinate touch ownership?"
        ],
        "resolution": {
          "hypothesis": "On Android, SkiaSharp\u0027s touch handler and Xamarin.Forms gesture recognizers (Pan/Pinch) compete for touch event ownership. Setting e.Handled=true in the touch handler prevents gestures from receiving events; setting it false prevents SkiaSharp from tracking touches. iOS doesn\u0027t have this problem because its SKTouchHandler is a UIGestureRecognizer that participates in the native gesture recognition system.",
          "proposals": [
            {
              "description": "Xamarin.Forms is end-of-life. Migrate to .NET MAUI with SkiaSharp.Views.Maui, which has a rewritten touch handler. This is the recommended path forward.",
              "title": "Migrate to .NET MAUI",
              "confidence": 0.7,
              "effort": "large"
            },
            {
              "description": "Instead of mixing Xamarin.Forms gesture recognizers with SkiaSharp touch events, implement pinch and pan detection entirely within the SKTouchAction handler. Track multiple touch points manually: compute distance between points for pinch, track centroid movement for pan.",
              "title": "Use only SkiaSharp touch events for all gestures",
              "confidence": 0.8,
              "effort": "medium"
            },
            {
              "description": "The Xamarin.Forms platform is end-of-life and SkiaSharp.Views.Forms has been removed from the codebase. This issue cannot be fixed in the current codebase. Close with guidance to migrate to MAUI.",
              "title": "Close as stale \u2014 Xamarin.Forms EOL",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Close as stale \u2014 Xamarin.Forms EOL",
          "recommendedReason": "Xamarin.Forms is end-of-life and SkiaSharp.Views.Forms has been entirely removed from the codebase. There is no code to fix. The reporter should migrate to MAUI."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.85,
          "reason": "Xamarin.Forms is end-of-life, SkiaSharp.Views.Forms has been removed from the codebase, and the touch handler has been rewritten for MAUI. The specific code paths causing this issue no longer exist."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views.forms, and android labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Forms",
              "os/Android"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post closure guidance with migration recommendation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for reporting this. The underlying issue was a conflict between Android\u0027s touch event dispatch and Xamarin.Forms gesture recognizers \u2014 SkiaSharp\u0027s touch handler and Pan/Pinch gesture recognizers compete for touch ownership on Android (unlike iOS, where the touch handler participates in the native gesture recognition system).\n\nXamarin.Forms has reached end-of-life and SkiaSharp.Views.Forms has been removed from the codebase, so this can\u0027t be addressed in current versions. If you\u0027re still working with SkiaSharp, we recommend migrating to .NET MAUI with \u0060SkiaSharp.Views.Maui\u0060, which has a rewritten touch handler.\n\nIf the gesture conflict persists in MAUI, please open a new issue with a MAUI reproduction project.\n\nClosing as the affected platform is no longer supported."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #909 (same gesture conflict on iOS/Forms)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 909
          },
          {
            "type": "close-issue",
            "description": "Close \u2014 Xamarin.Forms is end-of-life and code has been removed",
            "risk": "medium",
            "confidence": 0.85
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 310,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:00:19Z",
        "currentLabels": [
          "type/enhancement",
          "status/low-priority",
          "os/Windows-Classic",
          "area/SkiaSharp.Views"
        ]
      },
      "summary": "Re-entrant OnPaint in WinForms SKControl causes ExternalException in Bitmap.UnlockBits. When the user resizes the SKControl from within the PaintSurface event handler, a parent container (DevExpress XtraScrollableControl) can trigger a nested OnPaint call. The re-entrant call disposes and recreates the GDI\u002B bitmap via CreateBitmap(), so when the outer OnPaint tries to call UnlockBits on the now-disposed bitmap, GDI\u002B throws. The code still has no re-entrancy guard.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Place an SKControl inside a scrollable container (e.g., DevExpress XtraScrollableControl)",
            "Resize the SKControl.Height from within the PaintSurface event handler",
            "Scroll the container so the SKControl is partially or fully offscreen",
            "Trigger a content change that causes the height resize during paint"
          ],
          "environmentDetails": "Windows, WinForms, .NET Framework (2017-era report)"
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "ExternalException",
          "errorMessage": "A generic error occurred in GDI\u002B.",
          "stackTrace": "System.Runtime.InteropServices.ExternalException (0x80004005): A generic error occurred in GDI\u002B.\n   at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata)\n   at SkiaSharp.Views.Desktop.SKControl.OnPaint(PaintEventArgs e)\n   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer)\n   at System.Windows.Forms.Control.WmPaint(Message\u0026 m)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The SKControl.OnPaint code path has not changed since the issue was filed. No re-entrancy guard has been added. The bitmap LockBits/UnlockBits pattern is still identical."
        }
      },
      "analysis": {
        "summary": "The WinForms SKControl.OnPaint locks a GDI\u002B bitmap, fires the user\u0027s PaintSurface event, then unlocks the bitmap. If the user\u0027s PaintSurface handler triggers a re-entrant OnPaint (e.g. by resizing the control, causing a parent container to synchronously repaint), the re-entrant call disposes and recreates the bitmap, and the outer call crashes on UnlockBits. The reporter investigated this thoroughly and confirmed the re-entrancy as the root cause. A simple boolean re-entrancy guard would prevent the crash.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "OnPaint calls LockBits (line 43), then OnPaintSurface (line 49), then UnlockBits (line 55). No re-entrancy guard exists. If OnPaintSurface triggers a nested OnPaint, CreateBitmap() (line 38) disposes the locked bitmap and creates a new one, causing UnlockBits to fail on the disposed bitmap.",
            "relevance": "direct",
            "lines": "30-57"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "CreateBitmap() calls FreeBitmap() which disposes the existing bitmap when size changes. During re-entrant OnPaint after a resize, this disposes the bitmap that is still locked by the outer OnPaint call.",
            "relevance": "direct",
            "lines": "72-85"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "finding": "WPF SKElement uses the same Lock/OnPaintSurface/Unlock pattern with WriteableBitmap. Could be similarly vulnerable to re-entrancy, though WPF\u0027s rendering pipeline makes synchronous re-entrant OnRender less likely.",
            "relevance": "related",
            "lines": "45-88"
          }
        ],
        "rationale": "Classified as type/bug (not enhancement) because the control crashes due to lack of defensive coding \u2014 re-entrant OnPaint should be handled gracefully, not crash. The current type/enhancement label is incorrect. The area is clearly SkiaSharp.Views (WinForms SKControl). Severity is medium: it\u0027s a crash, but only triggered by modifying the control during paint, which is an unusual (though not invalid) pattern. The WPF SKElement has the same Lock/Unlock pattern and could be similarly vulnerable.",
        "keySignals": [
          {
            "text": "OnPaint event is being called from within the OnPaint event (due to my height resize code)",
            "source": "comment #2",
            "interpretation": "Re-entrant OnPaint is the root cause. The bitmap is locked in the outer call and disposed/recreated in the inner call."
          },
          {
            "text": "I am changing the SKControl.Height value from within the PaintSurface event, which is inside the bitmap lock/unlock",
            "source": "comment #1",
            "interpretation": "The user is resizing during paint, which causes the parent container to trigger a synchronous repaint."
          },
          {
            "text": "It would be easy enough to handle this situation in the SKControl itself so it doesn\u0027t crash",
            "source": "comment #2",
            "interpretation": "Reporter suggests a defensive fix in SKControl. A re-entrancy guard is straightforward."
          },
          {
            "text": "This issue serves to act as a note for further investigation",
            "source": "comment #5 (mattleibow)",
            "interpretation": "Maintainer acknowledged the issue and kept it open for investigation. No fix has been applied since."
          }
        ],
        "errorFingerprint": "ExternalException-GDI-UnlockBits-SKControl-OnPaint-reentrant",
        "workarounds": [
          "Do not resize the SKControl from within the PaintSurface event handler. Calculate layout dimensions separately and apply the resize outside of the paint event.",
          "Reset the parent scrollable container\u0027s scroll position before resizing the SKControl to avoid the parent triggering a synchronous repaint."
        ],
        "nextQuestions": [
          "Should a re-entrancy guard be added to SKControl.OnPaint (e.g. a bool _painting field that causes early return on re-entry)?",
          "Is the WPF SKElement vulnerable to the same re-entrancy issue?",
          "Should the bitmap be captured in a local variable before LockBits so UnlockBits always uses the same reference?"
        ],
        "resolution": {
          "hypothesis": "Re-entrant OnPaint disposes the locked bitmap. The outer OnPaint then calls UnlockBits on a disposed bitmap, causing the GDI\u002B ExternalException.",
          "proposals": [
            {
              "description": "Add a boolean field (_painting) that is set to true at the start of OnPaint and cleared at the end. If OnPaint is called while _painting is true, return immediately. This prevents the nested call from disposing the bitmap.",
              "title": "Add re-entrancy guard",
              "codeSnippet": "private bool _painting;\n\nprotected override void OnPaint(PaintEventArgs e)\n{\n    if (designMode || _painting)\n        return;\n    _painting = true;\n    try\n    {\n        // existing OnPaint body\n    }\n    finally\n    {\n        _painting = false;\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Store the bitmap reference in a local variable after LockBits. Use the local variable for UnlockBits and DrawImage so that even if CreateBitmap disposes the field, the locked reference remains valid for the outer call to unlock.",
              "title": "Capture bitmap reference locally",
              "confidence": 0.65,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Add re-entrancy guard",
          "recommendedReason": "Simplest and most defensive fix. Prevents all re-entrancy issues, not just the bitmap disposal race. Trivial to implement and low risk."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.82,
          "reason": "The root cause is well-understood and the fix is straightforward, but the code hasn\u0027t changed since 2017. Needs a developer to add the re-entrancy guard and verify the WPF SKElement isn\u0027t similarly affected."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Correct type from enhancement to bug and add reliability tenet",
            "risk": "low",
            "confidence": 0.88,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug is still present and describe the proposed fix",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the thorough investigation back in 2017, @Craig-TSS \u2014 your diagnosis was spot-on.\n\nThe \u0060SKControl.OnPaint\u0060 code path still has no re-entrancy guard. The \u0060LockBits\u0060 \u2192 \u0060OnPaintSurface\u0060 \u2192 \u0060UnlockBits\u0060 sequence is vulnerable whenever a nested \u0060OnPaint\u0060 is triggered during the paint event (e.g., by resizing the control from within \u0060PaintSurface\u0060).\n\nHere\u0027s a workaround you can use: avoid resizing the control from within the \u0060PaintSurface\u0060 handler. Calculate layout dimensions separately and apply resizes outside the paint event.\n\nThe fix on the SkiaSharp side would be a simple re-entrancy guard \u2014 a \u0060bool _painting\u0060 field that causes \u0060OnPaint\u0060 to return immediately if it\u0027s already executing. We\u0027ll also check whether the WPF \u0060SKElement\u0060 has the same vulnerability."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 243,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T14:56:44Z",
        "currentLabels": [
          "os/Windows-Classic",
          "area/Build",
          "type/feature-request"
        ]
      },
      "summary": "Feature request to bundle ANGLE (OpenGL ES over DirectX) with SkiaSharp for Windows desktop runtimes (WPF/WinForms). Originally filed for Win7 with DX9 support, the discussion evolved into how SkiaSharp could ship GPU-accelerated views for classic Windows desktop by packaging ANGLE as a separate NuGet dependency. SkiaSharp already has ANGLE interop code (GRGlInterface.CreateAngle, AngleSwapChainPanel for WinUI) and a Direct3D backend (GRContext.CreateDirect3D), but no GPU-accelerated views ship for WPF/WinForms.",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.8
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/OpenGL",
          "backend/Direct3D"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://i.imgur.com/DZWkJdg.png",
              "description": "ANGLE DX9 rendering support diagram"
            }
          ],
          "relatedIssues": [
            2817,
            2996,
            2104,
            2968
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "SkiaSharp still has no GPU-accelerated views for WPF/WinForms. The ANGLE interop exists in WinUI views only. While Win7 is EOL, the broader need for GPU rendering on classic Windows desktop remains. The D3D backend exists but isn\u0027t surfaced in views."
        }
      },
      "analysis": {
        "summary": "This is a long-standing feature request to ship ANGLE with SkiaSharp for Windows desktop. SkiaSharp already has significant ANGLE infrastructure (GRGlInterface.CreateAngle, AngleSwapChainPanel, GlesContext/Egl interop) but only for WinUI/UWP. WPF/WinForms views use raster-only rendering. Since filing, Skia gained a native Direct3D backend (GRContext.CreateDirect3D), which could be an alternative to ANGLE for GPU-accelerated desktop views. The maintainer discussed packaging ANGLE as a separate NuGet but noted DLL conflict concerns with AMD\u0027s system-wide libEGL.dll.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/GRGlInterface.cs",
            "finding": "GRGlInterface.Create() already falls back to CreateAngle() on Windows. CreateAngle() loads ANGLE\u0027s libEGL/libGLESv2 via AngleLoader. The API exists but requires the ANGLE DLLs to be present at runtime.",
            "relevance": "direct",
            "lines": "27-48"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "finding": "Full ANGLE SwapChainPanel implementation exists for WinUI \u2014 creates GlesContext, manages render loop, handles composition scale. This is the model for what a WPF/WinForms equivalent would look like.",
            "relevance": "direct",
            "lines": "1-307"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/Egl.cs",
            "finding": "Complete EGL interop with ANGLE-specific constants (D3D9, D3D11, WARP device types). Infrastructure for ANGLE is mature.",
            "relevance": "related",
            "lines": "60-80"
          },
          {
            "file": "binding/SkiaSharp/GRContext.cs",
            "finding": "GRContext.CreateDirect3D exists with GRD3DBackendContext. This provides a native D3D12 path that could bypass ANGLE entirely for GPU rendering on Windows.",
            "relevance": "related",
            "lines": "66-79"
          },
          {
            "file": "binding/SkiaSharp/GRD3DBackendContext.cs",
            "finding": "D3D backend context wraps IDXGIAdapter, ID3D12Device, and ID3D12CommandQueue \u2014 full D3D12 interop is available.",
            "relevance": "related",
            "lines": "1-37"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "WinForms SKControl uses System.Drawing.Bitmap (raster only) \u2014 no GPU path exists. This is the gap the feature request targets.",
            "relevance": "direct",
            "lines": "1-50"
          }
        ],
        "rationale": "Classified as feature-request because no current SkiaSharp API or packaging is broken \u2014 the request is for new capability (GPU views for WPF/WinForms). Area is SkiaSharp.Views rather than Build because the core deliverable is GPU-accelerated view controls, not just packaging ANGLE. The existing label area/Build reflects the original framing but the discussion shows this is really about shipping new view infrastructure. Windows-Classic platform and OpenGL\u002BDirect3D backends reflect the target surface area.",
        "keySignals": [
          {
            "text": "Angle has support even for DX9-based rendering which is preinstalled on Win7",
            "source": "issue body",
            "interpretation": "Original motivation was Win7 GPU support via ANGLE\u0027s DX9 backend."
          },
          {
            "text": "Packaging ANGLE as a separate package and referencing it from WPF/Winforms views should work",
            "source": "comment by kekekeks (2020-04-25)",
            "interpretation": "Avalonia maintainer confirms the packaging approach is viable."
          },
          {
            "text": "AMD ships their own libEGL.dll in system32. Including ANGLE with Skia will break users who are using AMD EGL implementation",
            "source": "comment by kekekeks (2020-04-25)",
            "interpretation": "DLL naming conflicts are a real deployment risk that needs design work."
          },
          {
            "text": "Maybe skia will get a DX backend - I see some work on that now",
            "source": "comment by mattleibow (2020-04-25)",
            "interpretation": "Skia\u0027s native D3D backend has since materialized (GRContext.CreateDirect3D exists), providing an alternative path."
          },
          {
            "text": "GRGlInterface.Create() falls back to CreateAngle() on Windows",
            "source": "code search: binding/SkiaSharp/GRGlInterface.cs:28",
            "interpretation": "ANGLE GL interface creation is already built into SkiaSharp\u0027s API surface \u2014 the gap is packaging and view controls."
          }
        ],
        "workarounds": [
          "Use GRGlInterface.CreateAngle() with manually-supplied ANGLE DLLs (libEGL.dll, libGLESv2.dll) in the output directory",
          "Use GRContext.CreateDirect3D() with a manually-created D3D12 device for GPU-accelerated rendering without ANGLE",
          "Use Avalonia.Angle.Windows.Natives NuGet package to supply ANGLE binaries (as referenced in the discussion)"
        ],
        "nextQuestions": [
          "Should the solution use ANGLE (OpenGL ES over DX) or Skia\u0027s native Direct3D12 backend?",
          "Should ANGLE be a separate NuGet package or bundled with views?",
          "How to handle DLL naming conflicts with AMD\u0027s system libEGL.dll?",
          "Is a cross-platform GPU view (#2104) the right umbrella for this work?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp needs GPU-accelerated view controls for WPF/WinForms. Two viable paths exist: (1) package ANGLE as a separate NuGet and create ANGLE-based views mirroring AngleSwapChainPanel, or (2) use Skia\u0027s native D3D12 backend via GRContext.CreateDirect3D to build D3D-native views without ANGLE.",
          "proposals": [
            {
              "description": "Build GPU-accelerated WPF/WinForms views using GRContext.CreateDirect3D (already in SkiaSharp API). This avoids ANGLE entirely and uses Skia\u0027s native D3D12 support. Requires creating D3D12 device/queue in the view and managing swap chains via DXGI.",
              "title": "Native D3D12 backend views",
              "confidence": 0.65,
              "effort": "large"
            },
            {
              "description": "Package ANGLE binaries as SkiaSharp.NativeAssets.ANGLE NuGet, referenced by WPF/WinForms view packages. Mirror the AngleSwapChainPanel pattern for WPF/WinForms hosting. Address DLL conflicts by loading from app-local directory.",
              "title": "Separate ANGLE NuGet package",
              "confidence": 0.6,
              "effort": "large"
            },
            {
              "description": "Document using Avalonia.Angle.Windows.Natives or similar third-party ANGLE NuGet with GRGlInterface.CreateAngle() for GPU rendering in WPF/WinForms. Low effort workaround users can apply today.",
              "title": "Use third-party ANGLE package",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Native D3D12 backend views",
          "recommendedReason": "Skia\u0027s native D3D12 backend avoids the ANGLE dependency, DLL conflict issues, and the maintenance burden of shipping ANGLE. It\u0027s the modern path forward for GPU rendering on Windows, aligned with #2817 and #2104."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Legitimate feature gap \u2014 no GPU-accelerated views for WPF/WinForms. The underlying infrastructure (ANGLE interop, D3D backend) exists but isn\u0027t surfaced in view controls. Related to #2104 (cross-platform GPU views) which is the likely umbrella for this work."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Update area label from Build to Views \u2014 the feature is about GPU view controls, not build packaging",
            "risk": "low",
            "confidence": 0.8,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "backend/OpenGL",
              "backend/Direct3D",
              "tenet/performance"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #2104 (cross-platform GPU backend views) \u2014 this is a subset of that work",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 2104
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #2817 (Direct3D support) \u2014 D3D backend is an alternative approach",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 2817
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 209,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T14:50:00Z",
        "currentLabels": [
          "type/bug",
          "status/help-wanted"
        ]
      },
      "summary": "Concurrent calls to SKBitmap.Decode from multiple threads cause AccessViolationException crashes. Reported across IIS, ASP.NET Core, Azure Functions, and .NET console apps. The underlying Skia C\u002B\u002B codec is not thread-safe, and simultaneous decode operations on separate SKBitmap instances still crash. Multiple reporters confirm a SemaphoreSlim(1,1) workaround eliminates the crash but serializes decoding. The issue has persisted across SkiaSharp versions from 1.x through 2.88.5, with reports spanning 2016\u20132024.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.92
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a multi-threaded application (IIS, Azure Functions, or console app with Task.Run)",
            "Call SKBitmap.Decode concurrently from multiple threads on separate byte arrays or files",
            "Observe AccessViolationException crash after a few iterations under concurrent load"
          ],
          "codeSnippets": [
            "const int numThreads = 100;\nconst int numIterationsPerThread = 1000;\nvar tasks = new List\u003CTask\u003E();\nfor (int i = 0; i \u003C numThreads; i\u002B\u002B) {\n    var task = Task.Run(() =\u003E {\n        for (int j = 0; j \u003C numIterationsPerThread; j\u002B\u002B) {\n            var imageData = ComputeThumbnail(referenceFile);\n        }\n    });\n    tasks.Add(task);\n}\nTask.WaitAll(tasks.ToArray());"
          ],
          "environmentDetails": "Windows (IIS), .NET Framework 4.x, .NET Core, .NET 5, .NET 7, Azure Functions Isolate Container",
          "relatedIssues": [
            235,
            1174,
            2194,
            2456
          ],
          "repoLinks": [
            {
              "url": "https://github.com/ncthbrt/skia-fsharp",
              "description": "F# repro project showing concurrent SKBitmap.Decode crash on .NET Core"
            }
          ]
        },
        "bugSignals": {
          "severity": "critical",
          "errorType": "AccessViolationException",
          "errorMessage": "Attempted to read or write protected memory. This is often an indication that other memory is corrupt.",
          "stackTrace": "at SkiaSharp.SkiaApi.sk_codec_get_info(IntPtr, SKImageInfo ByRef)\n  at SkiaSharp.SKBitmap.Decode(SKCodec)\n  at SkiaSharp.SKBitmap.Decode(SKStream)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net461",
            "netcoreapp2.0",
            "net5.0",
            "net7.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.56.2",
            "1.57.0",
            "2.80.2",
            "2.80.3",
            "2.88.5"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The SKBitmap.Decode code path has not changed structurally. It still creates an SKCodec per call, calls sk_codec_get_pixels, and there is no synchronization in the C# layer or the Skia C API layer. The SkiaSharp 3.x HandleDictionary uses locks for handle tracking but does not protect the underlying Skia codec operations."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "This appears to be a longstanding limitation rather than a regression. Reporter in comment 25 states reverting to 2.80.2 fixed the issue for them, but others report the same crash on older versions. The core thread-safety limitation of Skia codecs has existed throughout all versions."
        }
      },
      "analysis": {
        "summary": "SKBitmap.Decode is not thread-safe because the underlying Skia C\u002B\u002B codec operations (sk_codec_get_info, sk_codec_get_pixels, sk_codec_new_from_stream) are not designed for concurrent use. Each call to SKBitmap.Decode creates its own SKCodec instance, but Skia\u0027s internal state (global allocators, codec registries) may have shared mutable state that is not protected by locks. The C# wrapper (SKBitmap.cs:434-458) has no synchronization, and the P/Invoke calls go directly to native code. The GC.KeepAlive fix (commit 643e1b4c5) addressed a related but different issue \u2014 premature GC of objects during P/Invoke calls. The fundamental thread-safety gap in concurrent codec operations remains.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(SKCodec) and Decode(SKCodec, SKImageInfo) create a new SKBitmap, call codec.GetPixels to decode. No locking or synchronization. Each concurrent call gets its own codec and bitmap, but native Skia may share internal state.",
            "relevance": "direct",
            "lines": "434-458"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "All Decode overloads (Stream, SKStream, SKData, string, byte[], ReadOnlySpan\u003Cbyte\u003E) follow the same pattern: create SKCodec via SKCodec.Create, then call Decode(codec). No thread protection at any entry point.",
            "relevance": "direct",
            "lines": "461-586"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(SKStream) calls sk_codec_new_from_stream, which goes to native Skia. The stream ownership is transferred (RevokeOwnership). No locking around the native call.",
            "relevance": "direct",
            "lines": "252-264"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.GetPixels calls sk_codec_get_pixels \u2014 the native function where most AccessViolationExceptions occur in reporter stack traces. Parameters are local (nInfo, nOptions) but the native implementation may access global Skia state.",
            "relevance": "direct",
            "lines": "119-137"
          },
          {
            "file": "binding/SkiaSharp/HandleDictionary.cs",
            "finding": "HandleDictionary uses a PlatformLock (read-write lock) for instance tracking. This protects the C# handle dictionary but does not protect native Skia operations.",
            "relevance": "context",
            "lines": "21-27"
          }
        ],
        "rationale": "Classified as type/bug because multiple reporters demonstrate a consistent crash (AccessViolationException) during normal concurrent use of a public API. The area is area/SkiaSharp (core binding) rather than any View/Platform component since the crash is in SKBitmap.Decode and SKCodec \u2014 the core decoding pipeline. Severity is critical because it terminates the process without being catchable. The reliability tenet applies because server-side applications depend on concurrent image processing.",
        "keySignals": [
          {
            "text": "AccessViolationException at sk_codec_get_info during concurrent SKBitmap.Decode",
            "source": "issue body",
            "interpretation": "Native crash in Skia\u0027s codec layer proves this is a native thread-safety issue, not a C# bug."
          },
          {
            "text": "SemaphoreSlim with max count of 1 increases stability but sacrifices speed",
            "source": "issue body",
            "interpretation": "Serializing decode calls eliminates the crash \u2014 confirms the root cause is concurrent native access."
          },
          {
            "text": "Maintainer says SkiaSharp is \u0027thread safe\u0027 in that two threads can load a bitmap, but two threads shouldn\u0027t access the same object",
            "source": "comment 1",
            "interpretation": "The expectation is that separate instances should be safe concurrently. The crash contradicts this expectation, suggesting shared native state."
          },
          {
            "text": "Multiple reporters across versions 1.56.2 through 2.88.5 report the same crash",
            "source": "comments 9, 21, 23",
            "interpretation": "Longstanding issue across all major versions \u2014 not version-specific."
          },
          {
            "text": "Loading stream into byte array first makes the issue go away for some reporters",
            "source": "comment 24",
            "interpretation": "Suggests the managed stream wrapper (SKManagedStream) may have additional thread-safety issues beyond the codec itself."
          },
          {
            "text": "SKBitmap.Decode creates a new SKCodec per call with no shared state in C#",
            "source": "code search",
            "interpretation": "C# layer is clean \u2014 each call creates independent objects. The contention must be in native Skia code."
          }
        ],
        "errorFingerprint": "AccessViolationException-sk_codec-concurrent-decode",
        "workarounds": [
          "Use SemaphoreSlim(1,1) to serialize all SKBitmap.Decode calls \u2014 eliminates crashes but serializes throughput",
          "Load image data into a byte array before decoding instead of passing a stream \u2014 some reporters find this reduces (but may not eliminate) crashes",
          "Use SKImage.FromEncodedData(SKData) instead of SKBitmap.Decode \u2014 SKImage is immutable and may have better thread-safety characteristics for the decode path"
        ],
        "nextQuestions": [
          "Does Skia upstream document thread-safety guarantees for SkCodec? Is there a global mutex or codec registry that causes contention?",
          "Does SKImage.FromEncodedData truly avoid the same native thread-safety issue, or does it use the same codec path internally?",
          "Has the GC.KeepAlive fix (commit 643e1b4c5) or SkiaSharp 3.x\u0027s HandleDictionary locking partially mitigated this?",
          "Should SkiaSharp add an internal lock around codec creation/decode to protect against concurrent native access?"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s native codec implementation has shared mutable state (global codec registry, memory allocators, or image format decoders) that is not thread-safe. Even when each C# call creates independent SKCodec and SKBitmap objects, the underlying native code shares state that causes memory corruption under concurrent access.",
          "proposals": [
            {
              "description": "Use SemaphoreSlim(1,1) to serialize all SKBitmap.Decode calls. This is the proven workaround from the original reporter.",
              "title": "Serialize with SemaphoreSlim",
              "codeSnippet": "private static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try\n    {\n        return SKBitmap.Decode(data);\n    }\n    finally\n    {\n        _decodeLock.Release();\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Use SKImage.FromEncodedData(SKData.CreateCopy(bytes)) for concurrent image loading. SKImage is immutable and uses deferred decoding, which may avoid the codec thread-safety issue. Pixels are decoded lazily on first access.",
              "title": "Use SKImage instead of SKBitmap",
              "codeSnippet": "using var data = SKData.CreateCopy(bytes);\nusing var image = SKImage.FromEncodedData(data);\n// Use image directly for drawing, or convert to bitmap when needed on a single thread:\nusing var bitmap = SKBitmap.FromImage(image);",
              "confidence": 0.65,
              "effort": "small"
            },
            {
              "description": "Add a static lock or SemaphoreSlim inside SKCodec.GetPixels to serialize native codec operations within the SkiaSharp library itself. This would protect all callers transparently but would limit throughput to single-threaded decoding.",
              "title": "Add internal codec lock in SkiaSharp",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Serialize with SemaphoreSlim",
          "recommendedReason": "Proven workaround from the original reporter and multiple commenters. Trivial to implement, eliminates crashes completely. While it serializes decode throughput, it\u0027s the safest option until the root cause in native Skia is resolved."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real bug confirmed by multiple reporters across versions. Needs investigation into whether Skia upstream has addressed codec thread-safety, and whether SkiaSharp 3.x changes (HandleDictionary locking, GC.KeepAlive) have partially mitigated this."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, core area, and reliability labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround and status update",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the thorough investigation \u2014 this thread has been invaluable for understanding the scope of this issue.\n\nSkia\u0027s native codec operations are not designed for concurrent use, even when each call creates independent C# objects. The underlying native code shares state that can corrupt memory under concurrent access.\n\nHere\u0027s a workaround you can use while we investigate further:\n\n\u0060\u0060\u0060csharp\nprivate static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap?\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try\n    {\n        return SKBitmap.Decode(data);\n    }\n    finally\n    {\n        _decodeLock.Release();\n    }\n}\n\u0060\u0060\u0060\n\nNote that \u0060SKBitmap.Decode()\u0060 can return \u0060null\u0060 if decoding fails \u2014 callers should check the return value. The returned bitmap must be disposed by the caller when done.\n\nThis serializes decode operations and eliminates the crash, at the cost of concurrent throughput. We\u0027re evaluating whether an internal lock in SkiaSharp itself would be the right long-term fix, or whether Skia upstream has improved codec thread-safety in recent versions."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related concurrent access issues",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 2456
          },
          {
            "type": "link-related",
            "description": "Cross-reference thread-safety discussion",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 1174
          }
        ]
      }
    }
  ]
}