{
  "generatedAt": "2026-02-13T04:42:45.3340538Z",
  "totalCount": 78,
  "summary": {
    "needsInvestigation": 28,
    "closeable": 19,
    "quickWins": 19,
    "regressions": 15
  },
  "byType": [
    {
      "label": "type/bug",
      "count": 53
    },
    {
      "label": "type/enhancement",
      "count": 8
    },
    {
      "label": "type/question",
      "count": 7
    },
    {
      "label": "type/feature-request",
      "count": 7
    },
    {
      "label": "type/documentation",
      "count": 3
    }
  ],
  "byArea": [
    {
      "label": "area/SkiaSharp",
      "count": 27
    },
    {
      "label": "area/SkiaSharp.Views",
      "count": 15
    },
    {
      "label": "area/libSkiaSharp.native",
      "count": 12
    },
    {
      "label": "area/SkiaSharp.HarfBuzz",
      "count": 5
    },
    {
      "label": "area/SkiaSharp.Views.Maui",
      "count": 4
    },
    {
      "label": "area/Docs",
      "count": 4
    },
    {
      "label": "area/SkiaSharp.Views.Blazor",
      "count": 3
    },
    {
      "label": "area/HarfBuzzSharp",
      "count": 3
    },
    {
      "label": "area/SkiaSharp.Views.Forms",
      "count": 2
    },
    {
      "label": "area/SkiaSharp.Views.Uno",
      "count": 2
    },
    {
      "label": "area/Build",
      "count": 1
    }
  ],
  "byAction": [
    {
      "label": "needs-investigation",
      "count": 28
    },
    {
      "label": "keep-open",
      "count": 17
    },
    {
      "label": "close-with-docs",
      "count": 13
    },
    {
      "label": "close-as-fixed",
      "count": 9
    },
    {
      "label": "close-as-duplicate",
      "count": 6
    },
    {
      "label": "request-info",
      "count": 5
    }
  ],
  "bySeverity": [
    {
      "label": "medium",
      "count": 29
    },
    {
      "label": "high",
      "count": 17
    },
    {
      "label": "low",
      "count": 6
    },
    {
      "label": "critical",
      "count": 2
    }
  ],
  "issues": [
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3514,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:14:31Z",
        "currentLabels": []
      },
      "summary": "PR from mattleibow to update SkiaSharp from .NET 8 SDK (8.0.304) to .NET 10 SDK (10.0.103), restructuring the TFM system from Previous=net6.0/Current=net8.0 to Base=net6.0/Previous=net9.0/Current=net10.0, modernizing workload management via global.json workload sets instead of custom install-dotnet-workloads.ps1, removing the MAUI TPV workaround (dotnet/maui#24263), updating pipeline tool versions (Xcode 16.2, Emscripten 3.1.56), and adding a documentation checklist for future .NET version upgrades across 48 files.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.95
        },
        "area": {
          "value": "area/Build",
          "confidence": 0.95
        },
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            3422,
            3428
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.4"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "This PR targets the main branch and updates the entire build infrastructure for .NET 10. It will affect all future releases."
        }
      },
      "analysis": {
        "summary": "Major build system modernization PR from the maintainer. Shifts the TFM chain forward two generations (net6\u2192net8 becomes net6\u2192net9\u2192net10), replaces custom workload install scripts with built-in dotnet workload restore, removes a MAUI TPV workaround that\u0027s fixed upstream, updates CI pipeline tool versions, and fixes a latent bug where PlatformTargetFrameworksPrevious was referenced but never defined. Also adds a new documentation/updating-dotnet-version.md checklist to streamline future upgrades.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "Current TFM definitions: TFMPrevious=net6.0, TFMCurrent=net8.0, TFMNext=empty. The PR restructures this to Base=net6.0, Previous=net9.0, Current=net10.0.",
            "relevance": "direct",
            "lines": "62-66"
          },
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "PlatformTargetFrameworks references $(PlatformTargetFrameworksPrevious) but it is never defined \u2014 confirmed latent bug. Currently harmless because net6.0 has no platform TFMs, but would break when Previous becomes net9.0 with platform support.",
            "relevance": "direct",
            "lines": "114"
          },
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "MAUI TPV workaround: lines 132-139 clear TPV values, lines 159-166 restore them. This works around dotnet/maui#24263 which shipped a fix in .NET 9, making this workaround removable.",
            "relevance": "direct",
            "lines": "132-166"
          },
          {
            "file": "global.json",
            "finding": "SDK pinned to 8.0.100 with rollForward:latestMinor, no workload settings. PR adds workloadVersion for modern workload set management.",
            "relevance": "direct",
            "lines": "1-7"
          },
          {
            "file": "scripts/azure-templates-variables.yml",
            "finding": "DOTNET_VERSION=8.0.304, XCODE_VERSION=15.4, EMSCRIPTEN_VERSION=3.1.34, DOTNET_VERSION_PREVIEW=empty. All need updating for .NET 10.",
            "relevance": "direct",
            "lines": "15-26"
          },
          {
            "file": "scripts/install-dotnet-workloads.ps1",
            "finding": "Custom workload management with manual NuGet feed configuration and per-platform workload lists. PR replaces this with dotnet workload restore.",
            "relevance": "direct",
            "lines": "1-30"
          },
          {
            "file": "build.cake",
            "finding": "Hardcoded net8.0-android, net8.0-ios, net8.0-maccatalyst TFMs in Cake build scripts \u2014 these will need updating to net10.0.",
            "relevance": "direct",
            "lines": "285-397"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.Android/SkiaSharp.NativeAssets.Android.csproj",
            "finding": "NativeAssets csproj uses $(TFMCurrent)-android$(TPVAndroidCurrent) with conditional TFMNext. PR changes 14 such files to use TFMPrevious;TFMCurrent pattern.",
            "relevance": "related",
            "lines": "3-4"
          }
        ],
        "rationale": "This is clearly an enhancement (not a bug fix or feature request) \u2014 it improves the existing build system rather than adding user-facing functionality. It\u0027s area/Build since all 48 changed files are build props, pipeline YAML, csproj TFM updates, and workload scripts. The tenet/compatibility label applies because TFM changes directly affect which .NET versions consumers can target. It directly addresses .NET 10 support gaps reported in #3422 (Blazor WASM) and #3428 (MAUI iOS).",
        "keySignals": [
          {
            "text": "Pin SDK to 10.0.103 with workload sets (workloadVersion)",
            "source": "PR body",
            "interpretation": "Moves from custom workload install scripts to the modern global.json workload pinning approach introduced in .NET 8\u002B."
          },
          {
            "text": "TFMBase=net6.0, TFMPrevious=net9.0, TFMCurrent=net10.0, Removed TFMNext entirely",
            "source": "PR body",
            "interpretation": "Restructures from 2-tier (Previous\u002BCurrent) to 3-tier (Base\u002BPrevious\u002BCurrent) TFM system, dropping the preview TFMNext slot."
          },
          {
            "text": "Remove MAUI TPV workaround (dotnet/maui#24263 fixed in .NET 9\u002B)",
            "source": "PR body",
            "interpretation": "Lines 132-139 and 159-166 in SkiaSharp.Build.props clear and restore TPV values \u2014 this workaround can be removed since the fix shipped in .NET 9."
          },
          {
            "text": "Add full PlatformTargetFrameworksPrevious block (was referenced but never defined)",
            "source": "PR body",
            "interpretation": "Line 114 of SkiaSharp.Build.props references $(PlatformTargetFrameworksPrevious) but no PropertyGroup defines it \u2014 a latent bug that was harmless because Previous=net6.0 had no platform TFMs, but becomes critical when Previous=net9.0."
          },
          {
            "text": "Replace install-dotnet-workloads.ps1 with dotnet workload restore",
            "source": "PR body",
            "interpretation": "Eliminates 50\u002B lines of custom PowerShell that manually managed NuGet feeds and workload lists in favor of the SDK\u0027s built-in mechanism."
          },
          {
            "text": "DOTNET_VERSION: 8.0.304 \u2192 10.0.103, XCODE_VERSION: 15.4 \u2192 16.2, EMSCRIPTEN_VERSION: 3.1.34 \u2192 3.1.56",
            "source": "PR body",
            "interpretation": "Pipeline tool versions updated to match .NET 10 era requirements."
          }
        ],
        "nextQuestions": [
          "Are all TPVs verified against the actual .NET 10 workload manifests?",
          "Do the gallery samples (net6/7 era Uno) need separate handling or can they remain on older TFMs?",
          "Has CI been validated with the new Emscripten 3.1.56 version for WASM builds?",
          "Does dropping TFMNext mean preview testing shifts to a different mechanism?"
        ],
        "resolution": {
          "hypothesis": "The PR implements a well-structured .NET SDK version bump with proper TFM chain management. The key design decision is the 3-tier Base/Previous/Current system which maintains backward compatibility while dropping the preview slot.",
          "proposals": [
            {
              "description": "The PR is comprehensive and addresses all build system touchpoints. Review the 48 files for consistency, verify CI passes on all platforms, and merge.",
              "title": "Merge as-is after CI passes",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "After SDK install, run \u0027dotnet workload list\u0027 and verify that the TPV values in the PR match the actual workload manifest versions for .NET 10.",
              "title": "Verify TPVs against workload manifests",
              "confidence": 0.9,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge as-is after CI passes",
          "recommendedReason": "Maintainer-authored PR with detailed changelog covering all 48 files. The TFM restructuring pattern is clean and the removal of the MAUI workaround is correctly gated on the upstream fix shipping in .NET 9."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Maintainer-authored PR awaiting CI validation. No external action needed \u2014 review and merge when CI passes."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply enhancement and build labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/enhancement",
              "area/Build",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Link to .NET 10 Blazor WASM issue this PR addresses",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3422
          },
          {
            "type": "link-related",
            "description": "Link to .NET 10 MAUI iOS issue this PR addresses",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3428
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3511,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:14:31Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "External-Dependency-Info.txt still lists libmicrohttpd after PR #3463 removed the dependency from Skia DEPS",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.9
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Open External-Dependency-Info.txt in the repository",
            "Search for \u0027libmicrohttpd\u0027",
            "Observe it is still listed at lines 1475-1988 despite being removed from Skia DEPS in PR #3463"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/6816f7fd-e4e8-463c-a326-055032874ece",
              "description": "Screenshot showing libmicrohttpd entry in External-Dependency-Info.txt"
            }
          ],
          "environmentDetails": "Any version after PR #3463 merged (2026-01-27)",
          "relatedIssues": [
            3463
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "incorrect-output",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.3-preview.1"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The libmicrohttpd entry remains in External-Dependency-Info.txt on main branch as of today."
        }
      },
      "analysis": {
        "summary": "PR #3463 commented out microhttpd in Skia DEPS and documented its removal, but did not update External-Dependency-Info.txt (lines 1475-1988) or scripts/guardian/CredScanSuppressions.json (6 entries referencing microhttpd files). The microhttpd source directory no longer exists. This is a straightforward cleanup oversight.",
        "codeInvestigation": [
          {
            "file": "External-Dependency-Info.txt",
            "finding": "libmicrohttpd LGPL license text still present \u2014 514 lines of stale content",
            "relevance": "direct",
            "lines": "1475-1988"
          },
          {
            "file": "externals/skia/DEPS",
            "finding": "microhttpd entry is commented out with # prefix, confirming PR #3463 removed it",
            "relevance": "direct",
            "lines": "52"
          },
          {
            "file": "scripts/guardian/CredScanSuppressions.json",
            "finding": "6 suppression entries reference externals/skia/third_party/externals/microhttpd/ files that no longer exist",
            "relevance": "related",
            "lines": "5-26"
          },
          {
            "file": "externals/skia/third_party/libmicrohttpd/BUILD.gn",
            "finding": "BUILD.gn for libmicrohttpd still exists in the skia submodule but references source files that are no longer downloaded",
            "relevance": "related",
            "lines": "1-22"
          },
          {
            "file": "cgmanifest.json",
            "finding": "No microhttpd entries \u2014 already clean",
            "relevance": "context"
          }
        ],
        "rationale": "This is a valid bug \u2014 stale metadata left over from an incomplete cleanup in PR #3463. Classified as area/Docs because it affects documentation/metadata files, not functional code. Low severity because there is zero runtime or build impact \u2014 only the license listing file and credential scan suppressions are stale.",
        "keySignals": [
          {
            "text": "microhttpd entry commented out in DEPS",
            "source": "externals/skia/DEPS line 52",
            "interpretation": "Confirms dependency was intentionally removed in PR #3463."
          },
          {
            "text": "libmicrohttpd section spans lines 1475-1988 in External-Dependency-Info.txt",
            "source": "External-Dependency-Info.txt",
            "interpretation": "514 lines of LGPL license text remain for a dependency that is no longer used."
          },
          {
            "text": "externals/skia/third_party/externals/microhttpd directory does not exist",
            "source": "filesystem check",
            "interpretation": "Source files are gone since DEPS no longer downloads them, confirming the dependency is fully removed."
          },
          {
            "text": "CredScanSuppressions.json has 6 entries for microhttpd files",
            "source": "scripts/guardian/CredScanSuppressions.json lines 5-26",
            "interpretation": "Suppression entries reference files that no longer exist on disk."
          }
        ],
        "resolution": {
          "hypothesis": "PR #3463 removed the microhttpd dependency from Skia DEPS but did not clean up the corresponding entries in External-Dependency-Info.txt and CredScanSuppressions.json.",
          "proposals": [
            {
              "description": "Delete lines 1472-1990 (the libmicrohttpd section including header/footer markers) from External-Dependency-Info.txt.",
              "title": "Remove libmicrohttpd from External-Dependency-Info.txt",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Remove the 6 microhttpd file suppression entries from scripts/guardian/CredScanSuppressions.json since those files no longer exist.",
              "title": "Clean up CredScanSuppressions.json",
              "confidence": 0.95,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Remove libmicrohttpd from External-Dependency-Info.txt",
          "recommendedReason": "This is the specific file the reporter identified. Both proposals should be done together as a single cleanup PR."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.95,
          "reason": "Straightforward cleanup \u2014 remove stale entries from two files. No investigation needed."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply documentation area label",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/Docs"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report and confirm it will be cleaned up",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for catching this. You\u0027re right \u2014 PR #3463 removed microhttpd from Skia\u0027s DEPS but missed updating \u0060External-Dependency-Info.txt\u0060. The \u0060scripts/guardian/CredScanSuppressions.json\u0060 file also has 6 stale entries referencing microhttpd files that no longer exist.\n\nWe\u0027ll get both files cleaned up."
          },
          {
            "type": "link-related",
            "description": "Link to PR #3463 which caused the oversight",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3463
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3509,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T17:02:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "Near-empty bug report: \u0027images not appearing\u0027 with no code, no steps, no logs, no screenshots. Template placeholders left unfilled.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.5
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.4
        },
        "platforms": [
          "os/macOS"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [],
          "environmentDetails": "SkiaSharp 3.116.0, macOS, Visual Studio (Windows)"
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "wrong-output",
          "reproQuality": "none"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "currentRelevance": "unknown",
          "relevanceReason": "No code or reproduction provided \u2014 impossible to determine if the issue is real or a usage error."
        }
      },
      "analysis": {
        "summary": "The issue body consists almost entirely of unfilled template placeholders. The description says \u0027I have some code that puts things on the screen, but nothing appears\u0027 without providing any actual code, expected behavior, actual behavior, screenshots, or log output. The code block contains only the template placeholder text. There is no actionable information to investigate.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "DrawImage methods exist with multiple overloads. All delegate to sk_canvas_draw_image_rect(). No obvious bugs in the C# wrapper \u2014 null checks on image and paint parameters are present.",
            "relevance": "context",
            "lines": "455-510"
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "finding": "FromEncodedData() and related factory methods are well-defined. Return null on failure (not throw). No TODO or known issues that would cause silent rendering failures.",
            "relevance": "context",
            "lines": "158-232"
          }
        ],
        "rationale": "Classified as type/bug at low confidence because the reporter selected [BUG] template but provided zero evidence. Area is generic area/SkiaSharp because no specific component is identified. Severity is unknown \u2014 without code or reproduction steps, this could range from a trivial usage error to a real rendering bug. The mention of 2.88.9 as \u0027last known good\u0027 hints at a possible regression but without any code this cannot be verified.",
        "keySignals": [
          {
            "text": "I have some code that puts things on the screen, but nothing appears.",
            "source": "issue body",
            "interpretation": "Entire description \u2014 too vague to classify. Could be usage error, missing NuGet package, incorrect API usage, or a real rendering bug."
          },
          {
            "text": "Code section contains only template placeholder text",
            "source": "issue body",
            "interpretation": "Reporter did not fill in the bug template. No actual code was provided."
          },
          {
            "text": "Version 3.116.0 current, 2.88.9 last known good",
            "source": "issue body",
            "interpretation": "Suggests a possible regression from v2 to v3, but without code this is unverifiable."
          },
          {
            "text": "Platform: macOS, IDE: Visual Studio (Windows)",
            "source": "issue body",
            "interpretation": "Slight inconsistency \u2014 macOS platform but Windows IDE. May indicate cross-compilation or confusion."
          }
        ],
        "nextQuestions": [
          "What actual code is the reporter using to draw images?",
          "Is this SKCanvasView (MAUI/Forms), SKControl (WPF), or direct SKCanvas usage?",
          "What image format and loading method is being used?",
          "Is the SKImage being created successfully (non-null)?",
          "What platform target framework is the project using?"
        ],
        "resolution": {
          "hypothesis": "Cannot form a hypothesis without reproduction code. The issue could be anything from a missing NuGet package to incorrect canvas setup to a real rendering regression.",
          "proposals": [
            {
              "description": "Ask the reporter to fill in the template with actual code, expected behavior, and actual behavior. A minimal repro project would be ideal.",
              "title": "Request complete reproduction",
              "confidence": 1,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Request complete reproduction",
          "recommendedReason": "No analysis is possible without actual code. The template is almost entirely unfilled."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.95,
          "reason": "The issue contains no actionable information \u2014 no code, no steps, no logs, no screenshots. Template placeholders were left unfilled."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Keep type/bug label, add area and platform",
            "risk": "low",
            "confidence": 0.6,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/macOS"
            ]
          },
          {
            "type": "add-comment",
            "description": "Request missing information from the reporter",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for reporting this. Unfortunately, the issue template wasn\u0027t filled in with the details we need to investigate \u2014 there\u0027s no actual code, expected/actual behavior, or log output.\n\nWould you be able to update the issue with:\n1. The actual code you\u0027re using to load and draw images\n2. What you expect to see vs what actually happens\n3. Your target framework (e.g., \u0060net8.0-macos\u0060)\n4. A screenshot of the blank output\n\nA minimal reproduction project (even a few lines) would help us diagnose this quickly. Without code, we can\u0027t determine whether this is a usage issue or a real rendering bug."
          }
        ],
        "missingInfo": [
          "Actual code that reproduces the issue (not template placeholder)",
          "Expected behavior vs actual behavior",
          "Target framework (net8.0-macos, net8.0, etc.)",
          "Which SkiaSharp view/control is being used",
          "Screenshots showing the blank output",
          "Any error messages or log output"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3491,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:14:31Z",
        "currentLabels": [
          "copilot"
        ]
      },
      "summary": "PR adds SKSamplingOptions overloads to SKSurface.Draw and SKCanvas.DrawSurface, fixing #3344 \u2014 sampling options were not exposed on surface draw after Skia 2.x\u21923.x migration",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Call SKSurface.Draw or SKCanvas.DrawSurface",
            "Observe there is no overload accepting SKSamplingOptions",
            "In Skia 2.x, SkPaint carried filter quality; in 3.x it doesn\u0027t \u2014 so there\u0027s no way to specify sampling"
          ],
          "relatedIssues": [
            3344
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "workedIn": "2.88.9",
          "currentRelevance": "likely",
          "relevanceReason": "The sampling overloads don\u0027t exist on main \u2014 this PR adds them. Issue is still relevant without this PR."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.9,
          "reason": "PR #3491 adds the missing overloads. CI passes. Follows same pattern as existing DrawImage sampling overloads.",
          "relatedPRs": [
            3491
          ]
        }
      },
      "analysis": {
        "summary": "PR by Copilot bot adds sk_surface_draw_with_sampling() C API and 4 C# overloads for SKSurface.Draw/SKCanvas.DrawSurface with SKSamplingOptions. This addresses #3344 where sampling options could not be specified when drawing surfaces. The approach mirrors the existing DrawImage\u002Bsampling pattern exactly.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKSurface.cs",
            "finding": "Existing Draw(SKCanvas, float, float, SKPaint) calls sk_surface_draw without sampling. PR adds parallel Draw overload with SKSamplingOptions that calls sk_surface_draw_with_sampling.",
            "relevance": "direct",
            "lines": "280-285"
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "Existing DrawSurface delegates to SKSurface.Draw. PR adds matching DrawSurface overloads with SKSamplingOptions that delegate to the new SKSurface.Draw overload.",
            "relevance": "direct",
            "lines": "591-601"
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "DrawImage already has SKSamplingOptions overloads following the exact same pattern (point overload \u002B float x/y overload). PR mirrors this established pattern.",
            "relevance": "related",
            "lines": "462-474"
          },
          {
            "file": "externals/skia/include/core/SkSurface.h",
            "finding": "C\u002B\u002B SkSurface::draw(canvas, x, y, sampling, paint) is the primary method. The no-sampling version is a convenience wrapper passing SkSamplingOptions(). Confirms C# should expose both.",
            "relevance": "direct",
            "lines": "346-351"
          },
          {
            "file": "externals/skia/src/c/sk_surface.cpp",
            "finding": "Existing sk_surface_draw calls AsSurface-\u003Edraw(canvas, x, y, paint) \u2014 the old no-sampling C\u002B\u002B overload. PR\u0027s submodule commit adds sk_surface_draw_with_sampling that calls the sampling version.",
            "relevance": "direct",
            "lines": "84-86"
          }
        ],
        "rationale": "Classified as feature-request rather than bug because the old behavior was via SkPaint filter quality which was a Skia-wide API change, not a SkiaSharp regression. The missing overload is a gap in the C# wrapper, not broken functionality. Area is core SkiaSharp since changes are in SKSurface.cs and SKCanvas.cs. The tenet/compatibility label from #3344 is appropriate since this was working behavior in 2.88.x via paint filter quality.",
        "keySignals": [
          {
            "text": "There is no way to draw surface with sampling. SkPaint legacy field is not working also",
            "source": "#3344 body",
            "interpretation": "User lost capability going from 2.88.x to 3.x \u2014 sampling options were removed from SkPaint but not added as explicit parameters on DrawSurface."
          },
          {
            "text": "void draw(SkCanvas* canvas, SkScalar x, SkScalar y, const SkSamplingOptions\u0026 sampling, const SkPaint* paint)",
            "source": "externals/skia/include/core/SkSurface.h:346",
            "interpretation": "Skia C\u002B\u002B already has the sampling parameter \u2014 the gap is only in the C shim and C# wrapper."
          },
          {
            "text": "CI status: success, build #3.119.2-pr.3491.2 succeeded",
            "source": "PR status checks",
            "interpretation": "PR builds and passes CI, confirming the C API/binding/test chain works end-to-end."
          },
          {
            "text": "4 review comments from copilot-pull-request-reviewer, all resolved",
            "source": "PR review threads",
            "interpretation": "Automated review caught minor issues (unused variable, comment clarity) which were addressed."
          }
        ],
        "resolution": {
          "hypothesis": "The Skia C\u002B\u002B API has sampling-aware draw on SkSurface, but the C shim and C# wrapper only exposed the no-sampling version. Adding the missing overloads restores the capability lost when filter quality was removed from SkPaint.",
          "proposals": [
            {
              "description": "PR adds the C API function, generated bindings, C# overloads, and tests. CI passes. Follows established DrawImage\u002Bsampling pattern. Main review concern: ensure generated file was produced by generator, not hand-edited.",
              "title": "Merge PR #3491",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "If SkiaApi.generated.cs was hand-edited rather than regenerated via pwsh ./utils/generate.ps1, the maintainer should run the generator to confirm the output matches. The PR\u0027s generated code looks correct but should be verified.",
              "title": "Regenerate bindings",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3491",
          "recommendedReason": "Implementation is clean, mirrors existing patterns, CI passes, and addresses a real capability gap. The only concern is verifying the generated file was properly generated."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "PR is ready for human code review. CI passes, approach is correct, follows existing patterns. Maintainer should verify generated file and check submodule commit landed on correct branch."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add type and area labels to PR",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with original issue #3344",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3344
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3490,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:14:31Z",
        "currentLabels": [
          "copilot"
        ]
      },
      "summary": "Draft PR by maintainer (mattleibow) that adds new HarfBuzzSharp C# binding APIs for OpenType font features, variable font manipulation, language matching, and buffer cloning. Updates the binding generator (CppAst 0.24.0 upgrade with compatibility fixes), regenerates HarfBuzzApi.generated.cs (\u002B89 new extern functions, -28 removed), adds 586 lines of tests across 4 test files, and includes 5 new documentation files covering migration planning and binding generation. The CI build is currently failing.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.95
        },
        "area": {
          "value": "area/HarfBuzzSharp",
          "confidence": 0.98
        }
      },
      "evidence": {
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.2-pr.3490.1"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "Active draft PR targeting main. Adds new API surface not yet available."
        }
      },
      "analysis": {
        "summary": "This is a large enhancement PR that modernizes the HarfBuzzSharp binding. It progresses through incremental HarfBuzz header versions (2.9.1 \u2192 3.4.0 \u2192 4.4.1 \u2192 5.3.1 \u2192 7.3.0 \u2192 8.3.0) in separate commits, adds manual C# wrappers for Face/Font/Buffer/Language, upgrades the CppAst parser to 0.24.0 with compatibility fixes (space-around-pointers normalization, suffix-const removal, signed/unsigned long long mappings, cross-platform SDK include paths), and excludes new hb_paint_/hb_color_line_ namespaces from generation. The CI build (#3.119.2-pr.3490.1) is failing. The nuget.config change adding nuget.org as an explicit source may be unintentional or could conflict with the existing dotnet-public feed.",
        "codeInvestigation": [
          {
            "file": "binding/HarfBuzzSharp/Face.cs",
            "finding": "New methods: GetName, TryGetName (with language overloads), GetAllNameEntries, GetOpenTypeLayoutScriptTags, GetOpenTypeLayoutFeatureTags, TryGetOpenTypeLayoutFeatureNameIds. All follow correct patterns: ArgumentNullException for null params, stackalloc for buffer allocation, two-pass pattern (get length then get data) for string retrieval.",
            "relevance": "direct"
          },
          {
            "file": "binding/HarfBuzzSharp/Font.cs",
            "finding": "New APIs: GetPpem/SetPpem, Ptem property, SyntheticSlant property, SetSyntheticBold/GetSyntheticBold, SetVariation (uint and string tag overloads), SetVariations (array and ReadOnlySpan overloads), NamedInstance property. String tag overload validates length == 4. All use Handle correctly via P/Invoke.",
            "relevance": "direct"
          },
          {
            "file": "binding/HarfBuzzSharp/Buffer.cs",
            "finding": "New static method CreateSimilar(Buffer source) \u2014 validates null, delegates to hb_buffer_create_similar. Returns new Buffer wrapping the native handle. Follows factory method pattern.",
            "relevance": "direct"
          },
          {
            "file": "binding/HarfBuzzSharp/Language.cs",
            "finding": "New Matches(Language specific) method \u2014 validates null, delegates to hb_language_matches. Returns bool. Correct pattern.",
            "relevance": "direct"
          },
          {
            "file": "binding/HarfBuzzSharp/Definitions.cs",
            "finding": "New OpenTypeLayoutTableTag enum (Gsub, Gpos) with correct HarfBuzz tag encoding using bit shifts. New OpenTypeFeatureNameIds struct with 5 properties matching hb_ot_layout_feature_get_name_ids output parameters.",
            "relevance": "direct"
          },
          {
            "file": "utils/SkiaSharpGenerator/BaseTool.cs",
            "finding": "Three categories of changes: (1) Cross-platform SDK include path resolution for CppAst parsing (macOS, Linux, Windows). (2) Type mapping fixes: unsigned char\u2192Byte, signed char\u2192SByte, added signed/unsigned long long variants. (3) Type name normalization: remove suffix \u0027const\u0027, normalize \u0027type *\u0027 to \u0027type*\u0027 for CppAst 0.24.0 compatibility.",
            "relevance": "related"
          },
          {
            "file": "binding/libHarfBuzzSharp.json",
            "finding": "Excludes hb_paint_ and hb_color_line_ namespaces. Adds hb-paint.h to excluded headers. Adds 20\u002B paint/color_line types to excluded types. Adds hb_style_tag_t enum config. Adds generateProxy:false for 15\u002B callback function types (draw, paint).",
            "relevance": "related"
          },
          {
            "file": "nuget.config",
            "finding": "Adds explicit nuget.org source before the existing dotnet-public Azure DevOps feed. This may have been needed for the CppAst 0.24.0 NuGet package during development.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/enhancement because it adds substantial new API surface (OpenType layout queries, variable font controls, language matching) to an existing component. Not a feature-request (it\u0027s a PR with code). Area is area/HarfBuzzSharp since all new C# wrappers are in binding/HarfBuzzSharp/ and all new C API functions are HarfBuzz functions. No platform specificity \u2014 these are cross-platform APIs.",
        "keySignals": [
          {
            "text": "19 commits progressing through HarfBuzz header versions 2.9.1 \u2192 8.3.0",
            "source": "git log",
            "interpretation": "Methodical incremental binding update, not a one-shot change. Each commit regenerates bindings for a specific HarfBuzz version."
          },
          {
            "text": "Draft PR with failing CI build (#3.119.2-pr.3490.1)",
            "source": "GitHub PR status",
            "interpretation": "Work in progress. The build failure needs investigation before this can be reviewed for merge."
          },
          {
            "text": "\u002B89 new extern functions, -28 removed in HarfBuzzApi.generated.cs",
            "source": "diff analysis",
            "interpretation": "Significant API surface change. Removed functions may indicate renamed/refactored HarfBuzz C API entries across versions."
          },
          {
            "text": "CppAst upgraded from older version to 0.24.0 with space-around-pointer normalization",
            "source": "utils/SkiaSharpGenerator/BaseTool.cs diff",
            "interpretation": "Generator compatibility fix \u2014 CppAst 0.24.0 changes type display names, requiring normalization of pointer syntax."
          },
          {
            "text": "hb_paint_ and hb_color_line_ namespaces excluded from generation",
            "source": "binding/libHarfBuzzSharp.json diff",
            "interpretation": "Paint/color-line APIs intentionally deferred \u2014 complex callback-heavy APIs not yet ready for binding."
          },
          {
            "text": "586 lines of new tests across 4 files",
            "source": "diff stat",
            "interpretation": "Good test coverage for new APIs. Tests cover Buffer.CreateSimilar, Language.Matches, Face OpenType queries, Font variable/synthetic properties."
          }
        ],
        "nextQuestions": [
          "What is the CI build failure? Need to check Azure DevOps build logs for #3.119.2-pr.3490.1.",
          "Are the 28 removed extern functions expected removals (API renames across HarfBuzz versions) or accidental losses?",
          "Is the nuget.config change intentional for the final PR or a development artifact?",
          "The SkiaApi.generated.cs shows 990 lines changed \u2014 are those just comment/formatting changes from the CppAst upgrade or actual signature changes?",
          "Should the hb_paint_/hb_color_line_ APIs be tracked as a follow-up issue?"
        ],
        "resolution": {
          "hypothesis": "This is a well-structured enhancement PR that methodically updates HarfBuzzSharp bindings. The CI failure is the primary blocker. The generator changes (CppAst 0.24.0) affect both HarfBuzzSharp and SkiaSharp generated files.",
          "proposals": [
            {
              "description": "Investigate the Azure DevOps build failure for #3.119.2-pr.3490.1. This is the primary blocker for the PR.",
              "title": "Fix CI build failure",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "Audit the 28 removed extern functions in HarfBuzzApi.generated.cs to confirm they are expected API renames/removals across HarfBuzz versions and not accidental losses.",
              "title": "Verify removed extern functions",
              "confidence": 0.7,
              "effort": "small"
            },
            {
              "description": "Determine if the nuget.org source addition is needed for the final PR or should be reverted as a development artifact.",
              "title": "Review nuget.config change",
              "confidence": 0.6,
              "effort": "trivial"
            },
            {
              "description": "Create a follow-up issue to track the intentionally excluded hb_paint_ and hb_color_line_ APIs for future binding work.",
              "title": "Track deferred paint APIs",
              "confidence": 0.5,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Fix CI build failure",
          "recommendedReason": "The build failure is the only hard blocker. All other items are review observations that can be addressed during code review."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Draft PR with failing CI. Needs build failure diagnosis before it can proceed to review."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply enhancement and HarfBuzzSharp labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/enhancement",
              "area/HarfBuzzSharp"
            ]
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3489,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:14:31Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR optimizing SKBitmap.CopyTo with direct memory copy instead of canvas/shader pipeline when source and destination share the same SKColorType \u2014 has critical bugs (swapped src/dst in row copy, missing pixel allocation, missing alpha/colorspace handling) and no tests",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Review the diff in binding/SkiaSharp/SKBitmap.cs",
            "Note the fast-path optimization for same-ColorType CopyTo",
            "Observe swapped variable names in row-by-row copy block",
            "Observe no destination pixel allocation before writing"
          ],
          "relatedIssues": [
            2915,
            3317
          ],
          "repoLinks": [
            {
              "url": "https://github.com/mono/SkiaSharp/pull/3317",
              "description": "Related PR by jeremy-visionaid fixing shader disposal leak in CopyTo (also targets #2915)"
            }
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "likely",
          "relevanceReason": "CopyTo implementation on main still uses the canvas/shader pipeline. The optimization intent is valid \u2014 the method allocates SKCanvas, SKPaint, and SKShader for a simple pixel copy when color types match."
        }
      },
      "analysis": {
        "summary": "Community PR to optimize SKBitmap.CopyTo by using direct memory copy (Span\u003Cbyte\u003E.TryCopyTo) when source and destination have the same SKColorType, avoiding the expensive canvas/shader allocation pipeline. The optimization concept is sound and addresses real performance/memory issues (#2915), but the implementation has critical bugs: swapped source/destination in the row-by-row copy path, no destination pixel allocation, missing alpha type and color space conversion, and no tests.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "Current CopyTo allocates temp SKBitmap, calls TryAllocPixels, creates SKCanvas and SKPaint with SKShader, draws, then swaps. This is correct but expensive for same-colortype copies. The shader created at line 203 is not disposed (the bug #3317 fixes).",
            "relevance": "direct",
            "lines": "183-212"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "ExtractSubset calls sk_bitmap_extract_subset which shares underlying pixel memory \u2014 subset bitmaps have RowBytes larger than Width*BytesPerPixel. The PR\u0027s contiguity check (Width*Height*BytesPerPixel == ByteCount) correctly identifies non-subset bitmaps, but the row-by-row fallback has swapped src/dst.",
            "relevance": "direct",
            "lines": "216-222"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "GetPixelSpan() returns a span over the ENTIRE pixel buffer (including padding for subsets). GetPixelSpan(x,y) offsets into it. The PR uses GetPixelSpan() for the contiguous fast path, which is correct when ByteCount matches Width*Height*BytesPerPixel.",
            "relevance": "related",
            "lines": "297-304"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "GetAddress(x,y) calls sk_bitmap_get_addr \u2014 a P/Invoke per call. The row-by-row path calls this 2*(Height\u002B1) times, which is the performance concern jeremy-visionaid raised.",
            "relevance": "related",
            "lines": "119-122"
          }
        ],
        "rationale": "This is an enhancement PR, not a bug fix \u2014 it improves performance of an existing method. Area is core SkiaSharp (SKBitmap). The performance tenet applies because the stated goal is eliminating unnecessary allocations. The PR overlaps with #3317 (shader disposal fix) and relates to #2915 (memory leak). Despite the valid optimization concept, the implementation has several correctness bugs that must be fixed before merge.",
        "keySignals": [
          {
            "text": "Use direct memory copy instead of creating SKCanvas and DrawBitmap when source and destination Bitmap have the same SKColorType and Width",
            "source": "PR description",
            "interpretation": "Valid optimization \u2014 current CopyTo allocates SKCanvas, SKPaint, SKShader, and a temp SKBitmap just to copy pixels of the same color type."
          },
          {
            "text": "var des = new Span\u003Cbyte\u003E(srcAddress.ToPointer(), rowBytes); var src = new Span\u003Cbyte\u003E(desAddress.ToPointer(), rowBytes); src.TryCopyTo(des);",
            "source": "PR diff, row-by-row copy block",
            "interpretation": "Critical bug: variable names are swapped \u2014 \u0027des\u0027 points to srcAddress and \u0027src\u0027 points to desAddress. This copies destination pixels into source, which is backwards and corrupts data."
          },
          {
            "text": "I also have a memory copy approach since CopyTo is both slow and leaky as is (#2915). Unfortunately, this one doesn\u0027t handle that the bitmap might be a subset of another",
            "source": "comment by jeremy-visionaid",
            "interpretation": "Experienced community member identified the subset gap. OP later added row-by-row code to handle subsets, but introduced the src/dst swap bug in the process."
          },
          {
            "text": "I just find my project use up 1gb memories for no reason but a copyto",
            "source": "comment by OP",
            "interpretation": "Confirms the real-world performance impact \u2014 CopyTo\u0027s canvas/shader approach leaks memory per #2915, motivating this optimization."
          },
          {
            "text": "there\u0027s 3 P/Invokes per row (Height \u002B 2 * GetAddress). Not the end of the world, but you can do it with 0",
            "source": "review comment by jeremy-visionaid",
            "interpretation": "Row-by-row copy can be optimized further \u2014 compute stride once from RowBytes instead of calling GetAddress per row."
          }
        ],
        "nextQuestions": [
          "Should the optimization also handle different alpha types with same color type (e.g., Premul vs Unpremul)?",
          "Should CopyTo\u0027s behavior with mismatched dimensions be documented or changed (current code always resizes destination to match source)?",
          "How should this PR coordinate with #3317 (shader disposal fix) \u2014 merge #3317 first then rebase?",
          "Should benchmarks be added to validate the performance improvement claim?"
        ],
        "resolution": {
          "hypothesis": "The optimization concept is valid \u2014 direct memory copy for same-colortype bitmaps avoids unnecessary canvas/shader allocations. But the implementation needs several fixes before it\u0027s merge-ready.",
          "proposals": [
            {
              "description": "In the row-by-row copy block, variable names \u0027des\u0027 and \u0027src\u0027 are swapped. \u0027des\u0027 is constructed from srcAddress and \u0027src\u0027 from desAddress. This means TryCopyTo copies destination\u2192source (backwards). Swap the variable names or swap the pointer assignments.",
              "title": "Fix swapped src/dst in row-by-row copy",
              "confidence": 0.99,
              "effort": "trivial"
            },
            {
              "description": "The fast path writes directly into destination pixels without ensuring they\u0027re allocated. The existing code path allocates a temp bitmap with TryAllocPixels and swaps. The optimization must either: (a) check destination already has allocated pixels of matching dimensions, or (b) allocate destination pixels first (via TryAllocPixels) if they don\u0027t match.",
              "title": "Add destination pixel allocation",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "Matching ColorType alone is insufficient \u2014 bitmaps with the same SKColorType but different SKAlphaType (Premul vs Unpremul) or different SKColorSpace need conversion. The fast path should also verify AlphaType and ColorSpace match, or fall through to the canvas path.",
              "title": "Handle alpha type and color space differences",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "The PR checklist shows \u0027Has tests\u0027 is unchecked. Tests needed: same-colortype contiguous copy, subset bitmap copy, different-dimension copy, different-colortype fallback to canvas path. Also add a regression test for the #2915 memory leak scenario.",
              "title": "Add unit tests for CopyTo fast path",
              "confidence": 0.95,
              "effort": "medium"
            },
            {
              "description": "As jeremy-visionaid noted, the row-by-row path does 3 P/Invokes per row. Could compute stride once from RowBytes and use a single GetPixels() call, then iterate with pointer arithmetic.",
              "title": "Optimize row-by-row copy to avoid per-row P/Invokes",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Both PRs modify CopyTo. #3317 fixes the shader disposal leak (the root cause of #2915). Recommend merging #3317 first for the correctness fix, then rebasing this PR. The optimization makes the shader fix less critical for same-colortype copies but the canvas fallback path still needs it.",
              "title": "Coordinate with PR #3317",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Fix swapped src/dst in row-by-row copy",
          "recommendedReason": "This is the most critical bug \u2014 it causes data corruption by copying in the wrong direction. Must be fixed before any other improvements."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Valid optimization concept with real-world motivation (#2915 memory leak, 1GB usage reports), but implementation has critical bugs (swapped src/dst, missing allocation, missing alpha/colorspace checks) and no tests. Needs code review feedback and fixes before merge."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply enhancement, SkiaSharp, and performance labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp",
              "tenet/performance"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #2915 (root memory leak issue)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 2915
          },
          {
            "type": "link-related",
            "description": "Cross-reference #3317 (competing CopyTo fix for shader disposal)",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3317
          },
          {
            "type": "add-comment",
            "description": "Provide code review feedback on the critical bugs and coordination with #3317",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the optimization \u2014 the idea of using direct memory copy for same-ColorType bitmaps is solid, and the motivation is real (the current canvas/shader pipeline is expensive for what should be a simple copy).\n\nA few issues to address before this can be merged:\n\n1. **Swapped source/destination in row-by-row copy.** The \u0060des\u0060 span is constructed from \u0060srcAddress\u0060 and \u0060src\u0060 from \u0060desAddress\u0060 \u2014 this copies backwards. Swap the pointer assignments.\n\n2. **Destination pixel allocation.** The fast path writes into the destination\u0027s existing pixel buffer, but the current \u0060CopyTo\u0060 contract allocates fresh pixels on the destination (via temp \u002B Swap). If the destination is an empty \u0060new SKBitmap()\u0060, the fast path will fail or corrupt memory.\n\n3. **Alpha type and color space.** Matching \u0060ColorType\u0060 alone isn\u0027t sufficient \u2014 two bitmaps with the same \u0060SKColorType\u0060 but different \u0060SKAlphaType\u0060 (Premul vs Unpremul) or \u0060SKColorSpace\u0060 would produce incorrect colors with a raw memory copy. The fast path should verify these match too, or fall through to the canvas path.\n\n4. **Tests are needed.** The checklist shows tests unchecked \u2014 we\u0027d need coverage for: contiguous same-type copy, subset bitmap copy, mismatched dimensions, and the canvas fallback path.\n\n5. **Coordination with #3317.** That PR fixes the shader disposal leak in the same method. Recommend merging #3317 first for the correctness fix, then rebasing this PR on top.\n\nThe per-row P/Invoke concern jeremy-visionaid raised is also worth addressing \u2014 you can compute the stride once from \u0060RowBytes\u0060 and use \u0060GetPixels()\u0060 \u002B pointer arithmetic instead of \u0060GetAddress()\u0060 per row."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3484,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:20:00Z",
        "currentLabels": []
      },
      "summary": "Copilot-authored PR fixing SKFont.GetTextPath returning empty paths for emoji glyphs by modifying upstream SkTextUtils.cpp to substitute bounding-box rectangles when font.getPaths() yields nullptr",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create SKTypeface for an emoji-capable font (e.g., \u0027Segoe UI Emoji\u0027 or via MatchCharacter)",
            "Create SKFont with that typeface at size 48",
            "Call font.GetTextPath(\u0022\uD83D\uDE0A\u0022, SKPoint.Empty)",
            "Inspect path.Bounds \u2014 Width and Height are both 0"
          ],
          "environmentDetails": "SkiaSharp 3.119.0, Windows 11, Visual Studio",
          "relatedIssues": [
            3328,
            1275,
            3244
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "wrong-output",
          "errorMessage": "SKFont.GetTextPath returns empty path (0 width/height bounds) for emoji characters",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.119.0",
          "currentRelevance": "likely",
          "relevanceReason": "The upstream SkTextUtils::GetPath code on main still uses the same callback pattern that skips nullptr paths \u2014 the fix in this PR has not been merged."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.7,
          "reason": "Reporter of #3328 states it worked in 2.88.9. However, color emoji glyphs have never had vector outlines in Skia \u2014 the regression may be due to Skia version bump changing getPaths behavior rather than a SkiaSharp code change.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.119.0"
        }
      },
      "analysis": {
        "summary": "PR #3484 (by Copilot bot) attempts to fix #3328 by modifying upstream Skia code (SkTextUtils.cpp) to precompute glyph bounds and add bounding-box rectangles when font.getPaths() returns nullptr for color emoji glyphs. The fix changes the semantic contract of GetTextPath \u2014 previously it returned only vector outlines (empty for emoji), now it returns rectangles for non-outline glyphs. The PR modifies upstream Skia utility code rather than the SkiaSharp C API shim, which creates merge-conflict risk when updating Skia versions. It also adds non-standard FIX_SUMMARY.md and TESTING_NOTES.md files at the repo root.",
        "codeInvestigation": [
          {
            "file": "externals/skia/src/utils/SkTextUtils.cpp",
            "finding": "GetPath callback checks \u0027if (src)\u0027 before adding path \u2014 glyphs without vector outlines (like color emoji) are silently skipped, yielding empty output path. This is the root cause of #3328.",
            "relevance": "direct",
            "lines": "41-62"
          },
          {
            "file": "externals/skia/src/c/sk_font.cpp",
            "finding": "C API shim delegates directly to SkTextUtils::GetPath/GetPosPath with no SkiaSharp-specific logic. The fix could alternatively be placed here by wrapping the call with bounds-fallback logic at the C API layer, avoiding upstream Skia modifications.",
            "relevance": "direct",
            "lines": "191-197"
          },
          {
            "file": "binding/SkiaSharp/SKFont.cs",
            "finding": "C# wrapper calls sk_text_utils_get_path via P/Invoke. No validation or post-processing on the returned path \u2014 it trusts the native layer completely.",
            "relevance": "context",
            "lines": "748-756"
          },
          {
            "file": "tests/Tests/SkiaSharp/SKFontTest.cs",
            "finding": "Existing test GetTextPathSucceedsForEmptyString validates empty string returns 0 PointCount. The new emoji test at line 328\u002B follows similar patterns and uses appropriate SkippableFact \u002B MatchCharacter.",
            "relevance": "context",
            "lines": "318-326"
          }
        ],
        "rationale": "Classified as type/bug because the underlying issue (#3328) is a clear behavioral defect \u2014 GetTextPath returns empty paths for emoji, breaking layout and measurement. Area is area/SkiaSharp because the API surface is SKFont.GetTextPath in core SkiaSharp, and the native fix touches SkTextUtils which backs the C API. Severity is medium \u2014 it affects emoji-only text paths, not all text rendering.",
        "keySignals": [
          {
            "text": "Modifies externals/skia/src/utils/SkTextUtils.cpp \u2014 upstream Skia code, not the C API shim (src/c/)",
            "source": "PR diff",
            "interpretation": "Architecture policy states only externals/skia/src/c/ and include/c/ are editable. Modifying upstream Skia utility code creates maintenance burden and merge conflicts on Skia version bumps."
          },
          {
            "text": "font.getPaths() returns nullptr for color emoji glyphs (COLR/CPAL, bitmap)",
            "source": "PR description \u002B SkTextUtils.cpp:54-57",
            "interpretation": "Root cause is correct \u2014 color emoji don\u0027t have vector path outlines, so getPaths yields nullptr which the existing callback silently skips."
          },
          {
            "text": "Returns bounding-box rectangles instead of actual paths for emoji",
            "source": "PR description",
            "interpretation": "Behavioral change: GetTextPath\u0027s contract shifts from \u0027vector outlines only\u0027 to \u0027vector outlines or bounding rectangles\u0027. Callers expecting path shapes for clipping/stroking/animation would get rectangles."
          },
          {
            "text": "FIX_SUMMARY.md and TESTING_NOTES.md added at repo root",
            "source": "PR file list",
            "interpretation": "Non-standard files that don\u0027t belong in the repository. Copilot bot artifact \u2014 should be removed."
          },
          {
            "text": "PR checklist: \u0027Merged related skia PRs\u0027 is unchecked",
            "source": "PR body",
            "interpretation": "The submodule changes need a corresponding skia PR on the skiasharp branch, which doesn\u0027t appear to exist."
          },
          {
            "text": "No CI workflow runs found",
            "source": "GitHub Actions API",
            "interpretation": "The PR has never been built or tested in CI."
          }
        ],
        "nextQuestions": [
          "Should the fix be at the C API shim layer (externals/skia/src/c/sk_font.cpp) instead of upstream SkTextUtils.cpp to avoid maintenance burden?",
          "Is returning bounding-box rectangles the correct semantic for GetTextPath, or should a separate API be used for emoji measurement?",
          "Has the regression been confirmed by checking whether Skia\u0027s getPaths behavior changed between the 2.88.x and 3.x Skia versions?",
          "Should this behavioral change be opt-in rather than default, to avoid surprising callers who depend on GetTextPath returning only vector outlines?"
        ],
        "resolution": {
          "hypothesis": "Color emoji glyphs lack vector outlines, causing Skia\u0027s getPaths callback to skip them and produce empty output. The PR\u0027s approach of substituting bounding-box rectangles is technically functional but modifies the wrong layer and changes the API\u0027s semantic contract.",
          "proposals": [
            {
              "description": "Instead of modifying upstream SkTextUtils.cpp, implement the bounds-fallback logic in externals/skia/src/c/sk_font.cpp. After calling SkTextUtils::GetPath, check if the output path is empty while glyphs were present, then use font.getBounds() and add rectangles. This avoids modifying upstream code and confines the behavioral change to SkiaSharp\u0027s own layer.",
              "title": "Move fix to C API shim layer",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "description": "If the behavior change (rectangles for non-outline glyphs) is considered correct for all Skia users, propose the change upstream to Google\u0027s Skia project. This is the cleanest long-term approach but has uncertain timeline.",
              "title": "Upstream the fix to Skia",
              "confidence": 0.4,
              "effort": "large"
            },
            {
              "description": "Accept the current approach but remove FIX_SUMMARY.md and TESTING_NOTES.md, ensure the submodule commit is on the skiasharp branch, and verify CI passes. Acknowledge the upstream-modification risk.",
              "title": "Accept PR with cleanup",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Move fix to C API shim layer",
          "recommendedReason": "Avoids modifying upstream Skia code (which creates merge conflict risk on version bumps) while still fixing the bug. Keeps the behavioral change contained within SkiaSharp\u0027s own C API layer where it can be more easily maintained."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The PR addresses a real bug (#3328) but the implementation approach modifies upstream Skia code and changes GetTextPath\u0027s semantic contract. Needs maintainer review of whether the fix belongs at the C API shim layer instead, and whether bounding-box rectangles are the correct fallback."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug label to match the underlying issue",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp"
            ]
          },
          {
            "type": "link-related",
            "description": "Link to the underlying bug report #3328",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3328
          },
          {
            "type": "link-related",
            "description": "Link to older related emoji path issue #1275",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 1275
          },
          {
            "type": "add-comment",
            "description": "Post review feedback on the PR\u0027s approach and required cleanup",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for working on this \u2014 this addresses a real bug reported in #3328.\n\nA few concerns before this can move forward:\n\n1. **Upstream Skia modification.** The fix modifies \u0060externals/skia/src/utils/SkTextUtils.cpp\u0060, which is upstream Skia code. SkiaSharp\u0027s convention is to only modify \u0060externals/skia/src/c/\u0060 and \u0060include/c/\u0060 (our C API shim). Modifying upstream Skia code creates merge conflicts when bumping Skia versions. Consider moving the bounds-fallback logic into \u0060externals/skia/src/c/sk_font.cpp\u0060 instead \u2014 after calling \u0060SkTextUtils::GetPath\u0060, check if the output path is empty while input had glyphs, then fall back to bounding-box rectangles there.\n\n2. **Semantic contract change.** \u0060GetTextPath\u0060 has historically returned only vector path outlines. Returning rectangles for color emoji changes the API\u0027s contract. Callers using paths for clipping, stroking, or animation may get unexpected results. This should be documented clearly.\n\n3. **Cleanup needed.** Please remove \u0060FIX_SUMMARY.md\u0060 and \u0060TESTING_NOTES.md\u0060 from the repo root \u2014 these aren\u0027t standard SkiaSharp files.\n\n4. **CI status.** No CI runs have been triggered for this PR yet. The native changes require a full native build (\u0060dotnet cake --target=externals-{platform}\u0060) to validate.\n\n5. **Submodule branch.** The submodule commit needs to be on the \u0060skiasharp\u0060 branch with a proper PR in the skia fork."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3473,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:19:39Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR fixing GC-unsafe pointer escape in HarfBuzzSharp Blob.FromStream \u2014 fixes #3472",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/HarfBuzzSharp",
          "confidence": 0.99
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Call Blob.FromStream with any stream",
            "GC runs after the fixed block exits but before Skia finishes with the pointer",
            "Managed byte array is relocated \u2014 native pointer is now dangling"
          ],
          "environmentDetails": "All platforms \u2014 GC behavior is runtime-level, not platform-specific",
          "relatedIssues": [
            3472
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": false,
          "errorType": "crash",
          "errorMessage": "Potential crash from GC moving managed array after fixed block exits",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The vulnerable code path exists on main \u2014 Blob.FromStream has not been changed since the bug was introduced."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "This PR is the proposed fix. It has not been merged yet. The bug still exists on main.",
          "relatedPRs": [
            3473
          ]
        }
      },
      "analysis": {
        "summary": "PR replaces GC-unsafe fixed/pinned byte array with Marshal.AllocCoTaskMem unmanaged allocation in HarfBuzzSharp Blob.FromStream. The current code pins a managed array with \u0027fixed\u0027, but the pointer escapes the fixed scope via the Blob constructor \u2014 after the method returns, GC can relocate the array making the pointer dangling. The fix allocates unmanaged memory directly, copies stream data there, and passes Marshal.FreeCoTaskMem as the release callback.",
        "codeInvestigation": [
          {
            "file": "binding/HarfBuzzSharp/Blob.cs",
            "finding": "Current FromStream uses fixed(byte* dataPtr = data) but returns the pointer inside a Blob object that outlives the fixed scope. After the method returns, GC can move the byte[] array, making the pointer dangling. The release delegate only disposes the MemoryStream, not the byte array \u2014 the array has no GC root keeping it alive after the method returns.",
            "relevance": "direct",
            "lines": "71-82"
          },
          {
            "file": "binding/HarfBuzzSharp/Blob.cs",
            "finding": "The Create method passes the data pointer to hb_blob_create which stores it in native HarfBuzz memory. This pointer must remain valid for the lifetime of the blob \u2014 confirming the GC safety issue.",
            "relevance": "direct",
            "lines": "84-89"
          },
          {
            "file": "tests/Tests/HarfBuzzSharp/HBBlobTest.cs",
            "finding": "Existing test ShouldCreateFromStream only checks blob length, not content validity after GC. The PR adds CreateFromStreamIsGCSafe which forces GC and verifies content integrity.",
            "relevance": "related",
            "lines": "20-25"
          }
        ],
        "rationale": "This is clearly a bug (pointer escapes fixed scope = undefined behavior). The area is HarfBuzzSharp since the affected file is binding/HarfBuzzSharp/Blob.cs. Severity is high because it\u0027s a potential crash, though it\u0027s non-deterministic (depends on GC timing). The tenet/reliability label applies because this is a crash/corruption risk.",
        "keySignals": [
          {
            "text": "fixed (byte* dataPtr = data) { return new Blob((IntPtr)dataPtr, ...) }",
            "source": "binding/HarfBuzzSharp/Blob.cs:79-81",
            "interpretation": "Pointer from fixed block escapes scope \u2014 classic GC-unsafe pattern. The Blob stores this pointer long-term via hb_blob_create, but the managed array is unpinned after the fixed block exits."
          },
          {
            "text": "// TODO: check to see if we can avoid the second copy (the ToArray)",
            "source": "binding/HarfBuzzSharp/Blob.cs:73",
            "interpretation": "Original code already acknowledged the double-copy issue. The PR fixes both the GC safety bug AND the performance concern by copying directly to unmanaged memory."
          },
          {
            "text": "Avoids a potential crash from memory being moved by GC",
            "source": "PR description",
            "interpretation": "Author correctly identifies the root cause \u2014 GC relocation of pinned-then-unpinned managed array."
          },
          {
            "text": "This should also improve performance since it removes the redundant copy",
            "source": "issue #3472 comment by jeremy-visionaid",
            "interpretation": "Secondary benefit \u2014 eliminates MemoryStream.ToArray() copy, going directly from stream to unmanaged memory."
          }
        ],
        "nextQuestions": [
          "Should similar GC-safety patterns be audited across the codebase (e.g., other uses of fixed with escaping pointers)?",
          "Should non-seekable stream handling be tested explicitly?",
          "Is the int cast of stream.Length safe for very large streams (\u003E2GB)?"
        ],
        "resolution": {
          "hypothesis": "The fixed block pins the managed array only during the block scope, but the pointer is captured in the Blob and used long after. Replacing with Marshal.AllocCoTaskMem ensures the memory stays valid.",
          "proposals": [
            {
              "description": "The PR correctly replaces managed pinning with unmanaged allocation. It handles edge cases (null stream, non-seekable streams, empty streams, exception cleanup). All 6 copilot review comments were addressed. Tests verify both functionality and GC safety.",
              "title": "Merge PR as-is",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "The cast (int)(stream.Length - stream.Position) can overflow for streams \u003E2GB. Consider adding a bounds check as suggested in a resolved review comment. This is a minor improvement, not a blocker.",
              "title": "Add overflow check for large streams",
              "codeSnippet": "long remaining = stream.Length - stream.Position;\nif (remaining \u003E int.MaxValue)\n    throw new ArgumentOutOfRangeException(nameof(stream), \u0022Stream too large.\u0022);",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Other uses of fixed with byte* exist in HarfBuzzSharp (Font.cs, Buffer.cs). These appear safe (pointers don\u0027t escape the fixed scope), but a brief audit would confirm no similar bugs.",
              "title": "Audit similar patterns",
              "confidence": 0.6,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Merge PR as-is",
          "recommendedReason": "The fix is correct, well-tested, and addresses the identified GC safety bug. The review comments were all resolved. The int overflow edge case is extremely unlikely for font/blob data and can be addressed separately."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Community PR with correct fix for a real GC safety bug. Needs maintainer code review and merge decision. All automated review comments addressed."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, HarfBuzzSharp, and reliability labels to the PR",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/HarfBuzzSharp",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with issue #3472 (already linked via \u0027Fixes #3472\u0027)",
            "risk": "low",
            "confidence": 0.99,
            "linkedIssue": 3472
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3472,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:52:04Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "HarfBuzzSharp.Blob.FromStream uses a fixed block that only pins the managed byte array during constructor call \u2014 after it exits, GC can move or collect the array while native HarfBuzz still holds the raw pointer, causing crashes or data corruption",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.99
        },
        "area": {
          "value": "area/HarfBuzzSharp",
          "confidence": 0.99
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Blob from a Stream using Blob.FromStream()",
            "Use the Blob (e.g., create a Face and shape text)",
            "GC.Collect() or wait for GC compaction",
            "Access the Blob data \u2014 crash or corrupted data"
          ],
          "environmentDetails": "All platforms, all .NET versions. Confirmed by multiple reporters.",
          "relatedIssues": [
            2323,
            3393,
            3394,
            2821,
            3473
          ],
          "repoLinks": []
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": false,
          "errorType": "crash",
          "errorMessage": "AccessViolationException or corrupted glyph data (codepoints become 0)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0",
            "net9.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The buggy code in Blob.FromStream has not changed since it was first introduced (commit c1549d923). Bug exists in all versions of HarfBuzzSharp that include FromStream."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "PR #3473 has been submitted by the reporter with a correct fix using Marshal.AllocCoTaskMem, but it has not been merged yet.",
          "relatedPRs": [
            3473
          ]
        }
      },
      "analysis": {
        "summary": "Blob.FromStream creates a managed byte[] via MemoryStream.ToArray(), pins it with a fixed block, passes the pointer to hb_blob_create with MemoryMode.ReadOnly, then the fixed block exits. HarfBuzz holds the raw pointer but the GC can now relocate or collect the array. This is a use-after-move/use-after-free bug.",
        "codeInvestigation": [
          {
            "file": "binding/HarfBuzzSharp/Blob.cs",
            "finding": "FromStream uses fixed block that only pins the byte array during the Blob constructor call. After the fixed block exits at line 81, the managed byte[] \u0027data\u0027 is unpinned. HarfBuzz\u0027s hb_blob_create stores the raw pointer and uses it for the blob\u0027s lifetime, but the GC can relocate or collect the array at any time.",
            "relevance": "direct",
            "lines": "71-82"
          },
          {
            "file": "binding/HarfBuzzSharp/Blob.cs",
            "finding": "The private Create method passes the pointer to hb_blob_create with MemoryMode.ReadOnly, which tells HarfBuzz to use the pointer directly without copying. The pointer must remain valid for the blob\u0027s lifetime, but the fixed block ensures validity only during the constructor.",
            "relevance": "direct",
            "lines": "84-89"
          },
          {
            "file": "binding/HarfBuzzSharp/HarfBuzzApi.generated.cs",
            "finding": "MemoryMode enum: ReadOnly=1 means HarfBuzz does not copy data. Duplicate=0 would make HarfBuzz copy (and be safe), but ReadOnly is explicitly specified.",
            "relevance": "direct",
            "lines": "7295-7304"
          },
          {
            "file": "binding/SkiaSharp/SKData.cs",
            "finding": "SKData.CreateCopy uses fixed blocks correctly \u2014 the native function (sk_data_new_with_copy) copies the data within the fixed block, so the pointer doesn\u0027t need to outlive it. This is the correct pattern for when you want to pass managed data to native code.",
            "relevance": "related",
            "lines": "68-73"
          }
        ],
        "rationale": "This is clearly a bug, not a usage issue. The fixed block only pins the byte[] for the duration of the Blob constructor call. After the fixed block exits, the managed array is unpinned and may be relocated by GC compaction. Since MemoryMode.ReadOnly tells HarfBuzz not to copy the data, HarfBuzz directly uses the now-stale pointer. The area is area/HarfBuzzSharp (not area/SkiaSharp) since the bug is in the HarfBuzzSharp.Blob class. Severity is high because it causes crashes or silent data corruption. The os/Windows-Classic label is incorrect \u2014 this affects all platforms. Issue #2323 reported the same bug ~3 years earlier and was confirmed by user TJYSunset who experienced AccessViolationException and zeroed-out glyph codepoints.",
        "keySignals": [
          {
            "text": "fixed (byte* dataPtr = data) { return new Blob((IntPtr)dataPtr, ...) }",
            "source": "binding/HarfBuzzSharp/Blob.cs:79-81",
            "interpretation": "The fixed block only pins \u0027data\u0027 during the Blob constructor. After the block exits, dataPtr is stale."
          },
          {
            "text": "MemoryMode.ReadOnly",
            "source": "binding/HarfBuzzSharp/Blob.cs:80",
            "interpretation": "ReadOnly tells HarfBuzz NOT to copy the data \u2014 it uses the provided pointer directly. The pointer must remain valid for the blob\u0027s lifetime."
          },
          {
            "text": "releaseDelegate: () =\u003E ms.Dispose()",
            "source": "binding/HarfBuzzSharp/Blob.cs:80",
            "interpretation": "The release delegate disposes the MemoryStream, but ms.ToArray() returns an independent copy. The byte[] \u0027data\u0027 has no GC root after the method returns."
          },
          {
            "text": "At best all codepoints in Buffer.GlyphInfos becomes 0, at worst AccessViolationException",
            "source": "#2323 comment by TJYSunset",
            "interpretation": "Confirmed real-world impact \u2014 silent data corruption and hard crashes."
          },
          {
            "text": "#2323 opened 2023 reporting identical issue",
            "source": "#2323",
            "interpretation": "This bug was reported ~3 years ago as a question and confirmed by a user, but never fixed."
          }
        ],
        "workarounds": [
          "Allocate unmanaged memory with Marshal.AllocHGlobal, copy stream data into it, and construct the Blob with a release delegate that frees the unmanaged memory.",
          "Use Blob.FromFile() instead of Blob.FromStream() when loading from a file path."
        ],
        "nextQuestions": [
          "Should this use MemoryMode.Duplicate instead to let HarfBuzz copy the data, avoiding unmanaged allocation entirely?",
          "PR #3473 needs review \u2014 does the edge case handling (non-seekable streams, empty streams) match expectations?"
        ],
        "resolution": {
          "hypothesis": "The fixed block in FromStream only pins the managed byte array during the Blob constructor call. After the method returns, nothing roots or pins the array, so HarfBuzz holds a dangling pointer.",
          "proposals": [
            {
              "description": "PR #3473 replaces the managed byte array with unmanaged memory via Marshal.AllocCoTaskMem. The release delegate calls Marshal.FreeCoTaskMem. This is the correct fix \u2014 the pointer remains valid for the blob\u0027s lifetime and is freed when HarfBuzz destroys the blob.",
              "title": "Merge PR #3473 (AllocCoTaskMem)",
              "confidence": 0.92,
              "effort": "small"
            },
            {
              "description": "Change MemoryMode.ReadOnly to MemoryMode.Duplicate so HarfBuzz copies the data internally. Simpler change but incurs an extra copy. The fixed block would be sufficient since hb_blob_create would copy during the constructor call.",
              "title": "Use MemoryMode.Duplicate",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "Users can work around by allocating unmanaged memory and creating the Blob manually instead of using FromStream.",
              "title": "Workaround: manual unmanaged allocation",
              "codeSnippet": "var length = (int)(stream.Length - stream.Position);\nvar dataPtr = Marshal.AllocHGlobal(length);\ntry {\n    using var ums = new UnmanagedMemoryStream((byte*)dataPtr, length, length, FileAccess.ReadWrite);\n    stream.CopyTo(ums);\n    var blob = new Blob(dataPtr, length, MemoryMode.ReadOnly, () =\u003E Marshal.FreeHGlobal(dataPtr));\n} catch {\n    Marshal.FreeHGlobal(dataPtr);\n    throw;\n}",
              "confidence": 0.9,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Merge PR #3473 (AllocCoTaskMem)",
          "recommendedReason": "The reporter already submitted a well-structured PR with tests. It correctly handles non-seekable streams, empty streams, and exception cleanup. Review and merge is the fastest path to resolution."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.95,
          "reason": "A fix PR (#3473) already exists from the reporter. The bug is confirmed, the fix is correct in approach. Needs code review and merge."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix area label from area/SkiaSharp to area/HarfBuzzSharp, remove os/Windows-Classic (affects all platforms)",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/HarfBuzzSharp",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #2323 (same bug reported as a question ~3 years ago)",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 2323
          },
          {
            "type": "link-related",
            "description": "Cross-reference #3393 (broader GC safety initiative for P/Invokes)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3393
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug, confirm it\u0027s a known GC safety issue, note that PR #3473 is ready for review",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the detailed analysis and the fix in #3473 \u2014 this is a real GC safety bug.\n\nThe \u0060fixed\u0060 block in \u0060FromStream\u0060 only pins the managed \u0060byte[]\u0060 during the \u0060Blob\u0060 constructor call. After it exits, HarfBuzz holds a dangling pointer since \u0060MemoryMode.ReadOnly\u0060 tells it not to copy. This was also reported in #2323 and confirmed to cause \u0060AccessViolationException\u0060 and corrupted glyph data in production.\n\nYour fix using \u0060Marshal.AllocCoTaskMem\u0060 is the right approach \u2014 it keeps the pointer stable for the blob\u0027s lifetime. We\u0027ll review #3473."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3467,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:20:00Z",
        "currentLabels": []
      },
      "summary": "Copilot-authored test-only PR adding 6 tests to SKShaperTest.cs validating that ToHarfBuzzBlob no longer disposes the caller\u0027s SKStreamAsset \u2014 tests are designed to fail before #3466 and pass after",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.98
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Merge PR #3466 (behavioral change to ToHarfBuzzBlob)",
            "Apply PR #3467 tests to tests/Tests/SkiaSharp/SKShaperTest.cs",
            "Run: dotnet test tests/SkiaSharp.Tests.Console/SkiaSharp.Tests.Console.csproj --filter SKShaperTest"
          ],
          "environmentDetails": "SkiaSharp main branch, .NET 8\u002B, any OS",
          "relatedIssues": [
            3466,
            3472,
            2263
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "likely",
          "relevanceReason": "ToHarfBuzzBlob on main still disposes the stream via the destroy callback (line 24 of BlobExtensions.cs). Tests verify the behavioral change in PR #3466 which has not yet been merged."
        }
      },
      "analysis": {
        "summary": "PR #3467 is a Copilot-authored test-only PR that adds 6 test methods to SKShaperTest.cs. The tests validate the behavioral change proposed in PR #3466, where ToHarfBuzzBlob stops taking disposal ownership of SKStreamAsset. The current code (BlobExtensions.cs:24) passes \u0060() =\u003E asset.Dispose()\u0060 as the destroy callback to the Blob constructor, which incorrectly disposes the caller\u0027s stream when the blob is destroyed. PR #3466 removes this callback. PR #3467 tests that the stream survives blob creation/disposal.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob has two code paths: (1) memory-mapped: passes \u0060() =\u003E asset.Dispose()\u0060 as destroy callback, incorrectly disposing the caller\u0027s stream; (2) non-memory-mapped: allocates CoTaskMem, reads data, passes \u0060FreeCoTaskMem\u0060 as callback. PR #3466 removes the asset.Dispose() call in path 1 and adds try/catch for path 2.",
            "relevance": "direct",
            "lines": "10-37"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "SKShaper constructor chains OpenStream().ToHarfBuzzBlob() in a single using statement. Since ToHarfBuzzBlob currently disposes the stream, the stream gets disposed twice (once by blob callback, once by using). PR #3466 splits these into separate using statements.",
            "relevance": "direct",
            "lines": "19-21"
          },
          {
            "file": "tests/Tests/SkiaSharp/SKShaperTest.cs",
            "finding": "Existing SKShaperTest has 5 tests covering shaping text with different alignment options and the DrawShapedText extension method. PR #3467 adds 6 disposal-focused tests after line 150.",
            "relevance": "context",
            "lines": "10-150"
          }
        ],
        "rationale": "Classified as enhancement because this is a test-only PR that improves test coverage for an existing behavioral fix (PR #3466). It is not a bug fix itself. Area is SkiaSharp.HarfBuzz because all tests exercise BlobExtensions.ToHarfBuzzBlob and SKShaper, both in the SkiaSharp.HarfBuzz package. No platform or backend specificity \u2014 disposal behavior is cross-platform.",
        "keySignals": [
          {
            "text": "Add test coverage for PR #3466\u0027s behavioral change",
            "source": "PR description",
            "interpretation": "Explicit dependency on PR #3466 \u2014 tests will FAIL on current main without that fix."
          },
          {
            "text": "blob = new Blob(memoryBase, size, MemoryMode.ReadOnly, () =\u003E asset.Dispose())",
            "source": "BlobExtensions.cs:24 (main branch)",
            "interpretation": "Current code disposes the caller\u0027s stream when the blob is destroyed \u2014 the bug that #3466 fixes and #3467 tests."
          },
          {
            "text": "ToHarfBuzzBlobDoesNotDisposeStream",
            "source": "PR #3467 diff \u002B PR #3466 diff",
            "interpretation": "Both PRs add a test with this exact name \u2014 #3466 in BlobExtensionsTest.cs, #3467 in SKShaperTest.cs. Merge conflict on test name."
          },
          {
            "text": "Firewall rules blocked me from connecting",
            "source": "PR #3467 description",
            "interpretation": "Copilot agent could not build or run the tests due to network restrictions in the sandbox environment."
          },
          {
            "text": "using (var blob = Typeface.OpenStream(out index).ToHarfBuzzBlob())",
            "source": "SKShaper.cs:20 (main branch)",
            "interpretation": "SKShaper currently chains OpenStream().ToHarfBuzzBlob() without keeping a reference to the stream. PR #3466 splits this into separate using statements so the stream is properly disposed by the caller."
          }
        ],
        "nextQuestions": [
          "Should tests live in SKShaperTest.cs or in a new BlobExtensionsTest.cs (as PR #3466 does)?",
          "How to resolve the duplicate test name ToHarfBuzzBlobDoesNotDisposeStream between PR #3466 and #3467?",
          "Should PR #3467 be merged into #3466 instead of being a separate PR?",
          "Were the tests actually validated (Copilot agent couldn\u0027t build due to firewall)?"
        ],
        "resolution": {
          "hypothesis": "PR #3467 provides useful test coverage but has organizational issues \u2014 duplicate test names with #3466, tests in the wrong class, and unverified execution.",
          "proposals": [
            {
              "description": "Move the additional tests from PR #3467 into PR #3466\u0027s BlobExtensionsTest.cs (or a separate test class), resolve the duplicate test name, and close #3467. This avoids merge ordering issues and keeps all related changes together.",
              "title": "Consolidate into PR #3466",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Merge PR #3466 first, then rebase #3467 and resolve the duplicate test name. This preserves the separate PR but requires coordination.",
              "title": "Merge #3466 first then rebase #3467",
              "confidence": 0.7,
              "effort": "small"
            },
            {
              "description": "The ToHarfBuzzBlob tests are about BlobExtensions, not SKShaper. Move them from SKShaperTest.cs to BlobExtensionsTest.cs (the file #3466 creates) for better test organization. Keep SKShaperConstructorSucceeds in SKShaperTest.cs.",
              "title": "Move tests to BlobExtensionsTest",
              "confidence": 0.8,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Consolidate into PR #3466",
          "recommendedReason": "Avoids merge ordering complexity, resolves the duplicate test name in one place, and ensures all disposal-related changes (fix \u002B tests) are reviewed together. The Copilot-authored tests provide good additional coverage that complements #3466\u0027s single test."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Tests depend on unmerged PR #3466 and have organizational issues (duplicate test name, wrong test class). The fix PR (#3466) should be reviewed first, then decide whether to consolidate these tests into it or keep them separate."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply enhancement and HarfBuzz area labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.HarfBuzz"
            ]
          },
          {
            "type": "add-comment",
            "description": "Provide review feedback on test organization and dependency on #3466",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the additional test coverage.\n\nA few observations:\n\n1. **Dependency on #3466:** These tests are designed to fail on current \u0060main\u0060 and will only pass after #3466 is merged. Merging this first would introduce known-failing tests.\n\n2. **Duplicate test name:** Both this PR and #3466 add a test named \u0060ToHarfBuzzBlobDoesNotDisposeStream\u0060 \u2014 this PR puts it in \u0060SKShaperTest\u0060, while #3466 puts it in \u0060BlobExtensionsTest\u0060. These would conflict.\n\n3. **Test organization:** The \u0060ToHarfBuzzBlob*\u0060 tests exercise \u0060BlobExtensions\u0060, not \u0060SKShaper\u0060. It might be cleaner to move them into \u0060BlobExtensionsTest.cs\u0060 (the file #3466 creates) and keep only \u0060SKShaperConstructorSucceeds\u0060 in \u0060SKShaperTest\u0060.\n\nWould it make sense to fold these additional tests into #3466 directly? That way the behavioral change and its full test suite ship together."
          },
          {
            "type": "link-related",
            "description": "Cross-reference parent PR #3466",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3466
          },
          {
            "type": "link-related",
            "description": "Cross-reference related GC safety issue #3472 by same author",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 3472
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3466,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:19:39Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "PR fixing incorrect disposal ownership in ToHarfBuzzBlob extension method. Currently, when SKStreamAsset.GetMemoryBase() returns non-zero, the Blob\u0027s release callback disposes the stream \u2014 taking ownership away from the caller. When GetMemoryBase() is zero, data is copied but the stream is never disposed, causing a memory leak. This PR removes dispose ownership from both paths so callers manage stream lifetime, and fixes SKShaper to properly dispose the stream it creates via OpenStream().",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            3378,
            3319,
            3467
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "memory-leak",
          "errorMessage": "SKStreamAsset leaked when ToHarfBuzzBlob takes the else (copy) path; caller loses ownership when memoryBase path is taken",
          "reproQuality": "complete"
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The buggy code in BlobExtensions.cs and SKShaper.cs is unchanged on main. ToHarfBuzzBlob still disposes the asset in the memoryBase path and leaks in the copy path."
        }
      },
      "analysis": {
        "summary": "ToHarfBuzzBlob has two code paths with inconsistent ownership semantics. The memoryBase path (line 24) passes \u0060() =\u003E asset.Dispose()\u0060 as the Blob release callback, stealing ownership from the caller. The else path (line 28-30) copies data to CoTaskMem but never disposes the stream, causing a memory leak. SKShaper.cs compounds this by chaining \u0060OpenStream().ToHarfBuzzBlob()\u0060 without storing a reference to the stream, making it impossible to dispose deterministically. The PR correctly fixes both: removes dispose from both paths in ToHarfBuzzBlob and wraps the stream in a \u0060using\u0060 in SKShaper. The memoryBase path now requires the caller to keep the stream alive as long as the blob (correct, since the blob references the stream\u0027s memory).",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob has two paths: memoryBase path disposes the stream via release callback (line 24), else path copies to CoTaskMem and never disposes stream (line 28-30). Inconsistent ownership semantics \u2014 memoryBase path steals ownership, else path leaks.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "SKShaper constructor chains OpenStream().ToHarfBuzzBlob() without storing stream reference. Stream only disposed if memoryBase path is taken; otherwise leaked.",
            "relevance": "direct",
            "lines": "19-21"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "SKTypeface.OpenStream() creates a new SKStreamAsset via P/Invoke. Returns a new object that the caller is responsible for disposing.",
            "relevance": "related",
            "lines": "292-300"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "IsDisposed property exists on SKObject base class \u2014 the PR\u0027s test correctly uses this to verify stream is not disposed after blob creation.",
            "relevance": "context",
            "lines": "242"
          }
        ],
        "rationale": "Classified as type/bug because the current code has a clear defect: inconsistent disposal ownership and a confirmed memory leak in the else path. Area is SkiaSharp.HarfBuzz since both affected files (BlobExtensions.cs, SKShaper.cs) are in that project. Reliability tenet applies due to memory leak. No platform specificity \u2014 this is pure managed C# logic. The PR approach is the correct fix: the method that creates a resource should own its lifetime.",
        "keySignals": [
          {
            "text": "blob = new Blob(memoryBase, size, MemoryMode.ReadOnly, () =\u003E asset.Dispose())",
            "source": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs:24",
            "interpretation": "ToHarfBuzzBlob takes ownership of the stream via the release callback \u2014 callers lose control of stream lifetime."
          },
          {
            "text": "In the else path, asset.Read copies data but stream is never disposed",
            "source": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs:28-30",
            "interpretation": "Memory leak: when GetMemoryBase() returns IntPtr.Zero, the stream is orphaned with no disposal path."
          },
          {
            "text": "using (var blob = Typeface.OpenStream(out index).ToHarfBuzzBlob())",
            "source": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs:20",
            "interpretation": "The stream returned by OpenStream() is not stored \u2014 only disposed if ToHarfBuzzBlob happens to take the memoryBase path."
          },
          {
            "text": "mattleibow: This looks much better. I asked copilot to write some tests",
            "source": "comment #1",
            "interpretation": "Maintainer has reviewed and expressed approval in principle. Requested tests."
          },
          {
            "text": "OP added targeted tests: regression test for unwanted disposal and test ensuring managed stream ref not required by blob",
            "source": "comment #3",
            "interpretation": "PR now includes tests. OP considers copilot-generated tests off-topic and provided better-scoped alternatives."
          }
        ],
        "nextQuestions": [
          "Does the memoryBase path\u0027s blob remain valid after the stream is disposed? The blob holds a raw pointer to the stream\u0027s memory \u2014 need to verify HarfBuzz Blob copies the data when MakeImmutable() is called, or that callers always keep stream alive longer than blob.",
          "Are there other callers of ToHarfBuzzBlob besides SKShaper that might rely on the old disposal behavior?"
        ],
        "resolution": {
          "hypothesis": "ToHarfBuzzBlob incorrectly took ownership of the stream in the memoryBase path and failed to dispose it in the else path. The fix is to never take ownership (caller manages stream lifetime) and fix SKShaper to use a \u0060using\u0060 statement.",
          "proposals": [
            {
              "description": "The PR correctly removes dispose ownership from both paths in ToHarfBuzzBlob and fixes SKShaper to properly dispose the stream. Also adds try/catch for CoTaskMem allocation safety and includes a targeted regression test.",
              "title": "Merge PR #3466",
              "confidence": 0.9,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Merge PR #3466",
          "recommendedReason": "Maintainer has approved the approach. PR includes targeted tests. The fix correctly aligns ownership semantics: the creator of the stream manages its lifetime."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "PR has maintainer approval in principle and includes tests. Ready for final review and merge. Related issue #3378 should also be closed once this merges."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and area labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference bug report #3378 which describes the same memory leak",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3378
          },
          {
            "type": "link-related",
            "description": "Cross-reference related disposal PR #3319 (dispose temporary vertices) by same contributor",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 3319
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3440,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:52:04Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp.Views.Maui",
          "os/Windows-WinUI",
          "tenet/reliability"
        ]
      },
      "summary": "MAUI app using LiveCharts2 with SkiaSharp 3.119.1 crashes on certain Windows 11 systems with a COMException (Element not found) during WinRT activation of SkiaSharp.Views.WinUI.Native.PropertySetExtensions. The crash occurs in the ANGLE/OpenGL rendering path (SKSwapChainPanel) when GlesContext.CreateSurface() calls PropertySetExtensions.AddSingle() to set EGL surface properties. The WinRT runtime cannot locate or activate the native C\u002B\u002B/WinRT component, suggesting a deployment or WinRT registration issue specific to certain machine configurations.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.85
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/reliability"
        ],
        "partner": "partner/maui"
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a MAUI app with LiveCharts2 that uses SkiaSharp for rendering",
            "Deploy to certain Windows 11 systems (Lenovo 83C4 confirmed)",
            "Observe crash when the chart control loads and attempts GL rendering"
          ],
          "codeSnippets": [
            "\u003CliveCharts:CartesianChart x:Name=\u0022Graph\u0022 AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022 AbsoluteLayout.LayoutFlags=\u0022PositionProportional,SizeProportional\u0022 ZoomMode=\u0022None\u0022 EasingFunction=\u0022{x:Null}\u0022 /\u003E"
          ],
          "environmentDetails": "Windows 11 (10.0.26100.7462), Lenovo 83C4 (IdeaPad), SkiaSharp 3.119.1, MAUI with LiveCharts2",
          "relatedIssues": [
            2948
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": false,
          "errorType": "COMException / TypeInitializationException",
          "errorMessage": "System.Runtime.InteropServices.COMException: Element not found. The type initializer for \u0027SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0027 threw an exception.",
          "stackTrace": "System.Runtime.InteropServices.COMException: Element not found.\n  at void Marshal.ThrowExceptionForHR(int errorCode)()\n  at new BaseActivationFactory(string typeNamespace, string typeFullName)()\n  at static PropertySetExtensions()()\nSystem.TypeInitializationException:\n  at IObjectReference PropertySetExtensions.get__objRef_global__SkiaSharp_Views_WinUI_Native_IPropertySetExtensionsStatics()()\n  at void PropertySetExtensions.AddSingle(PropertySet propertySet, string key, float value)()\n  at void GlesContext.CreateSurface(SwapChainPanel panel, Size? renderSurfaceSize, float? resolutionScale)()\n  at void AngleSwapChainPanel.EnsureRenderSurface()()\n  at void AngleSwapChainPanel.OnLoaded(object sender, RoutedEventArgs e)()\n  at int RoutedEventHandler.Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e)()",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-windows10.0.19041.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.1"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The PropertySetExtensions WinRT component and ANGLE rendering path have not changed since 3.119.1. The native WinUI component architecture is the same on main."
        }
      },
      "analysis": {
        "summary": "The crash occurs because the WinRT runtime cannot activate the SkiaSharp.Views.WinUI.Native.PropertySetExtensions class from the native C\u002B\u002B/WinRT component DLL. This class is only used in the ANGLE/OpenGL rendering path (SKSwapChainPanel \u2192 GlesContext.CreateSurface), not in the CPU rendering path (SKXamlCanvas). LiveCharts2 appears to use the GL view (SKGLView \u2192 SKSwapChainPanel) on Windows, triggering this code path. The \u0027Element not found\u0027 COMException from BaseActivationFactory indicates the WinRT activation infrastructure cannot locate the class registration \u2014 either the native DLL is not deployed, is the wrong architecture, or the activation metadata is missing. Issue #2948 reported the identical stack trace with a different COM error (REGDB_E_CLASSNOTREG / 0x80040154) during Microsoft Store certification and was resolved externally. The \u0027certain systems\u0027 qualifier suggests an environment-specific deployment or WinRT registration issue.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/GlesContext.cs",
            "finding": "CreateSurface() calls PropertySetExtensions.AddSingle() at line 104 and PropertySetExtensions.AddSize() at line 98 to configure EGL surface creation properties. These are the call sites that trigger the WinRT activation of the native component.",
            "relevance": "direct",
            "lines": "77-114"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/PropertySetExtensions.cpp",
            "finding": "The C\u002B\u002B/WinRT component implementation is straightforward \u2014 just wraps PropertyValue::CreateSingle() and PropertyValue::CreateSize(). The code itself is correct; the issue is WinRT activation, not the implementation.",
            "relevance": "direct",
            "lines": "1-19"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/PropertySetExtensions.idl",
            "finding": "IDL declares the runtimeclass in namespace SkiaSharp.Views.WinUI.Native. WinRT activation requires the DLL containing this class to be findable by the activation system.",
            "relevance": "direct",
            "lines": "1-8"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "finding": "OnLoaded creates GlesContext and calls EnsureRenderSurface(), which calls glesContext.CreateSurface(). This is the entry point from the XAML lifecycle that triggers the crash.",
            "relevance": "direct",
            "lines": "124-135"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "finding": "SKXamlCanvas is entirely managed \u2014 uses WriteableBitmap for CPU rendering, no dependency on SkiaSharp.Views.WinUI.Native. Confirmed as an unaffected alternative rendering path.",
            "relevance": "related",
            "lines": "1-279"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.WinUI/SkiaSharp.NativeAssets.WinUI.csproj",
            "finding": "NativeAssets.WinUI package includes architecture-specific DLLs (x64, x86, arm64) from output/native/winui/. If this package\u0027s content is not properly deployed, the WinRT DLL will be missing.",
            "relevance": "related",
            "lines": "8-15"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.Windows.cs",
            "finding": "MAUI\u0027s SKGLViewHandler on Windows creates SKSwapChainPanel (the ANGLE/GL path). LiveCharts2 uses this GL view handler, causing it to hit the PropertySetExtensions activation path.",
            "relevance": "related",
            "lines": "7-13"
          }
        ],
        "rationale": "Classified as type/bug because this is a crash with a clear stack trace during normal rendering. The area is SkiaSharp.Views.Maui because the reporter uses MAUI, though the actual failure is in the WinUI views layer (SkiaSharp.Views.WinUI.Native). The crash is specific to the OpenGL/ANGLE backend path because PropertySetExtensions is only invoked during EGL surface creation in GlesContext.CreateSurface. Severity is high because it completely prevents rendering, but not critical because it only affects certain systems and only the GL path.",
        "keySignals": [
          {
            "text": "COMException: Element not found at BaseActivationFactory",
            "source": "issue body",
            "interpretation": "WinRT activation failure \u2014 the runtime cannot find the class registration for PropertySetExtensions. This is a deployment/packaging issue, not a code logic bug."
          },
          {
            "text": "crashes on certain systems",
            "source": "issue body",
            "interpretation": "Environment-specific \u2014 not all Windows deployments are affected, pointing to machine-specific factors (policy, DLL deployment, architecture)."
          },
          {
            "text": "We have tried both with HA enabled and disabled",
            "source": "issue body",
            "interpretation": "Reporter tested hardware acceleration toggle \u2014 rules out simple GPU driver issues. The problem is in WinRT component activation, not GPU rendering itself."
          },
          {
            "text": "SKGLViewHandler.Windows.cs uses SKSwapChainPanel (line 7)",
            "source": "code search",
            "interpretation": "MAUI\u0027s GL view handler on Windows creates SKSwapChainPanel, which inherits AngleSwapChainPanel, which calls PropertySetExtensions via GlesContext. LiveCharts2 likely uses the GL view path."
          },
          {
            "text": "SKCanvasViewHandler.Windows.cs uses SKXamlCanvas (line 8)",
            "source": "code search",
            "interpretation": "The CPU rendering path (SKXamlCanvas) does NOT use PropertySetExtensions at all \u2014 it\u0027s a pure managed implementation. This path would not be affected."
          },
          {
            "text": "#2948 closed: \u0027fixed by Microsoft Store adjusting their setup\u0027",
            "source": "issue #2948 comment",
            "interpretation": "Identical stack trace with different COM error code. External environment fix resolved it \u2014 further evidence this is deployment/environment, not a code bug."
          }
        ],
        "errorFingerprint": "COMException-ElementNotFound-PropertySetExtensions-WinUI",
        "workarounds": [
          "If LiveCharts2 supports it, configure the chart to use CPU rendering (SKCanvasView) instead of GPU rendering (SKGLView) to avoid the ANGLE/PropertySetExtensions code path entirely.",
          "Add an explicit PackageReference to SkiaSharp.NativeAssets.WinUI in the application project to ensure the native DLLs are deployed correctly, rather than relying on transitive references through LiveCharts2.",
          "Verify that SkiaSharp.Views.WinUI.Native.dll, libEGL.dll, and libGLESv2.dll are present in the application output directory after publish."
        ],
        "nextQuestions": [
          "Is the app deployed as packaged (MSIX) or unpackaged? Unpackaged WinUI apps may have different WinRT activation behavior.",
          "Are the native WinUI DLLs (SkiaSharp.Views.WinUI.Native.dll, libEGL.dll, libGLESv2.dll) present in the deployment output on the affected system?",
          "What is the target architecture (x64, x86, arm64) and does it match the deployed native binaries?",
          "Is the app published as framework-dependent or self-contained? Framework-dependent publish may not copy native assets correctly.",
          "Does LiveCharts2 offer a way to use SKCanvasView (CPU) instead of SKGLView (GPU) on Windows?"
        ],
        "resolution": {
          "hypothesis": "The WinRT activation of SkiaSharp.Views.WinUI.Native.PropertySetExtensions fails on certain systems because the native C\u002B\u002B/WinRT DLL is either not deployed to the output directory, is the wrong architecture, or the WinRT activation metadata is not properly registered in the app\u0027s deployment manifest. This is a deployment/packaging issue that manifests environment-specifically, similar to #2948.",
          "proposals": [
            {
              "description": "Check that SkiaSharp.Views.WinUI.Native.dll is present alongside the app executable on the failing system. If missing, add an explicit PackageReference to SkiaSharp.NativeAssets.WinUI in the application project.",
              "title": "Verify native DLL deployment",
              "codeSnippet": "\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.WinUI\u0022 Version=\u00223.119.1\u0022 /\u003E",
              "confidence": 0.65,
              "effort": "trivial"
            },
            {
              "description": "If LiveCharts2 supports it, configure the rendering to use SKCanvasView (CPU/WriteableBitmap) instead of SKGLView (ANGLE/OpenGL) on Windows. This completely avoids the PropertySetExtensions WinRT component. This is the most robust workaround since it eliminates the dependency on the native WinUI component.",
              "title": "Switch to CPU rendering path",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Replace the WinRT PropertySetExtensions component with direct P/Invoke or managed code in GlesContext.CreateSurface(). The component only does PropertyValue::CreateSingle() and PropertyValue::CreateSize() \u2014 these could potentially be done via the managed WinRT APIs without a separate native DLL, eliminating the WinRT activation requirement entirely.",
              "title": "Eliminate PropertySetExtensions dependency",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Verify native DLL deployment",
          "recommendedReason": "Most likely root cause based on #2948 precedent. Quick to verify and eliminates the most common cause of WinRT activation failures. If the DLLs are present, then the CPU rendering workaround is the next best option."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.8,
          "reason": "Need to confirm whether native DLLs are present on the failing system, the deployment mode (packaged vs unpackaged, self-contained vs framework-dependent), and architecture details to diagnose the WinRT activation failure."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp.Views.Maui, os/Windows-WinUI, tenet/reliability all apply",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Maui",
              "os/Windows-WinUI",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Request deployment details and suggest diagnostic steps",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the stack trace \u2014 this helps narrow things down.\n\nThe crash is in the WinRT activation of \u0060SkiaSharp.Views.WinUI.Native.PropertySetExtensions\u0060, which is a native C\u002B\u002B/WinRT component used only by the OpenGL/ANGLE rendering path (\u0060SKSwapChainPanel\u0060). LiveCharts2 uses this GPU-accelerated path on Windows. The \u0022Element not found\u0022 error means the WinRT runtime can\u0027t locate the component\u0027s class registration on the affected system.\n\nWe\u0027ve seen a very similar issue before (#2948) where the same stack trace appeared during Microsoft Store certification \u2014 that turned out to be an environment/deployment issue.\n\nTo help diagnose:\n1. Could you check if \u0060SkiaSharp.Views.WinUI.Native.dll\u0060 is present in your app\u0027s output directory on the affected machine?\n2. Is the app deployed as packaged (MSIX) or unpackaged?\n3. Is it published as self-contained or framework-dependent?\n4. What target architecture are you building for (x64, arm64)?\n\nAs an immediate workaround, you can try adding an explicit package reference to ensure the native assets are deployed:\n\n\u0060\u0060\u0060xml\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.WinUI\u0022 Version=\u00223.119.1\u0022 /\u003E\n\u0060\u0060\u0060\n\nIf LiveCharts2 supports configuring the rendering backend, switching to CPU rendering (which uses \u0060SKXamlCanvas\u0060 instead of \u0060SKSwapChainPanel\u0060) would bypass this component entirely."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #2948 \u2014 identical stack trace, different COM error code",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 2948
          }
        ],
        "missingInfo": [
          "Whether SkiaSharp.Views.WinUI.Native.dll is present in the app\u0027s output/deployment directory on the affected system",
          "Deployment mode: packaged (MSIX) or unpackaged, self-contained or framework-dependent",
          "Target architecture (x64, x86, or arm64) of the published app",
          "Whether the issue is reproducible on a clean Windows 11 install or only on specific machines"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3437,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:52:04Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability",
          "backend/SVG"
        ]
      },
      "summary": "When using SKSvgCanvas in parallel via Task.Run on Windows, \u003Ctext\u003E elements intermittently lose their text content and x/y attribute values, producing empty \u003Ctext\u003E tags. The issue is a data race in Skia\u0027s text rendering pipeline (GlyphsToUnichars \u2192 DirectWrite font subsystem) that manifests only on Windows. It affects all SkiaSharp 3.x versions and is a regression from 2.88.9. Linux is unaffected.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.8
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/SVG"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create multiple parallel tasks via Task.Run",
            "In each task, create an SKSvgCanvas writing to a MemoryStream",
            "Draw multiple text elements using canvas.DrawText with a font",
            "Dispose the canvas to flush SVG output",
            "Check the SVG string for blank \u003Ctext\u003E elements (regex: \u003E\\s\u002B\u003C/text\u003E)"
          ],
          "codeSnippets": [
            "await Task.WhenAll(Enumerable.Range(0, 5).Select(i =\u003E Task.Run(() =\u003E drawSvgFunc(i)))).ConfigureAwait(false);"
          ],
          "environmentDetails": "Windows 11, Visual Studio Code, SkiaSharp 3.116.0 / 3.119.1 / 3.119.2-preview.1",
          "repoLinks": [
            {
              "url": "https://github.com/jankurianski/skiasharp-svg-text-missing-bug",
              "description": "Full reproduction project by reporter"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "data-corruption",
          "errorMessage": "SVG \u003Ctext\u003E elements have empty text content and empty x/y attributes when SKSvgCanvas is used in parallel threads",
          "reproQuality": "complete"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "3.119.2-preview.1",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The SVG text rendering code path (SkSVGDevice::onDrawGlyphRunList \u2192 SVGTextBuilder \u2192 GlyphsToUnichars) has not changed between 3.116.0 and the current main branch. The underlying DirectWrite font subsystem code is also unchanged."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Reporter explicitly states 2.88.9 does not have the bug. The entire text rendering pipeline was rewritten between SkiaSharp 2.x and 3.x (Skia upgraded from m88 to m116\u002B), changing how glyphs are shaped, cached, and reversed to unicode. The new pipeline likely introduced a thread-safety issue in the Windows DirectWrite font subsystem.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "Data race in Skia\u0027s SVG text rendering on Windows. When multiple threads create separate SKSvgCanvas instances and draw text, the SVG \u003Ctext\u003E elements intermittently lose their content. The SVGTextBuilder (SkSVGDevice.cpp:1033) calls SkFontPriv::GlyphsToUnichars to reverse glyph IDs back to unicode characters. This calls typeface-\u003EgetGlyphToUnicodeMap() which on Windows uses DirectWrite COM interfaces (IDWriteFontFace). The race likely occurs in the shared DirectWrite font subsystem or Skia\u0027s internal glyph/strike caching, causing GlyphsToUnichars to return all-zero values, which SVGTextBuilder discards as NUL characters, producing empty text and position strings.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKSVG.cs",
            "finding": "SKSvgCanvas.Create delegates directly to sk_svgcanvas_create_with_stream. No threading protection or documentation about thread-safety. Each call creates a separate canvas backed by a separate stream, so the C# layer itself is thread-safe.",
            "relevance": "context",
            "lines": "17-33"
          },
          {
            "file": "externals/skia/src/svg/SkSVGDevice.cpp",
            "finding": "SVGTextBuilder (line 1033) reverses glyph IDs to unicode via SkFontPriv::GlyphsToUnichars. If GlyphsToUnichars returns all NUL (\\0) values, the switch at line 1068 discards all characters (discardPos=true), producing empty fText/fPosXStr/fPosYStr \u2014 exactly matching the reported symptoms.",
            "relevance": "direct",
            "lines": "1033-1150"
          },
          {
            "file": "externals/skia/src/core/SkFont.cpp",
            "finding": "GlyphsToUnichars calls typeface-\u003EgetGlyphToUnicodeMap() which allocates a buffer of numGlyphs unichars and fills it via the platform-specific typeface implementation. On concurrent access, the typeface\u0027s internal state or the glyph-to-unicode map could be corrupted.",
            "relevance": "direct",
            "lines": "477-491"
          },
          {
            "file": "externals/skia/src/ports/SkTypeface_win_dw.cpp",
            "finding": "DWriteFontTypeface::getGlyphToUnicodeMap accesses IDWriteFontFace and IDWriteFontFace1 COM interfaces. Uses GetGlyphCount(), GetUnicodeRanges(), and glyph_to_unicode_map() which call GetGlyphIndices(). DirectWrite is documented as thread-safe for most read operations, but there may be undocumented races in the font face caching or when multiple threads call GetGlyphIndices simultaneously.",
            "relevance": "direct",
            "lines": "610-631"
          },
          {
            "file": "externals/skia/src/c/sk_svg.cpp",
            "finding": "The C API sk_svgcanvas_create_with_stream does not expose the flags parameter from SkSVGCanvas::Make. The kConvertTextToPaths_Flag (which would avoid the GlyphsToUnichars code path) is not available through the SkiaSharp API.",
            "relevance": "related",
            "lines": "16-18"
          },
          {
            "file": "externals/skia/include/svg/SkSVGCanvas.h",
            "finding": "SkSVGCanvas supports kConvertTextToPaths_Flag which emits text as \u003Cpath\u003E elements instead of \u003Ctext\u003E. This bypasses GlyphsToUnichars entirely and would avoid the race condition, but the flag is not exposed in the C API.",
            "relevance": "related",
            "lines": "23-26"
          }
        ],
        "rationale": "This is clearly a bug (type/bug, 0.98) \u2014 the reporter describes broken output that should work. Area is area/SkiaSharp rather than area/libSkiaSharp.native because while the root cause is in native Skia code, the fix surface includes both the C API (missing flags parameter) and potentially the C# layer. Severity is high because text rendering silently produces corrupt output with no error. The Windows-only \u002B Linux-unaffected pattern strongly points to the DirectWrite font backend as the differentiator (FreeType on Linux vs DirectWrite on Windows).",
        "keySignals": [
          {
            "text": "The more text elements being drawn and the more threads running the same task, the more likely the problem is to occur",
            "source": "issue body",
            "interpretation": "Classic data race signature \u2014 probability increases with contention, not deterministic."
          },
          {
            "text": "This affects all SkiaSharp 3.x versions on Windows. Linux is unaffected.",
            "source": "issue body",
            "interpretation": "Platform-specific font backend is the differentiator. Windows uses DirectWrite (SkTypeface_win_dw), Linux uses FreeType (SkFontHost_FreeType). The bug is in the Windows-specific code path."
          },
          {
            "text": "This is a regression from SkiaSharp 2.88.9 which does not have the bug.",
            "source": "issue body",
            "interpretation": "Skia\u0027s text pipeline was rewritten between m88 and m116. The GlyphRunBuilder and strike cache architecture changed significantly."
          },
          {
            "text": "\u003Ctext\u003E elements have empty x/y attributes and no text content",
            "source": "issue body (actual behavior)",
            "interpretation": "SVGTextBuilder.fText, fPosXStr, fPosYStr are all empty. This means either runSize was 0 or all unichars were NUL (\\0), causing all characters to be discarded in the switch(c) case \u0027\\0\u0027 branch at SkSVGDevice.cpp:1068-1073."
          },
          {
            "text": "I tested on Ubuntu 22.04.2 LTS (using WSL) and the bug does not occur there, even with 100 text elements and 50 parallel tasks",
            "source": "comment #2",
            "interpretation": "Confirms Windows-only. FreeType\u0027s getGlyphToUnicodeMap uses its own cmap parsing which is likely thread-safe, while DWrite\u0027s implementation may have COM threading issues."
          }
        ],
        "workarounds": [
          "Serialize SVG generation tasks using SemaphoreSlim(1,1) or a lock to ensure only one thread renders SVG text at a time on Windows.",
          "Use sequential processing instead of Parallel/Task.Run for SVG generation on Windows."
        ],
        "nextQuestions": [
          "Is the race in DWrite\u0027s IDWriteFontFace::GetGlyphIndices or in Skia\u0027s glyph cache/strike cache?",
          "Would exposing kConvertTextToPaths_Flag in the C API be a viable permanent workaround?",
          "Does the issue reproduce with SKSurface (raster) \u002B drawText \u002B readPixels in parallel, or is it specific to the SVG text\u2192unicode reversal path?",
          "Can we reproduce this with a pure Skia C\u002B\u002B test to confirm it\u0027s an upstream Skia bug?"
        ],
        "resolution": {
          "hypothesis": "The race condition occurs in the DWrite font subsystem when multiple threads simultaneously call getGlyphToUnicodeMap on the same or related typeface instances. On Windows, concurrent GetGlyphIndices calls through IDWriteFontFace may corrupt the glyph-to-unicode mapping, causing GlyphsToUnichars to return NUL characters. The SVGTextBuilder then discards all NUL characters, producing empty text and position attributes. FreeType on Linux likely has better internal locking, explaining the platform difference.",
          "proposals": [
            {
              "description": "Users can wrap their SVG generation in a SemaphoreSlim(1,1) to ensure only one thread renders SVG at a time. This is a workaround, not a fix, but unblocks the reporter immediately.",
              "title": "Serialize SVG text rendering (workaround)",
              "codeSnippet": "private static readonly SemaphoreSlim _svgLock = new SemaphoreSlim(1, 1);\n\nawait Task.WhenAll(Enumerable.Range(0, 5).Select(i =\u003E Task.Run(async () =\u003E {\n    await _svgLock.WaitAsync();\n    try {\n        return drawSvgFunc(i);\n    } finally {\n        _svgLock.Release();\n    }\n})));",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Add a flags parameter to sk_svgcanvas_create_with_stream (or a new overload sk_svgcanvas_create_with_stream_and_flags) to expose SkSVGCanvas::kConvertTextToPaths_Flag. When enabled, text is emitted as \u003Cpath\u003E elements, completely bypassing the GlyphsToUnichars code path and the race condition. Trade-off: SVG text is no longer selectable/searchable.",
              "title": "Expose kConvertTextToPaths_Flag in C API",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Investigate and fix the data race in the Windows DirectWrite font path. This would involve identifying whether the race is in Skia\u0027s glyph cache or in DWrite COM calls, and adding appropriate synchronization. May require an upstream Skia bug report.",
              "title": "Fix upstream thread-safety in Skia DWrite font subsystem",
              "confidence": 0.5,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Serialize SVG text rendering (workaround)",
          "recommendedReason": "Immediately unblocks the reporter with a simple code change. The flag exposure and upstream fix are better long-term solutions but require more investigation and code changes."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Confirmed bug with complete reproduction, regression from 2.x to 3.x. Root cause is likely in Skia\u0027s Windows DirectWrite font subsystem threading. Needs deeper investigation to determine if fix should be in Skia (upstream), in the C API (expose flags), or both."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp, os/Windows-Classic, tenet/reliability, backend/SVG all match the classification.",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic",
              "tenet/reliability",
              "backend/SVG"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post acknowledgement with workaround and technical analysis",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the thorough report and reproduction repo \u2014 this is clearly a data race in Skia\u0027s text rendering pipeline on Windows.\n\nHere\u0027s a workaround you can use while we investigate: serialize your SVG generation tasks so only one thread renders at a time.\n\n\u0060\u0060\u0060csharp\nprivate static readonly SemaphoreSlim _svgLock = new SemaphoreSlim(1, 1);\n\nawait Task.WhenAll(Enumerable.Range(0, 5).Select(i =\u003E Task.Run(async () =\u003E {\n    await _svgLock.WaitAsync();\n    try {\n        return drawSvgFunc(i);\n    } finally {\n        _svgLock.Release();\n    }\n})));\n\u0060\u0060\u0060\n\nThe root cause appears to be in the SVG text rendering path: when \u0060SkSVGDevice\u0060 emits \u0060\u003Ctext\u003E\u0060 elements, it calls \u0060GlyphsToUnichars\u0060 to reverse glyph IDs back to unicode characters. On Windows, this goes through the DirectWrite font subsystem (\u0060IDWriteFontFace\u0060) which has a threading issue causing the glyph-to-unicode mapping to return empty/NUL values under concurrent access. FreeType on Linux doesn\u0027t have this issue, explaining the platform difference.\n\nWe\u0027re also looking at exposing Skia\u0027s \u0060kConvertTextToPaths_Flag\u0060 which would avoid this code path entirely by emitting text as \u0060\u003Cpath\u003E\u0060 elements (trade-off: text is no longer selectable in the SVG)."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3435,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:47:05Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "DllNotFoundException for libSkiaSharp in a Blazor WASM app after upgrading from .NET 9 to .NET 10. Tried SkiaSharp 3.116.1 and 3.119.2-preview.1; both fail on .NET 10 though 3.116.1 worked on .NET 9. This is a duplicate of #3422 \u2014 SkiaSharp does not yet target net10.0 (TFMCurrent is net8.0, TFMNext is empty), so the Blazor WASM package has no net10.0 assets and native static linking fails. PR #3514 tracks adding .NET 10 support.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.92
        },
        "platforms": [
          "os/WASM"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create or upgrade a Blazor WASM app to .NET 10",
            "Add SkiaSharp.Views.Blazor 3.116.1 or 3.119.2-preview.1",
            "Run the app \u2014 DllNotFoundException: libSkiaSharp at runtime"
          ],
          "environmentDetails": "Blazor WASM, .NET 10, SkiaSharp 3.116.1 and 3.119.2-preview.1",
          "relatedIssues": [
            3422
          ],
          "repoLinks": [
            {
              "url": "https://github.com/user/repo",
              "description": "Reporter\u0027s reproduction repository"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "DllNotFoundException",
          "errorMessage": "System.DllNotFoundException: libSkiaSharp",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net10.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.1",
            "3.119.2-preview.1"
          ],
          "workedIn": "3.116.1 on .NET 9",
          "brokeIn": "3.116.1 on .NET 10",
          "currentRelevance": "likely",
          "relevanceReason": "SkiaSharp still does not target net10.0 \u2014 TFMCurrent is net8.0 and TFMNext is empty in source/SkiaSharp.Build.props. PR #3514 is open but not yet merged."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.9,
          "reason": "Not a regression in SkiaSharp \u2014 the same SkiaSharp version works on .NET 9. The failure is caused by upgrading the .NET SDK to 10, which SkiaSharp does not yet support. The behavior is \u0027not yet supported\u0027 rather than \u0027previously worked and broke\u0027."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.85,
          "reason": "PR #3514 (Update to .NET 10 SDK and restructure TFMs) is open and would resolve this, but it has not been merged yet.",
          "relatedPRs": [
            3514
          ]
        }
      },
      "analysis": {
        "summary": "Blazor WASM on .NET 10 fails with DllNotFoundException because SkiaSharp does not yet target net10.0. WASM uses static linking \u2014 the .a files are compiled into dotnet.wasm via NativeFileReference at build time. While the NativeFileReference targets file has a net9.0\u002B fallback condition, the Blazor Views package itself only ships net8.0 and net6.0 TFMs, so .NET 10 projects cannot consume it properly. This is identical to #3422.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "TFMPrevious=net6.0, TFMCurrent=net8.0, TFMNext is empty. No .NET 10 target framework is configured.",
            "relevance": "direct",
            "lines": "62-66"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SkiaSharp.Views.Blazor.csproj",
            "finding": "TargetFrameworks=$(TFMCurrent);$(TFMPrevious);$(TFMNext) resolves to net8.0;net6.0 \u2014 no net10.0 target.",
            "relevance": "direct",
            "lines": "4"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.WebAssembly/buildTransitive/SkiaSharp.targets",
            "finding": "NativeFileReference conditions include a net9.0\u002B fallback (VersionGreaterThanOrEquals 9.0), but the Blazor package not having a net10.0 TFM means the overall integration is incomplete for .NET 10.",
            "relevance": "related",
            "lines": "32-40"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes a runtime failure, not a usage question. Area is SkiaSharp.Views.Blazor because the failure is specific to Blazor WASM deployment and the missing net10.0 TFM in the Blazor package. Platform is os/WASM (not os/Windows-Classic as currently labeled) because the issue is in the WASM static linking pipeline, not Windows-specific. Tenet is tenet/compatibility because this is about .NET version compatibility. This is a duplicate of #3422 which reports the exact same problem with more detail.",
        "keySignals": [
          {
            "text": "Started getting this runtime error after upgrading Blazor app from .Net 9 to .Net 10",
            "source": "issue body",
            "interpretation": "The .NET SDK upgrade is the trigger \u2014 SkiaSharp version didn\u0027t change, ruling out a SkiaSharp regression."
          },
          {
            "text": ".Net 9 app worked with 3.116.1",
            "source": "issue body",
            "interpretation": "Confirms the same SkiaSharp version works on .NET 9. The gap is .NET 10 support, not a SkiaSharp defect."
          },
          {
            "text": "Duplicate of #3422",
            "source": "comment #2 by Webreaper",
            "interpretation": "Community member identified this as a duplicate. #3422 has a full triage confirming the same root cause."
          },
          {
            "text": "TFMCurrent=net8.0, TFMNext is empty",
            "source": "code search: source/SkiaSharp.Build.props:64-66",
            "interpretation": "No .NET 10 TFM configured \u2014 the Blazor package ships net8.0;net6.0 only."
          }
        ],
        "errorFingerprint": "DllNotFoundException-libSkiaSharp-WASM-net10",
        "workarounds": [
          "Stay on .NET 9 until SkiaSharp officially adds .NET 10 support (PR #3514)",
          "Run \u0060dotnet workload install wasm-tools\u0060 \u2014 reported to help for some users on Windows (not confirmed universally)"
        ],
        "nextQuestions": [
          "Will PR #3514 fully resolve this, or are additional Emscripten version changes needed for .NET 10?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp does not yet target .NET 10. The Blazor WASM package only ships net8.0 and net6.0 TFMs, so .NET 10 projects fail at the native static linking step, producing a DllNotFoundException.",
          "proposals": [
            {
              "description": "Downgrade the project to net9.0 until SkiaSharp ships official .NET 10 support. .NET 9 \u002B SkiaSharp 3.116.1 is a known-working combination for Blazor WASM.",
              "title": "Stay on .NET 9",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "PR #3514 restructures TFMs to include net10.0 as TFMCurrent and updates the SDK. This is the proper fix that will add official .NET 10 support to SkiaSharp including the Blazor WASM package.",
              "title": "Merge PR #3514",
              "confidence": 0.85,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Stay on .NET 9",
          "recommendedReason": "Immediate workaround with high confidence. The proper fix (PR #3514) is pending review and not yet available to end users."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.92,
          "reason": "Identical root cause to #3422 (Blazor WASM \u002B .NET 10 = DllNotFoundException). Community member already identified the duplicate. #3422 has a more detailed report with code samples and broader version testing."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix incorrect labels: replace os/Windows-Classic with os/WASM and area/libSkiaSharp.native with area/SkiaSharp.Views.Blazor; add tenet/compatibility",
            "risk": "low",
            "confidence": 0.92,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Blazor",
              "os/WASM",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #3422 \u2014 same root cause (no .NET 10 TFM support in Blazor WASM package)",
            "risk": "medium",
            "confidence": 0.92,
            "linkedIssue": 3422
          },
          {
            "type": "add-comment",
            "description": "Post duplicate acknowledgement with workaround",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the report. This is a duplicate of #3422 \u2014 SkiaSharp does not yet target .NET 10, so the Blazor WASM native static linking fails.\n\nAs a workaround, stay on .NET 9 until .NET 10 support ships. PR #3514 tracks adding .NET 10 TFM support.\n\nClosing as duplicate of #3422."
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #3422",
            "risk": "medium",
            "confidence": 0.9
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3433,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:19:39Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR updating Microsoft.Windows.CsWinRT from 2.0.4 to 2.2.0 in SkiaSharp.Views.WinUI.Native.Projection to resolve trimming/AOT warnings (IL2026, IL2104) reported in #3327. Also adds CsWinRTWindowsMetadata property to work around a CsWinRT 2.2.0 code-generation bug (microsoft/CsWinRT#2214) where generated code references a non-existent IBufferMethods.IID when using .NET SDK 8.0.100\u0027s bundled Windows metadata. Build has not been verified by CI; the contributor confirmed it builds locally for externals-winui but has backward-compatibility concerns about pinning metadata version.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.9
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Use SkiaSharp.Views.WinUI 3.119.0 in a WinUI3 app with PublishAot=true",
            "Build in Release mode",
            "Observe IL2104/IL2026 trimming warnings from SkiaSharp.Views.WinUI.Native.Projection.dll"
          ],
          "environmentDetails": "Windows, Visual Studio, SkiaSharp 3.119.0, .NET 8, WinUI3",
          "relatedIssues": [
            3327
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "build-warning",
          "errorMessage": "Assembly \u0027SkiaSharp.Views.WinUI.Native.Projection\u0027 produced trim warnings (IL2104); IL2026: WinRT.WinrtModule.GetActivationFactory uses RequiresUnreferencedCode member",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-windows10.0.19041.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The Projection csproj on main still uses CsWinRT 2.0.4, which has the trim-unsafe WinRT interop code. The bug persists."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "This PR is the proposed fix but has not been merged. CsWinRT 2.0.4 is still on main. CI has not run on this PR.",
          "relatedPRs": [
            3433
          ]
        }
      },
      "analysis": {
        "summary": "PR #3433 addresses trimming warnings in SkiaSharp.Views.WinUI.Native.Projection by upgrading CsWinRT from 2.0.4 to 2.2.0 (which adds trimming/AOT safety). CsWinRT 2.2.0 has a code-generation change that references IBufferMethods.IID \u2014 a property that only exists in newer Windows SDK projections. The fix adds CsWinRTWindowsMetadata=10.0.17763.57 to force the correct metadata version. This is a valid workaround confirmed by CsWinRT maintainers in microsoft/CsWinRT#2214. However, there\u0027s an open concern: whether pinning CsWinRTWindowsMetadata affects end-users consuming the built NuGet package, and whether WindowsSdkPackageVersion would be a more appropriate approach.",
        "codeInvestigation": [
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native.Projection/SkiaSharp.Views.WinUI.Native.Projection.csproj",
            "finding": "Currently uses Microsoft.Windows.CsWinRT 2.0.4. CsWinRTIncludes is set to SkiaSharp.Views.WinUI.Native. No CsWinRTWindowsMetadata or WindowsSdkPackageVersion is set. TargetFramework is $(WindowsTargetFrameworksPrevious) \u2014 net8.0-windows10.0.19041.0.",
            "relevance": "direct",
            "lines": "19"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/BufferExtensions.h",
            "finding": "The native WinUI component exposes BufferExtensions with GetByteBuffer(IBuffer), which is the IBuffer interface that triggers the CsWinRT codegen issue with IBufferMethods.IID.",
            "relevance": "direct",
            "lines": "1-23"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/UWPExtensions.cs",
            "finding": "C# code calls BufferExtensions.GetByteBuffer(buffer) \u2014 this is the consumer of the generated projection code that triggers the trim-unsafe paths.",
            "relevance": "related",
            "lines": "179-180"
          },
          {
            "file": "global.json",
            "finding": "SDK pinned to 8.0.100 with rollForward: latestMinor. This SDK bundles older Windows metadata that lacks IBufferMethods.IID, which is why CsWinRTWindowsMetadata is needed.",
            "relevance": "context"
          },
          {
            "file": "source/SkiaSharp.Build.targets",
            "finding": "Build targets reference CsWinRTReplaceForPatchedRuntime for assembly signing when CsWinRTIncludes is set \u2014 confirms CsWinRT is integrated into the broader build pipeline.",
            "relevance": "context",
            "lines": "164-165"
          }
        ],
        "rationale": "Classified as type/bug because #3327 reports trimming warnings that may cause runtime crashes under NativeAOT \u2014 this is broken behavior, not a feature request. Area is SkiaSharp.Views because the affected file is the WinUI native projection used by SkiaSharp.Views.WinUI. Platform is WinUI-specific. Tenet is compatibility since trimming/AOT support is a compatibility concern.",
        "keySignals": [
          {
            "text": "CsWinRT version 2.0.4 \u2192 2.2.0 in SkiaSharp.Views.WinUI.Native.Projection.csproj",
            "source": "PR diff",
            "interpretation": "Core change \u2014 CsWinRT 2.2.0 is the latest stable and adds trimming/AOT safety for WinRT interop."
          },
          {
            "text": "error CS0117: \u0027IBufferMethods\u0027 does not contain a definition for \u0027IID\u0027",
            "source": "comment #2 (mattleibow)",
            "interpretation": "Build error from internal CI. CsWinRT 2.2.0 codegen references IBufferMethods.IID which doesn\u0027t exist in SDK 8.0.100\u0027s bundled Windows metadata."
          },
          {
            "text": "CsWinRTWindowsMetadata=10.0.17763.57 added to fix build",
            "source": "PR diff \u002B comment #4 (wangfys)",
            "interpretation": "Forces a specific Windows metadata version so CsWinRT 2.2.0\u0027s codegen finds the IID property. Confirmed by CsWinRT maintainers as the correct approach."
          },
          {
            "text": "concerned about what if users of SkiaSharp use an old version",
            "source": "comment #4 (wangfys)",
            "interpretation": "Open question about backward compatibility. The CsWinRTWindowsMetadata property affects build-time codegen, not runtime \u2014 but needs maintainer review."
          },
          {
            "text": "In your case though, this means you\u0027re using an outdated version of the Windows SDK projections",
            "source": "CsWinRT issue #2214 comment (dongle-the-gadget)",
            "interpretation": "CsWinRT maintainer confirms the root cause is outdated SDK projections, and suggests WindowsSdkPackageVersion as the proper fix."
          }
        ],
        "nextQuestions": [
          "Should WindowsSdkPackageVersion be used instead of CsWinRTWindowsMetadata for broader SDK compatibility?",
          "Does CsWinRTWindowsMetadata=10.0.17763.57 affect the runtime behavior of the built NuGet package for end-users on different Windows SDK versions?",
          "Should the PR also update global.json or SDK pinning to a newer .NET SDK that bundles compatible Windows metadata?",
          "Has the PR been rebased on main? The PR checklist shows \u0027Rebased on top of main\u0027 is unchecked.",
          "CI has not run \u2014 needs internal build trigger to verify the fix works end-to-end."
        ],
        "resolution": {
          "hypothesis": "CsWinRT 2.0.4 generates trim-unsafe WinRT interop code. Upgrading to 2.2.0 fixes the trimming warnings but requires pinning CsWinRTWindowsMetadata to provide compatible Windows SDK metadata for code generation.",
          "proposals": [
            {
              "description": "Accept the PR as-is after CI passes. The CsWinRTWindowsMetadata property is a build-time-only setting that doesn\u0027t affect runtime. CsWinRT maintainers confirmed this approach in microsoft/CsWinRT#2214.",
              "title": "Merge PR with CsWinRTWindowsMetadata",
              "confidence": 0.75,
              "effort": "trivial"
            },
            {
              "description": "Replace CsWinRTWindowsMetadata with WindowsSdkPackageVersion, which is the more standard MSBuild approach for pinning Windows SDK projection packages. This may be more forward-compatible.",
              "title": "Use WindowsSdkPackageVersion instead",
              "codeSnippet": "\u003CWindowsSdkPackageVersion\u003E10.0.17763.57\u003C/WindowsSdkPackageVersion\u003E",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Update global.json to a .NET SDK version that bundles Windows metadata compatible with CsWinRT 2.2.0, eliminating the need for CsWinRTWindowsMetadata entirely. More invasive but cleaner long-term.",
              "title": "Bump .NET SDK to include newer metadata",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Merge PR with CsWinRTWindowsMetadata",
          "recommendedReason": "The PR\u0027s approach is confirmed correct by CsWinRT maintainers. CsWinRTWindowsMetadata is build-time only and doesn\u0027t impact end-users. Low risk, directly fixes #3327."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "PR looks correct based on CsWinRT maintainer guidance, but CI has not run. Needs build verification and maintainer review of backward-compatibility concern before merge."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views, WinUI, and compatibility labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-WinUI",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference the bug this PR fixes",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3327
          },
          {
            "type": "add-comment",
            "description": "Acknowledge PR, provide technical review feedback on the approach and next steps",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the fix and for tracking down the CsWinRT codegen issue \u2014 the analysis of microsoft/CsWinRT#2214 is helpful.\n\nThe approach looks sound: CsWinRT 2.2.0 adds trimming/AOT safety, and \u0060CsWinRTWindowsMetadata\u0060 pins the Windows metadata version for build-time codegen. A few items to resolve before merge:\n\n1. **CI verification** \u2014 We\u0027ll need to run the internal build to confirm this passes end-to-end.\n2. **\u0060WindowsSdkPackageVersion\u0060 vs \u0060CsWinRTWindowsMetadata\u0060** \u2014 The CsWinRT maintainer suggested \u0060WindowsSdkPackageVersion\u0060 as the standard approach. Worth confirming whether \u0060CsWinRTWindowsMetadata\u0060 is equivalent or if \u0060WindowsSdkPackageVersion\u0060 is preferred.\n3. **Rebase** \u2014 Would you be able to rebase on top of the current \u0060main\u0060 branch?\n\nRegarding your backward-compatibility concern: \u0060CsWinRTWindowsMetadata\u0060 is a build-time property that controls code generation \u2014 it shouldn\u0027t affect consumers of the resulting NuGet package at runtime."
          }
        ],
        "missingInfo": [
          "CI build results \u2014 build has not been triggered",
          "Confirmation that CsWinRTWindowsMetadata doesn\u0027t affect end-user NuGet package behavior",
          "Whether WindowsSdkPackageVersion is preferred over CsWinRTWindowsMetadata"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3431,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:24:40Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "PR fixes NullReferenceException in Uno Platform SKXamlCanvas by separating pixel buffer and bitmap disposal \u2014 fixes #3430",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.Views.Uno",
          "confidence": 0.99
        },
        "platforms": [
          "os/Windows-WinUI",
          "os/WASM",
          "os/Linux",
          "os/macOS"
        ],
        "tenets": [
          "tenet/reliability"
        ],
        "partner": "partner/unoplatform"
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Use SKXamlCanvas in an Uno Platform Skia-based app",
            "Resize the canvas so that bitmap dimensions change but pixel dimensions also change",
            "FreeBitmap() at line 106 nulls the bitmap that was just recreated at line 91",
            "bitmap.PixelBuffer access at line 72 throws NullReferenceException"
          ],
          "environmentDetails": "Uno Platform Skia backend (Desktop/WASM), SkiaSharp 3.116.0\u002B",
          "relatedIssues": [
            3430
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "crash",
          "errorMessage": "NullReferenceException when canvas resizes \u2014 bitmap field nulled by FreeBitmap() called from pixel reallocation path",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The bug still exists in main \u2014 CreateBitmap() still has the coupled FreeBitmap() calls that null both pixels and bitmap together."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "Reporter states 2.88.9 was the last known good version. The Uno Skia canvas was rewritten for the v3 line with separate pixel/bitmap management but coupled disposal.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "PR #3431 correctly fixes the root cause of #3430 by decoupling pixel buffer (GCHandle-pinned byte[]) and WriteableBitmap lifecycle management. The original FreeBitmap() method freed both resources together, but CreateBitmap() has two independent conditions that each called it \u2014 bitmap size mismatch and pixel size mismatch \u2014 causing cross-contamination on resize.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs",
            "finding": "CreateBitmap() calls FreeBitmap() at two points: line 87 (bitmap size mismatch) and line 106 (pixel size mismatch). FreeBitmap() nulls BOTH pixels and bitmap. On resize, the second call destroys the bitmap that was just recreated between lines 89-101, causing NRE at line 72 (bitmap.PixelBuffer).",
            "relevance": "direct",
            "lines": "83-127"
          },
          {
            "file": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs",
            "finding": "DoUnloaded() only calls FreeBitmap() which frees pixels via GCHandle.Free() and nulls bitmap, but if pixels is already null (e.g. never allocated), the GCHandle isn\u0027t freed. Also, the PR correctly adds FreePixels() call.",
            "relevance": "direct",
            "lines": "34-35"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "finding": "WinUI version gets pixels from bitmap.GetPixels() \u2014 single lifecycle. FreeBitmap() just nulls bitmap/brush/pixels pointer. No GCHandle, no separate allocation. This is why the bug doesn\u0027t exist on WinUI.",
            "relevance": "related",
            "lines": "230-277"
          },
          {
            "file": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Wasm/SKXamlCanvas.Wasm.cs",
            "finding": "Wasm version has no bitmap field \u2014 only manages pixels/pixelsHandle. FreeBitmap() frees the GCHandle and clears the HTML canvas. No coupled disposal issue.",
            "relevance": "related",
            "lines": "73-100"
          }
        ],
        "rationale": "This is a community PR fixing a confirmed type/bug in area/SkiaSharp.Views.Uno. The Skia backend of Uno\u0027s SKXamlCanvas uses a separate GCHandle-pinned byte array (unlike WinUI which gets pixels directly from bitmap.GetPixels()), so pixel and bitmap lifetimes must be independent. The fix is minimal and correct: split FreeBitmap() into FreePixels() and FreeBitmap(), reorder allocation so pixels are allocated first, and update DoUnloaded() to free both. CI is currently failing.",
        "keySignals": [
          {
            "text": "FreeBitmap() nulls both pixels and bitmap, but called from two independent conditions",
            "source": "SKXamlCanvas.Skia.cs lines 87 and 106",
            "interpretation": "Root cause: coupled disposal in a split-condition method causes cross-resource destruction on resize."
          },
          {
            "text": "WinUI version uses bitmap.GetPixels() \u2014 single lifecycle, no separate pixel buffer",
            "source": "SKXamlCanvas.cs (WinUI) line 240",
            "interpretation": "Explains why WinUI doesn\u0027t have this bug \u2014 pixels are owned by the bitmap."
          },
          {
            "text": "DoUnloaded() only called FreeBitmap() \u2014 leaked GCHandle-pinned pixel buffer",
            "source": "SKXamlCanvas.Skia.cs line 34-35",
            "interpretation": "Secondary bug: unloading leaked pinned memory. PR fixes this by calling both FreeBitmap() and FreePixels()."
          },
          {
            "text": "CI status: failure \u2014 #3.119.2-pr.3431.1 failed",
            "source": "Azure Pipelines status check",
            "interpretation": "PR needs CI investigation before merge. May be flaky or unrelated failure."
          },
          {
            "text": "Wasm variant has only pixels (no bitmap field) \u2014 not affected by this specific bug",
            "source": "SKXamlCanvas.Wasm.cs lines 26-29, 78-86",
            "interpretation": "Wasm canvas correctly manages only pixel buffers. The bug is specific to the Skia backend which has both bitmap and pixels."
          }
        ],
        "nextQuestions": [
          "Why is CI failing? Is it a test failure related to this change or a pre-existing/flaky issue?",
          "Should the PR include a unit test that verifies resize doesn\u0027t throw?",
          "Does SKSwapChainPanel.Skia have a similar coupled-disposal pattern?"
        ],
        "resolution": {
          "hypothesis": "The Uno Skia SKXamlCanvas manages pixels (GCHandle-pinned byte[]) and bitmap (WriteableBitmap) independently, but FreeBitmap() freed both together. CreateBitmap() has two separate conditions calling FreeBitmap() \u2014 one for bitmap size mismatch and one for pixel size mismatch. On resize, the pixel-reallocation path destroys the just-recreated bitmap.",
          "proposals": [
            {
              "description": "The PR correctly splits FreeBitmap() into FreePixels() and FreeBitmap(), reorders allocation (pixels first, then bitmap), and updates DoUnloaded() to call both. Fix is minimal and surgical.",
              "title": "Merge PR #3431",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Add a unit test that creates an SKXamlCanvas, triggers a size change, and verifies no NRE. Currently no test coverage for Uno Skia canvas resize.",
              "title": "Add resize test",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Merge PR #3431",
          "recommendedReason": "The fix is correct, minimal, and matches the analysis from the #3430 triage. It also fixes a secondary GCHandle leak in DoUnloaded(). CI failure needs investigation first."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "PR is a correct fix for #3430. CI failure needs investigation before merge. The code change is reviewed and looks correct."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, Uno views area, platform, reliability, and partner labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Uno",
              "os/Windows-WinUI",
              "os/WASM",
              "os/Linux",
              "os/macOS",
              "tenet/reliability",
              "partner/unoplatform"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference the bug this PR fixes",
            "risk": "low",
            "confidence": 0.99,
            "linkedIssue": 3430
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3430,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:47:05Z",
        "currentLabels": [
          "type/bug",
          "os/WASM",
          "area/SkiaSharp.Views.Uno",
          "os/Windows-WinUI",
          "tenet/reliability"
        ]
      },
      "summary": "NullReferenceException in SKXamlCanvas.Skia.cs when canvas resizes \u2014 FreeBitmap() nulls bitmap field that was just recreated",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp.Views.Uno",
          "confidence": 0.99
        },
        "platforms": [
          "os/WASM",
          "os/Windows-WinUI",
          "os/Linux",
          "os/macOS"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Use Uno Platform\u0027s SKXamlCanvas on a Skia backend (WASM, WinUI via Skia, Linux, macOS)",
            "Resize the canvas so both bitmap and pixel dimensions change",
            "CreateBitmap() calls FreeBitmap() twice \u2014 second call nulls the freshly-created bitmap",
            "DoInvalidate() accesses bitmap.PixelBuffer.AsStream() on null bitmap \u2192 NRE"
          ],
          "environmentDetails": "Uno Platform Skia backends (WASM, Desktop), SkiaSharp 3.116.0",
          "relatedIssues": [
            2967,
            3255,
            3431
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": false,
          "errorType": "NullReferenceException",
          "errorMessage": "NullReferenceException at bitmap.PixelBuffer.AsStream() in DoInvalidate after CreateBitmap nulls bitmap",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "currentRelevance": "likely",
          "relevanceReason": "The buggy code in SKXamlCanvas.Skia.cs has not changed since commit c264c449b (Fix SKXamlCanvas on Uno Skia to use Bgra8888 #2918). The bug is still present on main."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "PR #3431 by the same author (MartinZikmund) provides the fix but has not been merged yet. The fix splits FreeBitmap into two methods: FreePixels() for pixel buffer management and FreeBitmap() for bitmap-only cleanup.",
          "relatedPRs": [
            3431
          ]
        }
      },
      "analysis": {
        "summary": "The FreeBitmap() method unconditionally nulls both the pixels array and the bitmap. In CreateBitmap(), when the canvas resizes, FreeBitmap() is called first for bitmap size mismatch (line 87), a new bitmap is created (lines 89-102), then FreeBitmap() is called again for pixel size mismatch (line 106), which nulls the just-created bitmap. DoInvalidate() then hits NRE at line 72 accessing bitmap.PixelBuffer.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs",
            "finding": "CreateBitmap() calls FreeBitmap() at line 87 (bitmap size mismatch) and again at line 106 (pixel size mismatch). The second call nulls bitmap that was just created at line 91. This is because FreeBitmap() unconditionally nulls both pixels and bitmap at lines 120-126.",
            "relevance": "direct",
            "lines": "86-113"
          },
          {
            "file": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs",
            "finding": "DoInvalidate() accesses bitmap.PixelBuffer.AsStream() at line 72 without null-checking bitmap. After CreateBitmap() returns with bitmap=null due to the double-free, this throws NRE.",
            "relevance": "direct",
            "lines": "68-78"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "finding": "WinUI version\u0027s CreateBitmap() only has one allocation block: create bitmap then get pixels from it via bitmap.GetPixels(). FreeBitmap() safely clears both because they share a lifecycle. The Uno Skia version diverges by using a separate GCHandle-pinned byte array.",
            "relevance": "related",
            "lines": "229-255"
          },
          {
            "file": "source/SkiaSharp.Views.Uno/SkiaSharp.Views.Uno.WinUI.Skia/SKXamlCanvas.Skia.cs",
            "finding": "FreeBitmap() sets both pixels=null and bitmap=null inside a single if(pixels!=null) guard. This couples two independent resources \u2014 the bitmap and the pinned pixel buffer \u2014 into a single disposal path.",
            "relevance": "direct",
            "lines": "118-126"
          }
        ],
        "rationale": "This is clearly a bug \u2014 the code path deterministically causes NRE whenever both bitmap and pixel dimensions change simultaneously (i.e., every canvas resize). The reporter linked the exact line and correctly identified the root cause. The WinUI version doesn\u0027t have this problem because pixels are obtained from bitmap.GetPixels() (single lifecycle), whereas the Uno Skia version uses a separate GCHandle-pinned byte array with an independent lifecycle. Severity is high because it\u0027s a crash on a common operation (canvas resize).",
        "keySignals": [
          {
            "text": "FreeBitmap method may have reset bitmap field to null",
            "source": "issue body",
            "interpretation": "Reporter correctly identified the root cause \u2014 FreeBitmap() nulls bitmap but is called twice in CreateBitmap()."
          },
          {
            "text": "bitmap?.PixelWidth != info.Width \u2192 FreeBitmap() ... then pixels == null \u2192 FreeBitmap() again",
            "source": "SKXamlCanvas.Skia.cs lines 86-113",
            "interpretation": "Second FreeBitmap() call at line 106 destroys the bitmap created at line 91, because FreeBitmap() unconditionally nulls both pixels and bitmap."
          },
          {
            "text": "WinUI version uses bitmap.GetPixels() \u2014 pixels tied to bitmap lifecycle",
            "source": "SkiaSharp.Views.WinUI/SKXamlCanvas.cs line 240",
            "interpretation": "The WinUI version has a single lifecycle for pixels\u002Bbitmap, so FreeBitmap() safely clears both. The Uno Skia version has separate lifecycles, making the combined free incorrect."
          },
          {
            "text": "PR #3431 splits FreeBitmap into FreePixels() and FreeBitmap()",
            "source": "PR #3431 diff",
            "interpretation": "Fix is already submitted by the reporter. The approach correctly separates the two lifecycles and reorders operations to handle pixels first, then bitmap."
          }
        ],
        "nextQuestions": [
          "Should the PR #3431 include a unit test that resizes the canvas and verifies no NRE?",
          "Are there other Uno platform-specific canvas types (e.g., WASM, Android, iOS) with similar combined disposal patterns?"
        ],
        "resolution": {
          "hypothesis": "FreeBitmap() couples two independent resource lifecycles (bitmap and pinned pixel buffer). When canvas resizes, both conditions trigger FreeBitmap(), and the second call destroys the bitmap that was just recreated between the two calls.",
          "proposals": [
            {
              "description": "PR #3431 by MartinZikmund correctly splits FreeBitmap() into FreePixels() (handles GCHandle \u002B byte array) and FreeBitmap() (handles bitmap only). It also reorders CreateBitmap() to handle pixels first, then bitmap, preventing the double-null scenario.",
              "title": "Merge PR #3431",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "As a defensive measure, add a null check for bitmap before accessing bitmap.PixelBuffer in DoInvalidate(). This doesn\u0027t fix the root cause but prevents the crash.",
              "title": "Add null guard in DoInvalidate",
              "codeSnippet": "if (bitmap == null)\n    return;\nusing (var data = bitmap.PixelBuffer.AsStream())\n{\n    data.Write(pixels, 0, pixels.Length);\n    data.Flush();\n}\nbitmap.Invalidate();",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3431",
          "recommendedReason": "The PR is already submitted by a trusted contributor (MartinZikmund, Uno Platform team), addresses the root cause by decoupling the two resource lifecycles, and follows the same split-responsibility pattern used elsewhere in the codebase."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.95,
          "reason": "Root cause is confirmed by code inspection, and a correct fix (PR #3431) is already submitted. The fix is minimal and surgical \u2014 it splits a method and reorders operations."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp.Views.Uno, os/WASM, os/Windows-WinUI, tenet/reliability. Add os/Linux and os/macOS since all Uno Skia backends are affected.",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Uno",
              "os/WASM",
              "os/Windows-WinUI",
              "os/Linux",
              "os/macOS",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug report and note that PR #3431 looks correct",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the detailed report and the fix in #3431.\n\nConfirmed the root cause: \u0060FreeBitmap()\u0060 nulls both \u0060pixels\u0060 and \u0060bitmap\u0060 together, but \u0060CreateBitmap()\u0060 has two separate conditions that each call \u0060FreeBitmap()\u0060. When the canvas resizes, the second call (for pixel size mismatch at line 106) destroys the bitmap that was just recreated (at line 91), causing the NRE at line 72.\n\nThe WinUI version avoids this because \u0060pixels\u0060 is obtained from \u0060bitmap.GetPixels()\u0060 \u2014 a single lifecycle. The Uno Skia version uses a separate \u0060GCHandle\u0060-pinned byte array, so the two resources need independent disposal.\n\nPR #3431\u0027s approach of splitting into \u0060FreePixels()\u0060 and \u0060FreeBitmap()\u0060 looks correct and minimal."
          },
          {
            "type": "link-related",
            "description": "Cross-reference PR #3431 which contains the fix",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3431
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3429,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:47:05Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "Memory leak in WPF SkiaSharp rendering on Nvidia Quadro GPUs at high DPI \u2014 root cause is WPF compositor/driver interaction, not SkiaSharp itself",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.7
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a WPF application using SkiaSharp (SKElement or SKGLElement)",
            "Run on a system with Nvidia Quadro GPU and a high-resolution monitor",
            "Draw patterns repeatedly \u2014 observe memory growing without bound",
            "Confirm leak does not occur with AMD, Nvidia GeForce, or when using RenderMode.SoftwareOnly"
          ],
          "environmentDetails": "Windows, Nvidia Quadro series GPU, high-resolution monitor, SkiaSharp 3.116.0",
          "relatedIssues": [
            3309,
            3311,
            1569
          ],
          "repoLinks": [
            {
              "url": "https://github.com/dotnet/wpf/issues/10005",
              "description": "WPF runtime bug: memory leak on certain graphics cards"
            },
            {
              "url": "https://github.com/beto-rodriguez/SkiaSharp-wpf-memory-leak",
              "description": "SKGLElement memory leak repro project from #3309"
            },
            {
              "url": "https://forums.developer.nvidia.com/t/quadro-card-memory-leak-under-per-frame-vbo-churn/349313",
              "description": "Nvidia forum: Quadro memory leak under per-frame VBO churn"
            }
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "memory-leak",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The WPF rendering code in SKElement.cs and SKGLElement.cs has not fundamentally changed since 3.116.0. However, the regression from 2.88.9 may relate to changes in bitmap size, rendering frequency, or the switch from SkiaSharp v2 to v3 internals rather than WPF view code itself."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.6,
          "reason": "Reporter claims 2.88.9 worked, but this is likely a WPF/driver interaction that depends on bitmap sizes, rendering frequency, and GPU driver version \u2014 not a direct SkiaSharp code regression. The root cause (dotnet/wpf#10005) affects WPF apps broadly, not just SkiaSharp."
        }
      },
      "analysis": {
        "summary": "Memory leak when rendering SkiaSharp content in WPF on Nvidia Quadro GPUs at high DPI. The reporter\u0027s workaround (disabling WPF hardware acceleration) confirms the leak is in WPF\u0027s D3D compositor layer, not in SkiaSharp\u0027s rendering code. This is a known WPF framework issue (dotnet/wpf#10005) affecting how GPU drivers manage texture memory for WriteableBitmap compositing. SkiaSharp contributes by creating large bitmaps on each render cycle, but the leak is in the WPF/driver layer.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "finding": "OnRender creates/reuses a WriteableBitmap, writes SkiaSharp pixels to it, then calls drawingContext.DrawImage(). The bitmap is cached (line 66) and only recreated on size change. WPF\u0027s compositor uploads this bitmap to GPU texture memory via D3D \u2014 the leak occurs in that upload/retention path on Nvidia Quadro drivers.",
            "relevance": "direct",
            "lines": "45-89"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKGLElement.cs",
            "finding": "SKGLElement uses OpenGL via OpenTK for GPU-accelerated rendering. Known memory leak exists (#3309) because Dispose does not call base GLWpfControl.Dispose(). PR #3311 fixes this. If the reporter uses SKGLElement, this could be the root cause.",
            "relevance": "direct",
            "lines": "117-181"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKGLElement.cs",
            "finding": "Release() disposes canvas, surface, renderTarget, and grContext but does NOT call base.Dispose(). This leaves OpenTK\u0027s GPU resources (framebuffers, textures) leaked. Fixed by PR #3311.",
            "relevance": "related",
            "lines": "192-218"
          }
        ],
        "rationale": "Classified as type/bug because memory grows unboundedly \u2014 that\u0027s broken behavior regardless of root cause. Area is SkiaSharp.Views because the WPF view controls (SKElement, SKGLElement) are the integration point, even though the root cause is in WPF\u0027s compositor. Severity is medium because it requires a specific GPU (Nvidia Quadro) and high-DPI setup. The reporter\u0027s SoftwareOnly workaround is the key signal: it proves the leak is in WPF\u0027s hardware-accelerated rendering pipeline, not in SkiaSharp\u0027s pixel generation. The claim of regression from 2.88.9 has low confidence as a SkiaSharp regression because the underlying WPF/driver interaction likely changed with driver updates or the move to v3.",
        "keySignals": [
          {
            "text": "it only occurred in the Nvidia Quadro series",
            "source": "issue body",
            "interpretation": "GPU-driver-specific issue \u2014 not a SkiaSharp code bug. Nvidia Quadro drivers have known memory management issues with WPF\u0027s D3D compositor."
          },
          {
            "text": "RenderOptions.ProcessRenderMode = RenderMode.SoftwareOnly... issue does not occur",
            "source": "issue body",
            "interpretation": "Disabling WPF hardware acceleration eliminates the leak, proving the issue is in WPF\u0027s GPU compositing layer, not in SkiaSharp\u0027s rendering."
          },
          {
            "text": "I\u0027ve checked that it doesn\u0027t happen with Nvidia Geforce, AMD",
            "source": "issue body",
            "interpretation": "Leak is driver-specific, not code-specific. Consumer Nvidia drivers (GeForce) handle the same WPF compositor workload without leaking."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "issue body",
            "interpretation": "May correlate with driver updates or v2\u2192v3 rendering differences rather than a specific SkiaSharp regression."
          }
        ],
        "workarounds": [
          "Disable Nvidia \u0027Threaded Optimization\u0027 in Nvidia Control Panel for the application",
          "If using SKGLElement, switch to SKElement (CPU-based rendering avoids OpenTK disposal leak)",
          "Try rolling back the Nvidia Quadro driver to an earlier version (e.g., 553.62 or 572.60)"
        ],
        "nextQuestions": [
          "Which WPF control is the reporter using \u2014 SKElement (CPU) or SKGLElement (GL)?",
          "What is the exact Nvidia Quadro model and driver version?",
          "What is the monitor resolution / DPI scaling percentage?",
          "Does the leak correlate with specific drawing operations, or any SkiaSharp rendering?"
        ],
        "resolution": {
          "hypothesis": "The memory leak is in WPF\u0027s D3D compositor layer when compositing WriteableBitmap or OpenGL interop textures on Nvidia Quadro GPU drivers. SkiaSharp triggers it by producing large bitmaps or GL surfaces on each render cycle, but the retention/leak occurs downstream in WPF \u002B driver. If using SKGLElement specifically, the known OpenTK disposal bug (#3309) may be the direct cause.",
          "proposals": [
            {
              "description": "In Nvidia Control Panel, set \u0027Threaded Optimization\u0027 to OFF for the application. This has been reported to resolve WPF memory leaks with Quadro drivers on the Nvidia developer forums.",
              "title": "Disable Nvidia Threaded Optimization",
              "confidence": 0.55,
              "effort": "trivial"
            },
            {
              "description": "If currently using SKGLElement (OpenGL-accelerated), switch to SKElement (CPU-based SkiaSharp rendering to WriteableBitmap). This avoids the known OpenTK disposal leak (#3309) and reduces GPU memory pressure. WPF still uses hardware acceleration for compositing, but the SkiaSharp-side GPU resources are eliminated.",
              "title": "Switch from SKGLElement to SKElement",
              "confidence": 0.6,
              "effort": "small"
            },
            {
              "description": "Try downgrading to Nvidia Quadro driver version 553.62 or 572.60. Per Nvidia forum reports, certain driver versions have fixed or mitigated this class of GPU memory leak.",
              "title": "Roll back Nvidia Quadro driver",
              "confidence": 0.45,
              "effort": "small"
            },
            {
              "description": "If the reporter uses SKGLElement, merging PR #3311 would fix the known OpenTK disposal leak by updating OpenTK and calling base.Dispose(). This doesn\u0027t fix the broader WPF compositor issue but eliminates a confirmed leak path.",
              "title": "Merge PR #3311 (SKGLElement disposal fix)",
              "confidence": 0.7,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Disable Nvidia Threaded Optimization",
          "recommendedReason": "Lowest effort, highest chance of addressing the WPF compositor leak specifically reported. If it doesn\u0027t help, asking which control (SKElement vs SKGLElement) the reporter uses will determine whether #3311 is relevant."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The report lacks critical information: which WPF control (SKElement vs SKGLElement), GPU model, driver version, DPI scaling. The leak may be a known WPF framework issue (dotnet/wpf#10005) or the known SKGLElement disposal bug (#3309). Need reporter clarification to determine which."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct: type/bug, os/Windows-Classic, tenet/reliability. Add area/SkiaSharp.Views.",
            "risk": "low",
            "confidence": 0.85,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Ask for clarification on control type and GPU details, provide driver-side workaround",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the detailed investigation \u2014 the fact that disabling WPF hardware acceleration resolves it is a strong signal that the leak is in WPF\u0027s D3D compositor layer rather than in SkiaSharp\u0027s rendering code itself. This is consistent with a known WPF framework issue ([dotnet/wpf#10005](https://github.com/dotnet/wpf/issues/10005)) affecting certain GPU drivers.\n\nA few questions to help narrow this down:\n\n1. Which SkiaSharp WPF control are you using \u2014 \u0060SKElement\u0060 or \u0060SKGLElement\u0060?\n2. What is the exact Nvidia Quadro model and driver version?\n3. What DPI scaling percentage is your high-resolution monitor set to?\n\nIf you\u0027re using \u0060SKGLElement\u0060, there\u0027s a known memory leak in the current OpenTK integration ([#3309](https://github.com/mono/SkiaSharp/issues/3309)) with a pending fix in [#3311](https://github.com/mono/SkiaSharp/issues/3311). Switching to \u0060SKElement\u0060 (CPU-based rendering) may resolve the leak while keeping WPF hardware acceleration enabled for the rest of your UI.\n\nAs an alternative workaround, try disabling **Threaded Optimization** in the Nvidia Control Panel for your application \u2014 this has been reported to mitigate WPF memory leaks with Quadro drivers."
          },
          {
            "type": "link-related",
            "description": "Cross-reference with SKGLElement disposal leak",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 3309
          }
        ],
        "missingInfo": [
          "Which WPF SkiaSharp control: SKElement or SKGLElement?",
          "Nvidia Quadro model and driver version",
          "Monitor resolution and Windows DPI scaling percentage",
          "Minimal reproduction project or code snippet"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3428,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:41:26Z",
        "currentLabels": [
          "type/bug",
          "os/iOS",
          "area/SkiaSharp.Views.Maui",
          "tenet/reliability"
        ]
      },
      "summary": "SKGLView in MAUI on iOS fails with \u0027Failed to bind EAGLDrawable\u0027 on .NET 10, resulting in a white canvas with no rendering. The iOS MAUI handler uses OpenGL ES (GLKView \u002B EAGLContext) which Apple deprecated in iOS 12. The Mac Catalyst handler already uses Metal (SKMetalView), but the iOS handler still relies on the deprecated EAGL/GLKit path. .NET 10 likely tightened or broke GLKit support, surfacing this as a runtime failure. SkiaSharp 3.116.0 on iOS via Mapsui MapControl.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.95
        },
        "platforms": [
          "os/iOS"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/compatibility",
          "tenet/reliability"
        ],
        "partner": "partner/maui"
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a MAUI app targeting .NET 10 with SkiaSharp 3.116.0",
            "Use SKGLView (GPU-accelerated view) on iOS",
            "Observe \u0027Failed to bind EAGLDrawable\u0027 in logs and white canvas"
          ],
          "codeSnippets": [
            "private void OnGLPaintSurface(object? sender, SKPaintGLSurfaceEventArgs args)\n{\n    if (_glView?.GRContext is null)\n    {\n        Logger.Log(LogLevel.Warning, \u0022Refresh can not be called because GRContext is null\u0022);\n        return;\n    }\n    PaintSurface(args.Surface.Canvas);\n}"
          ],
          "environmentDetails": "iOS, .NET 10, SkiaSharp 3.116.0, Visual Studio (macOS), Mapsui MapControl",
          "repoLinks": [
            {
              "url": "https://github.com/Mapsui/Mapsui/blob/main/Mapsui.UI.Maui/MapControl.cs",
              "description": "Mapsui MapControl source using SKGLView"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "rendering-failure",
          "errorMessage": "Failed to bind EAGLDrawable",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net10.0-ios"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "currentRelevance": "likely",
          "relevanceReason": "The iOS SKGLViewHandler still uses OpenGL ES (GLKView/EAGLContext) in current main. No code change has migrated iOS to Metal."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.6,
          "reason": "Reporter lists 2.88.9 as last known good, but this may reflect .NET 10 runtime changes rather than a SkiaSharp code regression. The SkiaSharp OpenGL code path hasn\u0027t changed \u2014 the environment (.NET 10 \u002B newer iOS) has. The regression is environmental, not a SkiaSharp code change.",
          "workedInVersion": "2.88.9"
        }
      },
      "analysis": {
        "summary": "The iOS MAUI SKGLViewHandler creates an OpenGL ES-based SKGLView (inheriting GLKView, using EAGLContext with OpenGLES2). Apple deprecated EAGL/GLKit in iOS 12 and the OpenGL ES stack is increasingly unreliable on newer iOS versions. .NET 10 appears to have broken or further restricted GLKit bindings, causing \u0027Failed to bind EAGLDrawable\u0027. The Mac Catalyst handler already uses SKMetalView (Metal backend), proving the Metal path works. The iOS handler needs the same migration to Metal.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.iOS.cs",
            "finding": "iOS handler marked [ObsoletedOSPlatform(\u0022ios12.0\u0022)] creates SKGLView (GLKView-based) with OpenGL ES. This is the deprecated code path causing the EAGL failure.",
            "relevance": "direct",
            "lines": "12-28"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/iOS/SKGLView.cs",
            "finding": "Initialize() creates EAGLContext(EAGLRenderingAPI.OpenGLES2), sets up GLKit drawable formats, and hooks GLKViewDelegate. This is the root of the EAGL binding failure.",
            "relevance": "direct",
            "lines": "86-102"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.MacCatalyst.cs",
            "finding": "Mac Catalyst handler uses SKMetalView instead of SKGLView \u2014 Metal backend works. This is the pattern iOS should follow.",
            "relevance": "related",
            "lines": "9-19"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Apple/SKMetalView.cs",
            "finding": "SKMetalView initializes Metal device, command queue, and MTKView delegate. This is the proven Metal rendering path that iOS should use.",
            "relevance": "related",
            "lines": "78-121"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes broken functionality (white canvas, no rendering) with an error message. Area is SkiaSharp.Views.Maui because the failure is in the MAUI SKGLViewHandler iOS platform code, not in core SkiaSharp. Backend is OpenGL because the EAGL error is specific to the OpenGL ES rendering path. The tenet/compatibility label reflects that this is a platform compatibility issue with .NET 10/newer iOS. Partner/maui applies since this involves MAUI integration. Severity is high because GPU rendering is completely broken on iOS with .NET 10.",
        "keySignals": [
          {
            "text": "Failed to bind EAGLDrawable",
            "source": "comment by charlenni",
            "interpretation": "iOS system-level OpenGL ES error \u2014 the GLKView cannot bind its EAGL drawable surface for rendering. This is a known consequence of Apple\u0027s OpenGL deprecation."
          },
          {
            "text": "not in .NET 9",
            "source": "issue body",
            "interpretation": ".NET 10 specific \u2014 suggests .NET 10 changed GLKit bindings or iOS runtime behavior that breaks EAGL."
          },
          {
            "text": "Context = new EAGLContext(EAGLRenderingAPI.OpenGLES2)",
            "source": "code: source/SkiaSharp.Views/SkiaSharp.Views/Platform/iOS/SKGLView.cs:94",
            "interpretation": "iOS SKGLView explicitly creates an OpenGL ES 2 context using deprecated EAGL API."
          },
          {
            "text": "SKGLViewHandler.MacCatalyst uses SKMetalView",
            "source": "code: source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.MacCatalyst.cs:9",
            "interpretation": "Mac Catalyst already migrated to Metal. iOS needs the same migration."
          },
          {
            "text": "[ObsoletedOSPlatform(\u0022ios12.0\u0022, \u0022Use \u0027Metal\u0027 instead.\u0022)]",
            "source": "code: source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.iOS.cs:12",
            "interpretation": "The code itself acknowledges OpenGL is deprecated on iOS 12\u002B and recommends Metal."
          }
        ],
        "errorFingerprint": "EAGLDrawable-bind-failure-iOS-GLKit-deprecated",
        "workarounds": [
          "Switch from SKGLView to SKCanvasView (CPU raster rendering) to avoid the OpenGL ES path entirely. This loses GPU acceleration but works reliably on all iOS versions.",
          "If the consuming library supports it, use SKMetalView directly instead of going through the MAUI SKGLView handler."
        ],
        "nextQuestions": [
          "Does .NET 10 for iOS remove or break GLKit bindings specifically, or is this an iOS version issue?",
          "Which iOS version is the reporter running? Newer iOS versions may further restrict OpenGL ES.",
          "Can the iOS SKGLViewHandler be migrated to SKMetalView (like Mac Catalyst) without breaking the public API surface?",
          "Does this affect SKGLView in non-MAUI contexts (e.g., direct SkiaSharp.Views.iOS usage)?"
        ],
        "resolution": {
          "hypothesis": "The iOS MAUI SKGLViewHandler uses the deprecated OpenGL ES (EAGL/GLKit) rendering path. .NET 10 likely changed iOS GLKit bindings or runtime behavior, causing the EAGL drawable to fail to bind. The fix is to migrate the iOS handler from SKGLView (OpenGL ES) to SKMetalView (Metal), matching what Mac Catalyst already does.",
          "proposals": [
            {
              "description": "Replace SKGLView with SKCanvasView in the consuming app (Mapsui). This uses CPU raster rendering instead of GPU, avoiding the EAGL path entirely. Performance will be lower for complex rendering but it works immediately.",
              "title": "Switch to SKCanvasView (workaround)",
              "codeSnippet": "// In Mapsui MapControl, replace:\n// private SKGLView _glView;\n// with:\n// private SKCanvasView _canvasView;\n// And use OnPaintSurface instead of OnGLPaintSurface",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "Change the iOS SKGLViewHandler to use SKMetalView instead of SKGLView, matching the Mac Catalyst handler pattern. This is the proper long-term fix \u2014 Metal is Apple\u0027s supported graphics API and the handler already has a working Metal implementation for Mac Catalyst that can be reused.",
              "title": "Migrate iOS SKGLViewHandler to Metal",
              "confidence": 0.85,
              "effort": "medium"
            },
            {
              "description": "If .NET 10 is not required, targeting .NET 9 should restore the previous behavior since the reporter confirms it works there.",
              "title": "Target .NET 9 to avoid the issue",
              "confidence": 0.8,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Switch to SKCanvasView (workaround)",
          "recommendedReason": "Immediate fix the reporter can apply today. The Metal migration is the proper long-term fix for SkiaSharp but requires maintainer effort."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real bug \u2014 the iOS GL path uses deprecated EAGL that fails on .NET 10. Needs investigation to determine whether to migrate iOS handler to Metal, and whether .NET 10 actually removed GLKit support or just broke it."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add backend/OpenGL and tenet/compatibility labels to existing labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Maui",
              "os/iOS",
              "backend/OpenGL",
              "tenet/compatibility",
              "tenet/reliability",
              "partner/maui"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug, provide workaround (SKCanvasView), explain root cause (deprecated EAGL), and ask for iOS version",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for reporting this. The \u0022Failed to bind EAGLDrawable\u0022 error confirms the issue is in the OpenGL ES rendering path.\n\nOn iOS, \u0060SKGLView\u0060 in MAUI uses Apple\u0027s deprecated OpenGL ES stack (EAGL/GLKit), which was deprecated in iOS 12. .NET 10 appears to have broken or further restricted GLKit bindings, causing the drawable to fail to bind.\n\nHere\u0027s a workaround you can use while we investigate: switch from \u0060SKGLView\u0060 to \u0060SKCanvasView\u0060. This uses CPU raster rendering instead of GPU, so it avoids the EAGL path entirely:\n\n\u0060\u0060\u0060csharp\n// Replace SKGLView usage with SKCanvasView\n// Use OnPaintSurface (SKPaintSurfaceEventArgs) instead of OnGLPaintSurface\nprivate void OnPaintSurface(object? sender, SKPaintSurfaceEventArgs args)\n{\n    PaintSurface(args.Surface.Canvas);\n}\n\u0060\u0060\u0060\n\nThe performance trade-off is that \u0060SKCanvasView\u0060 uses CPU rendering, which may be slower for complex scenes like maps. The proper fix is to migrate the iOS handler from OpenGL ES to Metal (which Mac Catalyst already uses).\n\nWould you be able to confirm which iOS version you\u0027re running, and whether the issue also occurs with a minimal SkiaSharp MAUI app (without Mapsui)? That would help us narrow down whether this is purely a .NET 10 change or also iOS-version-dependent."
          }
        ],
        "missingInfo": [
          "Exact iOS version the reporter is running",
          "Whether the issue also occurs with a minimal SkiaSharp MAUI app (without Mapsui)",
          "Whether switching to SKCanvasView resolves the issue as a workaround"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3427,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:25:00Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR that fixes a Blazor disposal race condition (#3322). When SKCanvasView is disposed in Blazor, DOM elements may already have been removed before Dispose() runs, causing ResizeObserver.unobserve() to throw TypeError (\u0027parameter 1 is not of type Element\u0027). The fix adds null-guard early returns in SizeWatcher.observe(), SizeWatcher.unobserve(), and removes a misleading console.error in SKHtmlCanvas.init() \u2014 all in JavaScript. This is a well-known Blazor lifecycle issue (dotnet/aspnetcore#45777).",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.98
        },
        "platforms": [
          "os/WASM"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Blazor WASM application with multiple SKCanvasView components",
            "Rapidly show and hide (add/remove from DOM) multiple SKCanvasView instances via conditional rendering",
            "Observe unhandled exception from Dispose() when the component is removed"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/59b9940f-dd7e-4763-bd78-a45bf2b73f99",
              "description": "Console error message during disposal"
            }
          ],
          "environmentDetails": "SkiaSharp 3.116.0, .NET 8.0 Blazor WASM, Visual Studio 2022 on Windows",
          "relatedIssues": [
            3322,
            2441
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "JSException (TypeError)",
          "errorMessage": "TypeError: Failed to execute \u0027unobserve\u0027 on \u0027ResizeObserver\u0027: parameter 1 is not of type \u0027Element\u0027.",
          "stackTrace": "Microsoft.JSInterop.JSException: TypeError: Failed to execute \u0027unobserve\u0027 on \u0027ResizeObserver\u0027: parameter 1 is not of type \u0027Element\u0027.\n   at Microsoft.JSInterop.WebAssembly.WebAssemblyJSRuntime.InvokeJS(...)\n   at SkiaSharp.Views.Blazor.Internal.JSModuleInterop.Invoke(...)\n   at SkiaSharp.Views.Blazor.Internal.SizeWatcherInterop.Stop()\n   at SkiaSharp.Views.Blazor.Internal.SizeWatcherInterop.OnDisposingModule()\n   at SkiaSharp.Views.Blazor.Internal.JSModuleInterop.Dispose()\n   at SkiaSharp.Views.Blazor.SKCanvasView.Dispose()",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-browser"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.3"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The SizeWatcher.ts unobserve() method still lacks null guards in the current main branch. Issue #2441 reported the same class of bug in 2.88.3, and #3322 reports it in 3.116.0 \u2014 the root cause has never been fixed."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "The current SizeWatcher.ts and SizeWatcher.js on main still lack null guards in both observe() and unobserve(). This PR provides the fix but has not been merged.",
          "relatedPRs": [
            3427
          ]
        }
      },
      "analysis": {
        "summary": "Blazor components can have their DOM elements removed before Dispose() is invoked \u2014 a well-documented Blazor lifecycle limitation (dotnet/aspnetcore#45777). When SKCanvasView.Dispose() is called, it triggers SizeWatcherInterop.Stop() which calls SizeWatcher.unobserve() in JavaScript. If the element has already been removed from the DOM, the elements Map returns undefined, and ResizeObserver.unobserve(undefined) throws TypeError. Similarly, SizeWatcher.observe() can fail if the element was removed between the async ImportAsync and the Start() call. The PR correctly adds null guards at the JS level and removes a misleading console.error in SKHtmlCanvas.init() that logged \u0027No canvas element was provided\u0027 for this normal disposal scenario.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/wwwroot/SizeWatcher.ts",
            "finding": "SizeWatcher.unobserve() calls this.elements.get(elementId) and passes result directly to ResizeObserver.unobserve() without null check. If element was removed from DOM and the map entry is missing/undefined, this throws TypeError.",
            "relevance": "direct",
            "lines": "37-45"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/wwwroot/SizeWatcher.ts",
            "finding": "SizeWatcher.observe() resolves element via querySelector but doesn\u0027t null-check the result before casting to SizeWatcherElement and setting properties on it. Would throw if element is already gone.",
            "relevance": "direct",
            "lines": "16-34"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/wwwroot/SKHtmlCanvas.ts",
            "finding": "SKHtmlCanvas.init() logs console.error(\u0027No canvas element was provided.\u0027) when element is null and returns null. The error log is misleading during normal Blazor disposal \u2014 the element was provided but already removed from DOM.",
            "relevance": "direct",
            "lines": "47-53"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/Internal/SizeWatcherInterop.cs",
            "finding": "OnDisposingModule() calls Stop(), which calls the JS unobserve. The C# side correctly uses ?. null-conditional on callbackReference but the JS side lacks equivalent guards.",
            "relevance": "related",
            "lines": "47-48"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/Internal/JSModuleInterop.cs",
            "finding": "Dispose() calls OnDisposingModule() then Module.Dispose(). If OnDisposingModule throws (due to JS TypeError), Module.Dispose() is never called \u2014 potential resource leak.",
            "relevance": "related",
            "lines": "37-41"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SKCanvasView.razor.cs",
            "finding": "SKCanvasView.Dispose() uses ?. null-conditional operators for sizeWatcher/interop/dpiWatcher, which handles the case where OnAfterRenderAsync never completed. This is correct defensive coding on the C# side.",
            "relevance": "context",
            "lines": "171-178"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SKGLView.razor.cs",
            "finding": "SKGLView.Dispose() does NOT use ?. null-conditional \u2014 it would throw NullReferenceException if OnAfterRenderAsync never completed. This is a separate but related bug.",
            "relevance": "related",
            "lines": "190-195"
          }
        ],
        "rationale": "This is clearly a bug \u2014 an unhandled exception thrown during normal component disposal. It\u0027s in the Blazor views package (area/SkiaSharp.Views.Blazor) and only affects WASM. Severity is medium: the exception is unhandled and logged as critical by Blazor\u0027s renderer, but it doesn\u0027t crash the application or lose data. It\u0027s not a regression in the traditional sense \u2014 the code never handled this Blazor lifecycle edge case. The PR\u0027s approach (JS-side null guards) is the correct fix pattern for this class of Blazor disposal issue.",
        "keySignals": [
          {
            "text": "TypeError: Failed to execute \u0027unobserve\u0027 on \u0027ResizeObserver\u0027: parameter 1 is not of type \u0027Element\u0027",
            "source": "issue #3322 body",
            "interpretation": "ResizeObserver.unobserve() was called with undefined \u2014 the element was already removed from the DOM before disposal."
          },
          {
            "text": "In Blazor, elements can be removed from the DOM before a component\u0027s Dispose() method is invoked",
            "source": "PR #3427 body",
            "interpretation": "This is a known Blazor platform limitation documented at dotnet/aspnetcore#45777. The fix must be defensive null-checking in JS."
          },
          {
            "text": "#2441 \u2014 same Blazor disposal exception from v2.88.3",
            "source": "similar-issues-ai bot on #3322",
            "interpretation": "This is a long-standing bug reported at least twice. The root cause was never addressed."
          },
          {
            "text": "SizeWatcher.unobserve() calls observer.unobserve(element) without null-checking the Map.get() result",
            "source": "code search: SizeWatcher.ts:44-45",
            "interpretation": "Direct cause \u2014 Map.get() returns undefined for removed elements, causing the TypeError."
          }
        ],
        "errorFingerprint": "JSException-TypeError-ResizeObserver-unobserve-Blazor",
        "workarounds": [
          "Wrap SKCanvasView usage in a try-catch in the parent component\u0027s Dispose method to suppress the exception",
          "Avoid rapidly showing/hiding multiple SKCanvasView instances \u2014 use CSS visibility instead of conditional rendering to keep elements in the DOM"
        ],
        "nextQuestions": [
          "Should SKGLView.Dispose() also use ?. null-conditional operators like SKCanvasView does (potential NullReferenceException)?",
          "Should JSModuleInterop.Dispose() wrap OnDisposingModule() in try-catch to ensure Module.Dispose() always runs?",
          "Are there similar null-guard issues in DpiWatcher.js?"
        ],
        "resolution": {
          "hypothesis": "Blazor\u0027s component lifecycle allows DOM elements to be removed before Dispose() is called. The SizeWatcher JS code assumes elements are still in the DOM during unobserve(), causing TypeError when they\u0027re not. The PR\u0027s null-guard approach is the standard fix for this Blazor lifecycle issue.",
          "proposals": [
            {
              "description": "The PR adds correct null guards in SizeWatcher.observe(), SizeWatcher.unobserve(), and removes the misleading console.error in SKHtmlCanvas.init(). Changes are minimal, JS-only, and follow the standard pattern for handling Blazor disposal races. The PR modifies both .ts (source) and .js (compiled) files consistently. Needs rebase on main and review of the unchecked PR checklist items.",
              "title": "Merge PR #3427 with review",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "Wrap OnDisposingModule() call in try-catch within JSModuleInterop.Dispose() to ensure Module.Dispose() always runs even if the JS interop call fails. This provides defense-in-depth for any future JS disposal errors.",
              "title": "Additional hardening in JSModuleInterop.Dispose()",
              "codeSnippet": "public void Dispose()\n{\n    try { OnDisposingModule(); } catch { }\n    Module.Dispose();\n}",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "SKGLView.Dispose() calls dpiWatcher.Unsubscribe(), sizeWatcher.Dispose(), interop.Dispose() without ?. null-conditional operators, unlike SKCanvasView.Dispose(). This would throw NullReferenceException if OnAfterRenderAsync never completed. Should be fixed as part of this PR or a follow-up.",
              "title": "Fix SKGLView.Dispose() null-conditional operators",
              "codeSnippet": "public void Dispose()\n{\n    dpiWatcher?.Unsubscribe(OnDpiChanged);\n    sizeWatcher?.Dispose();\n    interop?.Dispose();\n}",
              "confidence": 0.8,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3427 with review",
          "recommendedReason": "The PR directly fixes the reported bug with minimal, correct changes. The additional hardening proposals can be follow-up items or requested as part of the PR review."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Community PR with correct approach. Needs code review, rebase on main, and consideration of additional hardening (SKGLView null-safety, JSModuleInterop try-catch). The fix is sound but the PR checklist shows \u0027Rebased on top of main\u0027 is unchecked."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, Blazor views, WASM, and reliability labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Blazor",
              "os/WASM",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with original bug report #3322",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3322
          },
          {
            "type": "link-related",
            "description": "Cross-reference with older duplicate #2441 (same class of Blazor disposal bug)",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 2441
          },
          {
            "type": "add-comment",
            "description": "Post review feedback acknowledging the fix and suggesting additional hardening",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the fix \u2014 this is a well-known Blazor lifecycle issue and your approach of adding null guards in the JS layer is the right pattern.\n\nThe changes in \u0060SizeWatcher.ts\u0060/\u0060SizeWatcher.js\u0060 and \u0060SKHtmlCanvas.ts\u0060/\u0060SKHtmlCanvas.js\u0060 look correct. A couple of observations for consideration:\n\n1. \u0060SKGLView.razor.cs\u0060 has the same disposal vulnerability \u2014 it calls \u0060dpiWatcher.Unsubscribe()\u0060, \u0060sizeWatcher.Dispose()\u0060, and \u0060interop.Dispose()\u0060 without \u0060?.\u0060 null-conditional operators (unlike \u0060SKCanvasView.razor.cs\u0060 which already uses them). Would you be able to add that fix to this PR as well?\n\n2. \u0060JSModuleInterop.Dispose()\u0060 could benefit from a try-catch around \u0060OnDisposingModule()\u0060 to ensure \u0060Module.Dispose()\u0060 always runs even if the JS interop call throws.\n\nWould you be able to rebase on top of the current \u0060main\u0060 branch?"
          }
        ],
        "missingInfo": [
          "PR needs rebase on top of current main branch",
          "PR checklist item \u0027Updated documentation\u0027 is unchecked \u2014 confirm if docs changes are needed"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3423,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:41:26Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "ClickOnce deployment on .NET Framework 4.7.2 fails to include libSkiaSharp.dll in the published application, causing DllNotFoundException at runtime. The MSIX version of the same app works fine. The NativeAssets.Win32 MSBuild .targets file copies native DLLs to the build output via \u003CNone\u003E items with CopyToOutputDirectory, but ClickOnce does not pick up these files for its application manifest. A community workaround exists: manually add libSkiaSharp.dll as a Content item in the project.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.9
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility",
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET Framework 4.7.2 WinForms app",
            "Add SkiaSharp NuGet package (3.119.1 or 3.116.0)",
            "Use SKBitmap.Decode() in the app",
            "Publish with ClickOnce",
            "Run the ClickOnce-deployed app"
          ],
          "codeSnippets": [
            "var image = SKBitmap.Decode(imageData ?? throw new ArgumentNullException(nameof(imageData)))"
          ],
          "environmentDetails": "Windows 10/11, .NET Framework 4.7.2 WinForms, Visual Studio (Windows), ClickOnce deployment",
          "relatedIssues": [
            1327
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "DllNotFoundException",
          "errorMessage": "Unable to load library \u0027libSkiaSharp\u0027",
          "stackTrace": "System.TypeInitializationException: The type initializer for \u0027SkiaSharp.SKData\u0027 threw an exception. ---\u003E System.DllNotFoundException: Unable to load library \u0027libSkiaSharp\u0027.\n   at SkiaSharp.LibraryLoader.LoadLocalLibrary[T](String libraryName)\n   at System.Lazy\u00601.CreateValue()\n   at System.Lazy\u00601.LazyInitValue()\n   at SkiaSharp.SkiaApi.sk_data_new_empty()\n   at SkiaSharp.SKData..cctor()",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net472"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.1",
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The NativeAssets.Win32 .targets file still uses \u003CNone\u003E items with CopyToOutputDirectory which ClickOnce does not include in its application manifest. This packaging approach has not changed."
        }
      },
      "analysis": {
        "summary": "ClickOnce deployment ignores native DLLs added by the SkiaSharp.NativeAssets.Win32 .targets file because they use \u003CNone\u003E with CopyToOutputDirectory=PreserveNewest. ClickOnce requires items to be project Content with explicit application manifest inclusion. The build output (bin/Debug) contains the DLLs correctly, so development works, but ClickOnce publish does not include them. This is a long-standing packaging limitation \u2014 issue #1327 reported the identical problem in 2020.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp.NativeAssets.Win32/buildTransitive/net4/SkiaSharp.targets",
            "finding": "The .targets file adds native DLLs as \u003CNone\u003E items with CopyToOutputDirectory=PreserveNewest. This copies DLLs to build output but ClickOnce does not include \u003CNone\u003E items in its application manifest \u2014 only \u003CContent\u003E items are published.",
            "relevance": "direct",
            "lines": "10-27"
          },
          {
            "file": "binding/Binding.Shared/LibraryLoader.cs",
            "finding": "LibraryLoader searches assembly location, current directory, AppDomain paths, and architecture subdirectories (x86/x64/arm64). The loading logic itself is correct \u2014 the problem is the DLL never reaches the deployment directory.",
            "relevance": "related",
            "lines": "34-86"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.Win32/SkiaSharp.NativeAssets.Win32.csproj",
            "finding": "Project defines NativeAssetPackageFile items for win-x64, win-x86, win-arm64 which are placed in runtimes/ folder. The buildTransitive/net4/ targets handle net462 deployment.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/bug because the native DLLs should be deployed with the application but are silently omitted during ClickOnce publish, causing a runtime crash. Area is libSkiaSharp.native since the root cause is how the NativeAssets package delivers the native binary for ClickOnce scenarios. Severity is high because the app crashes on first use of any SkiaSharp API. The existing labels are already accurate.",
        "keySignals": [
          {
            "text": "DllNotFoundException: Unable to load library \u0027libSkiaSharp\u0027",
            "source": "issue body",
            "interpretation": "The native DLL is missing from the deployment \u2014 not a loading-order or dependency issue."
          },
          {
            "text": "MSIX version of the app does not however [have this problem]",
            "source": "issue body",
            "interpretation": "MSIX handles runtimes/ folder content natively; ClickOnce does not. Confirms packaging mechanism difference is the root cause."
          },
          {
            "text": "libSkiaSharp.dylib is not being included in the ClickOnce publish",
            "source": "issue body",
            "interpretation": "Reporter correctly identified the missing file \u2014 though on Windows it\u0027s libSkiaSharp.dll, not .dylib."
          },
          {
            "text": "right click on the added dll file, Properties, select Build Action = Content and Copy to Output Directory = Copy if newer",
            "source": "comment #2 (ERPCG)",
            "interpretation": "Community-confirmed workaround: manually adding the DLL as Content forces ClickOnce to include it in the application manifest."
          },
          {
            "text": "That was how I fixed it too",
            "source": "comment #3 (OP)",
            "interpretation": "OP confirms the workaround resolves the issue. Two independent confirmations."
          }
        ],
        "errorFingerprint": "DllNotFoundException-libSkiaSharp-ClickOnce-net4",
        "workarounds": [
          "Manually add libSkiaSharp.dll to the project as Content (Build Action=Content, Copy if newer). Find the DLL at packages/SkiaSharp.NativeAssets.Win32.{version}/runtimes/win-{arch}/native/libSkiaSharp.dll. Choose win-x64 for x64 or win-x86 for x86/AnyCPU.",
          "Use MSIX deployment instead of ClickOnce \u2014 MSIX correctly handles the runtimes/ native assets."
        ],
        "nextQuestions": [
          "Should the NativeAssets.Win32 .targets file use \u003CContent\u003E instead of \u003CNone\u003E for ClickOnce compatibility, or would that have side effects for other project types?",
          "Is there a way to conditionally use \u003CContent\u003E only when ClickOnce publishing is detected?"
        ],
        "resolution": {
          "hypothesis": "ClickOnce deployment only publishes items with Build Action=Content in the application manifest. The NativeAssets.Win32 .targets file uses \u003CNone\u003E with CopyToOutputDirectory, which works for MSBuild output but not ClickOnce manifests.",
          "proposals": [
            {
              "description": "Manually add the architecture-specific libSkiaSharp.dll to the project as a Content item. This forces ClickOnce to include it in the application manifest and deploy it. Steps: (1) Copy libSkiaSharp.dll from the NuGet package cache (packages/SkiaSharp.NativeAssets.Win32.{version}/runtimes/win-{arch}/native/), (2) Add to project via \u0027Add Existing Item\u0027, (3) Set Build Action=Content and Copy to Output Directory=Copy if newer, (4) Verify it appears in Publish \u003E Application Files with Action=Include.",
              "title": "Manual Content inclusion workaround",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Modify the NativeAssets.Win32 buildTransitive/net4/SkiaSharp.targets to use \u003CContent\u003E instead of \u003CNone\u003E for native DLL items, so ClickOnce includes them in the application manifest. This may need to be conditional to avoid side effects for non-ClickOnce projects.",
              "title": "Fix .targets to use Content for ClickOnce",
              "confidence": 0.6,
              "effort": "small"
            },
            {
              "description": "Use MSIX packaging instead of ClickOnce. MSIX correctly handles runtimes/ folder native assets from NuGet packages without manual intervention.",
              "title": "Switch to MSIX deployment",
              "confidence": 0.9,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Manual Content inclusion workaround",
          "recommendedReason": "Already confirmed working by both the community member and the OP. Trivial effort and no risk of side effects to other project types."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "The OP confirmed the workaround resolves the issue. This is a known ClickOnce limitation with NuGet runtimes/ native assets. The workaround is well-documented in the comments. However, a packaging fix in the .targets file could prevent future occurrences."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add tenet/compatibility label (ClickOnce deployment compatibility issue)",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/Windows-Classic",
              "tenet/compatibility",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the workaround and provide structured guidance",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for reporting this, and thanks @ERPCG for the detailed workaround.\n\nThis is a known limitation with ClickOnce and NuGet packages that deliver native binaries via the \u0060runtimes/\u0060 folder convention. ClickOnce only publishes items with \u0060Build Action = Content\u0060 in its application manifest, but the SkiaSharp NativeAssets package adds the DLLs as \u0060\u003CNone\u003E\u0060 items \u2014 which copies them to build output but not to the ClickOnce deployment.\n\nHere\u0027s the workaround (confirmed working by both reporters):\n\n1. Locate \u0060libSkiaSharp.dll\u0060 in your NuGet cache:\n   \u0060packages\\SkiaSharp.NativeAssets.Win32.{version}\\runtimes\\win-x64\\native\\\u0060 (use \u0060win-x86\u0060 for x86/AnyCPU)\n2. Add it to your project via **Add \u2192 Existing Item**\n3. Set **Build Action = Content** and **Copy to Output Directory = Copy if newer**\n4. Verify it appears in **Publish \u2192 Application Files** with **Action = Include**\n\nAlternatively, MSIX deployment handles native assets correctly without this manual step.\n\nRelated: #1327 (same issue reported in 2020)."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1327 (identical ClickOnce \u002B libSkiaSharp issue)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 1327
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3422,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:41:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Universal-UWP",
          "os/WASM",
          "area/SkiaSharp.Views.Blazor",
          "tenet/reliability"
        ]
      },
      "summary": "SkiaSharp fails on Blazor WASM with .NET 10: TypeInitializationException for SKImageInfo / DllNotFoundException for libSkiaSharp. Root cause is SkiaSharp does not yet officially target net10.0 \u2014 the Blazor package ships net6.0/net8.0 only, and the pre-built WASM static libraries (.a) may not match .NET 10\u0027s Emscripten version. The wasm-tools workload must also be explicitly installed. PR #3514 tracks adding .NET 10 support.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.9
        },
        "area": {
          "value": "area/SkiaSharp.Views.Blazor",
          "confidence": 0.95
        },
        "platforms": [
          "os/WASM"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Blazor WebAssembly project targeting net10.0",
            "Add SkiaSharp.Views.Blazor NuGet package (any version: 3.119.2-preview.1, 3.119.1, 3.118.0-preview.2.3)",
            "Add an SKCanvasView component to a Razor page",
            "Run the application and navigate to the page with the component"
          ],
          "environmentDetails": "Windows 11 Pro, VS 2026, .NET 10, Edge/Chrome. Also reproduced on macOS with Rider (comments #4, #9) and Linux production deployments (comment #8).",
          "relatedIssues": [
            3435,
            3224,
            2732,
            3068,
            3514
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "crash",
          "errorMessage": "ManagedError: TypeInitialization_Type, SkiaSharp.SKImageInfo",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net10.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.2-preview.1",
            "3.119.1",
            "3.118.0-preview.2.3",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The SkiaSharp build system still targets net8.0 as TFMCurrent with TFMNext empty \u2014 no net10.0 TFM exists in the released packages. PR #3514 (open) adds .NET 10 support but has not been merged or released."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.75,
          "reason": "PR #3514 (open, not merged) updates TFMs to include net10.0 and restructures the build for .NET 10 SDK. Until that ships in a release, .NET 10 WASM support is not officially available.",
          "relatedPRs": [
            3514
          ]
        }
      },
      "analysis": {
        "summary": "Blazor WASM on .NET 10 fails because SkiaSharp does not yet officially support net10.0. The Blazor package only ships net6.0 and net8.0 assemblies. While the NativeFileReference targets use VersionGreaterThanOrEquals(9.0) which should match 10.0, the pre-built static libraries (.a files) may be incompatible with .NET 10\u0027s Emscripten version. Additionally, the wasm-tools workload must be explicitly installed. Some users report dotnet workload restore fixes the issue, but others (especially on macOS) still fail.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "TFMPrevious=net6.0, TFMCurrent=net8.0, TFMNext=\u003Cempty\u003E. No net10.0 TFM defined. The Blazor package only builds for net6.0 and net8.0.",
            "relevance": "direct",
            "lines": "62-66"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SkiaSharp.Views.Blazor.csproj",
            "finding": "TargetFrameworks=$(TFMCurrent);$(TFMPrevious);$(TFMNext) \u2014 resolves to net8.0;net6.0 only. No net10.0 PackageReference for Microsoft.AspNetCore.Components.Web exists (only net6.0\u2013net9.0 conditions).",
            "relevance": "direct",
            "lines": "4"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.WebAssembly/buildTransitive/SkiaSharp.targets",
            "finding": "NativeFileReference for net9.0\u002B uses VersionGreaterThanOrEquals(9.0) which matches 10.0. The 3.1.56 emscripten variant .a files should be selected. However, .NET 10 may ship a newer Emscripten requiring recompiled .a files.",
            "relevance": "direct",
            "lines": "23-33"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.WebAssembly/buildTransitive/SkiaSharp.targets",
            "finding": "A workaround for dotnet/runtime#109289 reorders link step args for libSkiaSharp.a. This workaround may not be effective or needed in .NET 10, potentially causing linking failures.",
            "relevance": "related",
            "lines": "35-51"
          }
        ],
        "rationale": "Classified as type/bug because the expected behavior (SkiaSharp rendering in Blazor WASM) fails with a runtime exception. Area is SkiaSharp.Views.Blazor since the failure is specific to Blazor WASM platform integration, not core SkiaSharp functionality. Severity is high because it completely blocks all SkiaSharp usage on .NET 10 WASM \u2014 no workaround works for all users. The os/Windows-Universal-UWP label currently applied is incorrect \u2014 this is a WASM issue, not UWP.",
        "keySignals": [
          {
            "text": "ManagedError: TypeInitialization_Type, SkiaSharp.SKImageInfo",
            "source": "issue body",
            "interpretation": "SKImageInfo static constructor fails because libSkiaSharp cannot be loaded \u2014 classic WASM native linking failure."
          },
          {
            "text": "DllNotFoundException: libSkiaSharp at SkiaSharp.SKPath..ctor",
            "source": "comment #3 (jahnotto)",
            "interpretation": "Same root cause \u2014 native static library not linked into dotnet.wasm. Confirms this is a build-time linking issue, not a runtime loading issue."
          },
          {
            "text": "I tried rolling back to 2.88.9 but the same issue occurs, so it\u0027s something specific to .Net 10",
            "source": "comment #4 (Webreaper)",
            "interpretation": "Version-independent: all SkiaSharp versions fail on .NET 10 WASM. Points to a .NET 10 SDK / Emscripten toolchain incompatibility rather than a SkiaSharp regression."
          },
          {
            "text": "Restoring the .NET 10 wasm workload helped me. dotnet workload restore",
            "source": "comment #6 (EngstromJimmy)",
            "interpretation": "Confirms wasm-tools workload is required but not automatically installed. This is a partial workaround \u2014 works on Windows but not macOS for all users."
          },
          {
            "text": "dotnet workload restore didn\u0027t have any effect for me - still seeing the same issue on MacOS",
            "source": "comment #8 (Webreaper)",
            "interpretation": "Workload restore alone is insufficient on macOS. Suggests possible Emscripten version mismatch between pre-built .a files and .NET 10 SDK on macOS."
          },
          {
            "text": "TFMCurrent=net8.0, TFMNext=\u003Cempty\u003E",
            "source": "source/SkiaSharp.Build.props:64-66",
            "interpretation": "SkiaSharp\u0027s build system doesn\u0027t target net10.0. The Blazor package only ships net6.0 and net8.0 assemblies. PR #3514 addresses this."
          }
        ],
        "workarounds": [
          "Run \u0060dotnet workload install wasm-tools\u0060 or \u0060dotnet workload restore\u0060 to ensure the WASM build tools are installed (works for some users on Windows, not confirmed on macOS)",
          "Stay on .NET 9 until SkiaSharp officially adds .NET 10 support (PR #3514)"
        ],
        "nextQuestions": [
          "Does PR #3514 (.NET 10 SDK update) resolve this completely, including the macOS failures?",
          "Are the pre-built emscripten 3.1.56 .a files compatible with .NET 10\u0027s emscripten version, or do new .a files need to be compiled?",
          "Is the _SkiaSharpRuntimeIssue109289Workaround target still needed or harmful on .NET 10?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp does not yet support .NET 10. The Blazor package targets net6.0/net8.0 only, and the WASM static libraries may be compiled against an incompatible Emscripten version. The wasm-tools workload must be installed but is not sufficient on all platforms.",
          "proposals": [
            {
              "description": "Run \u0060dotnet workload install wasm-tools\u0060 to ensure the WASM build tools are available. This enables the native static linking step that embeds libSkiaSharp into dotnet.wasm. Works on Windows for some users but may not resolve the issue on macOS.",
              "title": "Install wasm-tools workload",
              "codeSnippet": "dotnet workload install wasm-tools\n# or\ndotnet workload restore",
              "confidence": 0.5,
              "effort": "trivial"
            },
            {
              "description": "Downgrade the project to net9.0 until SkiaSharp ships official .NET 10 support. .NET 9 \u002B SkiaSharp 3.119.1 is a known-working combination for Blazor WASM.",
              "title": "Stay on .NET 9",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "PR #3514 restructures TFMs to include net10.0 as TFMCurrent and updates the SDK. This is the proper fix that will add official .NET 10 support to SkiaSharp including the Blazor WASM package.",
              "title": "Merge PR #3514 \u2014 .NET 10 SDK update",
              "confidence": 0.85,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Stay on .NET 9",
          "recommendedReason": "Most reliable workaround while PR #3514 is in progress. The wasm-tools workload install only works for some users."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Known gap: .NET 10 is not yet an officially supported TFM. PR #3514 is the fix path but needs to be merged and released. Issue should remain open to track .NET 10 WASM support."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix labels: remove incorrect os/Windows-Universal-UWP, add tenet/compatibility",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Blazor",
              "os/WASM",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #3514 (.NET 10 SDK update PR)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 3514
          },
          {
            "type": "link-duplicate",
            "description": "Mark #3435 as duplicate of this issue (confirmed by reporter in #3435 comment)",
            "risk": "medium",
            "confidence": 0.95,
            "linkedIssue": 3435
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround and status update on .NET 10 support",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the report and the additional confirmation from others in the thread.\n\nSkiaSharp doesn\u0027t officially support .NET 10 yet \u2014 the current packages target net6.0 and net8.0 for Blazor WASM. The \u0060DllNotFoundException\u0060 / \u0060TypeInitializationException\u0060 occurs because the WASM static libraries (\u0060.a\u0060 files) aren\u0027t being linked into \u0060dotnet.wasm\u0060 correctly under the .NET 10 SDK.\n\nSome users have had success with:\n\n\u0060\u0060\u0060\ndotnet workload install wasm-tools\n\u0060\u0060\u0060\n\nThis ensures the WASM build tools are installed, which are required for native static linking. However, this doesn\u0027t work for everyone \u2014 particularly on macOS \u2014 likely due to Emscripten version differences between the pre-built libraries and the .NET 10 SDK.\n\nThe most reliable workaround right now is to **stay on .NET 9** (\u0060net9.0\u0060) until .NET 10 support ships. Work is tracked in PR #3514.\n\nWe\u0027ll update this issue when .NET 10 support is available in a release."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3421,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:35:28Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "Animation.Create() returns null for .lottie files because .lottie is a ZIP archive (dotLottie format), not raw Lottie JSON",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.8
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Download a .lottie file from LottieFiles (https://app.lottiefiles.com/)",
            "Call SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute) with the .lottie file path",
            "Observe that the returned Animation is null"
          ],
          "codeSnippets": [
            "var animation = SkiaSharp.Skottie.Animation.Create(sourceFileAbsolute);"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/9ca27c18-536b-4403-a41d-44e907329001",
              "description": "LottieFiles download showing .lottie file"
            },
            {
              "url": "https://github.com/user-attachments/assets/0fe1691c-82ee-462a-a110-f53b0682833f",
              "description": "Debug showing null animation result"
            }
          ],
          "environmentDetails": "Windows 11, SkiaSharp 3.116.0, Visual Studio (Windows)"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "This is not a version-specific issue. The Skottie API has never supported dotLottie ZIP format \u2014 it only accepts raw Lottie JSON."
        }
      },
      "analysis": {
        "summary": "The reporter is passing a .lottie file (dotLottie format) to Animation.Create(), which expects raw Lottie JSON. The .lottie format is a ZIP archive containing one or more Lottie JSON animations plus a manifest. Skia\u0027s Skottie module (skottie::Animation::Make) only parses JSON, so passing ZIP binary data causes it to return null. This is expected behavior \u2014 the API doesn\u0027t support the dotLottie container format.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp.Skottie/Animation.cs",
            "finding": "Animation.Create(string path) reads the file into SKData, strips BOM preamble, then passes raw bytes to skottie_animation_make_from_data(). No format detection or ZIP handling.",
            "relevance": "direct",
            "lines": "91-102"
          },
          {
            "file": "externals/skia/src/c/skottie_animation.cpp",
            "finding": "skottie_animation_make_from_data calls skottie::Animation::Make(data, length) which expects JSON text. ZIP binary data will fail JSON parsing and return nullptr.",
            "relevance": "direct",
            "lines": "24-25"
          },
          {
            "file": "externals/skia/modules/skottie/include/Skottie.h",
            "finding": "Upstream Skia Skottie only exposes Make(data, length), Make(stream), and MakeFromFile(path) \u2014 all expect Lottie JSON. No dotLottie format support exists in upstream Skia.",
            "relevance": "context",
            "lines": "190-192"
          }
        ],
        "rationale": "Classified as question rather than bug because the API is working as designed \u2014 Skottie parses Lottie JSON, and the .lottie (dotLottie) container format is a different specification entirely. The reporter\u0027s confusion is understandable since both formats use \u0027lottie\u0027 in the name, and LottieFiles defaults to .lottie downloads. The area is SkiaSharp (Skottie sub-module). No severity assigned since this is not broken behavior.",
        "keySignals": [
          {
            "text": "Loading .lottie file results in null",
            "source": "issue title",
            "interpretation": ".lottie files are ZIP archives (dotLottie format), not JSON \u2014 Skottie can\u0027t parse ZIP as JSON."
          },
          {
            "text": "https://app.lottiefiles.com/animation/5b206184-...",
            "source": "issue body",
            "interpretation": "LottieFiles now defaults to dotLottie (.lottie) downloads rather than raw JSON (.json). This is a common source of confusion."
          },
          {
            "text": "No exception is thrown, so it fails silently",
            "source": "issue body",
            "interpretation": "Factory-null-on-failure is by design in SkiaSharp \u2014 Animation.Create returns null when parsing fails. This matches the C\u002B\u002B Skottie behavior."
          }
        ],
        "workarounds": [
          "Extract the Lottie JSON from the .lottie ZIP archive before passing it to Animation.Create(). The .lottie format is a ZIP containing animations/*.json files.",
          "Download the Lottie JSON format directly from LottieFiles instead of the .lottie format."
        ],
        "nextQuestions": [
          "Should SkiaSharp add built-in dotLottie extraction as a convenience, or is this out of scope?"
        ],
        "resolution": {
          "hypothesis": "The .lottie file is a ZIP archive (dotLottie format) containing Lottie JSON. Skottie only parses raw JSON. Extracting the JSON from the ZIP resolves the issue.",
          "proposals": [
            {
              "description": "Use System.IO.Compression to extract the Lottie JSON from the dotLottie ZIP archive before passing it to Animation.Create().",
              "title": "Extract JSON from .lottie ZIP",
              "codeSnippet": "using System.IO.Compression;\n\n// .lottie files are ZIP archives containing Lottie JSON\nusing var archive = ZipFile.OpenRead(\u0022path/to/animation.lottie\u0022);\nvar jsonEntry = archive.Entries.FirstOrDefault(e =\u003E\n    e.FullName.EndsWith(\u0022.json\u0022, StringComparison.OrdinalIgnoreCase) \u0026\u0026\n    !e.FullName.Equals(\u0022manifest.json\u0022, StringComparison.OrdinalIgnoreCase));\n\nif (jsonEntry != null)\n{\n    using var stream = jsonEntry.Open();\n    using var ms = new MemoryStream();\n    stream.CopyTo(ms);\n    ms.Position = 0;\n    var animation = SkiaSharp.Skottie.Animation.Create(ms);\n    if (animation != null)\n    {\n        // Use the animation\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "On LottieFiles, download the .json format instead of .lottie. The JSON format is directly supported by Skottie without any extraction needed.",
              "title": "Download Lottie JSON instead",
              "confidence": 0.95,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Extract JSON from .lottie ZIP",
          "recommendedReason": "Most robust solution \u2014 works regardless of where the .lottie file comes from. The alternative (downloading JSON) only works if you control the download source."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.85,
          "reason": "The API is working as designed. The .lottie format is not Lottie JSON. A clear workaround exists."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Reclassify as question \u2014 this is a format confusion, not a bug",
            "risk": "low",
            "confidence": 0.8,
            "labels": [
              "type/question",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain .lottie vs Lottie JSON format difference and provide extraction workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. The issue here is that \u0060.lottie\u0060 files use the **dotLottie format**, which is a ZIP archive containing Lottie JSON \u2014 it\u0027s not raw JSON itself. Skottie (both in Skia and SkiaSharp) only parses raw Lottie JSON, so passing a ZIP file returns null as expected.\n\nHere\u0027s a workaround to extract the JSON from the \u0060.lottie\u0060 ZIP:\n\n\u0060\u0060\u0060csharp\nusing System.IO.Compression;\n\nusing var archive = ZipFile.OpenRead(sourceFileAbsolute);\nvar jsonEntry = archive.Entries.FirstOrDefault(e =\u003E\n    e.FullName.EndsWith(\u0022.json\u0022, StringComparison.OrdinalIgnoreCase) \u0026\u0026\n    !e.FullName.Equals(\u0022manifest.json\u0022, StringComparison.OrdinalIgnoreCase));\n\nif (jsonEntry != null)\n{\n    using var stream = jsonEntry.Open();\n    using var ms = new MemoryStream();\n    stream.CopyTo(ms);\n    ms.Position = 0;\n    var animation = SkiaSharp.Skottie.Animation.Create(ms);\n}\n\u0060\u0060\u0060\n\nAlternatively, LottieFiles allows downloading the raw \u0060.json\u0060 format directly, which works with \u0060Animation.Create()\u0060 without any extraction."
          },
          {
            "type": "close-issue",
            "description": "Close as answered \u2014 format confusion, not a bug",
            "risk": "medium",
            "confidence": 0.8
          },
          {
            "type": "link-related",
            "description": "Cross-reference #2166 (Skottie BOM loading issue \u2014 similar silent null return pattern)",
            "risk": "low",
            "confidence": 0.6,
            "linkedIssue": 2166
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3420,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:36:00Z",
        "currentLabels": [
          "type/bug",
          "os/Android",
          "area/libSkiaSharp.native",
          "tenet/compatibility"
        ]
      },
      "summary": "Android 16 KB page size support for libSkiaSharp.so \u2014 already fixed in SkiaSharp 3.116.1\u002B via PR #3096 (NDK r27c \u002B max-page-size=16384 linker flag). Reporter used v2.88.6 which will not receive the fix. Duplicate of #3419.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.98
        },
        "platforms": [
          "os/Android"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET MAUI Android app targeting Android 16",
            "Build AAB using SkiaSharp.NativeAssets.Android v2.88.6",
            "Run page size check on .so files",
            "libSkiaSharp.so shows 4 KB page size"
          ],
          "attachments": [
            {
              "url": "https://github.com/user-attachments/files/23669684/16KB_PageSize_Report.txt",
              "filename": "16KB_PageSize_Report.txt",
              "description": "16KB page size report"
            },
            {
              "url": "https://github.com/user-attachments/files/23547442/Android16_PageSize_Issue.pdf",
              "filename": "Android16_PageSize_Issue.pdf",
              "description": "Android 16 page size issue PDF"
            }
          ],
          "environmentDetails": "SkiaSharp.NativeAssets.Android v2.88.6, .NET MAUI 9.0, Android 16\u002B target",
          "relatedIssues": [
            3025,
            3096,
            3419
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "compatibility",
          "errorMessage": "libSkiaSharp.so has 4 KB page size, incompatible with Android 16\u002B 16 KB requirement",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net9.0-android"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.6",
            "2.88.9",
            "3.116.0"
          ],
          "workedIn": "3.116.1",
          "brokeIn": "2.88.6",
          "currentRelevance": "unlikely",
          "relevanceReason": "The fix was merged in PR #3096 (commit db01ee168) and backported to 3.116.1 and 3.118.0-preview.2. All 3.x releases from 3.116.1 onward include the 16KB page alignment linker flag. The reporter\u0027s v2.88.6 is EOL and will not receive the fix."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.98,
          "reason": "PR #3096 added \u0027-Wl,-z,max-page-size=16384\u0027 to the Android build for both libSkiaSharp.so and libHarfBuzzSharp.so. Backported to release/3.116.1 (PR #3098) and release/3.118.0-preview.2 (PR #3099). The linker flag is present in the current native/android/build.cake (line 43) and native/android/libHarfBuzzSharp/jni/HarfBuzzSharp.mk (line 11).",
          "relatedPRs": [
            3096,
            3098,
            3099
          ],
          "relatedCommits": [
            "db01ee168ac455c824a74ff09fbd197fe83cbf64"
          ],
          "fixedInVersion": "3.116.1"
        }
      },
      "analysis": {
        "summary": "Reporter requests 16 KB page size alignment for libSkiaSharp.so on Android, which Google requires for Android 16\u002B. This was already fixed in PR #3096 by adding the -Wl,-z,max-page-size=16384 linker flag and updating to NDK r27c. The fix shipped in SkiaSharp 3.116.1\u002B. The reporter is on v2.88.6 (EOL 2.x series), which will not receive the fix. Issue #3419 is an exact duplicate closed by maintainer as dup of this issue.",
        "codeInvestigation": [
          {
            "file": "native/android/build.cake",
            "finding": "Line 43 contains extra_ldflags with \u0027-Wl,-z,max-page-size=16384\u0027 \u2014 this is the 16KB page alignment linker flag required by Android 16\u002B. Present in current main branch.",
            "relevance": "direct",
            "lines": "43"
          },
          {
            "file": "native/android/build.cake",
            "finding": "Android builds for all 4 architectures: x86, x86_64, armeabi-v7a, arm64-v8a. The linker flag applies to all architectures.",
            "relevance": "context",
            "lines": "18-21"
          },
          {
            "file": "native/android/libHarfBuzzSharp/jni/HarfBuzzSharp.mk",
            "finding": "HarfBuzzSharp.mk also includes -Wl,-z,max-page-size=16384 in LOCAL_LDFLAGS, so libHarfBuzzSharp.so is also 16KB-aligned.",
            "relevance": "direct",
            "lines": "11"
          }
        ],
        "rationale": "Classified as type/bug (not feature-request) because the native library violates a platform requirement, causing deployment failure. Area is libSkiaSharp.native since this is a native build configuration issue, not a C# API problem. Severity is medium because it blocks Android 16\u002B deployment but has a clear upgrade path. The fix is confirmed present in the codebase \u2014 the linker flag exists in both build.cake and HarfBuzzSharp.mk.",
        "keySignals": [
          {
            "text": "extra_ldflags=[ \u0027-Wl,-z,max-page-size=16384\u0027 ]",
            "source": "native/android/build.cake:43",
            "interpretation": "The 16KB page alignment linker flag is already present in the current Android build configuration for libSkiaSharp.so."
          },
          {
            "text": "LOCAL_LDFLAGS := -Wl,--gc-sections -Wl,-z,max-page-size=16384",
            "source": "native/android/libHarfBuzzSharp/jni/HarfBuzzSharp.mk:11",
            "interpretation": "HarfBuzzSharp also has the 16KB alignment flag, so both native libraries are covered."
          },
          {
            "text": "Update the Android NDK to r27c and update to 16kb alignment (#3096)",
            "source": "git log commit db01ee168",
            "interpretation": "The fix was merged to main and backported to 3.116.1 and 3.118.0-preview.2."
          },
          {
            "text": "Have you tried the 3.x series of SkiaSharp? The 2.x series is not really supported",
            "source": "comment by mattleibow on #3420",
            "interpretation": "Maintainer already directed reporter to upgrade to 3.x, confirming 2.x will not be fixed."
          },
          {
            "text": "SkiaSharp.NativeAssets.Android v2.88.6",
            "source": "issue body",
            "interpretation": "Reporter is on 2.88.6 (EOL). The fix only exists in 3.116.1\u002B."
          }
        ],
        "workarounds": [
          "Upgrade to SkiaSharp 3.116.1 or later, which includes the 16KB page alignment fix for both libSkiaSharp.so and libHarfBuzzSharp.so."
        ],
        "resolution": {
          "hypothesis": "The issue is already fixed in SkiaSharp 3.116.1\u002B via PR #3096. The reporter needs to upgrade from the unsupported 2.x series.",
          "proposals": [
            {
              "description": "Upgrade from SkiaSharp 2.88.6 to 3.116.1 or later. The 16KB page alignment was added in PR #3096 and backported to 3.116.1. All subsequent 3.x releases include this fix.",
              "title": "Upgrade to SkiaSharp 3.116.1\u002B",
              "confidence": 0.98,
              "effort": "medium"
            },
            {
              "description": "For the best experience, upgrade directly to the latest stable 3.119.x release which includes the 16KB alignment fix plus all other improvements since 3.116.1.",
              "title": "Use latest 3.119.x release",
              "confidence": 0.98,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Upgrade to SkiaSharp 3.116.1\u002B",
          "recommendedReason": "The fix already exists and is released. Minimum viable upgrade is 3.116.1; latest stable 3.119.x is recommended for additional improvements."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.95,
          "reason": "The 16KB page alignment was fixed in PR #3096 and shipped in SkiaSharp 3.116.1\u002B. The 2.x series is EOL. Reporter should upgrade."
        },
        "actions": [
          {
            "type": "add-comment",
            "description": "Inform reporter the fix exists in 3.116.1\u002B and recommend upgrading",
            "risk": "high",
            "confidence": 0.95,
            "comment": "Thanks for the report. The 16 KB page alignment for Android was fixed in PR #3096 and shipped starting with SkiaSharp 3.116.1. Both \u0060libSkiaSharp.so\u0060 and \u0060libHarfBuzzSharp.so\u0060 are now built with \u0060-Wl,-z,max-page-size=16384\u0060.\n\nAs mentioned above, the 2.x series is no longer supported and won\u0027t receive this fix. Upgrading to SkiaSharp 3.116.1 or later (the latest stable is 3.119.2) will resolve the Android 16\u002B compatibility issue.\n\nFor migration guidance from 2.x to 3.x, see the [SkiaSharp 3.0 migration notes](https://github.com/mono/SkiaSharp/wiki/SkiaSharp-3.0-Migration)."
          },
          {
            "type": "link-duplicate",
            "description": "Link to original tracking issue #3025",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 3025
          },
          {
            "type": "close-issue",
            "description": "Close as already fixed in 3.116.1\u002B",
            "risk": "medium",
            "confidence": 0.9
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3418,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:25:00Z",
        "currentLabels": []
      },
      "summary": "Draft PR investigating significant rendering performance gap between native C\u002B\u002B Skia (~120fps) and SkiaSharp C# (\u003C10fps) using MotionMark benchmark, with partial improvements to ~40fps via OpenGL configuration changes",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.9
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.85
        },
        "platforms": [
          "os/macOS"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Run the MotionMark benchmark from https://github.com/wieslawsoltes/FastSkiaSharp (C\u002B\u002B native)",
            "Compare FPS with the equivalent SkiaSharp C# implementation in the macOS sample",
            "Observe ~120fps in C\u002B\u002B vs \u003C10fps in SkiaSharp"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/b4a89a55-21b4-40e6-8222-b7731b43f3d0",
              "description": "Performance comparison showing C\u002B\u002B vs SkiaSharp FPS"
            }
          ],
          "environmentDetails": "macOS, OpenGL backend, SkiaSharp current version, net9.0-macos",
          "repoLinks": [
            {
              "url": "https://github.com/wieslawsoltes/FastSkiaSharp",
              "description": "Original C\u002B\u002B MotionMark benchmark showing 120fps"
            },
            {
              "url": "https://github.com/mattleibow/FastSkiaSharp",
              "description": "Maintainer fork with downgraded Skia (111-119fps)"
            }
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "current (Skia m119 equivalent)"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The performance gap is structural \u2014 it exists across Skia versions (newer Skia only marginally faster: 120fps vs 111-119fps). The C\u002B\u002B to C# overhead is the core issue."
        }
      },
      "analysis": {
        "summary": "Maintainer-authored draft PR investigating a 10x\u002B rendering performance gap between native C\u002B\u002B Skia and SkiaSharp. The PR identifies multiple contributing factors: VSync locking, suboptimal OpenGL pixel format (multisample 4x), display queue overhead, and potentially P/Invoke marshaling cost. Partial fixes achieve ~40fps but a significant gap remains.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKGLView.cs",
            "finding": "Current production code uses multisample 4x (SampleBuffers=1, Samples=4), 32-bit color, 24-bit depth, and no explicit OpenGL profile. The PR changes to: no multisample (SampleBuffers=0), OpenGL 3.2 Core profile, 24-bit color \u002B 8-bit alpha, 0-bit depth \u2014 matching C\u002B\u002B sk_app pixel format exactly.",
            "relevance": "direct",
            "lines": "62-81"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKGLView.cs",
            "finding": "Current code does not set SwapInterval. The PR adds SwapInterval=0 (VSync disabled) in PrepareOpenGL, matching C\u002B\u002B behavior. VSync at 60Hz would cap fps to 60, but the sub-10fps baseline suggests VSync alone doesn\u0027t explain the gap.",
            "relevance": "direct",
            "lines": "88-95"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKGLView.cs",
            "finding": "DrawRect creates surface only when null, but PR restructures to RenderDirect() bypassing the NSView display queue. The PR also changes flush pattern from canvas.Flush()\u002Bcontext.Flush() to the new gr_direct_context_flush_surface API.",
            "relevance": "direct",
            "lines": "108-176"
          },
          {
            "file": "binding/SkiaSharp/GRContext.cs",
            "finding": "PR adds new Flush(SKSurface) method wrapping gr_direct_context_flush_surface \u2014 a combined surface\u002Bcontext flush matching C\u002B\u002B pattern. This is a new API addition.",
            "relevance": "direct",
            "lines": "153-158"
          },
          {
            "file": "externals/skia/src/c/gr_context.cpp",
            "finding": "gr_direct_context_flush_surface implementation exists in the C API layer, calling through to Skia\u0027s surface flush \u002B context submit pattern.",
            "relevance": "direct",
            "lines": "146"
          },
          {
            "file": "samples/Basic/macOS/SkiaSharpSample/MotionMarkScene.cs",
            "finding": "New benchmark scene using paths (lines, quads, cubics) with configurable complexity (1K-120K elements). Uses CollectionsMarshal.AsSpan for zero-copy iteration \u2014 well-optimized C# code.",
            "relevance": "context"
          },
          {
            "file": "samples/Basic/macOS/SkiaSharpSample/Main.cs",
            "finding": "PR replaces NSApplication.Main(args) with a manual tight render loop: process pending events \u2192 RenderFrame \u2192 repeat. This matches the C\u002B\u002B sk_app pattern and bypasses macOS display queue latency.",
            "relevance": "direct"
          }
        ],
        "rationale": "This is an enhancement PR, not a bug \u2014 SkiaSharp renders correctly, just slowly. Classified as area/SkiaSharp.Views because the primary changes target SKGLView\u0027s OpenGL initialization and render loop on macOS. The performance tenet applies directly. The PR is a draft investigation by the maintainer (mattleibow), including a MotionMark benchmark scene, OpenGL configuration changes, a new GRContext.Flush(SKSurface) API, and a tight render loop bypassing NSRunLoop.",
        "keySignals": [
          {
            "text": "The native code is 120fps, but skiasharp is sub 10fps",
            "source": "PR description",
            "interpretation": "10x\u002B performance gap indicates structural overhead, not a simple configuration issue."
          },
          {
            "text": "I got to 40fps by using the new opengl flags in the SKGLView",
            "source": "PR description",
            "interpretation": "OpenGL pixel format changes (removing multisample, adding VSync disable) provide ~4x improvement, but 3x gap remains."
          },
          {
            "text": "My fork which downgrades skia to the same version in skiasharp is a tiny bit slower, 111-119 fps",
            "source": "PR description",
            "interpretation": "Newer Skia version is only marginally faster \u2014 the perf gap is NOT caused by Skia version differences."
          },
          {
            "text": "This all appears to be inside the skia code, which appears to be using similar compiler args",
            "source": "PR description",
            "interpretation": "Compiler optimizations are similar; the gap is likely in the C#\u2192C interop layer, render loop architecture, or GPU synchronization patterns."
          }
        ],
        "nextQuestions": [
          "What proportion of the remaining gap (40fps vs 120fps) is P/Invoke overhead vs GPU synchronization differences?",
          "Would the newer interop primitives from Epic #2615 (source generators, LibraryImport) reduce the P/Invoke overhead measurably?",
          "Is the gap similar on other platforms (Android, iOS) or specific to macOS OpenGL?",
          "Does the #3393 GC.KeepAlive issue contribute to performance (GC pressure from unprotected P/Invoke sites)?",
          "How does Metal backend compare \u2014 macOS OpenGL is deprecated and may have driver overhead"
        ],
        "resolution": {
          "hypothesis": "The performance gap has multiple contributing factors: (1) VSync and multisample overhead in OpenGL config (~4x improvement when fixed), (2) NSView display queue adds latency vs tight render loop, (3) remaining gap likely from P/Invoke marshaling overhead on hot render paths and GRContext flush pattern differences.",
          "proposals": [
            {
              "description": "Apply the pixel format changes from this PR: disable multisample, use OpenGL 3.2 Core, disable VSync, match C\u002B\u002B sk_app pixel format. This alone achieved ~4x improvement (sub-10fps \u2192 ~40fps).",
              "title": "OpenGL configuration optimization",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "The new GRContext.Flush(SKSurface) API combines surface and context flush in a single P/Invoke call, reducing interop overhead on the hot path.",
              "title": "Surface flush API",
              "confidence": 0.7,
              "effort": "small"
            },
            {
              "description": "Related to Epic #2615 \u2014 use LibraryImport source generators and newer interop primitives to reduce marshaling overhead on hot rendering paths.",
              "title": "Modernize P/Invoke layer",
              "confidence": 0.5,
              "effort": "large"
            },
            {
              "description": "macOS OpenGL is deprecated since Mojave. Metal backend may have less driver overhead and better performance characteristics. Worth benchmarking.",
              "title": "Investigate Metal backend",
              "confidence": 0.4,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "OpenGL configuration optimization",
          "recommendedReason": "Already proven to deliver ~4x improvement with minimal code changes. Should be merged independently of ongoing investigation."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "This is an active investigation by the maintainer. The PR identifies partial fixes but the root cause of the remaining 3x gap (40fps vs 120fps) is still under investigation. The OpenGL config changes and new flush API could be extracted and merged independently."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply enhancement, views, macOS, OpenGL, and performance labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "os/macOS",
              "backend/OpenGL",
              "tenet/performance"
            ]
          },
          {
            "type": "add-comment",
            "description": "Respond to community question about perf findings and status",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for the interest. This is still an active investigation.\n\nSo far we\u0027ve identified several factors contributing to the performance gap:\n\n1. **OpenGL configuration** \u2014 The default SKGLView pixel format used 4x multisample and didn\u0027t disable VSync. Matching the C\u002B\u002B sk_app configuration (no multisample, VSync off, OpenGL 3.2 Core profile) improved from sub-10fps to ~40fps.\n\n2. **Render loop architecture** \u2014 The standard NSView display queue adds latency. A tight render loop matching the C\u002B\u002B pattern helps.\n\n3. **Remaining gap** \u2014 Even with these optimizations, there\u0027s still a ~3x gap (40fps vs 120fps) that needs further investigation. Potential factors include P/Invoke marshaling overhead on hot paths and GPU flush pattern differences.\n\nThe investigation is ongoing. Some of the configuration improvements (pixel format, VSync) could be shipped independently."
          },
          {
            "type": "link-related",
            "description": "Cross-reference P/Invoke modernization epic",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 2615
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3402,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:36:00Z",
        "currentLabels": [
          "type/feature-request"
        ]
      },
      "summary": "Feature request: support drawing to/from compressed indexed color bitmaps (1bpp, 2bpp, 4bpp) for retro game graphics in Avalonia UI",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        }
      },
      "evidence": {
        "reproEvidence": {
          "environmentDetails": "Avalonia UI, wants NES/SNES graphics system",
          "relatedIssues": [
            568,
            363,
            2383
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "Skia removed indexed color (Index8/ColorTable) support in M61 (2017). The upstream library fundamentally does not support sub-byte-per-pixel indexed color types. This is not something SkiaSharp can add without forking Skia\u0027s pixel pipeline."
        }
      },
      "analysis": {
        "summary": "User requests native support for 1bpp, 2bpp, and 4bpp indexed color bitmaps with palette-based drawing, motivated by building a NES/SNES tile graphics editor in Avalonia UI. They want pixel operations on packed formats without expanding to 32bpp, and storage efficiency for large tile sets (8\u00D78 tiles \u00D7 65536 pages).",
        "codeInvestigation": [
          {
            "file": "externals/skia/include/core/SkColorType.h",
            "finding": "SkColorType enum has no indexed, palette-based, or sub-8bpp formats. The minimum pixel size is 8 bits (Alpha8, Gray8). No 1bpp/2bpp/4bpp types exist upstream.",
            "relevance": "direct",
            "lines": "19-66"
          },
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "SKColorType mirrors Skia\u0027s enum exactly: smallest type is Alpha8 (1 byte). No indexed color types. GetBytesPerPixel() has no sub-byte entries.",
            "relevance": "direct",
            "lines": "36-63"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "Legacy string constant \u0027UnsupportedColorTypeMessage\u0027 references Index8 \u2014 a vestige from when Skia had indexed color. The actual Index8 type no longer exists in the enum.",
            "relevance": "context",
            "lines": "16"
          },
          {
            "file": "binding/SkiaSharp/SKImageInfo.cs",
            "finding": "BitsPerPixel is computed as BytesPerPixel * 8, meaning the minimum is 8 bits. The architecture assumes whole-byte pixels throughout \u2014 sub-byte formats would require pervasive changes.",
            "relevance": "direct",
            "lines": "104-118"
          }
        ],
        "rationale": "Classified as feature-request because the user explicitly asks for new pixel format support that has never existed in SkiaSharp. Area is core SkiaSharp since it involves SKColorType and the pixel pipeline. Skia upstream removed its last indexed format (Index8) in M61 circa 2017 (tracked in #568). The current SKColorType enum has no sub-8bpp or indexed types. Adding 1/2/4bpp indexed color would require either a custom pixel pipeline outside Skia or upstream Skia changes \u2014 neither is feasible for SkiaSharp to take on. The user\u0027s real need is compact storage and palette-based rendering for retro game tiles, which can be achieved with application-level indirection using existing SkiaSharp APIs.",
        "keySignals": [
          {
            "text": "Please support drawing to and from compressed 1bpp 2bpp and 4bpp indexed color graphics",
            "source": "issue body",
            "interpretation": "Requests pixel formats that do not exist in Skia or SkiaSharp \u2014 these are sub-byte packed indexed formats."
          },
          {
            "text": "Pixel operations should work on multiple pixels at a time with these formats without expanding them in memory",
            "source": "issue body - additional context",
            "interpretation": "Asks for native bitwise pixel operations on packed formats \u2014 this would require a custom blitter in the rendering pipeline, well beyond SkiaSharp\u0027s wrapping scope."
          },
          {
            "text": "8 * 8 * 32 * 30 * 65536 pixels which in 4bpp color would be 1.87 GiB",
            "source": "issue body",
            "interpretation": "Use case is massive tile-based retro game graphics. Storage concern is legitimate but solvable at the application layer with indexed lookup tables."
          },
          {
            "text": "Color Tables and Index8: removed in Skia M61",
            "source": "#568",
            "interpretation": "Skia upstream intentionally removed indexed color support years ago. SkiaSharp cannot re-add it without forking the pixel pipeline."
          }
        ],
        "nextQuestions": [
          "Would the user accept an application-level palette lookup approach using SKBitmap with Alpha8 (for 8-bit indices) and SKColorFilter or manual pixel expansion?",
          "Is the primary concern storage size on disk, or in-memory rendering performance?"
        ],
        "resolution": {
          "hypothesis": "Skia intentionally removed indexed color support in 2017. Sub-byte pixel formats (1/2/4bpp) are not part of Skia\u0027s pixel model and would require forking the rendering pipeline. The user\u0027s retro game tile use case can be achieved with application-level palette indirection: store indices in compact byte arrays, expand to RGBA only when rendering to SKBitmap.",
          "proposals": [
            {
              "description": "Store tile indices as byte arrays (one index per byte using Alpha8 color type for 256-color palettes). When rendering, expand indices to RGBA using a lookup table and write into an SKBitmap via GetPixels()/InstallPixels(). This gives compact in-memory storage (1 byte per pixel vs 4) while using standard SkiaSharp APIs.",
              "title": "Application-level palette lookup with Alpha8",
              "codeSnippet": "// Store palette (up to 256 colors)\nvar palette = new SKColor[256];\npalette[0] = SKColors.Black;\npalette[1] = SKColors.Red;\n// ... fill palette\n\n// Tile indices stored compactly (1 byte per pixel)\nbyte[] tileIndices = new byte[8 * 8]; // 8x8 tile\n\n// Expand to RGBA when rendering\nvar info = new SKImageInfo(8, 8, SKColorType.Rgba8888, SKAlphaType.Premul);\nusing var bitmap = new SKBitmap(info);\nunsafe\n{\n    var ptr = (uint*)bitmap.GetPixels();\n    for (int i = 0; i \u003C tileIndices.Length; i\u002B\u002B)\n        ptr[i] = (uint)palette[tileIndices[i]];\n}\nbitmap.NotifyPixelsChanged();\n// Draw tile to canvas\ncanvas.DrawBitmap(bitmap, x, y);",
              "confidence": 0.85,
              "effort": "medium"
            },
            {
              "description": "For 1/2/4bpp storage efficiency, pack indices into byte arrays at the application level (e.g., 2 pixels per byte for 4bpp). Only expand to full SKBitmap pixels when a tile needs to be rendered. This achieves the reporter\u0027s storage goal without requiring Skia-level changes.",
              "title": "Bit-packed storage with on-demand expansion",
              "confidence": 0.8,
              "effort": "medium"
            },
            {
              "description": "Maintain a shared render buffer and re-expand only changed tiles. Create SKImage from the buffer for efficient GPU upload. Reduces per-frame expansion cost for large tile maps.",
              "title": "Use SKImage.FromPixels with pre-expanded buffer",
              "confidence": 0.75,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Application-level palette lookup with Alpha8",
          "recommendedReason": "Achieves 4:1 memory reduction (1 byte vs 4 bytes per pixel) while using standard, well-tested SkiaSharp APIs. The expansion step is simple and fast for 8\u00D78 tiles. For sub-byte packing (4bpp/2bpp/1bpp), the application can add bit-packing on top of this pattern."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Feature request for indexed color support that Skia upstream intentionally removed. Workaround exists using application-level palette lookup. Keeping open for maintainer to decide whether to close as won\u0027t-fix or leave as a tracked request."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm existing feature-request label and add area",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain that indexed color is not supported in Skia upstream and provide a workaround using palette lookup at the application level",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed explanation of your use case.\n\nSkia (the underlying C\u002B\u002B library) removed indexed/palette-based color types (Index8) back in 2017, and has no support for sub-byte pixel formats like 1bpp, 2bpp, or 4bpp. All pixel formats in Skia use at least 8 bits per pixel. Since SkiaSharp wraps Skia, adding these formats would require changes to Skia\u0027s core rendering pipeline \u2014 which is outside our scope.\n\nThat said, you can achieve compact palette-based tile rendering at the application level:\n\n\u0060\u0060\u0060csharp\n// Store your palette\nvar palette = new SKColor[16]; // 4bpp = 16 colors\npalette[0] = SKColors.Black;\npalette[1] = SKColors.Red;\n// ...\n\n// Store tile indices compactly (1 byte per pixel, or bit-pack for 4bpp)\nbyte[] tileIndices = new byte[8 * 8]; // 8x8 NES tile\n\n// Expand to RGBA only when rendering\nvar info = new SKImageInfo(8, 8, SKColorType.Rgba8888, SKAlphaType.Premul);\nusing var bitmap = new SKBitmap(info);\nunsafe\n{\n    var ptr = (uint*)bitmap.GetPixels();\n    for (int i = 0; i \u003C tileIndices.Length; i\u002B\u002B)\n        ptr[i] = (uint)palette[tileIndices[i]];\n}\nbitmap.NotifyPixelsChanged();\ncanvas.DrawBitmap(bitmap, destX, destY);\n\u0060\u0060\u0060\n\nFor sub-byte packing (4bpp/2bpp), you can pack multiple indices per byte in your storage format and unpack only when expanding to the render buffer. This keeps your binary storage compact while using SkiaSharp\u0027s standard rendering path.\n\nFor a NES/SNES-style tile system with 65K\u002B tiles, consider maintaining a small render buffer and only expanding the visible tiles each frame \u2014 the expansion cost for 8\u00D78 tiles is negligible.\n\nSee also #568 (the Skia M61 update that removed Index8) and #2383 (similar discussion about non-standard pixel formats)."
          },
          {
            "type": "link-related",
            "description": "Cross-reference the Skia M61 update issue that removed Index8",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 568
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3400,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:30:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "backend/PDF",
          "tenet/reliability",
          "backend/Xps"
        ]
      },
      "summary": "SKDocument.CreateXps() renders embedded SVG \u003Cimage\u003E elements at incorrect (smaller) dimensions, while CreatePdf() renders them correctly \u2014 upstream Skia XPS backend bug in SkXPSDevice image handling",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.92
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/XPS"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Load an SVG containing \u003Cimage\u003E elements with Base64-encoded images using SKSvg.Load()",
            "Generate XPS using SKDocument.CreateXps() with canvas.Scale(72/96) and canvas.DrawPicture()",
            "Generate PDF using SKDocument.CreatePdf() with the same code",
            "Compare: PDF images are correct, XPS images are ~30-40% of expected size"
          ],
          "environmentDetails": "Windows 10/11, .NET 9.0, SkiaSharp 3.119.1 (also reproducible on 3.116.0), Svg.Skia 3.2.1",
          "relatedIssues": [
            1728
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "wrong-output",
          "errorMessage": "Images are significantly smaller (approximately 30-40% of correct size) in XPS output",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net9.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.1",
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The upstream Skia XPS device code (SkXPSDevice::drawImageRect, SkXPSDevice::createXpsImageBrush) has not been fixed. The bug exists in the Skia C\u002B\u002B layer and the code path is unchanged."
        }
      },
      "analysis": {
        "summary": "XPS image scaling bug in the upstream Skia XPS backend. The SkXPSDevice::drawImageRect method converts images to bitmap shaders and draws them via createXpsImageBrush, which sets image brush viewbox/viewport in pixel coordinates. The XPS DPI conversion in endSheet() (96 DPI target vs user-specified DPI) correctly scales vector geometry but image brushes don\u0027t scale proportionally, producing undersized images. This is the same root cause as #1728 (XPS DrawBitmap clipping). A commenter on #1728 identified specific Skia source lines and filed upstream Skia bug https://issues.skia.org/issues/360641492.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKDocument.cs",
            "finding": "CreateXps(SKWStream, float dpi) passes through to sk_document_create_xps_from_stream \u2014 C# wrapper is correct, no transformation or modification of parameters.",
            "relevance": "context",
            "lines": "67-73"
          },
          {
            "file": "externals/skia/src/c/sk_document.cpp",
            "finding": "C API sk_document_create_xps_from_stream calls SkXPS::MakeDocument(AsWStream(stream), dpi) directly \u2014 no bug at C shim layer.",
            "relevance": "context",
            "lines": "30-31"
          },
          {
            "file": "externals/skia/src/xps/SkXPSDocument.cpp",
            "finding": "XPS document constructor computes fUnitsPerMeter (points-based at 72pt/inch) and fPixelsPerMeter (DPI-based). When DPI=72 (default), both equal ~2834.645. These are passed to beginSheet().",
            "relevance": "related",
            "lines": "37-50"
          },
          {
            "file": "externals/skia/src/xps/SkXPSDevice.cpp",
            "finding": "endSheet() applies a scale of 96/fCurrentUnitsPerMeter to convert from geometry units to XPS\u0027s native 96 DPI. This correctly scales vector content but the image brush viewbox/viewport (set in pixel space in createXpsImageBrush) doesn\u0027t account for this transform.",
            "relevance": "direct",
            "lines": "265-298"
          },
          {
            "file": "externals/skia/src/xps/SkXPSDevice.cpp",
            "finding": "drawImageRect converts image to bitmap, creates a bitmap shader with RectToRect matrix, then calls drawRect. The image dimensions in pixel space flow into createXpsImageBrush where bitmapRect uses raw pixel width/height for the XPS viewbox.",
            "relevance": "direct",
            "lines": "1997-2031"
          },
          {
            "file": "externals/skia/src/xps/SkXPSDevice.cpp",
            "finding": "createXpsImageBrush sets XPS_RECT viewbox using bitmap pixel dimensions directly. The localMatrix from the shader maps these to geometry coordinates, but the endSheet DPI transform creates a mismatch for the image brush sizing.",
            "relevance": "direct",
            "lines": "635-822"
          }
        ],
        "rationale": "Classified as type/bug because the same code produces correct output with CreatePdf() but incorrect output with CreateXps() \u2014 this is broken behavior, not user error. Area changed to area/libSkiaSharp.native because the bug is in the Skia C\u002B\u002B XPS backend (SkXPSDevice), not in the C# wrapper. The C# SKDocument.CreateXps() correctly passes parameters through to the C API. Severity is medium: it affects a real use case (label printing via Windows XPS pipeline) but XPS usage is niche and PDF is a viable workaround.",
        "keySignals": [
          {
            "text": "PDF Output: \u2705 Images render correctly; XPS Output: \u274C Images are significantly smaller (approximately 30-40% of correct size)",
            "source": "issue body",
            "interpretation": "Same SKPicture object, different backends \u2014 isolates the bug to the XPS backend specifically."
          },
          {
            "text": "All other SVG elements (text, barcodes, rectangles, shapes) render correctly in both formats",
            "source": "issue body",
            "interpretation": "Vector geometry is scaled correctly by endSheet(); only rasterized image content is affected \u2014 points to SkXPSDevice::drawImageRect/createXpsImageBrush."
          },
          {
            "text": "It turns out that this is a bug in the Google Skia code. It\u0027s even commented",
            "source": "#1728 comment by oatkins",
            "interpretation": "Independently confirmed as upstream Skia bug. Filed as https://issues.skia.org/issues/360641492."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "issue body",
            "interpretation": "Reporter claims it worked in 2.88.x, but #1728 reports the same issue on 2.88.8 \u2014 the regression claim may be incorrect or the symptom manifests differently."
          }
        ],
        "workarounds": [
          "Use SKDocument.CreatePdf() instead of CreateXps() \u2014 PDF backend handles images correctly",
          "Convert PDF to XPS using a separate tool (e.g., Windows print-to-XPS from PDF) if XPS output is required for the print pipeline"
        ],
        "nextQuestions": [
          "Has upstream Skia bug https://issues.skia.org/issues/360641492 received any response or fix?",
          "Is the reporter\u0027s claim of working in 2.88.9 accurate, given #1728 reports the same issue on 2.88.8?",
          "Could the DPI parameter to CreateXps() be adjusted to partially compensate for the scaling issue?"
        ],
        "resolution": {
          "hypothesis": "The Skia XPS backend (SkXPSDevice) has a long-standing bug in image rendering where the image brush viewbox/viewport is set in pixel coordinates that don\u0027t correctly account for the DPI scaling applied by endSheet(). This causes images to appear smaller than expected while vector geometry renders correctly.",
          "proposals": [
            {
              "description": "Replace SKDocument.CreateXps() with SKDocument.CreatePdf(). If XPS is required for the Windows print pipeline, generate PDF first and convert to XPS using the Windows print subsystem (e.g., Microsoft Print to XPS from a PDF viewer, or programmatic conversion via Windows.Graphics.Printing).",
              "title": "Use PDF instead of XPS",
              "confidence": 0.95,
              "effort": "small"
            },
            {
              "description": "Fix SkXPSDevice::createXpsImageBrush to account for the DPI conversion that endSheet() applies. The image brush viewbox/viewport dimensions need to be adjusted by the same scale factor (targetUnitsPerMeter / fCurrentUnitsPerMeter) that endSheet uses for geometry. This is an upstream Skia fix.",
              "title": "Fix upstream Skia XPS image scaling",
              "confidence": 0.6,
              "effort": "large"
            },
            {
              "description": "Rasterize the SVG to an SKImage at the target resolution first, then draw the raster image into the XPS document at 1:1 scale (no canvas.Scale). This avoids the image-vs-geometry scaling mismatch.",
              "title": "Pre-scale images before XPS rendering",
              "confidence": 0.55,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Use PDF instead of XPS",
          "recommendedReason": "PDF backend is proven to render images correctly. XPS-specific output can be obtained by converting from PDF if needed. The XPS image bug is in upstream Skia and a proper fix requires changes to Skia\u0027s XPS device code."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Confirmed upstream Skia XPS bug. Root cause is identified but fix requires upstream Skia changes. Related to open issue #1728 and upstream Skia bug report."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Update area to libSkiaSharp.native (bug is in Skia C\u002B\u002B XPS backend), remove backend/PDF (PDF works correctly, it\u0027s not the bug area)",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/Windows-Classic",
              "backend/XPS",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1728 \u2014 same root cause (XPS image rendering bug in SkXPSDevice)",
            "risk": "low",
            "confidence": 0.92,
            "linkedIssue": 1728
          },
          {
            "type": "add-comment",
            "description": "Post analysis linking to #1728 and upstream Skia bug, suggest PDF workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed reproduction steps.\n\nThis is a known bug in the upstream Skia XPS backend \u2014 the same root cause as #1728. The issue is in \u0060SkXPSDevice::createXpsImageBrush\u0060 where image brush dimensions aren\u0027t correctly adjusted for the DPI scaling that the XPS output applies to geometry. Vector content (text, shapes, paths) scales correctly through \u0060endSheet()\u0060, but rasterized image content does not.\n\nThis has been reported upstream to Google Skia as https://issues.skia.org/issues/360641492.\n\nHere\u0027s a workaround you can use while we investigate: use \u0060SKDocument.CreatePdf()\u0060 instead of \u0060CreateXps()\u0060. If you specifically need XPS output for the Windows print pipeline, you can generate PDF first and convert to XPS using the system\u0027s Microsoft Print to XPS printer driver, or use \u0060System.Drawing.Printing\u0060 / \u0060Windows.Graphics.Printing\u0060 APIs to print the PDF through the XPS spool path.\n\nWe\u0027ll track the upstream Skia fix and apply it when available."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3398,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:30:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "Intermittent native crash in sk_canvas_draw_path when Mapsui calls GetMapInfo during PointerMoved events on Avalonia desktop",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.65
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.75
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create Avalonia desktop app using Mapsui with SkiaSharp rendering",
            "Call GetMapInfo() from PointerMoved event handler",
            "Move pointer rapidly over map \u2014 crash occurs intermittently"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/cf361924-61d3-4773-9689-b4c36b927b71",
              "description": "Error dialog showing crash"
            },
            {
              "url": "https://github.com/user-attachments/assets/40e7de45-62b9-42bf-9c05-7073203d9258",
              "description": "Application crash details"
            }
          ],
          "environmentDetails": ".NET 9.0.7 (CoreCLR 9.0.725.31616), Windows 11, Avalonia 11.3.7",
          "relatedIssues": [
            3393,
            3394,
            1168,
            1180
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "crash",
          "errorMessage": "Unhandled exception in sk_canvas_draw_path \u2014 process terminated",
          "stackTrace": "at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr)\nat SkiaSharp.SKCanvas.DrawPath(SKPath, SKPaint)\nat Mapsui.Rendering.Skia.Extensions.SkCanvasExtensions.DrawPath(...)\nat Mapsui.Rendering.Skia.LineStringRenderer.Draw(...)\nat Mapsui.Rendering.Skia.MapRenderer.GetMapInfo(...)\nat Mapsui.UI.Avalonia.MapControl.GetMapInfo(...)\nat FlightControlViewModel.MapControl_PointerMoved(...)",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net9.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.8",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "currentRelevance": "likely",
          "relevanceReason": "Reporter selected 3.116.0 in template but Comment 2 says \u0027SkiaSharp.dll version is 2.88.8.0\u0027. Mapsui may be pinned to 2.88.x. The P/Invoke GC safety issue (#3393) affects all versions."
        }
      },
      "analysis": {
        "summary": "Intermittent native crash in sk_canvas_draw_path during high-frequency PointerMoved events. Two likely root causes: (1) SkiaSharp\u0027s known missing GC.KeepAlive calls in P/Invoke wrappers (#3393), where GC can collect SKPath/SKPaint during the native call; (2) Mapsui threading issues \u2014 GetMapInfo renders to a canvas concurrently with the main render loop. The intermittent nature and high-frequency event trigger strongly suggest GC pressure causing premature collection.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "DrawPath checks for null path/paint but does NOT call GC.KeepAlive after P/Invoke. Once Handle IntPtrs are extracted, the GC can collect the managed objects and finalize them, freeing native memory mid-call.",
            "relevance": "direct",
            "lines": "405-412"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKNativeObject has a ~finalizer that calls Dispose(false), which sets Handle to IntPtr.Zero and calls DisposeNative(). If GC finalizes during P/Invoke, native handle is freed.",
            "relevance": "direct",
            "lines": "229-276"
          },
          {
            "file": "externals/skia/src/c/sk_canvas.cpp",
            "finding": "sk_canvas_draw_path dereferences all three pointers (canvas, path, paint) without null checks \u2014 passing freed/zeroed handles causes undefined behavior (crash).",
            "relevance": "direct",
            "lines": "180-182"
          }
        ],
        "rationale": "Classified as type/bug with moderate confidence because #3393 documents a real SkiaSharp P/Invoke safety gap that directly affects this code path (DrawPath extracts Handle IntPtrs without GC.KeepAlive). However, the crash may also be caused by Mapsui\u0027s own threading model \u2014 calling GetMapInfo from PointerMoved while the render loop is active could share SKCanvas/SKPath/SKPaint across threads. Area is core SkiaSharp since the crash is in the P/Invoke layer, not in a views package. Severity is medium: the crash is intermittent and requires specific Mapsui usage patterns to trigger.",
        "keySignals": [
          {
            "text": "always collapse when drawing graphics, Occasionally, it does not necessarily appear, but it appears frequently",
            "source": "issue body",
            "interpretation": "Intermittent crash \u2014 classic symptom of race condition or GC timing issue, not a deterministic bug."
          },
          {
            "text": "at SkiaSharp.SkiaApi.sk_canvas_draw_path(IntPtr, IntPtr, IntPtr)",
            "source": "comment 3 stack trace",
            "interpretation": "Crash in native P/Invoke \u2014 the managed IntPtr handles may point to freed memory if GC collected the source objects."
          },
          {
            "text": "the SkiaSharp.dll version is 2.88.8.0",
            "source": "comment 2",
            "interpretation": "Contradicts the 3.116.0 selection in template. Reporter may be using an older SkiaSharp via Mapsui\u0027s dependency."
          },
          {
            "text": "The crash indeed occurred during the process of using MapInfo\u0027s query GetMapInfo(). It was retrieving MapInfo in the PointerMoved event.",
            "source": "issue body",
            "interpretation": "High-frequency event causing concurrent rendering \u2014 GetMapInfo draws features to a canvas to hit-test, potentially racing with the main render loop."
          },
          {
            "text": "Looks more like a Mapsui issue? There\u0027s doesn\u0027t look like there\u0027s anything here that suggests that SkiaSharp is at fault...",
            "source": "comment 4 (molesmoke)",
            "interpretation": "Community agrees this may be a Mapsui usage issue, not a SkiaSharp defect."
          }
        ],
        "errorFingerprint": "sk_canvas_draw_path:intermittent:PointerMoved:Mapsui",
        "workarounds": [
          "Throttle or debounce GetMapInfo calls in PointerMoved to reduce GC pressure and concurrent access",
          "Add lock/synchronization around Mapsui canvas operations to prevent concurrent draw calls",
          "Report issue to Mapsui \u2014 their rendering code should use GC.KeepAlive or hold references during P/Invoke-heavy operations"
        ],
        "nextQuestions": [
          "Is the actual SkiaSharp version 2.88.8 or 3.116.0? The reporter contradicts themselves.",
          "Does Mapsui\u0027s GetMapInfo share canvas/path/paint objects with the main render loop?",
          "Would the GC.KeepAlive fix in PR #3394 prevent this crash?"
        ],
        "resolution": {
          "hypothesis": "The GC collects SKPath or SKPaint during the sk_canvas_draw_path P/Invoke call because no GC.KeepAlive holds them alive after Handle extraction. Under GC pressure from rapid PointerMoved events, the finalizer frees native memory mid-call, causing the crash. Alternatively, Mapsui may be sharing SkiaSharp objects across threads without synchronization.",
          "proposals": [
            {
              "description": "Reduce call frequency to lower GC pressure and avoid concurrent canvas access. Add a simple throttle or debounce to the PointerMoved handler.",
              "title": "Throttle GetMapInfo in PointerMoved",
              "codeSnippet": "private DateTime _lastMapInfo = DateTime.MinValue;\nprivate void MapControl_PointerMoved(object sender, PointerEventArgs e)\n{\n    if ((DateTime.UtcNow - _lastMapInfo).TotalMilliseconds \u003C 100)\n        return;\n    _lastMapInfo = DateTime.UtcNow;\n    var mapInfo = MapControl.GetMapInfo(screenPosition);\n}",
              "confidence": 0.6,
              "effort": "trivial"
            },
            {
              "description": "Mapsui\u0027s GetMapInfo renders features to a canvas from the PointerMoved event while the main render loop may also be drawing. SKCanvas/SKPath/SKPaint are NOT thread-safe. Mapsui should synchronize access or use separate objects per thread.",
              "title": "Report to Mapsui for thread-safety review",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "PR #3394 adds GC.KeepAlive calls after P/Invoke methods to prevent premature GC collection. This would protect DrawPath and similar calls from the race between GC finalization and native execution.",
              "title": "SkiaSharp GC.KeepAlive fix (PR #3394)",
              "confidence": 0.55,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Throttle GetMapInfo in PointerMoved",
          "recommendedReason": "Simplest immediate fix the reporter can apply. Reduces both GC pressure and concurrent access risk. The deeper fixes (Mapsui thread-safety, SkiaSharp GC.KeepAlive) require upstream changes."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.75,
          "reason": "Version confusion (2.88.8 vs 3.116.0) needs clarification. The crash is likely caused by Mapsui\u0027s threading model and/or SkiaSharp\u0027s P/Invoke GC safety gap, but we need the actual version and whether Mapsui synchronizes canvas access."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels already correct \u2014 type/bug, os/Windows-Classic, tenet/reliability are applied",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis explaining likely causes and workaround",
            "risk": "high",
            "confidence": 0.7,
            "comment": "Thanks for the stack trace \u2014 that helps narrow things down.\n\nThe crash in \u0060sk_canvas_draw_path\u0060 during \u0060PointerMoved\u0060 \u2192 \u0060GetMapInfo\u0060 suggests one of two issues:\n\n1. **Threading**: Mapsui\u0027s \u0060GetMapInfo\u0060 draws features to a canvas to hit-test. If the main render loop is also drawing at the same time, \u0060SKCanvas\u0060, \u0060SKPath\u0060, and \u0060SKPaint\u0060 are being shared across threads \u2014 these types are [not thread-safe](https://learn.microsoft.com/en-us/dotnet/api/skiasharp.skcanvas). The intermittent nature is consistent with a race condition.\n\n2. **GC collection during P/Invoke**: Under GC pressure (rapid PointerMoved calls), the .NET GC can collect managed SkiaSharp objects while their native handles are still in use (#3393). PR #3394 addresses this.\n\nA quick thing to try: **throttle your \u0060GetMapInfo\u0060 calls** in the \u0060PointerMoved\u0060 handler to reduce both GC pressure and the chance of concurrent canvas access:\n\n\u0060\u0060\u0060csharp\nprivate DateTime _lastMapInfo = DateTime.MinValue;\nprivate void MapControl_PointerMoved(object sender, PointerEventArgs e)\n{\n    if ((DateTime.UtcNow - _lastMapInfo).TotalMilliseconds \u003C 100)\n        return;\n    _lastMapInfo = DateTime.UtcNow;\n    // your GetMapInfo call here\n}\n\u0060\u0060\u0060\n\nAlso \u2014 could you clarify which SkiaSharp version you\u0027re actually using? You selected 3.116.0 in the template, but Comment 2 mentions \u0060SkiaSharp.dll version is 2.88.8.0\u0060. If Mapsui is pinning to 2.88.x, that\u0027s important to know.\n\nThis may also be worth reporting to the Mapsui project, as the rendering path in their \u0060GetMapInfo\u0060 may need synchronization."
          },
          {
            "type": "link-related",
            "description": "Cross-reference the P/Invoke GC safety issue",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 3393
          }
        ],
        "missingInfo": [
          "Exact SkiaSharp version in use \u2014 the reporter says both 3.116.0 and 2.88.8.0",
          "Whether Mapsui\u0027s GetMapInfo and main render loop share SKCanvas/SKPath/SKPaint objects",
          "Whether the issue reproduces without GetMapInfo in PointerMoved"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3396,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:28:00Z",
        "currentLabels": [
          "type/feature-request",
          "os/WASM",
          "area/SkiaSharp.Views.Uno"
        ]
      },
      "summary": "User cannot get SkiaSharp to work on Unity WebGL. They get DllNotFoundException for libSkiaSharp in the browser console. They have tried the NativeAssets.WebAssembly NuGet package and multiple Unity versions (2021.2, 2022.3). SkiaSharp\u0027s WASM support uses static linking via MSBuild NativeFileReference, which only works with .NET SDK builds (Blazor, Uno). Unity WebGL uses its own Emscripten-based build pipeline that doesn\u0027t go through MSBuild, so the NativeAssets.WebAssembly package\u0027s build targets never fire. Unity is not an officially supported platform.",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.7
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.9
        },
        "platforms": [
          "os/WASM"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Download SkiaSharp managed NuGet and NativeAssets.WebAssembly NuGet",
            "Extract libSkiaSharp.a files and place in Unity project",
            "Build Unity project for WebGL target",
            "Run in browser \u2014 get DllNotFoundException for libSkiaSharp"
          ],
          "environmentDetails": "Unity 2021.2 and 2022.3, WebGL build target",
          "relatedIssues": [
            921,
            1819,
            2181,
            3016
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "Unity WebGL is still not officially supported. The WASM native assets still use MSBuild NativeFileReference which Unity\u0027s build system does not process."
        }
      },
      "analysis": {
        "summary": "SkiaSharp\u0027s WebAssembly support relies on .NET SDK static linking \u2014 the NativeAssets.WebAssembly package provides .a files that are linked into dotnet.wasm via MSBuild NativeFileReference. Unity WebGL uses Emscripten but does NOT use .NET MSBuild, so the static linking targets never apply. The user\u0027s DllNotFoundException occurs because the managed C# DLL calls DllImport(\u0022libSkiaSharp\u0022) which expects either a dynamically loaded library or statically linked symbols resolved by the .NET WASM runtime \u2014 neither is available in Unity\u0027s IL2CPP/Mono WebGL runtime. This is fundamentally a platform support gap, not a configuration issue.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaApi.cs",
            "finding": "DllImport constant is \u0027libSkiaSharp\u0027 \u2014 on .NET WASM this resolves to statically linked symbols via the .NET runtime. Unity WebGL uses a different runtime (IL2CPP or Mono) that doesn\u0027t have this resolution mechanism.",
            "relevance": "direct",
            "lines": "12"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.WebAssembly/buildTransitive/SkiaSharp.targets",
            "finding": "WASM integration uses MSBuild properties UsingMicrosoftNETSdkBlazorWebAssembly/UsingMicrosoftNETSdkWebAssembly and NativeFileReference items. Also has Uno-specific support via IsUnoHead/UnoRuntimeIdentifier. None of these apply to Unity\u0027s build system.",
            "relevance": "direct",
            "lines": "22-41"
          },
          {
            "file": "documentation/packages.md",
            "finding": "Documents that WASM uses static linking via NativeFileReference, and explicitly notes Unity WebGL is not officially supported and requires manual configuration beyond standard NativeFileReference.",
            "relevance": "context",
            "lines": "95-99"
          }
        ],
        "rationale": "Classified as type/question rather than type/feature-request because the user is primarily asking \u0027how to get it to work\u0027 and \u0027has anyone got this working.\u0027 However, confidence is moderate (0.70) because the underlying answer is that Unity WebGL is not supported \u2014 making this borderline between a question and a feature request. The existing type/feature-request label is also defensible. The area is area/libSkiaSharp.native (not area/SkiaSharp.Views.Uno) because the issue is purely about native library loading on Unity WebGL, which has nothing to do with the Uno Platform views layer.",
        "keySignals": [
          {
            "text": "DLLNotFound libSkiaSharp in the Browser console",
            "source": "issue body",
            "interpretation": "Unity WebGL cannot resolve the P/Invoke to libSkiaSharp because the .a static library was not linked into the WASM binary by Unity\u0027s build pipeline."
          },
          {
            "text": "I have tried placing all the different libSkiaSharp.a files in Unity",
            "source": "issue body",
            "interpretation": "User is manually copying .a files \u2014 this won\u0027t work because Unity needs explicit Emscripten linker configuration, not just file placement."
          },
          {
            "text": "I am not sure if this is because the managed C# dll is expecting a dynamic linked library instead of a static one",
            "source": "issue body",
            "interpretation": "Correct intuition \u2014 the managed DLL uses DllImport which on .NET WASM is resolved to statically linked symbols. Unity WebGL doesn\u0027t have this resolution mechanism."
          },
          {
            "text": "Unity WebGL \u2014 Uses Emscripten like Blazor WASM but doesn\u0027t go through MSBuild. SkiaSharp doesn\u0027t officially support Unity WebGL.",
            "source": "documentation (skia-patterns.md)",
            "interpretation": "Confirms this is a known unsupported scenario documented in project knowledge base."
          }
        ],
        "workarounds": [
          "Use SkiaSharp with Blazor WebAssembly instead of Unity WebGL for browser-based vector graphics",
          "For Unity specifically, consider using Unity\u0027s built-in Vector Graphics package or SVG importer for vector art"
        ],
        "nextQuestions": [
          "Is there community interest in official Unity support?",
          "Could Unity\u0027s native plugin system (with .jslib or Emscripten --pre-js) be used to manually link libSkiaSharp.a and expose symbols?"
        ],
        "resolution": {
          "hypothesis": "Unity WebGL does not use .NET MSBuild, so the NativeAssets.WebAssembly package\u0027s NativeFileReference-based static linking never occurs. The libSkiaSharp.a file is present but not linked into the Unity WebGL output.",
          "proposals": [
            {
              "description": "If the goal is browser-based vector graphics with SkiaSharp, use Blazor WebAssembly with SkiaSharp.Views.Blazor. This is the officially supported WASM path and handles all native linking automatically.",
              "title": "Use Blazor WASM instead",
              "confidence": 0.9,
              "effort": "large"
            },
            {
              "description": "Theoretically, Unity\u0027s native plugin system supports Emscripten static libraries. One would need to configure Unity to pass libSkiaSharp.a to the Emscripten linker with appropriate flags (-s USE_WEBGL2=1, etc.) and ensure all C API symbols are exported. This is untested and unsupported.",
              "title": "Manual Emscripten linking in Unity",
              "confidence": 0.3,
              "effort": "large"
            },
            {
              "description": "For vector art in Unity targeting Standalone, Android, and WebGL, consider Unity\u0027s built-in Vector Graphics package, or third-party solutions like NanoSVG or the Unity SVG importer, which are designed for Unity\u0027s build pipeline.",
              "title": "Use Unity-native alternatives",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Use Unity-native alternatives",
          "recommendedReason": "The user\u0027s goal is vector art across Standalone, Android, and WebGL in Unity. Unity-native solutions avoid the fundamental platform mismatch and work across all Unity build targets without manual linker configuration."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.75,
          "reason": "Unity WebGL is not an officially supported platform. The DllNotFoundException is expected behavior because SkiaSharp\u0027s WASM support requires .NET SDK MSBuild integration. The issue has been open since October 2025 with no community solutions posted."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix area label from area/SkiaSharp.Views.Uno to area/libSkiaSharp.native \u2014 this is a native loading issue on Unity WebGL, not related to Uno views",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/question",
              "area/libSkiaSharp.native",
              "os/WASM",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain why Unity WebGL is unsupported and suggest alternatives",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for the detailed write-up of what you\u0027ve tried.\n\nSkiaSharp\u0027s WebAssembly support works through static linking at .NET SDK build time \u2014 the \u0060NativeAssets.WebAssembly\u0060 package provides \u0060.a\u0060 files that get linked into \u0060dotnet.wasm\u0060 via MSBuild\u0027s \u0060NativeFileReference\u0060 mechanism. This works automatically with Blazor WebAssembly and Uno Platform because they use the .NET SDK build pipeline.\n\nUnity WebGL uses Emscripten separately from .NET\u0027s MSBuild toolchain, so the NativeAssets package\u0027s build targets never fire. Simply placing \u0060.a\u0060 files in the Unity project won\u0027t work \u2014 they need to be explicitly passed to Emscripten\u0027s linker with the right flags. Unity WebGL is not an officially supported platform for SkiaSharp.\n\nFor vector art across Standalone, Android, and WebGL in Unity, you might consider Unity-native solutions like the [Vector Graphics package](https://docs.unity3d.com/Packages/com.unity.vectorgraphics@2.0/manual/index.html) or SVG importers that work with Unity\u0027s build pipeline.\n\nRelated issues: #921, #1819."
          },
          {
            "type": "link-related",
            "description": "Cross-reference Unity usage issue #921",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 921
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3394,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:24:40Z",
        "currentLabels": []
      },
      "summary": "Draft PR #3394 by Copilot adds GC.KeepAlive() calls to ~40 methods across 5 files (SKCanvas, SKPaint, SKImage, SKBitmap, SKPath) to prevent premature GC collection of managed objects during P/Invoke calls. This is a partial fix for #3393 (and duplicate #2821), covering ~20% of the ~910 affected call sites. The PR could not build due to CI firewall issues, and maintainer jonpryor\u0027s review raises a deeper concern: property setters and struct-to-native conversions (e.g. SKCanvasSaveLayerRec.ToNative()) also extract handles without KeepAlive protection. Types using GetObject() without HandleDictionary registration (SKPaint, SKPath, SKCodec, SKTextBlob, etc.) are additionally vulnerable.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/reliability"
        ],
        "partner": "partner/unoplatform"
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "var canvas = ...\nvar picture = ...\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point, so GC can collect it\n// But native code may still be using picture.Handle!"
          ],
          "relatedIssues": [
            3393,
            2821,
            1258,
            1244
          ],
          "repoLinks": [
            {
              "url": "https://github.com/unoplatform/uno/pull/21660",
              "description": "Uno Platform PR demonstrating real-world GC race condition with SkiaSharp"
            },
            {
              "url": "https://github.com/dotnet/java-interop/issues/719",
              "description": "Same class of bug in dotnet/java-interop"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "race condition",
          "errorMessage": "Premature GC collection of managed objects during P/Invoke calls causes crashes, AccessViolationException, or data corruption",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-android"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "Only 14 GC.KeepAlive calls exist in the current codebase across 6 files. The vast majority of ~910 P/Invoke call sites remain unprotected. This PR has not been merged."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "PR #3394 is a draft, not merged, could not build in CI, and covers only ~20% of affected call sites. The review from jonpryor identifies additional unaddressed patterns (property setters, struct-to-native). Issue #1258 added a handful of GC.KeepAlive calls historically but the systemic problem remains.",
          "relatedPRs": [
            3394,
            1258
          ]
        }
      },
      "analysis": {
        "summary": "This draft PR partially addresses a systemic GC safety issue in SkiaSharp\u0027s P/Invoke layer. When a managed wrapper object\u0027s handle is extracted and passed to native code, the GC can collect and finalize the wrapper before the native call completes, causing use-after-free. The PR adds GC.KeepAlive() after P/Invoke calls in ~40 methods, but the scope is incomplete: 67 P/Invoke calls in SKCanvas alone have zero GC.KeepAlive, and the broader codebase has ~910 unprotected call sites. Maintainer jonpryor\u0027s review raises a critical additional concern about types that use GetObject() without HandleDictionary registration (SKPaint, SKPath, SKCodec, SKFontStyle, SKTextBlob, SKVertices, SKDocument, etc.) \u2014 these have no static root keeping them alive, making them especially vulnerable in property-setter and struct-conversion scenarios.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "DrawPicture calls SkiaApi.sk_canvas_draw_picture with picture.Handle and paint.Handle but has no GC.KeepAlive \u2014 exactly the pattern described in the bug report and Chris Brumme\u0027s blog post",
            "relevance": "direct",
            "lines": "533-538"
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "SaveLayer(in SKCanvasSaveLayerRec rec) calls rec.ToNative() which extracts handles from Paint and Backdrop, then passes the native struct to sk_canvas_save_layer_rec \u2014 neither rec.Paint nor rec.Backdrop is kept alive",
            "relevance": "direct",
            "lines": "68-72"
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "SKCanvasSaveLayerRec.ToNative() extracts Paint?.Handle and Backdrop?.Handle into a native struct \u2014 after this point, Paint and Backdrop have no managed references and are eligible for GC",
            "relevance": "direct",
            "lines": "1100-1109"
          },
          {
            "file": "binding/SkiaSharp/SKPaint.cs",
            "finding": "SKPaint.GetObject creates new instances without HandleDictionary registration \u2014 no static root keeps these alive, confirming jonpryor\u0027s concern about types that bypass GetOrAddObject",
            "relevance": "direct",
            "lines": "831-832"
          },
          {
            "file": "binding/SkiaSharp/SKShader.cs",
            "finding": "SKShader.GetObject uses GetOrAddObject which registers in HandleDictionary \u2014 these instances ARE rooted and less vulnerable to premature collection",
            "relevance": "context",
            "lines": "458-459"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKObject has ownedObjects and keepAliveObjects ConcurrentDictionaries, and RegisterHandle for HandleDictionary \u2014 this is the mechanism that protects some types but not others",
            "relevance": "context",
            "lines": "14-32"
          },
          {
            "file": "binding/SkiaSharp/SKData.cs",
            "finding": "SKData has 5 existing GC.KeepAlive(stream) calls in stream-reading methods \u2014 this is the established pattern for the fix",
            "relevance": "context",
            "lines": "167-191"
          }
        ],
        "rationale": "Classified as type/bug because this PR fixes a genuine race condition that causes crashes and data corruption. Area is area/SkiaSharp because it affects the core binding layer\u0027s P/Invoke wrappers, not views or platform-specific code. Severity is high (not critical) because the race window is narrow and typically manifests under GC pressure on mobile devices. The tenet/reliability and partner/unoplatform labels match the parent issue #3393 since Uno Platform reported a real-world instance.",
        "keySignals": [
          {
            "text": "SKCanvas.cs has 67 P/Invoke calls and 0 GC.KeepAlive calls",
            "source": "code search",
            "interpretation": "The most critical drawing class has zero protection against premature GC collection."
          },
          {
            "text": "Only 14 GC.KeepAlive calls exist across 6 files (SKData, SKImage, SKFontStyleSet, SKTextBlob, SKSurface, SKBitmap)",
            "source": "code search",
            "interpretation": "Historical fixes (PR #1258) added some protections but the vast majority of call sites remain unprotected."
          },
          {
            "text": "jonpryor review: \u0027I am thus rather concerned about the behavior of properties in general. If the property type uses HandleDictionary, things should be fine. If they don\u0027t...\u0027",
            "source": "PR review comment",
            "interpretation": "The scope is broader than method parameters \u2014 property setters and struct-to-native conversions also extract handles. Types with GetObject() that bypass HandleDictionary are especially vulnerable."
          },
          {
            "text": "SKPaint.GetObject just news up a value: \u0027handle == IntPtr.Zero ? null : new SKPaint(handle, true)\u0027",
            "source": "binding/SkiaSharp/SKPaint.cs:831-832",
            "interpretation": "SKPaint instances have no static root in HandleDictionary, making them vulnerable to collection when their handle is extracted for P/Invoke."
          },
          {
            "text": "Draft PR, not merged, CI firewall blocked build",
            "source": "PR metadata",
            "interpretation": "The PR has not been validated \u2014 it couldn\u0027t build in CI due to firewall rules blocking NuGet downloads."
          }
        ],
        "workarounds": [
          "Callers can add GC.KeepAlive() after their own SkiaSharp API calls to keep objects alive across native boundaries",
          "Hold explicit references to all SkiaSharp objects (e.g. assign to a field or local variable that outlives the API call scope)"
        ],
        "nextQuestions": [
          "Should the fix be applied via the code generator (utils/generate.ps1) rather than manual edits to avoid maintenance burden?",
          "How should property setters be handled \u2014 should the setter keep a managed reference to the assigned value?",
          "Should types that bypass HandleDictionary (SKPaint, SKPath, etc.) be migrated to use GetOrAddObject?",
          "Is GC.KeepAlive(this) needed for instance methods, or is it sufficient to rely on callers to keep the receiver alive?"
        ],
        "resolution": {
          "hypothesis": "The .NET GC can collect managed wrapper objects after their IntPtr handles are extracted for P/Invoke calls, causing native code to operate on freed handles. The fix requires systematic GC.KeepAlive() calls after all P/Invoke invocations, plus addressing the deeper HandleDictionary registration gap for some types.",
          "proposals": [
            {
              "description": "Expand PR #3394\u0027s approach to cover all ~910 P/Invoke call sites. Add GC.KeepAlive for every reference-type parameter (including \u0027this\u0027 via Handle) after each native call. This is the approach started in the PR but needs to cover the remaining ~80% of methods.",
              "title": "Complete the manual GC.KeepAlive audit",
              "confidence": 0.7,
              "effort": "large"
            },
            {
              "description": "Modify utils/generate.ps1 to automatically emit GC.KeepAlive calls in generated P/Invoke wrappers. This would handle generated methods automatically and reduce maintenance burden. Manual methods would still need hand-editing.",
              "title": "Generator-based GC.KeepAlive emission",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "description": "Migrate types that use plain GetObject() (SKPaint, SKPath, SKCodec, SKDocument, SKFontStyle, SKTextBlob, SKVertices) to use GetOrAddObject with HandleDictionary registration. This provides a static root that prevents premature collection for property-assigned objects, as jonpryor\u0027s review identified.",
              "title": "Address HandleDictionary registration gap",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Complete the manual GC.KeepAlive audit",
          "recommendedReason": "This is the most direct and proven fix pattern (already used in 14 places). Generator-based emission is ideal long-term but the generator doesn\u0027t cover all methods. HandleDictionary migration is a separate concern that should be addressed alongside but not instead of GC.KeepAlive."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "The PR is a valid partial fix for a real systemic bug, but it\u0027s incomplete (~20% coverage), couldn\u0027t build in CI, and jonpryor\u0027s review identifies additional unaddressed patterns. The PR needs substantial rework to address review feedback and expand scope before it can be merged."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, SkiaSharp, reliability labels to match parent issue #3393",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference parent issue #3393",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3393
          },
          {
            "type": "link-related",
            "description": "Cross-reference duplicate issue #2821 (same bug reported independently)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 2821
          },
          {
            "type": "add-comment",
            "description": "Acknowledge PR, note incomplete scope, and flag jonpryor\u0027s review concerns",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the initial work on this. The GC.KeepAlive pattern is correct and matches the existing usage in SKData and SKImage.\n\nA few things to address before this can move forward:\n\n1. **Scope**: This covers ~40 methods but the issue affects ~910 call sites. We should decide whether to do this incrementally or find a generator-based approach.\n2. **Review feedback**: @jonpryor raises a valid concern about property setters and struct-to-native conversions (e.g. \u0060SKCanvasSaveLayerRec.ToNative()\u0060). Types that bypass \u0060HandleDictionary\u0060 registration (\u0060SKPaint\u0060, \u0060SKPath\u0060, \u0060SKCodec\u0060, etc.) are especially vulnerable in these patterns.\n3. **Build**: The CI build failed due to firewall issues \u2014 this needs a successful build and test run.\n\nRelated: #3393 (parent issue), #2821 (duplicate report), #1258 (historical partial fix)."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3393,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:23:33Z",
        "currentLabels": [
          "type/bug",
          "os/Android",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "SkiaSharp\u0027s P/Invoke wrapper methods do not call GC.KeepAlive() on managed parameters after native calls, allowing the .NET GC to prematurely collect objects whose IntPtr handles are still in use by native Skia code. This is a systemic issue affecting ~910 P/Invoke call sites across 50\u002B files in binding/SkiaSharp/, with only 14 existing GC.KeepAlive calls. Under GC pressure (especially on mobile/Android), this race condition can cause crashes, data corruption, or AccessViolationExceptions. Version 3.116.0 is reported, but this has existed since the library\u0027s inception.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/reliability"
        ],
        "partner": "partner/unoplatform"
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an SKCanvas and SKPicture instance",
            "Call canvas.DrawPicture(picture) where picture is not referenced afterward",
            "Under GC pressure, the GC may collect picture (and finalize it) while native sk_canvas_draw_picture() is still executing",
            "This causes a race between the application and the GC/Finalizer, eventually resulting in a crash"
          ],
          "codeSnippets": [
            "var canvas = \u2026\nvar picture = \u2026\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point \u2014 GC can collect it"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, VS Code macOS, Android \u002B All platforms",
          "relatedIssues": [
            1258
          ],
          "repoLinks": [
            {
              "url": "https://github.com/unoplatform/uno/pull/21660",
              "description": "Uno Platform PR demonstrating the real-world crash from missing GC.KeepAlive"
            },
            {
              "url": "https://github.com/dotnet/java-interop/issues/719",
              "description": "Same pattern in dotnet/java-interop \u2014 non-Skia example of the same GC race"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": false,
          "errorType": "potential AccessViolationException / use-after-free crash",
          "errorMessage": "Managed objects can be GC-collected while native code is operating on their handles",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-android"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The issue is systemic \u2014 910 P/Invoke call sites across 50\u002B files still lack GC.KeepAlive. Only 14 calls exist (added via PR #1258 in 2020 for pixel operations). No version has comprehensively addressed this."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "Draft PR #3394 (by Copilot) covers ~40 methods (~20% of affected call sites) but is incomplete, still in draft, and has not been merged. The vast majority of P/Invoke wrappers remain unprotected.",
          "relatedPRs": [
            3394,
            1258
          ]
        }
      },
      "analysis": {
        "summary": "Systemic GC safety bug: nearly all SkiaSharp P/Invoke wrappers extract IntPtr handles from managed objects and pass them to native calls without GC.KeepAlive(), creating a race condition where the GC can finalize and dispose the native handle while Skia is still using it. The reporter (jonpryor, a .NET runtime expert) provides authoritative references including Chris Brumme\u0027s blog post on handle lifetime. The issue is confirmed by a real-world crash in Uno Platform (uno#21660). The fix pattern is well-understood (add GC.KeepAlive after each P/Invoke call for all reference-type parameters) and is already used in 14 places, but 910\u002B call sites remain unprotected.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "DrawPicture(SKPicture, SKPaint) passes picture.Handle and paint.Handle to SkiaApi.sk_canvas_draw_picture() without any GC.KeepAlive. 67 total P/Invoke calls in this file, 0 GC.KeepAlive calls.",
            "relevance": "direct",
            "lines": "533-538"
          },
          {
            "file": "binding/SkiaSharp/SKData.cs",
            "finding": "SKData.Create(SKStream) correctly uses try/finally with GC.KeepAlive(stream) \u2014 this is the reference pattern. 5 GC.KeepAlive calls protect stream and this references.",
            "relevance": "related",
            "lines": "165-192"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKObject has a KeepAliveObjects ConcurrentDictionary for long-lived references, but this doesn\u0027t protect transient P/Invoke parameters \u2014 only retained references.",
            "relevance": "context",
            "lines": "28-35"
          },
          {
            "file": "binding/SkiaSharp/SKPaint.cs",
            "finding": "49 P/Invoke calls, 0 GC.KeepAlive. Property setters like Shader, MaskFilter, ColorFilter pass parameter.Handle without protection.",
            "relevance": "direct"
          },
          {
            "file": "binding/SkiaSharp/SKPath.cs",
            "finding": "92 P/Invoke calls, 0 GC.KeepAlive. AddPath, Op, and other methods taking SKPath parameters are all unprotected.",
            "relevance": "direct"
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "finding": "34 P/Invoke calls, 3 GC.KeepAlive. Some protection exists for bitmap and this references in pixel operations (from PR #1258), but most factory methods and instance methods remain unprotected.",
            "relevance": "direct",
            "lines": "1-34"
          }
        ],
        "rationale": "This is clearly a bug \u2014 the reporter demonstrates a race condition that violates .NET P/Invoke safety rules. The area is area/SkiaSharp because the problem is in the C# binding layer (binding/SkiaSharp/*.cs), not in views or native code. Severity is high because it can cause crashes and data corruption, though it requires GC pressure to trigger (making it intermittent and hard to diagnose). The tenet/reliability label is correct. The partner/unoplatform label is warranted because the issue was discovered via Uno Platform\u0027s own investigation.",
        "keySignals": [
          {
            "text": "Once execution hits SkiaApi.sk_canvas_draw_picture(), nothing ensures that picture is kept alive. (Or canvas, for that matter!)",
            "source": "issue body",
            "interpretation": "The reporter identifies the exact race condition: Handle extracted \u2192 P/Invoke entered \u2192 GC can collect \u2192 finalizer disposes native handle \u2192 crash."
          },
          {
            "text": "unoplatform/uno#21660 is a Skia-related example of this",
            "source": "issue body",
            "interpretation": "Real-world evidence: Uno Platform hit this crash in production and had to fix it on their side."
          },
          {
            "text": "14 GC.KeepAlive calls vs 910 P/Invoke calls across binding/SkiaSharp/",
            "source": "code search",
            "interpretation": "Only ~1.5% of P/Invoke call sites are protected. The existing KeepAlive calls (from PR #1258) prove the maintainer agrees with the pattern \u2014 it just wasn\u0027t applied systematically."
          },
          {
            "text": "50 files in binding/SkiaSharp have P/Invoke calls but zero GC.KeepAlive",
            "source": "code search",
            "interpretation": "The problem is pervasive \u2014 SKCanvas (67 calls), SKPath (92 calls), SKPaint (49 calls), SKFont (42 calls) all have zero protection."
          },
          {
            "text": "The reporter is jonpryor \u2014 .NET runtime team member and Xamarin/java-interop maintainer",
            "source": "issue author",
            "interpretation": "Authoritative source. The reporter understands .NET GC semantics deeply and cites the canonical reference (Chris Brumme\u0027s blog)."
          }
        ],
        "workarounds": [
          "Callers can add GC.KeepAlive() after their own SkiaSharp API calls to keep parameters alive, e.g.: canvas.DrawPicture(picture); GC.KeepAlive(picture); GC.KeepAlive(canvas);",
          "Keep explicit references to all SkiaSharp objects in scope until drawing operations complete (e.g., store in a field or local variable that\u0027s used after the draw call)"
        ],
        "nextQuestions": [
          "Should GC.KeepAlive(this) also be added to instance methods, or should callers be responsible for keeping the receiver alive?",
          "Can the code generator (pwsh ./utils/generate.ps1) be modified to automatically emit GC.KeepAlive for generated bindings?",
          "What is the performance impact of adding GC.KeepAlive to every P/Invoke wrapper? (Expected: negligible \u2014 it\u0027s a no-op that just marks a reference as live)",
          "Should PR #3394 be completed and merged, or should a fresh comprehensive approach be taken?"
        ],
        "resolution": {
          "hypothesis": "The .NET GC can collect managed SkiaSharp objects while their native handles are still in use by Skia C\u002B\u002B code, because the C# wrappers extract IntPtr handles before P/Invoke calls and never mark the managed objects as still-live afterward. The fix is to add GC.KeepAlive() for all reference-type parameters after every P/Invoke call.",
          "proposals": [
            {
              "description": "Add GC.KeepAlive() calls after every P/Invoke invocation for all reference-type parameters. This covers ~910 call sites across 50\u002B files. Draft PR #3394 already covers ~20% \u2014 complete the remaining ~80%.",
              "title": "Complete systematic GC.KeepAlive audit",
              "codeSnippet": "public void DrawPicture (SKPicture picture, SKPaint paint = null)\n{\n    if (picture == null)\n        throw new ArgumentNullException (nameof (picture));\n    SkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n    GC.KeepAlive (this);\n    GC.KeepAlive (picture);\n    GC.KeepAlive (paint);\n}",
              "confidence": 0.95,
              "effort": "large"
            },
            {
              "description": "If the P/Invoke bindings are partially generated (*.generated.cs), modify the generator (utils/generate.ps1) to automatically emit GC.KeepAlive for all reference-type parameters in generated wrappers. This prevents future regressions.",
              "title": "Modify generator to emit GC.KeepAlive",
              "confidence": 0.75,
              "effort": "medium"
            },
            {
              "description": "As an immediate workaround, callers can add GC.KeepAlive() after their own SkiaSharp API calls. This is not a real fix but can prevent crashes in critical code paths while the library fix is developed.",
              "title": "Caller-side workaround",
              "codeSnippet": "var canvas = surface.Canvas;\nvar picture = recorder.EndRecording();\ncanvas.DrawPicture(picture);\nGC.KeepAlive(picture);\nGC.KeepAlive(canvas);",
              "confidence": 0.9,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Complete systematic GC.KeepAlive audit",
          "recommendedReason": "The caller-side workaround is impractical at scale \u2014 every consumer would need to add GC.KeepAlive everywhere. A systematic audit with GC.KeepAlive in every wrapper method is the correct fix, follows the pattern already established in SKData.cs, and PR #3394 provides a starting point."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "The bug is well-understood and the fix pattern is clear, but the scope is massive (~910 call sites). Draft PR #3394 needs review and completion. The issue should remain open to track the systematic audit."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Current labels are already correct. Add partner/unoplatform since the issue was discovered via Uno Platform\u0027s investigation.",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/reliability",
              "partner/unoplatform"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report, confirm the scope of the problem, reference existing work",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the thorough writeup and references \u2014 this is a real and well-understood GC safety issue.\n\nA code audit confirms the scope: there are ~910 P/Invoke call sites across 50\u002B files in \u0060binding/SkiaSharp/\u0060, but only 14 \u0060GC.KeepAlive\u0060 calls (mostly in \u0060SKData\u0060 and \u0060SKImage\u0060 from PR #1258). Key files like \u0060SKCanvas\u0060 (67 calls), \u0060SKPath\u0060 (92 calls), and \u0060SKPaint\u0060 (49 calls) have zero protection.\n\nDraft PR #3394 started addressing this for ~40 methods (~20% coverage), but the remaining ~80% still needs work.\n\nAs an immediate workaround, callers can add \u0060GC.KeepAlive()\u0060 after their SkiaSharp calls:\n\n\u0060\u0060\u0060csharp\ncanvas.DrawPicture(picture);\nGC.KeepAlive(picture);\nGC.KeepAlive(canvas);\n\u0060\u0060\u0060\n\nWe\u0027ll also look into whether the generator can be updated to emit \u0060GC.KeepAlive\u0060 automatically to prevent future regressions."
          },
          {
            "type": "link-related",
            "description": "Link to existing draft PR #3394 which partially addresses this",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3394
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3386,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:25:00Z",
        "currentLabels": [
          "type/bug",
          "os/Linux",
          "area/libSkiaSharp.native",
          "tenet/compatibility"
        ]
      },
      "summary": "DllNotFoundException deploying SkiaSharp with NativeAssets.Linux.NoDependencies via .NET Aspire to Azure Container Apps \u2014 wrong native binary deployed",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          "os/Linux"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET 9 WebAPI project using .NET Aspire",
            "Add PackageReference for SkiaSharp and SkiaSharp.NativeAssets.Linux.NoDependencies",
            "Deploy to Azure Container Apps via Aspire",
            "Call an endpoint that uses SKBitmap.Decode()"
          ],
          "environmentDetails": "Azure Container Apps, Linux container, .NET 9.0.10, deployed via .NET Aspire, SkiaSharp 3.116.0",
          "relatedIssues": [
            2438,
            1706,
            2377,
            2607,
            3235
          ],
          "repoLinks": [
            {
              "url": "https://github.com/AvantiPoint/aspnet-skia",
              "description": "Custom Docker base image with native dependencies installed for SkiaSharp on ASP.NET"
            }
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "DllNotFoundException",
          "errorMessage": "Unable to load shared library \u0027libSkiaSharp\u0027 or one of its dependencies. libfontconfig.so.1: cannot open shared object file: No such file or directory",
          "stackTrace": "System.DllNotFoundException at SkiaSharp.SkiaApi.sk_managedstream_set_procs \u2192 SKAbstractManagedStream..cctor() \u2192 SKManagedStream..ctor() \u2192 SKCodec.WrapManagedStream() \u2192 SKCodec.Create() \u2192 SKBitmap.Decode()",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net9.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The issue is a deployment/packaging interaction between NoDependencies and .NET Aspire\u0027s container build, not a SkiaSharp code regression. The underlying packaging structure hasn\u0027t changed, so this issue persists in current versions."
        }
      },
      "analysis": {
        "summary": "Reporter references NativeAssets.Linux.NoDependencies but the runtime error shows libfontconfig.so.1 missing \u2014 a dependency that NoDependencies explicitly excludes. This proves the deployed binary is NOT the NoDependencies variant; the standard NativeAssets.Linux binary (which requires fontconfig) was loaded instead. .NET Aspire\u0027s container build process likely selects the wrong native binary variant or a transitive dependency overrides NoDependencies.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKAbstractManagedStream.cs",
            "finding": "Static constructor calls SkiaApi.sk_managedstream_set_procs() \u2014 this is the P/Invoke that triggers DllNotFoundException. The crash occurs at type initialization time, before any user code executes.",
            "relevance": "direct",
            "lines": "14-32"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.Linux.NoDependencies/SkiaSharp.NativeAssets.Linux.NoDependencies.csproj",
            "finding": "Package notes confirm NoDependencies only requires libpthread, libdl, libm, libc \u2014 fontconfig is explicitly excluded. The binary is packaged under runtimes/linux-x64/native/ etc.",
            "relevance": "direct",
            "lines": "6-16"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.Linux/SkiaSharp.NativeAssets.Linux.csproj",
            "finding": "Standard Linux package uses output/native/linux/ (different from linuxnodeps/) and packages under the same runtimes/linux-x64/native/ path. Both packages target the same RID paths, meaning a conflict between them results in one overwriting the other.",
            "relevance": "direct",
            "lines": "7-15"
          },
          {
            "file": "documentation/packages.md",
            "finding": "Troubleshooting section documents the \u0027Wrong Binary Deployed\u0027 pattern and lists checking for transitive NativeAssets.Linux references and container build tools deploying wrong RID variants as causes.",
            "relevance": "context",
            "lines": "176-196"
          }
        ],
        "rationale": "Classified as type/bug because the NoDependencies package explicitly promises zero external dependencies, yet fontconfig is being required at runtime \u2014 meaning the wrong binary was deployed. This is area/libSkiaSharp.native because it\u0027s about native library selection and deployment, not a C# API issue. Severity is medium: it blocks production deployment but has a known workaround (switch to NativeAssets.Linux \u002B install fontconfig). Not a regression \u2014 the reporter\u0027s \u0027last known good\u0027 of 2.88.9 likely reflects a different deployment mechanism rather than a SkiaSharp change.",
        "keySignals": [
          {
            "text": "libfontconfig.so.1: cannot open shared object file: No such file or directory",
            "source": "issue body (first line of DllNotFoundException)",
            "interpretation": "Per skia-patterns.md \u0027Wrong Binary Pattern\u0027: a libSkiaSharp.so WAS found and loaded, but it depends on fontconfig. NoDependencies has zero external deps, so this binary is NOT from NoDependencies \u2014 deployment is broken."
          },
          {
            "text": "PackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022",
            "source": "issue body (csproj)",
            "interpretation": "Reporter correctly references NoDependencies, confirming the issue is in the deployment pipeline selecting the wrong binary, not a misconfigured project."
          },
          {
            "text": "I switched to SkiaSharp.NativeAssets.Linux and created a custom Docker image with native dependencies",
            "source": "comment #2 (OP)",
            "interpretation": "Reporter found the workaround themselves \u2014 confirming the root cause is wrong binary selection. Switching to the fontconfig-dependent package and providing fontconfig resolves the issue."
          },
          {
            "text": "System.Memory.Data was not found due to trimming",
            "source": "comment #2 (OP)",
            "interpretation": "Secondary issue: .NET Aspire enables trimming by default, which strips transitive references. This is a separate deployment concern unrelated to SkiaSharp\u0027s native loading."
          }
        ],
        "workarounds": [
          "Switch from NativeAssets.Linux.NoDependencies to NativeAssets.Linux, and install fontconfig in the container image (apt-get install -y libfontconfig1)",
          "Use a custom base image with native dependencies pre-installed (e.g., ghcr.io/avantipoint/aspnet-skia:9.0)",
          "If trimming causes System.Memory.Data to be stripped, add it as a direct PackageReference"
        ],
        "nextQuestions": [
          "Does .NET Aspire\u0027s container build process use a different RID resolution that prefers NativeAssets.Linux over NoDependencies?",
          "Is there a transitive NativeAssets.Linux reference being pulled in via another package that overrides NoDependencies?",
          "Could SkiaSharp improve packaging so NoDependencies always wins when both packages are referenced?"
        ],
        "resolution": {
          "hypothesis": ".NET Aspire\u0027s container build process deploys the standard NativeAssets.Linux binary instead of the NoDependencies variant, likely due to RID resolution conflicts or transitive package references overriding the explicit NoDependencies reference.",
          "proposals": [
            {
              "description": "Replace NativeAssets.Linux.NoDependencies with NativeAssets.Linux and install fontconfig in the container. This accepts the fontconfig dependency but ensures the correct binary is loaded.",
              "title": "Switch to NativeAssets.Linux with fontconfig",
              "codeSnippet": "\u003C!-- In csproj --\u003E\n\u003CPackageReference Include=\u0022SkiaSharp\u0022 /\u003E\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux\u0022 /\u003E\n\n\u003C!-- In Dockerfile or ContainerBaseImage setup --\u003E\nRUN apt-get update \u0026\u0026 apt-get install -y libfontconfig1",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "Use a custom Docker base image like ghcr.io/avantipoint/aspnet-skia:9.0 that pre-installs all SkiaSharp native dependencies. Set ContainerBaseImage in csproj.",
              "title": "Custom base image with dependencies",
              "codeSnippet": "\u003CPropertyGroup\u003E\n  \u003CContainerBaseImage\u003Eghcr.io/avantipoint/aspnet-skia:9.0\u003C/ContainerBaseImage\u003E\n\u003C/PropertyGroup\u003E",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Investigate whether .NET Aspire\u0027s container publish process has a bug or limitation with RID-specific native assets when both NativeAssets.Linux and NoDependencies are in the dependency graph. May require reporting upstream to the Aspire team.",
              "title": "Investigate Aspire RID resolution",
              "confidence": 0.6,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Switch to NativeAssets.Linux with fontconfig",
          "recommendedReason": "Simplest and most reliable workaround. The reporter confirmed this approach works. Avoids fighting with Aspire\u0027s RID resolution."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.7,
          "reason": "The reporter provided their own workaround and the issue is caused by .NET Aspire\u0027s container deployment, not a SkiaSharp code defect. However, keeping open to track whether SkiaSharp packaging can prevent this class of RID conflict is reasonable."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 no changes needed",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/Linux",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report, confirm the diagnosis, and thank the reporter for the workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the thorough write-up and for sharing the workaround.\n\nThe \u0060libfontconfig.so.1\u0060 error confirms the binary being loaded is the standard \u0060NativeAssets.Linux\u0060 variant, not \u0060NoDependencies\u0060 \u2014 the NoDependencies build has zero external dependencies, so a fontconfig error means the wrong \u0060.so\u0060 was deployed. This appears to be a .NET Aspire container build issue where its RID resolution selects the wrong native binary variant.\n\nYour workaround \u2014 switching to \u0060SkiaSharp.NativeAssets.Linux\u0060 \u002B installing fontconfig \u2014 is the right approach when Aspire controls the container build. We\u0027ll keep this open to investigate whether SkiaSharp\u0027s packaging can prevent this class of conflict.\n\nFor anyone else hitting this:\n1. Replace \u0060SkiaSharp.NativeAssets.Linux.NoDependencies\u0060 with \u0060SkiaSharp.NativeAssets.Linux\u0060\n2. Install fontconfig in your container: \u0060apt-get install -y libfontconfig1\u0060\n3. If trimming strips \u0060System.Memory.Data\u0060, add it as a direct \u0060PackageReference\u0060"
          },
          {
            "type": "link-related",
            "description": "Cross-reference similar container deployment issues",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 2438
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3385,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:23:34Z",
        "currentLabels": [
          "type/feature-request"
        ]
      },
      "summary": "Request for SKColorType.Gray16 to support 16-bit grayscale PNGs \u2014 blocked by upstream Skia which lacks kGray_16_SkColorType and explicitly strips 16-bit gray to 8-bit in its PNG decoder.",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        }
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            1222
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "Upstream Skia still does not define kGray_16_SkColorType as of the current pinned version. The PNG codec TODO comment remains at SkPngCodec.cpp:861."
        }
      },
      "analysis": {
        "summary": "User wants to decode 16-bit grayscale PNGs with full precision. SkiaSharp\u0027s SKColorType enum mirrors upstream Skia\u0027s SkColorType enum, which does not include a Gray16 variant. Skia\u0027s PNG decoder explicitly strips 16-bit grayscale to 8-bit (SkPngCodec.cpp:861-865) with a TODO asking whether 16-bit gray precision should be supported. This is an upstream limitation, not a SkiaSharp-specific gap.",
        "codeInvestigation": [
          {
            "file": "externals/skia/include/core/SkColorType.h",
            "finding": "Upstream Skia SkColorType enum has kGray_8_SkColorType (line 34) but no kGray_16 variant. The last enum value is kR8_unorm_SkColorType.",
            "relevance": "direct",
            "lines": "19-66"
          },
          {
            "file": "externals/skia/src/codec/SkPngCodec.cpp",
            "finding": "PNG decoder explicitly strips 16-bit grayscale to 8-bit with png_set_strip_16(). Has a TODO comment asking whether 16-bit gray should be supported.",
            "relevance": "direct",
            "lines": "861-865"
          },
          {
            "file": "externals/skia/include/c/sk_types.h",
            "finding": "C API sk_colortype_t enum has GRAY_8_SK_COLORTYPE but no GRAY_16 variant \u2014 mirrors the upstream gap.",
            "relevance": "direct",
            "lines": "98-126"
          },
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "SKColorType C# enum has Gray8 = 9 but no Gray16. The enum is a 1:1 mapping of the C API values.",
            "relevance": "direct",
            "lines": "36-63"
          },
          {
            "file": "binding/SkiaSharp/EnumMappings.cs",
            "finding": "ToNative/FromNative mappings cover all current color types. Adding Gray16 would require entries in both directions plus the upstream enum values.",
            "relevance": "context",
            "lines": "43-103"
          }
        ],
        "rationale": "Classified as feature-request because the issue explicitly uses the [FEATURE] template and requests adding a new enum value. Area is area/SkiaSharp because SKColorType is defined in the core SkiaSharp binding (Definitions.cs). The comment from molesmoke correctly identifies this as an upstream Skia limitation \u2014 Skia\u0027s SkColorType enum (SkColorType.h) has kGray_8_SkColorType but no 16-bit gray equivalent, and the PNG codec actively downgrades 16-bit gray to 8-bit.",
        "keySignals": [
          {
            "text": "i want to use 16bit grayscale pngs but it looks like it doesnt exist in skiasharp",
            "source": "issue body",
            "interpretation": "User needs 16-bit precision for grayscale data \u2014 likely scientific/medical imaging use case."
          },
          {
            "text": "There\u0027s no Gray16 support upstream: https://api.skia.org/SkColorType_8h.html",
            "source": "comment by molesmoke",
            "interpretation": "Correctly identifies the root cause \u2014 this is blocked by upstream Skia, not just a SkiaSharp mapping gap."
          },
          {
            "text": "// TODO: Should we support 16-bits of precision for gray images?",
            "source": "externals/skia/src/codec/SkPngCodec.cpp:861",
            "interpretation": "Skia developers have considered this but not implemented it. The decoder uses png_set_strip_16() to discard precision."
          }
        ],
        "workarounds": [
          "Decode 16-bit grayscale PNGs outside of SkiaSharp (e.g., using a dedicated PNG library like ImageSharp or libpng directly), then import the raw pixel data into an SKBitmap using SKColorType.Alpha16 (which is a 16-bit single-channel format) or SKColorType.Rg1616 for two-channel data.",
          "Use SKBitmap.FromImage() after decoding with SKCodec \u2014 the 16-bit data will be silently downsampled to 8-bit Gray8, which may be acceptable for display purposes even if precision is lost."
        ],
        "nextQuestions": [
          "Would Alpha16 (A16_unorm, 16-bit single channel) serve as an adequate workaround for raw pixel import, despite being semantically \u0027alpha\u0027 rather than \u0027gray\u0027?",
          "Is the use case display/rendering, or pixel-level data analysis where full 16-bit precision is critical?"
        ],
        "resolution": {
          "hypothesis": "Gray16 cannot be added to SkiaSharp without upstream Skia first adding kGray_16_SkColorType and updating the PNG codec to preserve 16-bit precision for grayscale images.",
          "proposals": [
            {
              "description": "Decode the 16-bit grayscale PNG using a library that supports it (e.g., SixLabors.ImageSharp, which supports Gray16), then copy the raw 16-bit pixel data into an SKBitmap using SKColorType.Alpha16 as the closest 16-bit single-channel format. This preserves the full 16-bit precision for processing, though rendering will interpret the channel as alpha rather than luminance.",
              "title": "External decode \u002B raw pixel import",
              "confidence": 0.65,
              "effort": "medium"
            },
            {
              "description": "Load the 16-bit grayscale PNG normally via SKBitmap.Decode() or SKImage.FromEncodedData(). Skia\u0027s PNG decoder will silently strip 16-bit to 8-bit, giving a Gray8 result. Acceptable for display/preview but loses precision.",
              "title": "Accept 8-bit downsampling",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Add kGray_16_SkColorType to upstream Skia\u0027s SkColorType enum, update the PNG codec to stop stripping 16-bit gray, and propagate through C API and SkiaSharp. This is the proper fix but requires upstream Skia acceptance.",
              "title": "Upstream Skia contribution",
              "confidence": 0.3,
              "effort": "large"
            }
          ],
          "recommendedProposal": "External decode \u002B raw pixel import",
          "recommendedReason": "Provides 16-bit precision without waiting for upstream Skia changes. The Alpha16 channel semantics are different but the raw data is preserved for custom processing."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Valid feature request blocked by upstream Skia limitation. Cannot be implemented without upstream changes, but the request is legitimate and should remain open for tracking."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm existing type/feature-request label and add area/SkiaSharp",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain upstream limitation, provide workaround options",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the request. As molesmoke noted, Skia\u0027s \u0060SkColorType\u0060 enum doesn\u0027t include a Gray16 variant \u2014 the only grayscale type is \u0060kGray_8_SkColorType\u0060. The PNG decoder also explicitly strips 16-bit grayscale to 8-bit (\u0060png_set_strip_16\u0060), so even the raw pixel data isn\u0027t preserved during decode.\n\nThis means adding \u0060SKColorType.Gray16\u0060 to SkiaSharp would require upstream Skia changes first.\n\nIn the meantime, if you need the full 16-bit precision, one option is to decode the PNG with a library that supports Gray16 (such as SixLabors.ImageSharp) and import the raw pixel data into an \u0060SKBitmap\u0060 using \u0060SKColorType.Alpha16\u0060 \u2014 it\u0027s semantically \u0022alpha\u0022 rather than \u0022gray,\u0022 but it\u0027s a 16-bit single-channel format that preserves the precision.\n\nIf 8-bit precision is acceptable for your use case, \u0060SKBitmap.Decode()\u0060 will load the image fine \u2014 it just silently downsamples to Gray8."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3380,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:24:40Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR by first-time contributor bumping OpenTK.GLWpfControl from 3.3.0 to 3.3.1 for .NET Framework targets in SkiaSharp.Views.WPF. This restores strong-naming support, fixing #3379 where strong-named applications get FileLoadException because GLWpfControl 3.3.0 is not strong-named. The change is a single-line version bump in the csproj. PR is mergeable but needs rebasing on top of current main.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            3379
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "FileLoadException",
          "errorMessage": "Could not load file or assembly \u0027GLWpfControl, Version=3.3.0.0, Culture=neutral, PublicKeyToken=null\u0027 or one of its dependencies. A strongly-named assembly is required. (Exception from HRESULT: 0x80131044)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net48"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The csproj on main still references OpenTK.GLWpfControl 3.3.0 for net4 targets. The bug persists in all current SkiaSharp 3.x releases."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "Reporter states it worked in 2.88.9. The OpenTK.GLWpfControl dependency was introduced or changed during the SkiaSharp 3.x modernization, bringing in the unsigned 3.3.0 version.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "This PR is the proposed fix but has not been merged. Main branch still references OpenTK.GLWpfControl 3.3.0.",
          "relatedPRs": [
            3380
          ]
        }
      },
      "analysis": {
        "summary": "This is a straightforward community PR that bumps OpenTK.GLWpfControl from 3.3.0 to 3.3.1 for .NET Framework 4.x targets. The 3.3.1 release of GLWpfControl added strong-name signing, which is required for consumers that enable SignAssembly. The change is minimal (one line in the csproj), has no API or behavioral changes, and directly resolves the bug reported in #3379. The PR needs rebasing but is otherwise ready for review.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "The net4 ItemGroup references OpenTK 3.3.1 but OpenTK.GLWpfControl 3.3.0 \u2014 an inconsistency. OpenTK itself was already bumped to 3.3.1 (strong-named), but GLWpfControl was left at 3.3.0 (unsigned).",
            "relevance": "direct",
            "lines": "13-16"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "SignAssembly is only disabled for non-net4 targets. For net4, the assembly is strong-named, requiring all dependencies to also be strong-named.",
            "relevance": "direct",
            "lines": "10"
          },
          {
            "file": "scripts/VERSIONS.txt",
            "finding": "VERSIONS.txt tracks OpenTK.GLWpfControl at 4.3.4 (release). This is for the non-net4 path which currently uses 4.2.3 \u2014 a separate version gap that could be addressed in a follow-up.",
            "relevance": "context",
            "lines": "27"
          }
        ],
        "rationale": "Classified as type/bug because it fixes a concrete FileLoadException (#3379) that prevents strong-named WPF applications from using SkiaSharp.Views.WPF on .NET Framework. Area is SkiaSharp.Views since the change is in the WPF views csproj. Severity is medium \u2014 it blocks a specific use case (strong-named apps) but doesn\u0027t affect unsigned applications. It\u0027s a regression from 2.88.x where either strong-naming wasn\u0027t an issue or the dependency was different.",
        "keySignals": [
          {
            "text": "Fixes #3379 \u2014 Version update to restore strong-naming support",
            "source": "PR description",
            "interpretation": "PR explicitly links to the bug report and states the intent clearly."
          },
          {
            "text": "OpenTK.GLWpfControl 3.3.0 \u2192 3.3.1 (net4 targets only)",
            "source": "PR diff",
            "interpretation": "Minimal, targeted change \u2014 only affects the .NET Framework 4.x conditional ItemGroup. Non-net4 targets already use 4.2.3."
          },
          {
            "text": "SignAssembly Condition=\u0022!$(TargetFramework.StartsWith(\u0027net4\u0027))\u0022\u003Efalse",
            "source": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj:10",
            "interpretation": "SkiaSharp.Views.WPF disables strong-naming for non-net4 targets but keeps it enabled for net4. This explains why net4 requires all dependencies to be strong-named."
          },
          {
            "text": "mergeable_state: behind",
            "source": "GitHub API",
            "interpretation": "PR needs rebasing on current main before merge. No merge conflicts detected."
          }
        ],
        "workarounds": [
          "Users can work around this by not strong-naming their assembly, though this may not be viable for enterprise applications with strong-naming requirements."
        ],
        "nextQuestions": [
          "Should the non-net4 OpenTK.GLWpfControl also be bumped from 4.2.3 to 4.3.4 per VERSIONS.txt?",
          "Are there any breaking changes in OpenTK.GLWpfControl 3.3.1 relative to 3.3.0?"
        ],
        "resolution": {
          "hypothesis": "OpenTK.GLWpfControl 3.3.0 lacks strong-name signing. Since SkiaSharp.Views.WPF is strong-named for net4 targets, all its dependencies must also be strong-named. Bumping to 3.3.1 (which added strong-naming) resolves the FileLoadException.",
          "proposals": [
            {
              "description": "Accept this community PR after rebase. The one-line version bump from 3.3.0 to 3.3.1 restores strong-naming compatibility. No API or behavioral changes.",
              "title": "Merge PR #3380",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "While merging #3380, also update the non-net4 OpenTK.GLWpfControl from 4.2.3 to 4.3.4 to match VERSIONS.txt. This is a separate improvement but could be bundled.",
              "title": "Also bump non-net4 GLWpfControl to 4.3.4",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3380",
          "recommendedReason": "The PR is minimal, correct, and directly fixes the reported bug. Rebasing is the only prerequisite."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "Valid community PR that fixes a real bug (#3379). Needs rebase on main, then can be merged. No concerns with the change itself."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views, Windows, compatibility labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference the bug report this PR fixes",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3379
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the contribution and request rebase",
            "risk": "high",
            "confidence": 0.88,
            "comment": "Thanks for the fix \u2014 the version bump looks correct and matches the strong-naming change in GLWpfControl 3.3.1.\n\nThe PR is currently behind \u0060main\u0060. Would you be able to rebase onto the latest \u0060main\u0060 so CI can run? Once that\u0027s green, this should be ready to merge."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3379,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:18:05Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp.Views",
          "tenet/compatibility"
        ]
      },
      "summary": "SkiaSharp.Views.WPF references OpenTK.GLWpfControl 3.3.0 for .NET Framework targets, which is not strong-named. This causes FileLoadException in applications that enable strong-name signing (SignAssembly), since all dependencies must also be strong-named. OpenTK.GLWpfControl 3.3.1 added strong-name signing, so bumping the version from 3.3.0 to 3.3.1 resolves the issue. A community PR #3380 already proposes this fix.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET Framework 4.8 WPF project with strong-name signing enabled (SignAssembly=true)",
            "Add a PackageReference to SkiaSharp.Views.WPF 3.119.1",
            "Build and run the application",
            "Observe FileLoadException for GLWpfControl assembly"
          ],
          "codeSnippets": [
            "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\n  \u003CPropertyGroup\u003E\n    \u003COutputType\u003EWinExe\u003C/OutputType\u003E\n    \u003CTargetFramework\u003Enet48\u003C/TargetFramework\u003E\n    \u003CSignAssembly\u003Etrue\u003C/SignAssembly\u003E\n    \u003CAssemblyOriginatorKeyFile\u003EMyStrongNameKey.snk\u003C/AssemblyOriginatorKeyFile\u003E\n  \u003C/PropertyGroup\u003E\n  \u003CItemGroup\u003E\n    \u003CPackageReference Include=\u0022SkiaSharp.Views.WPF\u0022 Version=\u00223.119.1\u0022 /\u003E\n  \u003C/ItemGroup\u003E\n\u003C/Project\u003E"
          ],
          "environmentDetails": "Windows, .NET Framework 4.8, Visual Studio (Windows), strong-name signing enabled",
          "relatedIssues": [
            1767
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "FileLoadException",
          "errorMessage": "Could not load file or assembly \u0027GLWpfControl, Version=3.3.0.0, Culture=neutral, PublicKeyToken=null\u0027 or one of its dependencies. A strongly-named assembly is required. (Exception from HRESULT: 0x80131044)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net48"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The csproj on main still references OpenTK.GLWpfControl 3.3.0 for .NET Framework targets. The issue persists in all 3.x releases."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.75,
          "reason": "Reporter says 2.88.9 worked. The SKGLElement class (and its dependency on OpenTK.GLWpfControl) was introduced in SkiaSharp 3.0 via PR #2317, so the strong-naming incompatibility started with the 3.x line. In 2.88.x, the WPF view didn\u0027t depend on GLWpfControl.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "The csproj on main still shows OpenTK.GLWpfControl 3.3.0. PR #3380 proposes the fix but has not been merged.",
          "relatedPRs": [
            3380
          ]
        }
      },
      "analysis": {
        "summary": "SkiaSharp.Views.WPF depends on OpenTK.GLWpfControl 3.3.0 for .NET Framework targets (net4*). That version lacks strong-name signing. When the consuming application enables SignAssembly, the CLR refuses to load the unsigned GLWpfControl assembly, throwing FileLoadException. The upstream OpenTK project added strong-naming in GLWpfControl 3.3.1. The fix is a one-line version bump in the csproj.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "For net4* targets, references OpenTK 3.3.1 (strong-named) and OpenTK.GLWpfControl 3.3.0 (NOT strong-named). The GLWpfControl version is the problem.",
            "relevance": "direct",
            "lines": "13-16"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "SignAssembly is explicitly disabled for non-net4 targets but remains enabled for net4*. This means the WPF assembly itself is strong-named for .NET Framework, requiring all dependencies to also be strong-named.",
            "relevance": "direct",
            "lines": "10"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj",
            "finding": "For modern .NET targets, OpenTK.GLWpfControl is at 4.2.3 \u2014 a different major version line not affected by this issue.",
            "relevance": "context",
            "lines": "17-20"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKGLElement.cs",
            "finding": "SKGLElement inherits from GLWpfControl, making it a direct dependency that cannot be avoided.",
            "relevance": "related",
            "lines": "29"
          },
          {
            "file": "scripts/VERSIONS.txt",
            "finding": "VERSIONS.txt lists OpenTK.GLWpfControl at 4.3.4, which is the modern .NET version. The net4* 3.x line version is not tracked here.",
            "relevance": "context",
            "lines": "27"
          }
        ],
        "rationale": "This is clearly a bug \u2014 a dependency version choice that breaks strong-named applications. It\u0027s area/SkiaSharp.Views because the issue is in the WPF views package dependency, not core SkiaSharp. Windows-Classic because it only affects .NET Framework WPF. tenet/compatibility because strong-naming is a .NET compatibility requirement. Severity is medium \u2014 the app won\u0027t load the GL control at all, but only affects the subset of users who strong-name their .NET Framework apps.",
        "keySignals": [
          {
            "text": "PackageReference Include=\u0022OpenTK.GLWpfControl\u0022 Version=\u00223.3.0\u0022",
            "source": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj:15",
            "interpretation": "Root cause \u2014 version 3.3.0 is not strong-named; 3.3.1 is."
          },
          {
            "text": "SignAssembly Condition=\u0022!$(TargetFramework.StartsWith(\u0027net4\u0027))\u0022\u003Efalse\u003C/SignAssembly\u003E",
            "source": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SkiaSharp.Views.WPF.csproj:10",
            "interpretation": "SkiaSharp.Views.WPF itself IS strong-named for net4* targets, creating a mismatch with unsigned GLWpfControl."
          },
          {
            "text": "FileLoadException: A strongly-named assembly is required (0x80131044)",
            "source": "issue body",
            "interpretation": "CLR enforces that strong-named assemblies can only reference other strong-named assemblies."
          },
          {
            "text": "Strong-naming was added in OpenTK.GLWpfControl 3.3.1",
            "source": "issue body \u002B opentk/GLWpfControl#164",
            "interpretation": "Upstream already fixed this; SkiaSharp just needs to bump the dependency version."
          }
        ],
        "errorFingerprint": "FileLoadException-GLWpfControl-StrongName-net4",
        "workarounds": [
          "Use a binding redirect in app.config to force-load the unsigned assembly (may not work in all strong-naming scenarios)",
          "Target modern .NET (net6.0-windows\u002B) instead of .NET Framework, which uses OpenTK.GLWpfControl 4.x and doesn\u0027t require strong-naming"
        ],
        "nextQuestions": [
          "Should VERSIONS.txt also be updated to track the net4* version of OpenTK.GLWpfControl separately?",
          "Are there any breaking API changes between OpenTK.GLWpfControl 3.3.0 and 3.3.1 that could affect SKGLElement?"
        ],
        "resolution": {
          "hypothesis": "OpenTK.GLWpfControl 3.3.0 is not strong-named, but SkiaSharp.Views.WPF IS strong-named for .NET Framework targets. The CLR enforces that strong-named assemblies can only reference other strong-named assemblies, causing FileLoadException at runtime.",
          "proposals": [
            {
              "description": "Change the PackageReference from OpenTK.GLWpfControl 3.3.0 to 3.3.1 in the net4* ItemGroup. Version 3.3.1 is strong-named. Community PR #3380 already implements this exact change.",
              "title": "Bump GLWpfControl to 3.3.1",
              "codeSnippet": "\u003CPackageReference Include=\u0022OpenTK.GLWpfControl\u0022 Version=\u00223.3.1\u0022 NoWarn=\u0022NU1701\u0022 /\u003E",
              "confidence": 0.98,
              "effort": "trivial"
            },
            {
              "description": "Users can work around the issue by targeting net6.0-windows or later instead of net48, which uses the OpenTK 4.x line (already strong-name compatible).",
              "title": "Migrate to modern .NET",
              "confidence": 0.9,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Bump GLWpfControl to 3.3.1",
          "recommendedReason": "Trivial one-line version bump with zero risk. The upstream already fixed strong-naming in 3.3.1. PR #3380 from the reporter implements this exact change and should be reviewed and merged."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.9,
          "reason": "The fix is trivial (one-line version bump) and a community PR #3380 already implements it. Review and merge the PR to resolve this."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp.Views, os/Windows-Classic, tenet/compatibility",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the issue and point to PR #3380 as the fix",
            "risk": "high",
            "confidence": 0.92,
            "comment": "Thanks for the detailed report and the fix in #3380.\n\nYou\u0027re right \u2014 \u0060OpenTK.GLWpfControl\u0060 3.3.0 isn\u0027t strong-named, and since \u0060SkiaSharp.Views.WPF\u0060 is strong-named for .NET Framework targets, the CLR rejects the unsigned dependency at load time. Bumping to 3.3.1 (which added strong-naming) is the correct fix.\n\nIn the meantime, if you need a workaround: targeting \u0060net6.0-windows\u0060 or later avoids this entirely, since the modern .NET path uses OpenTK.GLWpfControl 4.x which doesn\u0027t have this issue."
          },
          {
            "type": "link-related",
            "description": "Link to community PR #3380 which implements the fix",
            "risk": "low",
            "confidence": 0.98,
            "linkedIssue": 3380
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3378,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:18:05Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "os/Android",
          "area/SkiaSharp",
          "backend/Metal",
          "tenet/reliability"
        ]
      },
      "summary": "Memory leak in ToHarfBuzzBlob() extension method: when SKStreamAsset.GetMemoryBase() returns IntPtr.Zero, the stream data is copied to unmanaged memory but the SKStreamAsset itself is never disposed. In the other code path (memoryBase != IntPtr.Zero), the asset IS disposed via the Blob\u0027s release callback, creating inconsistent ownership semantics. The reporter\u0027s code creates SKShaper instances (which internally call ToHarfBuzzBlob), and even with proper disposal of SKShaper, the underlying SKStreamAsset leaks. First observed on Android with SkiaSharp 3.116.0, also reproducible on Windows.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "class TextSegmentShaper : IDisposable\n{\n    public SKPaint Paint { get; set; }\n    public SKShaper Shaper { get; set; }\n    ...\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposedValue)\n        {\n            Paint?.Dispose();\n            Shaper?.Dispose();\n            Paint = null;\n            Shaper = null;\n            disposedValue = true;\n        }\n    }\n}"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), first observed on Android, also on Windows",
          "relatedIssues": [
            3376,
            3466,
            3467
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "memory-leak",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The ToHarfBuzzBlob code has not changed since 3.116.0. The leak still exists on main. PR #3466 proposes a fix but is not yet merged."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.9,
          "reason": "Two open PRs address this: #3376 (reporter\u0027s fix, adds dispose in else path) and #3466 (preferred fix, removes dispose from both paths and fixes SKShaper caller). Neither is merged yet.",
          "relatedPRs": [
            3376,
            3466,
            3467
          ]
        }
      },
      "analysis": {
        "summary": "ToHarfBuzzBlob() has two code paths: when GetMemoryBase() returns a valid pointer, the Blob\u0027s release callback disposes the SKStreamAsset; when it returns IntPtr.Zero, data is copied but the SKStreamAsset is never disposed. The SKShaper constructor calls Typeface.OpenStream().ToHarfBuzzBlob() in a using block for the blob only \u2014 the intermediate SKStreamAsset is never assigned to a variable and leaks in the else path. The agreed fix direction (per maintainer mattleibow) is PR #3466: remove dispose from both paths in ToHarfBuzzBlob (it shouldn\u0027t take ownership), and fix SKShaper to explicitly dispose the stream.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob has two paths: line 24 disposes asset via blob callback when memoryBase is valid; line 30 copies data but NEVER disposes asset when memoryBase is IntPtr.Zero. This is the root cause of the leak.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "SKShaper constructor calls Typeface.OpenStream(out index).ToHarfBuzzBlob() in a using block for the blob only. The SKStreamAsset returned by OpenStream() is not stored or disposed separately \u2014 it relies entirely on ToHarfBuzzBlob to handle it.",
            "relevance": "direct",
            "lines": "19-22"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "OpenStream() returns a new SKStreamAsset wrapping native memory via SkiaApi.sk_typeface_open_stream. This is the object that leaks when ToHarfBuzzBlob\u0027s else path is hit.",
            "relevance": "related",
            "lines": "295-300"
          }
        ],
        "rationale": "Classified as type/bug because this is confirmed broken behavior \u2014 a native resource leak in a well-defined code path. Area is SkiaSharp.HarfBuzz (not SkiaSharp) because the bug is in BlobExtensions.cs and SKShaper.cs, both in the SkiaSharp.HarfBuzz package. The title says \u0027SKShader\u0027 but the report is about SKShaper/ToHarfBuzzBlob. Not platform-specific \u2014 it\u0027s a managed code logic error affecting all platforms equally. Current labels incorrectly include backend/Metal (no rendering backend is involved) and area/SkiaSharp (should be area/SkiaSharp.HarfBuzz). Severity is medium: it\u0027s a gradual memory leak, not a crash, but can degrade long-running apps.",
        "keySignals": [
          {
            "text": "I think the bug is in ToHarfBuzzBlob() extension - it doesn\u0027t dispose SKStreamAsset in all paths",
            "source": "issue body",
            "interpretation": "Reporter correctly identified the root cause \u2014 the else branch in BlobExtensions.cs line 30 copies data but never disposes the asset."
          },
          {
            "text": "First observed bug on Android, but seems to be a problem also on Windows",
            "source": "issue body",
            "interpretation": "Cross-platform issue \u2014 managed code bug, not platform-specific. Current os/ and backend/ labels are overly specific."
          },
          {
            "text": "The extension method copies the data and does not own or keep a reference to the asset. Would it be better to maybe fix the caller?",
            "source": "PR #3376 comment by mattleibow",
            "interpretation": "Maintainer confirms the bug and prefers the caller (SKShaper) to handle disposal, not the extension method."
          },
          {
            "text": "I\u0027ve put an alternate PR here to remove the stream disposal on the other path and fix the SKShaper constructor",
            "source": "PR #3376 comment by jeremy-visionaid",
            "interpretation": "PR #3466 is the preferred fix direction: consistent non-ownership in ToHarfBuzzBlob, explicit disposal in SKShaper."
          }
        ],
        "errorFingerprint": "memory-leak-ToHarfBuzzBlob-SKStreamAsset-undisposed",
        "workarounds": [
          "No user-level workaround \u2014 the leak is internal to SKShaper\u0027s constructor. Users cannot access the intermediate SKStreamAsset."
        ],
        "nextQuestions": [
          "Does GetMemoryBase() typically return IntPtr.Zero for most typefaces, or only certain ones? This determines how frequently the leak path is hit.",
          "Are there other callers of ToHarfBuzzBlob outside of SKShaper that might also leak?"
        ],
        "resolution": {
          "hypothesis": "ToHarfBuzzBlob has inconsistent ownership: one path disposes the asset, the other doesn\u0027t. The SKShaper constructor doesn\u0027t compensate because it assumes the blob handles it. Fix: make ToHarfBuzzBlob never take ownership, and have the caller (SKShaper) explicitly dispose the stream.",
          "proposals": [
            {
              "description": "Remove dispose from both paths in ToHarfBuzzBlob (it copies data, shouldn\u0027t own the asset). Fix SKShaper to wrap OpenStream() result in a using statement. This is the maintainer-approved approach.",
              "title": "Merge PR #3466",
              "codeSnippet": "// SKShaper.cs constructor fix:\nusing (var stream = Typeface.OpenStream(out index))\nusing (var blob = stream.ToHarfBuzzBlob())\nusing (var face = new Face(blob, index))\n{ ... }",
              "confidence": 0.92,
              "effort": "small"
            },
            {
              "description": "Reporter\u0027s original fix: add asset.Dispose() after reading in the else path. Simpler but maintains inconsistent ownership \u2014 one path disposes via callback, one disposes inline.",
              "title": "Add dispose in else path (PR #3376)",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3466",
          "recommendedReason": "Cleaner ownership semantics: ToHarfBuzzBlob never takes ownership, caller is always responsible. Maintainer mattleibow explicitly approved this direction."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "Confirmed bug with an open PR (#3466) that has maintainer approval in principle. Issue should stay open until the PR is merged."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix labels: change area from SkiaSharp to SkiaSharp.HarfBuzz, remove incorrect backend/Metal, remove platform labels since this is cross-platform managed code",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference PR #3466 which contains the maintainer-approved fix",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3466
          },
          {
            "type": "add-comment",
            "description": "Acknowledge confirmed bug, note the preferred fix direction",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for identifying this \u2014 the analysis is spot on. The leak is in \u0060ToHarfBuzzBlob()\u0060 (BlobExtensions.cs): when \u0060GetMemoryBase()\u0060 returns \u0060IntPtr.Zero\u0060, the \u0060SKStreamAsset\u0060 is read but never disposed.\n\nPR #3466 takes the cleaner approach here: remove the dispose responsibility from \u0060ToHarfBuzzBlob\u0060 entirely (it copies data and shouldn\u0027t own the asset), and fix the \u0060SKShaper\u0060 constructor to explicitly dispose the stream:\n\n\u0060\u0060\u0060csharp\nusing (var stream = Typeface.OpenStream(out index))\nusing (var blob = stream.ToHarfBuzzBlob())\nusing (var face = new Face(blob, index))\n{\n    // ...\n}\n\u0060\u0060\u0060\n\nThere\u0027s no user-level workaround since the leak is internal to \u0060SKShaper\u0060\u0027s constructor. The fix in #3466 is the path forward."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3376,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:30:00Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR adding asset.Dispose() to ToHarfBuzzBlob\u0027s else branch to fix memory leak \u2014 maintainer disagrees with ownership model, superseded by #3466 which takes the correct approach of removing dispose ownership from both paths",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.9
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.98
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an SKShaper instance with any typeface",
            "The SKShaper constructor calls Typeface.OpenStream().ToHarfBuzzBlob()",
            "If SKStreamAsset.GetMemoryBase() returns IntPtr.Zero, the stream is never disposed",
            "Repeated SKShaper creation leaks native memory"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Android and Windows",
          "relatedIssues": [
            3373,
            3378,
            3466,
            3467
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "memory-leak",
          "errorMessage": "SKStreamAsset leaks when ToHarfBuzzBlob copies data (MemoryBase == IntPtr.Zero path)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-android",
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The inconsistent disposal code in BlobExtensions.cs and the missing stream disposal in SKShaper.cs are still present on main."
        }
      },
      "analysis": {
        "summary": "This PR attempts to fix a memory leak in ToHarfBuzzBlob by adding asset.Dispose() in the Blob release callback on the else branch. However, the maintainer (mattleibow) pointed out that the extension method copies the data and should not own the asset \u2014 disposing it in the Blob callback could break callers who still need the stream. The community reached consensus that the correct fix is in #3466: remove dispose ownership from both paths in ToHarfBuzzBlob and have SKShaper properly dispose the stream it creates.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "Two code paths with inconsistent ownership: memoryBase!=0 disposes asset in release callback (line 24), memoryBase==0 copies data but never disposes asset (line 30). This PR adds Dispose to line 30\u0027s callback, but the correct fix is to remove Dispose from line 24 instead.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "SKShaper.ctor calls Typeface.OpenStream().ToHarfBuzzBlob() without capturing the stream in a variable \u2014 the stream is never explicitly disposed by SKShaper. This is the actual caller that should own the stream lifetime.",
            "relevance": "direct",
            "lines": "19-20"
          }
        ],
        "rationale": "Classified as type/bug because this PR addresses a real memory leak (confirmed in #3378). Area is SkiaSharp.HarfBuzz since the affected code is BlobExtensions.cs and SKShaper.cs. Severity is medium \u2014 the leak occurs per SKShaper construction but doesn\u0027t cause crashes. The PR\u0027s approach is rejected by the maintainer because it moves disposal responsibility into a release callback where the caller can\u0027t control it, and the alternative PR #3466 takes the architecturally correct approach.",
        "keySignals": [
          {
            "text": "Extension \u0060public static Blob ToHarfBuzzBlob(this SKStreamAsset asset)\u0060 may leak when asset MemoryBase is not IntPtr.Zero",
            "source": "PR description",
            "interpretation": "Correctly identifies the bug: inconsistent disposal between the two code paths."
          },
          {
            "text": "The extension method copies the data and does not own or keep a reference to the asset. Would it be better to maybe fix the caller?",
            "source": "comment by mattleibow (maintainer)",
            "interpretation": "Maintainer rejects this PR\u0027s approach \u2014 the extension should not take ownership of the asset."
          },
          {
            "text": "the asset is already being disposed on the other path (that should probably be removed)",
            "source": "comment by molesmoke",
            "interpretation": "The existing disposal on the memoryBase!=0 path is itself a bug \u2014 both paths should NOT dispose."
          },
          {
            "text": "I\u0027ve put an alternate PR here to remove the stream disposal on the other path and fix the SKShaper constructor: #3466",
            "source": "comment by jeremy-visionaid",
            "interpretation": "Alternate PR takes the correct approach: no disposal in extension, caller (SKShaper) manages lifetime."
          },
          {
            "text": "Great, that may be the way forward",
            "source": "comment by michaldobrodenka (original PR author)",
            "interpretation": "Original author concedes this PR is superseded by #3466."
          }
        ],
        "nextQuestions": [
          "Should #3466 be merged instead?",
          "Does #3466 need any additional review or test changes?"
        ],
        "resolution": {
          "hypothesis": "The correct fix is to remove disposal ownership from ToHarfBuzzBlob entirely (both paths) and have callers like SKShaper explicitly dispose the stream. PR #3466 implements this correctly.",
          "proposals": [
            {
              "description": "PR #3466 takes the architecturally correct approach: removes dispose ownership from both ToHarfBuzzBlob paths and fixes SKShaper to properly dispose the stream. It also includes tests. This PR should be closed in favor of #3466.",
              "title": "Close in favor of #3466",
              "confidence": 0.92,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Close in favor of #3466",
          "recommendedReason": "The maintainer rejected this PR\u0027s approach, the original author agrees #3466 is the way forward, and #3466 includes tests."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.92,
          "reason": "Superseded by #3466 which takes the maintainer-approved approach. Original PR author acknowledges #3466 is the way forward."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and HarfBuzz area labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz"
            ]
          },
          {
            "type": "link-duplicate",
            "description": "Superseded by #3466 which fixes the same bug with correct ownership semantics",
            "risk": "medium",
            "confidence": 0.92,
            "linkedIssue": 3466
          },
          {
            "type": "add-comment",
            "description": "Thank the contributor and explain closure in favor of #3466",
            "risk": "high",
            "confidence": 0.88,
            "comment": "Thanks for identifying this memory leak \u2014 the bug is real and your PR helped surface the correct fix.\n\nAs discussed in the comments, the extension method shouldn\u0027t take disposal ownership of the \u0060SKStreamAsset\u0060 since the caller may still need it. PR #3466 takes the approach of removing disposal from both paths in \u0060ToHarfBuzzBlob\u0060 and having \u0060SKShaper\u0060 explicitly dispose the stream it creates via \u0060OpenStream()\u0060. That\u0027s the cleaner ownership model.\n\nClosing in favor of #3466."
          },
          {
            "type": "close-issue",
            "description": "Close as superseded by #3466",
            "risk": "medium",
            "confidence": 0.9
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3375,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:20:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      "summary": "Stack overflow crash on Windows x86 with .NET 8/9 due to missing Cdecl calling convention on LibraryImport P/Invoke declarations",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability",
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET 8 or .NET 9 project referencing SkiaSharp 3.116\u002B",
            "Target x86 (win-x86) platform",
            "Call any SkiaSharp API that P/Invokes into the native library (e.g., SKBitmap.GetPixel)",
            "Observe stack overflow crash"
          ],
          "environmentDetails": "Windows 11, .NET 8.0/9.0, x86 target, SkiaSharp 3.116\u002B / 3.119.1",
          "relatedIssues": []
        },
        "bugSignals": {
          "severity": "critical",
          "isRegression": true,
          "errorType": "crash",
          "errorMessage": "Stack overflow at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color(IntPtr, Int32, Int32)",
          "stackTrace": "at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color(IntPtr, Int32, Int32)",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0",
            "net9.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "3.119.1",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The code generator (Generator.cs line 546) still emits [LibraryImport] without Cdecl calling convention. The generated file SkiaApi.generated.cs still lacks the necessary [UnmanagedCallConv] attribute. The bug is present on the main branch."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "SkiaSharp 2.88.x used DllImport with CallingConvention.Cdecl exclusively. SkiaSharp 3.x introduced LibraryImport for .NET 7\u002B but omitted the Cdecl calling convention. On x64 this is invisible (one calling convention), on x86 it causes stack corruption.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "The P/Invoke code generator emits [LibraryImport(SKIA)] without specifying a calling convention. On .NET 7\u002B x86 Windows, LibraryImport defaults to CallingConvention.Winapi which resolves to StdCall. The native C API functions use Cdecl (the C default). This calling convention mismatch causes stack corruption on x86, manifesting as a stack overflow. On x64, there is only one calling convention, so the mismatch is invisible.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaApi.generated.cs",
            "finding": "[LibraryImport(SKIA)] at line 1647 does not specify calling convention. The [DllImport] fallback at line 1650 correctly specifies CallingConvention.Cdecl. This pattern repeats for ALL P/Invoke declarations in the file.",
            "relevance": "direct",
            "lines": "1644-1660"
          },
          {
            "file": "utils/SkiaSharpGenerator/Generate/Generator.cs",
            "finding": "Line 546 emits \u0060[LibraryImport ({config.DllName})]\u0060 without calling convention. Line 552 emits \u0060[DllImport ({config.DllName}, CallingConvention = CallingConvention.Cdecl)]\u0060. The LibraryImport path should also specify Cdecl via [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })].",
            "relevance": "direct",
            "lines": "545-555"
          },
          {
            "file": "binding/SkiaSharp/SkiaSharp.csproj",
            "finding": "USE_DELEGATES is defined for net4x (Framework), USE_LIBRARY_IMPORT for net7.0\u002B. This confirms .NET Framework uses correct Cdecl delegates while .NET 7\u002B uses the broken LibraryImport path.",
            "relevance": "direct",
            "lines": "12-17"
          },
          {
            "file": "externals/skia/include/c/sk_types.h",
            "finding": "SK_C_API macro only specifies dllexport/dllimport visibility, NOT a calling convention. Native functions default to __cdecl (C default on Windows).",
            "relevance": "direct",
            "lines": "25-38"
          },
          {
            "file": "externals/skia/src/c/sk_bitmap.cpp",
            "finding": "sk_bitmap_get_pixel_color is a plain C function with no explicit calling convention \u2014 uses default __cdecl.",
            "relevance": "context",
            "lines": "87-89"
          }
        ],
        "rationale": "Both reporters describe x86-only crashes with .NET 8/9 that work fine on x64. The second reporter provides a clear stack overflow trace at sk_bitmap_get_pixel_color. Code investigation confirms the generated [LibraryImport] declarations lack Cdecl specification while the [DllImport] fallback correctly specifies it. The native SK_C_API macro contains no calling convention specifier, defaulting to Cdecl. This is clearly a code-generation bug, not a usage issue. Severity is critical because ALL P/Invoke calls on x86 .NET 7\u002B are affected \u2014 the library is fundamentally broken on this platform.",
        "keySignals": [
          {
            "text": "x86 crash, x64 works",
            "source": "issue body \u002B comment 2",
            "interpretation": "Classic calling convention mismatch symptom \u2014 only matters on x86 where StdCall and Cdecl differ."
          },
          {
            "text": "Stack overflow at SkiaSharp.SkiaApi.sk_bitmap_get_pixel_color",
            "source": "comment 2 (TomPMoleman)",
            "interpretation": "Stack corruption from calling convention mismatch causes stack overflow at the P/Invoke boundary."
          },
          {
            "text": "x86 \u002B net472: working, x86 \u002B Net8.0: ISSUE",
            "source": "comment 2 (TomPMoleman)",
            "interpretation": ".NET Framework uses USE_DELEGATES path with correct Cdecl convention; .NET 8 uses USE_LIBRARY_IMPORT path missing Cdecl."
          },
          {
            "text": "Rollback to 2.88.9 fixes it",
            "source": "issue body",
            "interpretation": "SkiaSharp 2.88.x didn\u0027t have LibraryImport \u2014 used DllImport with CallingConvention.Cdecl only."
          },
          {
            "text": "[LibraryImport(SKIA)] without calling convention in generated code",
            "source": "SkiaApi.generated.cs:1647-1648, Generator.cs:546",
            "interpretation": "Root cause \u2014 generator emits LibraryImport without Cdecl, defaulting to StdCall on x86 Windows."
          }
        ],
        "errorFingerprint": "stack-overflow::sk_*::x86::net7\u002B::libraryimport-missing-cdecl",
        "workarounds": [
          "Target x64 instead of x86 (x64 has a single calling convention, so the bug is invisible)",
          "Downgrade to SkiaSharp 2.88.x which uses DllImport with correct Cdecl convention"
        ],
        "nextQuestions": [
          "Confirm that adding [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })] to the generator output fixes x86 .NET 8/9",
          "Check if HarfBuzzSharp has the same LibraryImport calling convention issue"
        ],
        "resolution": {
          "hypothesis": "LibraryImport without Cdecl calling convention defaults to StdCall on x86 Windows, causing stack corruption on every P/Invoke call into the native Cdecl library.",
          "proposals": [
            {
              "description": "Update Generator.cs line 546 to also emit [UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })] after the [LibraryImport] attribute. Then regenerate SkiaApi.generated.cs with \u0060pwsh ./utils/generate.ps1\u0060.",
              "title": "Fix code generator to emit Cdecl for LibraryImport",
              "confidence": 0.95,
              "effort": "small"
            },
            {
              "description": "As a workaround, compile for x64 or AnyCPU (prefer 64-bit) instead of x86. On x64 Windows there is only one calling convention, so the mismatch is invisible.",
              "title": "Target x64 instead of x86",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Downgrade to SkiaSharp 2.88.9 which uses DllImport with CallingConvention.Cdecl exclusively. This avoids the LibraryImport path entirely.",
              "title": "Downgrade to SkiaSharp 2.88.x",
              "confidence": 0.9,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Fix code generator to emit Cdecl for LibraryImport",
          "recommendedReason": "This is a straightforward code generator fix. The DllImport path already has the correct pattern. Adding the equivalent attribute for LibraryImport is a small, low-risk change that fixes the platform entirely."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Root cause identified with high confidence (calling convention mismatch in generated code). Needs a fix in the code generator and regeneration of bindings. Should be verified on x86 .NET 8/9 before shipping."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp, os/Windows-Classic, tenet/reliability are all accurate",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis confirming root cause and providing workaround",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the detailed stack trace \u2014 that confirmed this.\n\nThe root cause is a calling convention mismatch in the P/Invoke bindings. SkiaSharp 3.x uses \u0060[LibraryImport]\u0060 for .NET 7\u002B, but the generated declarations don\u0027t specify \u0060Cdecl\u0060 calling convention. On x86 Windows, \u0060LibraryImport\u0060 defaults to \u0060StdCall\u0060, while the native C API uses \u0060Cdecl\u0060. This stack corruption manifests as a stack overflow. On x64 there\u0027s only one calling convention, which is why it works there. On .NET Framework, SkiaSharp uses a different code path (\u0060DllImport\u0060) that correctly specifies \u0060Cdecl\u0060.\n\nWorkaround: target x64 instead of x86 if possible \u2014 the calling convention mismatch is invisible on x64.\n\nThe fix is to update the code generator to emit \u0060[UnmanagedCallConv(CallConvs = new[] { typeof(CallConvCdecl) })]\u0060 alongside the \u0060[LibraryImport]\u0060 attribute."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3372,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:15:00Z",
        "currentLabels": [
          "area/SkiaSharp.Views",
          "type/feature-request",
          "os/Windows-WinUI"
        ]
      },
      "summary": "Replace Microsoft.WindowsAppSDK metapackage with Microsoft.WindowsAppSDK.WinUI sub-package (v1.8) to avoid forcing full metapackage on downstream consumers",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "tenets": [
          "tenet/compatibility"
        ],
        "partner": "partner/maui"
      },
      "evidence": {
        "reproEvidence": {
          "environmentDetails": "Windows, WinAppSDK 1.8\u002B, .NET MAUI",
          "relatedIssues": []
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.4.230913002",
            "1.8"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "SkiaSharp still references Microsoft.WindowsAppSDK 1.4.230913002 metapackage. The WinAppSDK 1.8 package split has shipped, making this request actionable."
        }
      },
      "analysis": {
        "summary": "SkiaSharp.Views.WinUI currently references the Microsoft.WindowsAppSDK metapackage at v1.4, which forces all downstream consumers (including MAUI) to pull in the entire WinAppSDK. Since WinAppSDK 1.8 split the packages, SkiaSharp could reference only Microsoft.WindowsAppSDK.WinUI \u2014 the only component it actually uses. This would unblock downstream projects from reducing their dependency footprint.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj",
            "finding": "References Microsoft.WindowsAppSDK v1.4.230913002 (the full metapackage). This is the primary reference that needs to change to Microsoft.WindowsAppSDK.WinUI.",
            "relevance": "direct",
            "lines": "17"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/*.cs",
            "finding": "Only uses Microsoft.UI.Dispatching, Microsoft.UI.Xaml.* namespaces \u2014 all WinUI XAML types. No usage of other WinAppSDK components (notifications, lifecycle, etc.). Confirms the metapackage is unnecessarily broad.",
            "relevance": "direct"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native.vcxproj",
            "finding": "The native C\u002B\u002B project also references Microsoft.WindowsAppSDK 1.4.230913002 via NuGet packages.config. This would also need updating if the managed package changes.",
            "relevance": "direct",
            "lines": "3, 181, 192-193"
          },
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native/packages.config",
            "finding": "Lists Microsoft.WindowsAppSDK 1.4.230913002 as a native NuGet dependency. Must be updated in tandem with the managed project.",
            "relevance": "direct"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/SkiaSharp.Views.Maui.Core.csproj",
            "finding": "MAUI project references SkiaSharp.Views.WinUI via ProjectReference. The WindowsAppSDK metapackage flows transitively to MAUI consumers through this chain.",
            "relevance": "related",
            "lines": "23"
          },
          {
            "file": "samples/Basic/WinUI/SkiaSharpSample/SkiaSharpSample.csproj",
            "finding": "Sample project references Microsoft.WindowsAppSDK v1.4.231219000 (slightly newer than the library). Sample should also be updated for consistency.",
            "relevance": "related",
            "lines": "16"
          }
        ],
        "rationale": "This is clearly a feature request (package dependency restructuring, not a bug). The area is SkiaSharp.Views because the change targets SkiaSharp.Views.WinUI.csproj and its native counterpart. The MAUI partner label applies because dotMorten explicitly discusses MAUI RC2 being unable to properly reduce dependencies without this change. The compatibility tenet applies because bumping from WinAppSDK 1.4 to 1.8 may force consumers to upgrade their WinAppSDK version.",
        "keySignals": [
          {
            "text": "Please upgrade the WinUI package to reference Microsoft.WindowsAppSDK.WinUI 1.8, so that it no longer relies on the Microsoft.WindowsAppSDK metapackage",
            "source": "issue body",
            "interpretation": "Clear request to swap metapackage for sub-package to reduce dependency footprint."
          },
          {
            "text": "It\u0027s a bit on all us 3rd party library developers to fix the low level dependencies first so higher-level projects can reap the benefits",
            "source": "comment #3 (dotMorten)",
            "interpretation": "Ecosystem argument \u2014 SkiaSharp is a foundational library that blocks MAUI and others from adopting the split packages."
          },
          {
            "text": "1.8 upgrade is planned for RC2, but it can\u0027t be done right without this",
            "source": "comment #5 (dotMorten)",
            "interpretation": "MAUI RC2 is blocked on this change for proper WinAppSDK dependency reduction."
          },
          {
            "text": "1.8 breaks some maui features with net10-rc1\u002BWebView2",
            "source": "comment #4 (jeromelaban)",
            "interpretation": "Version bump carries risk \u2014 WinAppSDK 1.8 has known compatibility issues with .NET 10 RC1 and WebView2 in MAUI."
          }
        ],
        "nextQuestions": [
          "Does Microsoft.WindowsAppSDK.WinUI 1.8 include native C\u002B\u002B build props/targets equivalent to the metapackage, or does the native project need a different sub-package?",
          "What is the minimum WinAppSDK version that supports the split packages \u2014 is 1.8 the first, or can a lower version be used?",
          "Will bumping from 1.4 to 1.8 cause TargetPlatformMinVersion or API compatibility issues for existing consumers?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp.Views.WinUI only uses WinUI XAML types, so the Microsoft.WindowsAppSDK metapackage can be replaced with the Microsoft.WindowsAppSDK.WinUI sub-package at version 1.8\u002B. This requires updating both the managed .csproj and the native .vcxproj \u002B packages.config.",
          "proposals": [
            {
              "description": "Change PackageReference in SkiaSharp.Views.WinUI.csproj from Microsoft.WindowsAppSDK to Microsoft.WindowsAppSDK.WinUI at version 1.8.x. Also update the native C\u002B\u002B project (vcxproj \u002B packages.config) to use the equivalent native WinUI sub-package. Update the sample project for consistency.",
              "title": "Replace metapackage with WinUI sub-package",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "As a less disruptive alternative, bump Microsoft.WindowsAppSDK from 1.4 to 1.8 without switching to the sub-package. This doesn\u0027t solve the metapackage bloat but modernizes the version. Lower risk but doesn\u0027t address the core request.",
              "title": "Bump metapackage version only",
              "confidence": 0.6,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Replace metapackage with WinUI sub-package",
          "recommendedReason": "Directly addresses the request and unblocks downstream MAUI dependency reduction. The code investigation confirms only WinUI types are used, so no other WinAppSDK components are needed."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "Valid feature request with clear ecosystem benefit. Needs investigation into whether the WinUI sub-package provides equivalent native C\u002B\u002B build support and whether the version bump introduces compatibility issues."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/feature-request, area/SkiaSharp.Views, os/Windows-WinUI. Add partner/maui since MAUI is directly impacted.",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views",
              "os/Windows-WinUI",
              "partner/maui"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the request, confirm code investigation findings, and note that only WinUI types are used.",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for filing this. We\u0027ve confirmed that SkiaSharp.Views.WinUI only uses \u0060Microsoft.UI.Xaml.*\u0060 and \u0060Microsoft.UI.Dispatching\u0060 \u2014 no other WinAppSDK components \u2014 so switching from the metapackage to \u0060Microsoft.WindowsAppSDK.WinUI\u0060 is viable.\n\nThe change involves both the managed project (\u0060SkiaSharp.Views.WinUI.csproj\u0060) and the native C\u002B\u002B project (\u0060SkiaSharp.Views.WinUI.Native.vcxproj\u0060 \u002B \u0060packages.config\u0060), which also reference the metapackage at 1.4. We\u0027ll need to verify the native sub-package provides equivalent build props/targets before making the switch.\n\nThe version bump from 1.4 to 1.8 is the main compatibility concern \u2014 it raises the minimum WinAppSDK version for consumers."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3365,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:15:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/libSkiaSharp.native",
          "tenet/reliability"
        ]
      },
      "summary": "Duplicate of #3267 \u2014 libSkiaSharp.dll has hard link-time dependency on d3d12.dll, crashing on Windows systems without DX12",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility",
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET app referencing SkiaSharp 3.116.0\u002B",
            "Deploy to a Windows 10 machine that lacks DX12 support (unpatched or older hardware)",
            "Run the app \u2014 crash on load because libSkiaSharp.dll imports d3d12.dll which is missing"
          ],
          "environmentDetails": "Windows 10 without DX12 (approx 0.1% of 1M installations). Also reproduced on Windows 7 (#3267) and Windows Server 2012 R2 (#3300).",
          "relatedIssues": [
            3267,
            3300,
            2305,
            2235
          ]
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "crash",
          "errorMessage": "Hard crash on load \u2014 d3d12.dll not found on systems without DX12 support",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The native Windows build still sets skia_use_direct3d=true by default, which links d3d12.lib at compile time. No /DELAYLOAD is configured. The dependency is still present in the current build."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "SkiaSharp 2.88.x did not link d3d12.lib. The Direct3D backend was added in the 3.x series, introducing a hard import dependency on d3d12.dll.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "The Windows native build (native/windows/build.cake) passes skia_use_direct3d=true to GN, which causes Skia\u0027s BUILD.gn to link d3d12.lib, dxgi.lib, and d3dcompiler.lib directly. This creates a hard import-table dependency on d3d12.dll in the resulting libSkiaSharp.dll. On Windows systems without DX12 (older Win10, Win7, Server 2012 R2), the DLL loader fails immediately \u2014 before any SkiaSharp code runs \u2014 because d3d12.dll is missing.",
        "codeInvestigation": [
          {
            "file": "native/windows/build.cake",
            "finding": "SUPPORT_DIRECT3D defaults to true. Line 76 passes skia_use_direct3d=true to GN args. This is the root configuration that enables the d3d12.lib linkage.",
            "relevance": "direct",
            "lines": "11-12"
          },
          {
            "file": "externals/skia/BUILD.gn",
            "finding": "When skia_use_direct3d is true, BUILD.gn adds libs \u002B= [\u0027d3d12.lib\u0027, \u0027dxgi.lib\u0027, \u0027d3dcompiler.lib\u0027]. These are static import libs \u2014 the resulting DLL will fail to load if d3d12.dll is not present on the system.",
            "relevance": "direct",
            "lines": "1037-1049"
          },
          {
            "file": "externals/skia/BUILD.gn",
            "finding": "There is also a dawn_enable_d3d12 code path that links the same libs, but this is only active when skia_use_dawn=true (currently false by default).",
            "relevance": "related",
            "lines": "917-922"
          },
          {
            "file": "scripts/cake/native-shared.cake",
            "finding": "CheckWindowsDependencies verifies DLL imports post-build but only excludes VCRUNTIME/MSVCP. d3d12.dll is not flagged. No /DELAYLOAD is configured anywhere in the build.",
            "relevance": "related",
            "lines": "52-86"
          }
        ],
        "rationale": "This is clearly a bug (type/bug) \u2014 the crash happens at DLL load time, not during any D3D12 API call. SkiaSharp defaults to CPU/raster rendering, so the D3D12 dependency should never be required for basic usage. The area is libSkiaSharp.native since the issue is in the native build configuration, not the C# bindings. Severity is high: it affects real production deployments (0.1% of 1M installs) with no user-side workaround except downgrading. This is a duplicate of #3267 which reports the identical root cause but on Win7 \u2014 the underlying problem (link-time d3d12.lib) is the same regardless of Windows version.",
        "keySignals": [
          {
            "text": "out of a sample of 1 million installations around 0.1% are crashing because their systems don\u0027t have DX12",
            "source": "issue body",
            "interpretation": "Real production impact \u2014 approximately 1000 users affected. Not theoretical."
          },
          {
            "text": "This should be a runtime dependency that is dynamically loaded",
            "source": "issue body",
            "interpretation": "Reporter correctly identifies the root cause: link-time vs runtime dependency."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "issue body",
            "interpretation": "Confirms regression \u2014 D3D12 backend was not present in 2.88.x series."
          },
          {
            "text": "While this is in reference to Windows 7, all of our crashes occur on Windows 10",
            "source": "comment #3",
            "interpretation": "Same root cause as #3267 but broader impact \u2014 not just Win7, also unpatched Win10."
          },
          {
            "text": "the common theme is that they\u0027re on systems that don\u0027t support DX12",
            "source": "comment #4 (molesmoke)",
            "interpretation": "Community correctly identifies this as a duplicate of #3267 with the same resolution path."
          }
        ],
        "nextQuestions": [
          "Would adding /DELAYLOAD:d3d12.dll to extra_ldflags be a safe fix? This would defer loading until D3D12 APIs are actually called.",
          "Alternatively, should SUPPORT_DIRECT3D default to false, requiring opt-in?",
          "Does Skia internally handle the case where d3d12.dll is delay-loaded but unavailable at runtime?"
        ],
        "resolution": {
          "hypothesis": "libSkiaSharp.dll statically imports d3d12.dll via link-time dependency. On systems without DX12, the Windows loader fails before any code executes. The fix is to either delay-load d3d12.dll or disable D3D12 by default.",
          "proposals": [
            {
              "description": "Add /DELAYLOAD:d3d12.dll, /DELAYLOAD:dxgi.dll, and /DELAYLOAD:d3dcompiler.dll to extra_ldflags in native/windows/build.cake and add delayimp.lib to the link. This defers loading until D3D12 functions are actually called, allowing SkiaSharp to work on systems without DX12 as long as D3D12 features are not used.",
              "title": "Add /DELAYLOAD for d3d12.dll",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Change SUPPORT_DIRECT3D default from \u0027true\u0027 to \u0027false\u0027 in native/windows/build.cake. Users who need D3D12 rendering would opt in via build argument. This eliminates the dependency entirely for the default build.",
              "title": "Disable Direct3D by default",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "As an immediate workaround, downgrade to SkiaSharp 2.88.9 which does not have the D3D12 dependency. This is the version the reporter confirmed as working.",
              "title": "Downgrade to SkiaSharp 2.88.x",
              "confidence": 0.95,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Add /DELAYLOAD for d3d12.dll",
          "recommendedReason": "Delay loading preserves D3D12 capability for users who need it while eliminating the hard dependency. This is the standard Windows pattern for optional system DLLs. The downgrade workaround is viable immediately but loses all 3.x improvements."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.9,
          "reason": "Same root cause as #3267 (d3d12.dll hard dependency). The only difference is the reporter\u0027s Windows version (Win10 vs Win7), but the fix is identical. Community commenter also confirms this is a duplicate."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Current labels are already correct \u2014 type/bug, area/libSkiaSharp.native, os/Windows-Classic, tenet/reliability. Add tenet/compatibility.",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/Windows-Classic",
              "tenet/reliability",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report, confirm duplicate status, and note the production impact data as valuable evidence for #3267",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed production data \u2014 knowing this affects ~0.1% of 1M installations is valuable evidence.\n\nThis is the same root cause as #3267: \u0060libSkiaSharp.dll\u0060 statically imports \u0060d3d12.dll\u0060 because the Windows native build links \u0060d3d12.lib\u0060 at compile time (via \u0060skia_use_direct3d=true\u0060). On any system without DX12 support, the Windows loader fails before SkiaSharp code runs.\n\nThe fix is the same regardless of Windows version \u2014 either delay-load the D3D12 DLLs or make D3D12 opt-in. I\u0027m closing this as a duplicate; your production impact data has been noted in #3267\u0027s tracking.\n\nAs an immediate workaround, downgrading to SkiaSharp 2.88.9 avoids the dependency entirely (as you\u0027ve confirmed)."
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #3267",
            "risk": "medium",
            "confidence": 0.9,
            "linkedIssue": 3267
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #3267",
            "risk": "medium",
            "confidence": 0.9
          },
          {
            "type": "link-related",
            "description": "Cross-reference #3300 (same issue on Windows Server 2012 R2)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3300
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3362,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:30:00Z",
        "currentLabels": []
      },
      "summary": "Copilot bot PR to migrate docs from Xamarin.Forms to .NET MAUI \u2014 already completed on docs branch",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.98
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.98
        }
      },
      "evidence": {
        "reproEvidence": {
          "environmentDetails": "PR created by Copilot bot, targets docs branch, 54 files, 296\u002B/296- (1:1 replacements)"
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "The docs branch was independently migrated to MAUI via commits 38d5cac69..b1bf5612c on 2026-01-29. Zero Xamarin references remain. This PR\u0027s changes are entirely redundant."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.99,
          "reason": "The exact same migration (Xamarin.Forms \u2192 .NET MAUI) was completed on the docs branch in commits 38d5cac69 (\u0027Remove all Xamarin references from docs and root files\u0027) and b1bf5612c (\u0027Remove all remaining Xamarin references\u0027) on 2026-01-29. grep confirms zero Xamarin references remain on the docs branch.",
          "relatedCommits": [
            "38d5cac69",
            "10027c66e",
            "939d37b2c",
            "b1bf5612c"
          ]
        }
      },
      "analysis": {
        "summary": "PR #3362 is a Copilot-bot-generated PR from 2025-09-05 that mechanically replaces Xamarin.Forms references with .NET MAUI across 54 documentation files on the docs branch. The same migration was independently completed on the docs branch on 2026-01-29 via 4 commits. The PR now has merge conflicts and is fully redundant.",
        "codeInvestigation": [
          {
            "file": ".docs/docs/docs/basics/integration.md",
            "finding": "Already references \u0027.NET MAUI\u0027, uses ms.service: dotnet-maui, zero Xamarin references \u2014 confirms migration is complete",
            "relevance": "direct"
          },
          {
            "file": ".docs/docs/docs/basics/animation.md",
            "finding": "Zero Xamarin.Forms references (grep count: 0) \u2014 PR\u0027s proposed changes already present",
            "relevance": "direct"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Controls/SkiaSharp.Views.Maui.Controls.csproj",
            "finding": "Confirms SkiaSharp.Views.Maui.Controls is the correct package name used in the PR\u0027s replacement text",
            "relevance": "context"
          }
        ],
        "rationale": "This is clearly a documentation PR \u2014 all 54 files are in docs/ and contain only text/metadata changes. The area is area/Docs since it modifies the documentation website content on the docs branch. The PR is superseded because the target branch already contains the identical migration, confirmed by grep showing zero remaining Xamarin references. mattleibow approved in Sept 2025 but it was never merged; the work was done independently later.",
        "keySignals": [
          {
            "text": "mergeable_state: dirty",
            "source": "GitHub API",
            "interpretation": "PR has merge conflicts because the same changes were applied independently on the target branch."
          },
          {
            "text": "Zero Xamarin.Forms references remain on docs branch",
            "source": "grep -rl \u0027Xamarin.Forms|SkiaSharp.Views.Forms\u0027 .docs/docs/ returned 0 results",
            "interpretation": "The migration this PR attempts is already 100% complete on the target branch."
          },
          {
            "text": "Commits 38d5cac69..b1bf5612c on 2026-01-29",
            "source": "git log on docs branch",
            "interpretation": "Four commits completed the full Xamarin\u2192MAUI migration 5 months after this PR was opened."
          },
          {
            "text": "PR author: Copilot bot, draft: true",
            "source": "GitHub API",
            "interpretation": "Auto-generated PR that was never finalized or merged."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.97,
          "reason": "The migration this PR implements was independently completed on the docs branch on 2026-01-29. The PR has merge conflicts and is fully redundant."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply documentation and docs area labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/documentation",
              "area/Docs"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain the PR is superseded and close",
            "risk": "high",
            "confidence": 0.95,
            "comment": "Thanks for the contribution. This migration was independently completed on the \u0060docs\u0060 branch in January 2026 (commits 38d5cac69..b1bf5612c), so this PR is now fully superseded. Closing as the target branch already contains all these changes."
          },
          {
            "type": "close-issue",
            "description": "Close as superseded \u2014 migration already complete on target branch",
            "risk": "medium",
            "confidence": 0.97
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3357,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:13:03Z",
        "currentLabels": [
          "area/Docs"
        ]
      },
      "summary": "Maintainer request to migrate API documentation from external XML files (docs/SkiaSharpAPI/*.xml, ~240 files) into inline C# XML doc comments in the binding source files. PR #3363 attempted this but was closed without merging because NuGet doc tooling cannot handle packages with different APIs across target frameworks. The issue remains open as a desired long-term goal, blocked on tooling.",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.98
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.98
        }
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            3356,
            3358,
            3363,
            3410
          ]
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.95,
          "reason": "PR #3363 attempted the migration but was closed without merging. Maintainer commented: \u0027the automated tooling to process nugets do not support nugets with different apis in different tfms. For now, we still have to use a separate docs repo.\u0027 The migration is blocked on NuGet documentation tooling, not on the content itself.",
          "relatedPRs": [
            3363
          ]
        }
      },
      "analysis": {
        "summary": "This is a maintainer-initiated docs migration task. The goal is to move all API documentation from the external XML doc repo (docs/SkiaSharpAPI/) into triple-slash (///) XML doc comments directly in the C# source (binding/SkiaSharp/*.cs). Multiple attempts were made (#3356 partial WIP, #3358 closed, PR #3363 with 40 commits touching 165 files). PR #3363 was the most complete attempt but was closed by the maintainer because NuGet doc generation tooling cannot produce correct documentation for packages that expose different APIs across different TFMs (e.g., net8.0 vs net8.0-ios). The issue remains open and desired.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "Zero inline XML doc comments (/// \u003Csummary\u003E). No triple-slash comments on any public member. Confirms the migration has not been done for this major class.",
            "relevance": "direct",
            "lines": "1-15"
          },
          {
            "file": "docs/SkiaSharpAPI/SkiaSharp/SKBitmap.xml",
            "finding": "Full XML API documentation exists externally \u2014 type summary, remarks, member docs. This is the source material that needs to be migrated into the C# source.",
            "relevance": "direct",
            "lines": "1-30"
          },
          {
            "file": "docs/SkiaSharpAPI/SkiaSharp/",
            "finding": "~240 XML doc files exist covering SkiaSharp types. Corresponding 85 C# source files in binding/SkiaSharp/ have essentially no inline docs.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/documentation because the issue is entirely about moving documentation content between formats (external XML \u2192 inline C# comments). Area is area/Docs because it concerns the documentation infrastructure, not any specific SkiaSharp API component. No platforms, backends, or tenets apply since this is a cross-cutting docs task.",
        "keySignals": [
          {
            "text": "Can you help migrate my docs from the docs folder into the c# source",
            "source": "issue body",
            "interpretation": "Maintainer-initiated documentation migration request. Clear intent \u2014 not a question or bug."
          },
          {
            "text": "Closing this for now as the automated tooling to process nugets do not support nugets with different apis in different tfms",
            "source": "PR #3363 comment by mattleibow",
            "interpretation": "The migration is technically feasible but blocked on NuGet doc tooling. The issue is NOT abandoned \u2014 maintainer said \u0027for now\u0027 and \u0027I will continue to investigate\u0027."
          },
          {
            "text": "Each type should be migrated and committed separately",
            "source": "issue body",
            "interpretation": "Maintainer wants atomic commits per type for review workflow. This constraint makes the migration a large but well-structured task."
          },
          {
            "text": "Fixes #3357",
            "source": "PR #3363 body",
            "interpretation": "PR #3363 was the official attempt to resolve this issue. Its closure without merge confirms the issue is still open."
          }
        ],
        "nextQuestions": [
          "Has the NuGet doc tooling limitation been resolved since PR #3363 was closed (Jan 2026)?",
          "Should the migration proceed in stages (e.g., types with consistent APIs across TFMs first)?",
          "Are the migration guide files (API.Docs.Migration.Guide.md, API.Docs.Migration.Checklist.md) available somewhere or need to be recreated?"
        ],
        "resolution": {
          "hypothesis": "The migration is blocked on NuGet documentation tooling not supporting different APIs across TFMs. Once that tooling limitation is resolved (either upstream fix or a workaround like conditional XML doc generation), the migration can proceed using the PR #3363 approach.",
          "proposals": [
            {
              "description": "Monitor NuGet/dotnet SDK updates for support of per-TFM XML documentation in packages. The migration content is ready (proven by PR #3363\u0027s 40 commits) but cannot ship until tooling supports it.",
              "title": "Wait for tooling fix",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Use #if directives or partial classes to provide different docs per TFM, allowing the NuGet doc extractor to process each TFM separately. This adds complexity but may unblock the migration.",
              "title": "Migrate with conditional compilation",
              "confidence": 0.4,
              "effort": "large"
            },
            {
              "description": "Identify types whose public API surface is identical across all TFMs and migrate those first. This sidesteps the multi-TFM tooling issue for a subset of the docs.",
              "title": "Migrate common-API types first",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Wait for tooling fix",
          "recommendedReason": "The maintainer explicitly closed PR #3363 to wait for tooling improvements. Forcing the migration now would reproduce the same problem. The content is ready and can be re-applied quickly once tooling supports it."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.92,
          "reason": "The maintainer opened this issue and explicitly said the PR was closed \u0027for now\u0027 \u2014 indicating this remains a desired goal. The issue is blocked on external tooling, not abandoned. Keep open to track when the tooling limitation is resolved."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply documentation type label alongside existing area/Docs",
            "risk": "low",
            "confidence": 0.98,
            "labels": [
              "type/documentation",
              "area/Docs"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference the closed PR that attempted this migration",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3363
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3346,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:05:45Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      "summary": "Published Windows ARM64 app using SkiaSharp 3.116.0 crashes immediately on launch. Works fine in Debug and Release modes, only fails when published. Reporter found that installing the Microsoft Visual C\u002B\u002B Redistributable resolves the crash, suggesting a missing dynamic CRT dependency in the native binaries. Issue was closed after PR #3510 added build-time verification that ANGLE DLLs (libEGL.dll, libGLESv2.dll) and all Windows native binaries are statically linked against the CRT, preventing future regressions.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.82
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a SkiaSharp app targeting Windows ARM64",
            "Build in Release mode \u2014 works fine",
            "Publish the app for Windows ARM64",
            "Run the published executable on a fresh ARM64 Windows machine without VC\u002B\u002B Redistributable installed",
            "App crashes immediately on launch"
          ],
          "environmentDetails": "Windows 10 and 11, ARM64, SkiaSharp 3.116.0, Visual Studio (Windows)",
          "repoLinks": [
            {
              "url": "https://github.com/riccardomartins/ArmDemoTryout/tree/main/ArmDemoTryout",
              "description": "Minimal repro project from reporter"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "crash",
          "errorMessage": "Application crashes immediately on launch when published for Windows ARM64",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "PR #3510 added build-time dependency verification for all Windows native DLLs. CI confirms ANGLE, libSkiaSharp, and libHarfBuzzSharp are statically linked and do not depend on VCRUNTIME or MSVCP."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.9,
          "reason": "PR #3510 merged into main on 2026-02-11. CI confirmed all Windows native binaries (ANGLE, libSkiaSharp, libHarfBuzzSharp) do not dynamically link VCRUNTIME or MSVCP. Build-time CheckWindowsDependencies verification now prevents regressions across all Windows build targets.",
          "relatedPRs": [
            3510
          ]
        }
      },
      "analysis": {
        "summary": "Published Windows ARM64 app crashes on fresh machines without VC\u002B\u002B Redistributable. The root cause was a dynamic CRT dependency in one of the shipped native DLLs, most likely the ANGLE DLLs (libEGL.dll, libGLESv2.dll) used for GPU rendering. Publishing trims the output and runs on machines that may not have the VC\u002B\u002B Redistributable pre-installed, exposing the missing dependency. PR #3510 confirmed via dumpbin that current builds are statically linked and added CI verification across all Windows native build targets.",
        "codeInvestigation": [
          {
            "file": "native/winui-angle/build.cake",
            "finding": "VERIFY_EXCLUDED array defines [\u0027VCRUNTIME\u0027, \u0027MSVCP\u0027] \u2014 CheckWindowsDependencies rejects any ANGLE DLL that dynamically links these CRT libraries.",
            "relevance": "direct",
            "lines": "7"
          },
          {
            "file": "native/winui-angle/build.cake",
            "finding": "ANGLE build targets arm64, x64, x86. Uses is_component_build=false (static linking). CheckWindowsDependencies called after each build to verify no CRT dependencies.",
            "relevance": "direct",
            "lines": "115-158"
          },
          {
            "file": "native/windows/build.cake",
            "finding": "libSkiaSharp.dll and libHarfBuzzSharp.dll also use VERIFY_EXCLUDED = [\u0027VCRUNTIME\u0027, \u0027MSVCP\u0027] with CheckWindowsDependencies verification, added in PR #3510.",
            "relevance": "related",
            "lines": "14, 87, 109"
          },
          {
            "file": "scripts/cake/native-shared.cake",
            "finding": "CheckWindowsDependencies uses dumpbin /dependents to enumerate DLL imports, then rejects any matching the excluded list. Shared across all Windows native builds.",
            "relevance": "related",
            "lines": "52-86"
          }
        ],
        "rationale": "Classified as type/bug because the app crashes (not a usage question or feature request). Area is libSkiaSharp.native because the crash stems from native DLL dynamic linking, not managed code. Platform is Windows-Classic since the reporter used standard Windows (not WinUI). Severity is high \u2014 the crash prevents the app from launching at all in published form. The tenet/reliability label is appropriate for crash-on-launch behavior.",
        "keySignals": [
          {
            "text": "App crashes immediately on launch when published for Windows ARM64",
            "source": "issue body",
            "interpretation": "Publish-only crash suggests stripped/self-contained deployment exposes a missing native dependency that the development environment satisfies."
          },
          {
            "text": "Installing Microsoft Visual C\u002B\u002B Redistributable fixes the crash",
            "source": "comment by riccardomartins (2025-09-03)",
            "interpretation": "Confirms the root cause is a dynamic VCRUNTIME/MSVCP dependency in shipped native DLLs \u2014 fresh ARM64 machines lack the CRT without explicit installation."
          },
          {
            "text": "Were you using the GPU rendering? If so, I am trying to release a fix for that.",
            "source": "comment by mattleibow (2025-09-06)",
            "interpretation": "Maintainer suspected ANGLE (GPU) DLLs as the source of the dynamic CRT dependency, directing the investigation."
          },
          {
            "text": "CI on PR #3510 confirms ANGLE DLLs do not depend on VCRUNTIME or MSVCP \u2014 already statically linked",
            "source": "closing comment by mattleibow (2026-02-11)",
            "interpretation": "Current builds verified clean. PR adds build-time CI gates to catch future regressions."
          }
        ],
        "workarounds": [
          "Install Microsoft Visual C\u002B\u002B Redistributable on the target ARM64 machine (confirmed by reporter to resolve the crash)",
          "Use software/raster rendering instead of GPU rendering to avoid ANGLE DLL dependency"
        ],
        "nextQuestions": [
          "Was the reporter\u0027s 3.116.0 build actually shipping ANGLE DLLs with dynamic CRT links, or was the crash from a different dependency?",
          "Which specific DLL was the source of the VCRUNTIME dependency in the 3.116.0 timeframe?"
        ],
        "resolution": {
          "hypothesis": "One or more native Windows DLLs shipped with SkiaSharp 3.116.0 had a dynamic dependency on VCRUNTIME/MSVCP. On fresh ARM64 Windows machines without the VC\u002B\u002B Redistributable, this caused immediate crash on load. The ANGLE DLLs (libEGL.dll, libGLESv2.dll) were the most likely culprits since the maintainer specifically asked about GPU rendering.",
          "proposals": [
            {
              "description": "Install the Microsoft Visual C\u002B\u002B Redistributable on target machines. This is the reporter\u0027s confirmed workaround.",
              "title": "Install VC\u002B\u002B Redistributable",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Add CheckWindowsDependencies CI verification to all Windows native builds, rejecting any DLL that dynamically links VCRUNTIME or MSVCP. Already merged.",
              "title": "Build-time dependency verification (PR #3510)",
              "confidence": 0.95,
              "effort": "small"
            },
            {
              "description": "Switch to software/raster rendering to avoid ANGLE DLL loading entirely, sidestepping the CRT dependency.",
              "title": "Disable GPU rendering",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Build-time dependency verification (PR #3510)",
          "recommendedReason": "Addresses the root cause at the build level with CI regression prevention. Already merged and verified across all 62 native build jobs."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.92,
          "reason": "PR #3510 merged 2026-02-11 adds build-time verification that all Windows native DLLs are statically linked. Issue already closed by maintainer with explanation."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, os/Windows-Classic, tenet/reliability all match",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Link to PR #3510 which adds the build-time dependency verification fix",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3510
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3344,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:30:00Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp",
          "tenet/compatibility"
        ]
      },
      "summary": "SKSurface.Draw and SKCanvas.DrawSurface lack SKSamplingOptions parameter \u2014 upstream Skia supports it but C API and C# wrapper never exposed it",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Call SKCanvas.DrawSurface(surface, x, y, paint) \u2014 no SKSamplingOptions parameter available",
            "Call SKSurface.Draw(canvas, x, y, paint) \u2014 no SKSamplingOptions parameter available",
            "Attempt to use SKPaint.FilterQuality to control sampling \u2014 value is obsolete and not forwarded to native layer for surface drawing"
          ],
          "environmentDetails": "Windows, Visual Studio, SkiaSharp 3.116.0",
          "relatedIssues": [
            2663
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "currentRelevance": "likely",
          "relevanceReason": "The C API sk_surface_draw still lacks a sampling options parameter. The upstream Skia C\u002B\u002B API SkSurface::draw supports SkSamplingOptions but the C shim was never updated."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.85,
          "reason": "PR #3491 adds sk_surface_draw_with_sampling to the C API and new C# overloads with SKSamplingOptions. PR is open, CI passes, assigned to mattleibow for review.",
          "relatedPRs": [
            3491
          ]
        }
      },
      "analysis": {
        "summary": "The upstream Skia C\u002B\u002B SkSurface::draw method accepts SkSamplingOptions, but the SkiaSharp C API (sk_surface_draw) was never updated to forward this parameter. The C# methods SKSurface.Draw and SKCanvas.DrawSurface therefore have no way to specify sampling. Unlike DrawImage (which was updated with sampling overloads), DrawSurface was missed during the 2.x\u21923.x migration.",
        "codeInvestigation": [
          {
            "file": "externals/skia/include/core/SkSurface.h",
            "finding": "Upstream SkSurface::draw has two overloads: one with SkSamplingOptions (line 346) and a convenience overload without it that defaults to SkSamplingOptions() (line 349-350). The sampling-aware overload is the primary one.",
            "relevance": "direct",
            "lines": "346-351"
          },
          {
            "file": "externals/skia/src/c/sk_surface.cpp",
            "finding": "C API sk_surface_draw calls AsSurface(surface)-\u003Edraw(canvas, x, y, AsPaint(paint)) \u2014 the convenience overload without sampling. No sk_surface_draw_with_sampling function exists.",
            "relevance": "direct",
            "lines": "84-86"
          },
          {
            "file": "externals/skia/include/c/sk_surface.h",
            "finding": "C header declares sk_surface_draw without sampling parameter. No sampling variant declared.",
            "relevance": "direct",
            "lines": "34"
          },
          {
            "file": "binding/SkiaSharp/SKSurface.cs",
            "finding": "SKSurface.Draw(SKCanvas, float, float, SKPaint) calls sk_surface_draw \u2014 no sampling parameter forwarded. Unlike DrawImage, no FilterQuality-to-sampling conversion either.",
            "relevance": "direct",
            "lines": "280-286"
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "SKCanvas.DrawSurface delegates to surface.Draw(this, x, y, paint) \u2014 just a convenience wrapper, inherits the same limitation.",
            "relevance": "direct",
            "lines": "589-602"
          },
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "DrawImage methods show the correct pattern: legacy overloads extract paint?.FilterQuality.ToSamplingOptions(), and new overloads accept SKSamplingOptions directly. DrawSurface should follow this same pattern.",
            "relevance": "related",
            "lines": "455-478"
          }
        ],
        "rationale": "Classified as feature-request rather than bug because the API never had an explicit SKSamplingOptions parameter \u2014 the gap is a missing overload, not broken behavior. However, the reporter notes FilterQuality on SKPaint no longer works for surface drawing, which is a compatibility regression from the 2.88.x\u21923.x migration where FilterQuality was removed from SkPaint upstream. The tenet/compatibility label is appropriate. Area is core SkiaSharp since this is in the canvas/surface drawing layer, not views or platform-specific code.",
        "keySignals": [
          {
            "text": "There is no way to draw surface with sampling. SkPaint legacy field is not working also",
            "source": "issue body",
            "interpretation": "Both the new SKSamplingOptions path and the legacy FilterQuality path are missing for surface drawing."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "issue body",
            "interpretation": "In 2.88.x, SkPaint.FilterQuality was consumed natively by Skia for all draw operations. After the Skia migration, FilterQuality became a compat shim that DrawImage forwards but DrawSurface does not."
          },
          {
            "text": "void draw(SkCanvas*, SkScalar, SkScalar, const SkSamplingOptions\u0026, const SkPaint*)",
            "source": "externals/skia/include/core/SkSurface.h:346",
            "interpretation": "Upstream C\u002B\u002B API supports sampling options \u2014 the capability exists, just not exposed through the C shim."
          }
        ],
        "workarounds": [
          "Use surface.Snapshot() to get an SKImage, then call canvas.DrawImage(image, x, y, sampling, paint) which does accept SKSamplingOptions"
        ],
        "nextQuestions": [
          "Should the existing DrawSurface overloads forward FilterQuality from SKPaint (like DrawImage does) for backward compatibility?",
          "Should the C API function be named sk_surface_draw_with_sampling or should the existing sk_surface_draw signature be updated?"
        ],
        "resolution": {
          "hypothesis": "The C API sk_surface_draw needs a new variant that accepts sk_sampling_options_t, and the C# SKSurface.Draw and SKCanvas.DrawSurface need new overloads accepting SKSamplingOptions, following the same pattern as DrawImage.",
          "proposals": [
            {
              "description": "Use SKSurface.Snapshot() to capture the surface as an SKImage, then draw with SKCanvas.DrawImage which supports SKSamplingOptions. This avoids the gap without waiting for the API fix.",
              "title": "Snapshot workaround",
              "codeSnippet": "using var image = surface.Snapshot();\nif (image is null)\n    return; // or handle error\nvar sampling = new SKSamplingOptions(SKFilterMode.Linear, SKMipmapMode.Linear);\ncanvas.DrawImage(image, x, y, sampling, paint);",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "PR #3491 adds sk_surface_draw_with_sampling to the C API and new C# overloads with SKSamplingOptions on both SKSurface.Draw and SKCanvas.DrawSurface. The PR is open, CI passes, and follows the same pattern as DrawImage.",
              "title": "Merge PR #3491",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Snapshot workaround",
          "recommendedReason": "Provides an immediate workaround the reporter can use today. The proper fix via PR #3491 is already in review."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "PR #3491 is open and addresses this issue. Keep open until the PR is merged."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Reclassify as feature-request (missing API overload, not broken behavior)",
            "risk": "low",
            "confidence": 0.75,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post workaround using Snapshot \u002B DrawImage, note that PR #3491 is in review",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. You\u0027re right that \u0060SKSurface.Draw\u0060 and \u0060SKCanvas.DrawSurface\u0060 don\u0027t accept \u0060SKSamplingOptions\u0060 \u2014 the upstream Skia C\u002B\u002B API supports it, but the SkiaSharp C shim was never updated during the 2.x\u21923.x migration.\n\nHere\u0027s a workaround you can use while we work on the proper fix: snapshot the surface to an \u0060SKImage\u0060 and use \u0060DrawImage\u0060, which does support sampling options:\n\n\u0060\u0060\u0060csharp\nusing var image = surface.Snapshot();\nif (image is null)\n    return; // handle error as appropriate\nvar sampling = new SKSamplingOptions(SKFilterMode.Linear, SKMipmapMode.Linear);\ncanvas.DrawImage(image, x, y, sampling, paint);\n\u0060\u0060\u0060\n\nNote that \u0060Snapshot()\u0060 can return null if the surface is invalid, so always null-check before use.\n\nPR #3491 adds the missing \u0060SKSamplingOptions\u0060 overloads to both \u0060SKSurface.Draw\u0060 and \u0060SKCanvas.DrawSurface\u0060 and is currently in review."
          },
          {
            "type": "link-related",
            "description": "Cross-reference PR #3491 which fixes this issue",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 3491
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3343,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:30:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "area/SkiaSharp.Views.Maui",
          "tenet/reliability"
        ]
      },
      "summary": "Telerik MAUI app crashes on Windows after upgrading to SkiaSharp 3.116.1 \u2014 likely same root cause as #3136 (WinUI native DLL dynamically links VC\u002B\u002B runtime instead of static)",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.75
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.7
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Use Telerik MAUI 11.0.0 controls (which reference SkiaSharp 3.116.1)",
            "Run the app on Windows (10, 11, or Server 2019/2022/2025)",
            "App crashes (no further details provided)"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/42cc4a83-7e5d-465d-9e49-d64ede04da96",
              "description": "Screenshot of DLLs posted by reporter (image not viewable)"
            }
          ],
          "environmentDetails": "Windows 10/11/Server 2019/2022/2025, .NET 9, Visual Studio (Windows), Telerik MAUI 11.0.0",
          "relatedIssues": [
            3136,
            3019
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "crash",
          "reproQuality": "none",
          "targetFrameworks": [
            "net9.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.1",
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.1",
          "currentRelevance": "likely",
          "relevanceReason": "The WinUI native DLL dynamic linking issue identified in #3136 has not yet been fixed in any released version. Maintainer acknowledged the root cause on 2025-08-31."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.65,
          "reason": "Reporter claims 2.88.9 worked. However, the WinUI native interop component was rewritten for SkiaSharp 3.x, so the VC\u002B\u002B runtime dependency is new in 3.x. The regression is real but caused by the 3.x architecture change, not a point regression.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.1"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.8,
          "reason": "Maintainer @mattleibow acknowledged in #3136 on 2025-08-31 that the WinUI interop was built without statically linking the runtime. He stated \u0027I am hoping to fix this soon. Just fixing some signing issues in the pipelines.\u0027 No PR has been submitted yet."
        }
      },
      "analysis": {
        "summary": "Vague crash report from Telerik MAUI user on Windows. No stack trace, error message, or code provided. Commenter @Inrego linked #3136 and confirmed the VCRedist workaround fixes it, strongly suggesting the same root cause: SkiaSharp.Views.WinUI.Native.dll dynamically links to VC\u002B\u002B runtime instead of static linking.",
        "codeInvestigation": [
          {
            "file": "native/winui/build.cake",
            "finding": "VERIFY_EXCLUDED includes VCRUNTIME and MSVCP \u2014 build system is supposed to verify these are NOT dependencies of the output DLL. If the built DLL still requires them, the verification may have been bypassed or failed.",
            "relevance": "direct",
            "lines": "4"
          },
          {
            "file": "native/winui/build.cake",
            "finding": "CheckDeps() is called on both SkiaSharp.Views.WinUI.Native.dll and Projection.dll after build, confirming the intent to exclude VC\u002B\u002B runtime deps.",
            "relevance": "direct",
            "lines": "47-48"
          },
          {
            "file": "binding/Binding.Shared/LibraryLoader.cs",
            "finding": "Windows native library loading uses Win32 LoadLibrary \u2014 standard P/Invoke path. If the loaded DLL has unsatisfied dependencies (VC\u002B\u002B runtime), LoadLibrary will fail with a hard crash.",
            "relevance": "related",
            "lines": "132-148"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/UWPExtensions.cs",
            "finding": "Uses BufferExtensions.GetByteBuffer(buffer) from WinUI.Native namespace \u2014 this is the exact code path that crashed in #3136 with REGDB_E_CLASSNOTREG.",
            "relevance": "related",
            "lines": "104"
          }
        ],
        "rationale": "Classified as type/bug because a crash is reported (even without evidence). Area is SkiaSharp.Views.Maui because the crash occurs through Telerik MAUI controls which use SkiaSharp\u0027s MAUI views. Platform changed from os/Windows-Classic to os/Windows-WinUI because MAUI on Windows uses WinUI, not Win32. Severity is high because it\u0027s a crash affecting production apps, but confidence is lower due to the complete absence of diagnostic information. The link to #3136 is the strongest signal \u2014 same symptoms, same platform, confirmed workaround.",
        "keySignals": [
          {
            "text": "I believe this is related: https://github.com/mono/SkiaSharp/issues/3136 ... Fix to crash, run this on machine: winget install Microsoft.VCRedist.2015\u002B.x64",
            "source": "comment by @Inrego",
            "interpretation": "Direct confirmation from another affected user that this is the same issue as #3136 and VCRedist fixes it."
          },
          {
            "text": "I think that I was building the interop and not statically linking the runtime. Try installing the msvc runtime.",
            "source": "#3136 comment by @mattleibow (maintainer)",
            "interpretation": "Maintainer confirmed root cause: WinUI native DLL dynamically links VC\u002B\u002B runtime instead of static linking."
          },
          {
            "text": "The behavior start occurring when Telerik MAUI controls were updated to 3.116.1 in Telerik Maui 11.0.0 version",
            "source": "issue body",
            "interpretation": "Reporter doesn\u0027t use SkiaSharp directly \u2014 uses it through Telerik MAUI. Telerik bumped their SkiaSharp dependency to 3.x."
          },
          {
            "text": "Windows 10 11 and server 2019,2022,2025",
            "source": "issue body",
            "interpretation": "Windows Server editions may not have VC\u002B\u002B Redistributable installed by default, matching the #3136 pattern."
          }
        ],
        "workarounds": [
          "Install VC\u002B\u002B Redistributable on affected machines: winget install Microsoft.VCRedist.2015\u002B.x64",
          "Pin SkiaSharp to 2.88.x if Telerik supports it (reporter\u0027s last known good version)"
        ],
        "nextQuestions": [
          "What is the actual crash exception/stack trace? The report has zero diagnostic information.",
          "Does installing VCRedist resolve the crash for this reporter specifically?",
          "Is the crash on all Windows editions or only Server editions (which may lack VCRedist)?"
        ],
        "resolution": {
          "hypothesis": "The crash is caused by SkiaSharp.Views.WinUI.Native.dll dynamically linking to VC\u002B\u002B runtime (vcruntime140.dll/msvcp140.dll). On Windows editions without VCRedist pre-installed (Server, IoT, some stripped builds), this causes a hard crash when the DLL is loaded.",
          "proposals": [
            {
              "description": "Install the Visual C\u002B\u002B Redistributable on affected machines. This is the same workaround confirmed by @Inrego in both #3343 and #3136. Run: winget install Microsoft.VCRedist.2015\u002B.x64",
              "title": "Install VC\u002B\u002B Redistributable (workaround)",
              "codeSnippet": "winget install Microsoft.VCRedist.2015\u002B.x64",
              "confidence": 0.75,
              "effort": "trivial"
            },
            {
              "description": "Fix the WinUI native project to statically link the VC\u002B\u002B runtime (/MT instead of /MD). Maintainer acknowledged this as the proper fix in #3136.",
              "title": "Static link VC\u002B\u002B runtime in WinUI native build",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "If Telerik MAUI supports older SkiaSharp, pin to 2.88.9 which the reporter says worked. This avoids the WinUI native DLL entirely (different rendering path in 2.x).",
              "title": "Pin to SkiaSharp 2.88.x",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Install VC\u002B\u002B Redistributable (workaround)",
          "recommendedReason": "Confirmed to fix the crash by @Inrego. Immediate relief while waiting for the static linking fix."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.8,
          "reason": "The report has zero diagnostic information \u2014 no stack trace, no error message, no code. While it\u0027s likely the same issue as #3136 (confirmed by commenter), we can\u0027t be certain without a stack trace. The reporter should confirm the VCRedist workaround and provide crash details."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Fix platform label: MAUI on Windows uses WinUI, not Win32. Keep other labels.",
            "risk": "low",
            "confidence": 0.85,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Maui",
              "os/Windows-WinUI",
              "tenet/reliability"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #3136 \u2014 same root cause (WinUI native VC\u002B\u002B runtime dependency), confirmed by commenter",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3136
          },
          {
            "type": "add-comment",
            "description": "Acknowledge crash, link to #3136, provide VCRedist workaround, ask for stack trace to confirm",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for the report. This looks related to #3136, where the \u0060SkiaSharp.Views.WinUI.Native\u0060 DLL was built with a dynamic VC\u002B\u002B runtime dependency instead of static linking. On Windows editions that don\u0027t ship with the Visual C\u002B\u002B Redistributable pre-installed (Server, IoT), this causes a crash.\n\nAs a workaround while we work on a fix, you can install the VC\u002B\u002B Redistributable on affected machines:\n\n\u0060\u0060\u0060\nwinget install Microsoft.VCRedist.2015\u002B.x64\n\u0060\u0060\u0060\n\nTo help us confirm this is the same issue, would you be able to share the crash stack trace or exception details? That will let us verify whether your crash matches #3136 or is a different problem."
          }
        ],
        "missingInfo": [
          "Stack trace or crash dump from the crash",
          "Exact error message or exception type",
          "Whether installing VC\u002B\u002B Redistributable resolves the crash",
          "Whether the crash occurs on all mentioned Windows editions or specific ones"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3336,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:35:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE constant has wrong value (0x33AA instead of 0x33A9) in Egl.cs, making it identical to EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "backends": [
          "backend/OpenGL"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Open source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/Egl.cs",
            "Observe line 62: EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE = 0x33AA",
            "Observe line 63: EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE = 0x33AA",
            "Compare against ANGLE extension spec: FAST should be 0x33A9, COPY is 0x33AA"
          ],
          "environmentDetails": "SkiaSharp 3.x, WinUI, ANGLE D3D11 backend"
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "wrong-value",
          "errorMessage": "EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE = 0x33AA should be 0x33A9",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-windows10.0.19041.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.0.119",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The constants in Egl.cs are unchanged since the file was introduced. The wrong value persists on the main branch."
        }
      },
      "analysis": {
        "summary": "The EGL constant EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE is defined as 0x33AA in Egl.cs, but the official ANGLE extension spec defines it as 0x33A9. The COPY constant (0x33AA) is correct. Both constants currently share the same value, which means GlesContext.cs always requests the COPY present path instead of the intended FAST path. This affects ANGLE display initialization for all three fallback paths (D3D11, D3D11 FL9.3, and D3D WARP).",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/Egl.cs",
            "finding": "EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE (0x33AA) and EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE (0x33AA) share the same value. Per the official ANGLE extension, FAST should be 0x33A9 and COPY should be 0x33AA.",
            "relevance": "direct",
            "lines": "61-63"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/GlesContext.cs",
            "finding": "Three display attribute arrays (defaultDisplayAttributes, fl9_3DisplayAttributes, warpDisplayAttributes) all pass EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE to ANGLE. Due to the wrong constant value, all three request the COPY path instead of FAST.",
            "relevance": "direct",
            "lines": "160-198"
          }
        ],
        "rationale": "This is clearly a type/bug \u2014 a constant has a verifiably incorrect value compared to the official ANGLE extension specification. Area is area/SkiaSharp.Views because Egl.cs is part of the WinUI views GLES interop layer. Severity is medium: the code silently requests the COPY present path instead of the FAST path, which may degrade performance but doesn\u0027t cause crashes. The commenter molesmoke notes the fast path produces vertically flipped surfaces (non-conformant), so there may be behavioral implications beyond performance.",
        "keySignals": [
          {
            "text": "EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE = 0x33AA",
            "source": "Egl.cs:62",
            "interpretation": "Incorrect value \u2014 should be 0x33A9 per ANGLE spec. Currently identical to COPY constant on line 63."
          },
          {
            "text": "EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE = 0x33AA",
            "source": "Egl.cs:63",
            "interpretation": "Correct value. But having both constants equal means GlesContext always uses COPY path regardless of which constant is referenced."
          },
          {
            "text": "Egl.EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE, Egl.EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE",
            "source": "GlesContext.cs:168,184,195",
            "interpretation": "All three display attribute arrays (D3D11, FL9.3, WARP) use FAST_ANGLE, but actually get COPY behavior due to wrong constant."
          },
          {
            "text": "part of the perf improvement is that it\u0027s not conformant (the surfaces are vertically flipped)",
            "source": "comment #1 (molesmoke)",
            "interpretation": "FAST path is non-conformant with flipped surfaces. Enabling it correctly could be a breaking change for users creating surfaces from SKSwapChainPanel.GRContext."
          },
          {
            "text": "SKSwapChainPanel seems to still render the right way up for its paint event",
            "source": "comment #1 (molesmoke)",
            "interpretation": "SKSwapChainPanel itself handles orientation correctly, so the fallout from fixing the constant may be limited to direct GRContext users."
          }
        ],
        "nextQuestions": [
          "Should the fix change to the correct FAST value (0x33A9), or should the code explicitly use the COPY path? The commenter raises a valid concern about vertically flipped surfaces.",
          "Are there downstream users of SKSwapChainPanel.GRContext who create their own surfaces that would be affected by flipped surface origin?",
          "Should the fix include documentation about the surface origin change for direct GRContext users?"
        ],
        "resolution": {
          "hypothesis": "The FAST constant was mistyped when the EGL interop was first created. Fixing it to 0x33A9 would enable the actual fast present path, improving performance but introducing non-conformant (vertically flipped) surfaces.",
          "proposals": [
            {
              "description": "Change EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE from 0x33AA to 0x33A9. This enables the actual fast present path, which may improve ANGLE/D3D performance. However, surfaces will be vertically flipped (non-conformant), which could affect users who create surfaces from SKSwapChainPanel.GRContext directly.",
              "title": "Fix FAST constant to correct value",
              "codeSnippet": "public const int EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE = 0x33A9;",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "Change the GlesContext.cs usages to explicitly reference EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE instead of FAST. This preserves current behavior intentionally and fixes the misleading constant while avoiding any breaking change.",
              "title": "Switch to explicit COPY path",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Fix FAST constant to correct value",
          "recommendedReason": "The original code intended to use the fast path (comments say \u0027optimization that can have large performance benefits\u0027). Fixing the constant restores the intended behavior. The commenter confirms SKSwapChainPanel handles orientation correctly, limiting the breaking change surface."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "The constant is verifiably wrong and the fix is trivial, but the maintainer needs to decide between fixing the FAST value (potentially breaking change) or explicitly switching to COPY (preserving current behavior). The commenter specifically asked mattleibow for a decision."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views, WinUI, and OpenGL labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-WinUI",
              "backend/OpenGL"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report and summarize the two fix options",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for catching this \u2014 confirmed. Both \u0060EGL_EXPERIMENTAL_PRESENT_PATH_FAST_ANGLE\u0060 and \u0060EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE\u0060 are set to \u00600x33AA\u0060 in \u0060Egl.cs\u0060, but the ANGLE spec defines FAST as \u00600x33A9\u0060. All three display attribute arrays in \u0060GlesContext.cs\u0060 reference the FAST constant, so the code has always been using the COPY present path.\n\nTwo options:\n1. **Fix the constant to \u00600x33A9\u0060** \u2014 restores the intended fast present path (perf improvement), but surfaces become non-conformant (vertically flipped). As @molesmoke noted, \u0060SKSwapChainPanel\u0060 itself handles this correctly, but direct \u0060GRContext\u0060 users would need to set \u0060GRSurfaceOrigin.TopLeft\u0060.\n2. **Switch usages to \u0060EGL_EXPERIMENTAL_PRESENT_PATH_COPY_ANGLE\u0060** \u2014 preserves current behavior explicitly, no breaking change.\n\nLeaning toward option 1 since the original code comments describe it as an optimization, but this needs a decision on the breaking change."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3330,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:36:36Z",
        "currentLabels": [
          "community \u2728"
        ]
      },
      "summary": "Community PR from Progress (Telerik) to change the access modifier of WindowsExtensions.GetPixels(WriteableBitmap) from internal to public in SkiaSharp.Views.WinUI. The method returns an IntPtr to the WriteableBitmap\u0027s pixel buffer via WinRT BufferExtensions. The author needs this to build a custom SKXamlCanvas implementation. The change is a single-line visibility change with no behavioral modifications.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.92
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-WinUI"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "internal static IntPtr GetPixels(this WriteableBitmap bitmap) =\u003E public static IntPtr GetPixels(this WriteableBitmap bitmap)"
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The GetPixels method is still internal on main. The PR has not been merged."
        }
      },
      "analysis": {
        "summary": "This PR makes the internal GetPixels extension method on WriteableBitmap public in the WinUI views package. The method wraps WinRT BufferExtensions.GetByteBuffer to get a raw IntPtr to the WriteableBitmap\u0027s pixel buffer. This is used internally by SKXamlCanvas for rendering, and Progress wants it public to build their own custom canvas. The change is minimal (1 line) with no behavioral impact, but makes a raw-pointer API part of the public surface.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/UWPExtensions.cs",
            "finding": "GetPixels is an internal extension method on WriteableBitmap that returns IntPtr via bitmap.PixelBuffer.GetByteBuffer(). The PR changes only the access modifier from internal to public.",
            "relevance": "direct",
            "lines": "176-177"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/UWPExtensions.cs",
            "finding": "GetByteBuffer is a companion internal extension method on IBuffer that calls BufferExtensions.GetByteBuffer(buffer). This stays internal in the PR, which is correct \u2014 it\u0027s an implementation detail.",
            "relevance": "related",
            "lines": "179-180"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "finding": "SKXamlCanvas already calls bitmap.GetPixels() internally to render \u2014 this confirms the method works and is battle-tested for this purpose.",
            "relevance": "related",
            "lines": "240"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/UWPExtensions.cs",
            "finding": "Other WriteableBitmap extension methods (ToWriteableBitmap, ToSKBitmap, ToSKImage, ToSKPixmap) are already public. GetPixels is the only WriteableBitmap extension that remains internal.",
            "relevance": "context",
            "lines": "86-127"
          }
        ],
        "rationale": "Classified as enhancement because it improves the existing API by exposing internal functionality \u2014 no new code is added. Area is SkiaSharp.Views because the change is in the Views.WinUI project (UWPExtensions.cs). Platform is WinUI because WriteableBitmap and BufferExtensions are WinUI/UWP APIs. The companion internal method GetByteBuffer stays internal, which is appropriate since GetPixels is the meaningful public abstraction.",
        "keySignals": [
          {
            "text": "We would like to use the GetPixels() method in our custom SKXamlCanvas",
            "source": "PR body",
            "interpretation": "Progress needs pixel buffer access to build custom WinUI canvas \u2014 legitimate use case for a UI component vendor."
          },
          {
            "text": "@dotnet-policy-service agree company=\u0022Progress\u0022",
            "source": "comment by eli-popova",
            "interpretation": "CLA signed under Progress \u2014 this is a corporate contribution from Telerik/Progress."
          },
          {
            "text": "internal static IntPtr GetPixels(this WriteableBitmap bitmap)",
            "source": "code search",
            "interpretation": "Currently internal. The method is a thin wrapper around WinRT BufferExtensions \u2014 making it public has minimal risk but commits to the API surface."
          }
        ],
        "nextQuestions": [
          "Should GetPixels be documented with XML docs before making it public?",
          "Is a raw IntPtr return appropriate for the public API, or should a safer wrapper (e.g., Span\u003Cbyte\u003E) be provided?",
          "Are there other internal methods in WindowsExtensions that should be made public at the same time?"
        ],
        "resolution": {
          "hypothesis": "The GetPixels method was kept internal because it returns a raw IntPtr, but it\u0027s needed by downstream consumers building custom WinUI canvas controls. Making it public is low-risk since the method is already well-tested internally.",
          "proposals": [
            {
              "description": "Merge the 1-line visibility change. The method is already battle-tested internally in SKXamlCanvas and returns a straightforward IntPtr to the pixel buffer. All other WriteableBitmap extensions in the class are already public.",
              "title": "Accept as-is",
              "confidence": 0.75,
              "effort": "trivial"
            },
            {
              "description": "Accept the change but request XML documentation (triple-slash comments) on the newly public GetPixels method, describing what the returned IntPtr points to, its lifetime/validity, and that the caller must not use it after WriteableBitmap is invalidated or disposed.",
              "title": "Accept with XML documentation",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "Ask the author about their specific use case to determine if a higher-level API (e.g., a CreateSKSurface extension on WriteableBitmap) would serve them better than raw pixel access. This would provide a safer, more discoverable API surface.",
              "title": "Request broader API review",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Accept with XML documentation",
          "recommendedReason": "The change is minimal and well-motivated, but newly public APIs should have documentation. Requiring XML docs is low-friction and ensures consumers understand the IntPtr semantics."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Valid enhancement PR from a corporate contributor (Progress). Needs maintainer review for API surface commitment \u2014 making internal APIs public is a permanent decision. The change itself is trivial and low-risk."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply enhancement and views labels",
            "risk": "low",
            "confidence": 0.92,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "os/Windows-WinUI"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge PR, note API surface consideration, request documentation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the PR. Making \u0060GetPixels\u0060 public is reasonable \u2014 it\u0027s the only \u0060WriteableBitmap\u0060 extension in this class that\u0027s still internal, and the use case (custom canvas implementations) is legitimate.\n\nBefore merging, would you be able to add XML documentation to the method? Since it returns a raw \u0060IntPtr\u0060, it would help consumers to know what the pointer refers to and when it\u0027s valid. Something like:\n\n\u0060\u0060\u0060csharp\n/// \u003Csummary\u003E\n/// Gets a pointer to the pixel buffer of the \u003Csee cref=\u0022WriteableBitmap\u0022/\u003E.\n/// \u003C/summary\u003E\n/// \u003Cparam name=\u0022bitmap\u0022\u003EThe bitmap to get the pixels from.\u003C/param\u003E\n/// \u003Creturns\u003EA pointer to the pixel buffer.\u003C/returns\u003E\npublic static IntPtr GetPixels(this WriteableBitmap bitmap) =\u003E\n    bitmap.PixelBuffer.GetByteBuffer();\n\u0060\u0060\u0060\n\nAlso, the PR checklist mentions no tests \u2014 could you confirm whether the existing \u0060SKXamlCanvas\u0060 tests cover this code path, or if a new test is needed?"
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3329,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:40:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "Reporter asks why SkiaSharp NuGet doesn\u0027t auto-include Linux NativeAssets \u2014 this is by-design because Linux has no TFM and requires manual package selection between NativeAssets.Linux (fontconfig) and NoDependencies variants",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.88
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          "os/Linux"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET project targeting Linux",
            "Add SkiaSharp 3.119.0 NuGet reference",
            "Have a transitive dependency that pulls in an older SkiaSharp.NativeAssets.Linux (e.g. 2.88.7)",
            "Run on Linux in GitHub Actions CI",
            "Observe version mismatch: native library 88.1 vs expected [119.0, 120.0)"
          ],
          "environmentDetails": "Linux runner in GitHub Actions CI, SkiaSharp 3.119.0 (reported), transitive NativeAssets.Linux 2.88.7",
          "relatedIssues": [
            3117,
            3238
          ],
          "repoLinks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.0",
            "3.116.0",
            "2.88.7",
            "2.88.1",
            "2.88.9"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "Linux NativeAssets are still not auto-included in SkiaSharp 3.x \u2014 this is by design and documented. The reporter\u0027s confusion about why Linux is excluded persists across versions."
        }
      },
      "analysis": {
        "summary": "Reporter believes it\u0027s a bug that SkiaSharp.csproj doesn\u0027t include a ProjectReference to NativeAssets.Linux, but this is intentional. Unlike Android, iOS, macOS, and Windows, Linux has no platform-specific TFM (there is no \u0027net8.0-linux\u0027). Additionally, Linux requires users to choose between two mutually exclusive variants: NativeAssets.Linux (with fontconfig) and NativeAssets.Linux.NoDependencies (no external deps). The version mismatch error occurs because a transitive dependency pulls in an old NativeAssets.Linux version, and no explicit PackageReference pins it to the correct version.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaSharp.csproj",
            "finding": "NativeAssets ProjectReferences exist for Android (-android), iOS (-ios), MacCatalyst (-maccatalyst), macOS (-macos or non-platform), Tizen (-tizen), tvOS (-tvos), Win32 (-windows or non-platform). Linux is intentionally absent \u2014 no -linux TFM exists in .NET.",
            "relevance": "direct",
            "lines": "18-26"
          },
          {
            "file": "documentation/packages.md",
            "finding": "Documentation explicitly states NativeAssets.Linux, NativeAssets.Linux.NoDependencies, NativeAssets.WebAssembly, and NativeAssets.NanoServer must be added manually. This is documented behavior, not a bug.",
            "relevance": "direct",
            "lines": "115-121"
          },
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "AllTargetFrameworks = BasicTargetFrameworks \u002B PlatformTargetFrameworks. PlatformTargetFrameworks includes ios, maccatalyst, android, tizen, tvos, macos, windows \u2014 but NOT linux. .NET SDK does not define a linux platform TFM.",
            "relevance": "direct",
            "lines": "94-115"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.Linux/SkiaSharp.NativeAssets.Linux.csproj",
            "finding": "Uses BasicTargetFrameworks (not AllTargetFrameworks), targets netstandard2.0/2.1/net462/net8.0. Ships runtimes for linux-x64, linux-x86, linux-arm64, linux-arm, linux-riscv64, linux-loongarch64, plus musl variants. Requires fontconfig.",
            "relevance": "context"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.Linux.NoDependencies/SkiaSharp.NativeAssets.Linux.NoDependencies.csproj",
            "finding": "Same architecture matrix as NativeAssets.Linux but from linuxnodeps/alpinenodeps build output. No fontconfig dependency. Two competing packages for the same RIDs \u2014 user must choose one.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as question (not bug) because the behavior is by design and documented in documentation/packages.md. The SkiaSharp.csproj correctly omits Linux because (1) there\u0027s no -linux TFM to condition on, (2) Linux has two incompatible native variants requiring user selection, and (3) auto-including would force unnecessary binary downloads. The reporter\u0027s proposed fix (adding a ProjectReference with Condition=\u0022$(TargetFramework.Contains(\u0027-linux\u0027))\u0022) wouldn\u0027t work because .NET doesn\u0027t have a -linux TFM. The actual fix is adding an explicit PackageReference to the correct NativeAssets.Linux variant in the application project. Area is libSkiaSharp.native because this is about native asset packaging and deployment.",
        "keySignals": [
          {
            "text": "SkiaSharp.NativeAssets.Linux v2.88.7 is being included as a transient package rather than v3.119.0",
            "source": "issue body",
            "interpretation": "A transitive dependency (likely another library) is pulling in an old NativeAssets.Linux version. Without an explicit PackageReference at the app level, NuGet resolves to the transitive version."
          },
          {
            "text": "SkiaSharp references every other platform\u0027s native assets. So why does it not reference Linux?",
            "source": "comment 2 (OP)",
            "interpretation": "Valid observation, but the answer is: no -linux TFM exists, and Linux has two variants requiring user choice. macOS and Win32 are included for non-platform TFMs via !$(TargetFramework.Contains(\u0027-\u0027))."
          },
          {
            "text": "Linux having multiple distros, C libraries etc. and needing a mechanism with NuGet to support the different configurations",
            "source": "comment 3 (molesmoke)",
            "interpretation": "Community member correctly explains the design rationale \u2014 Linux\u0027s variant matrix (glibc vs musl, fontconfig vs no-deps) prevents automatic inclusion."
          },
          {
            "text": "Add this to SkiaSharp.csproj: \u003CProjectReference ... Condition=\u0022$(TargetFramework.Contains(\u0027-linux\u0027))\u0022 /\u003E",
            "source": "issue body",
            "interpretation": "Proposed fix won\u0027t work \u2014 .NET has no -linux TFM. The condition would never match."
          }
        ],
        "workarounds": [
          "Add an explicit PackageReference to SkiaSharp.NativeAssets.Linux (or NoDependencies) matching your SkiaSharp version in the application project",
          "If a transitive dependency pulls in an old version, the explicit PackageReference at the app level will override it via NuGet\u0027s nearest-wins resolution"
        ],
        "nextQuestions": [
          "Which transitive dependency is pulling in SkiaSharp.NativeAssets.Linux 2.88.7? A binlog would confirm.",
          "Is the reporter using NativeAssets.Linux or NativeAssets.Linux.NoDependencies? The choice affects fontconfig requirements."
        ],
        "resolution": {
          "hypothesis": "A transitive NuGet dependency brings in an old NativeAssets.Linux version. The fix is adding an explicit PackageReference to the matching version in the application project. Linux not being auto-included is by design.",
          "proposals": [
            {
              "description": "Add a direct PackageReference to SkiaSharp.NativeAssets.Linux (or NoDependencies) at the same version as SkiaSharp in the application project. This overrides the transitive old version via NuGet\u0027s nearest-wins resolution.",
              "title": "Add explicit NativeAssets.Linux PackageReference",
              "codeSnippet": "\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux\u0022 Version=\u00223.119.0\u0022 /\u003E",
              "confidence": 0.92,
              "effort": "trivial"
            },
            {
              "description": "If running in GitHub Actions or containers without fontconfig, use NativeAssets.Linux.NoDependencies instead. This has zero third-party dependencies.",
              "title": "Use NoDependencies variant for CI/containers",
              "codeSnippet": "\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022 Version=\u00223.119.0\u0022 /\u003E",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "Run \u0027dotnet build --binary-logger\u0027 and inspect the binlog with MSBuild Structured Log Viewer to find which package transitively references the old NativeAssets.Linux 2.88.7. Then either update that package or pin the version.",
              "title": "Identify the transitive dependency source",
              "confidence": 0.9,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Add explicit NativeAssets.Linux PackageReference",
          "recommendedReason": "Simplest fix \u2014 one line in the csproj. Directly resolves the version mismatch by overriding the transitive dependency."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.82,
          "reason": "By-design behavior documented in packages.md. The workaround (explicit PackageReference) is well-established and resolves the issue. Multiple community members in #3117 confirmed this approach works."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Relabel as question about Linux native asset packaging",
            "risk": "low",
            "confidence": 0.88,
            "labels": [
              "type/question",
              "area/libSkiaSharp.native",
              "os/Linux"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain by-design behavior and provide workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for raising this \u2014 it\u0027s a common source of confusion.\n\nLinux NativeAssets are intentionally not auto-included by the SkiaSharp package. Unlike iOS, Android, macOS, and Windows, .NET doesn\u0027t have a \u0060-linux\u0060 TFM, so there\u0027s no condition to match on. Additionally, Linux has two mutually exclusive variants \u2014 \u0060NativeAssets.Linux\u0060 (requires fontconfig for system font enumeration) and \u0060NativeAssets.Linux.NoDependencies\u0060 (zero external dependencies, for containers) \u2014 so the user needs to choose which one fits their deployment.\n\nThe version mismatch you\u0027re seeing (native 88.1 vs expected 119.0) is because a transitive dependency is pulling in an old \u0060NativeAssets.Linux\u0060. Here\u0027s the fix \u2014 add an explicit reference in your **application** project:\n\n\u0060\u0060\u0060xml\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux\u0022 Version=\u00223.119.0\u0022 /\u003E\n\u0060\u0060\u0060\n\nOr if you\u0027re in a minimal container / CI without fontconfig:\n\n\u0060\u0060\u0060xml\n\u003CPackageReference Include=\u0022SkiaSharp.NativeAssets.Linux.NoDependencies\u0022 Version=\u00223.119.0\u0022 /\u003E\n\u0060\u0060\u0060\n\nThis overrides the transitive version via NuGet\u0027s nearest-wins resolution. To identify which package is pulling in the old version, you can run \u0060dotnet build --binary-logger\u0060 and inspect the binlog.\n\nThis is documented in the [NuGet packages documentation](https://github.com/mono/SkiaSharp/blob/main/documentation/packages.md#auto-included-nativeassets) under \u0022Must be added manually.\u0022"
          },
          {
            "type": "link-related",
            "description": "Cross-reference #3117 (same version mismatch pattern on Linux)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3117
          },
          {
            "type": "close-issue",
            "description": "Close as answered \u2014 by-design behavior with documented workaround",
            "risk": "medium",
            "confidence": 0.78
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3328,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:37:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SKFont.GetTextPath returns an empty path (zero bounds) for emoji characters because upstream Skia\u0027s SkTextUtils::GetPath silently skips glyphs that lack vector outlines (color emoji use COLR/CBDT/sbix bitmap formats instead).",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create SKTypeface for \u0027Segoe UI Emoji\u0027 via SKTypeface.FromFamilyName",
            "Create SKFont with that typeface at size 48",
            "Call font.GetTextPath(\u0022\uD83D\uDE0A\u0022, new SKPoint(0, 0))",
            "Inspect path.Bounds \u2014 Width and Height are both 0"
          ],
          "environmentDetails": "SkiaSharp 3.119.0, Windows 11, Visual Studio",
          "relatedIssues": [
            3244,
            1275,
            3484
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "wrong-output",
          "errorMessage": "SKFont.GetTextPath returns empty path (0 width and 0 height bounds) for emoji characters",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.119.0",
          "currentRelevance": "likely",
          "relevanceReason": "The upstream SkTextUtils::GetPath code on main still uses the same callback pattern that skips nullptr paths \u2014 the issue is unfixed."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.65,
          "reason": "Reporter states 2.88.9 worked, but color emoji glyphs have never had vector outlines in Skia. The older Skia version bundled with 2.88.x may have had different getPaths fallback behavior or the font resolved differently. The behavior change is more likely a side effect of the Skia engine upgrade than a SkiaSharp code regression."
        }
      },
      "analysis": {
        "summary": "GetTextPath delegates to SkTextUtils::GetPath which calls SkFont::getPaths(). The callback (SkTextUtils.cpp:50-58) checks \u0060if (src)\u0060 and skips glyphs where src is nullptr. Color emoji fonts (Segoe UI Emoji, Noto Color Emoji) store glyphs as bitmaps/COLR data without vector outlines, so getPaths returns nullptr for these glyphs, resulting in an empty path.",
        "codeInvestigation": [
          {
            "file": "externals/skia/src/utils/SkTextUtils.cpp",
            "finding": "GetPath() calls font.getPaths() with a callback that checks \u0060if (src)\u0060 \u2014 nullptr paths (color emoji) are silently skipped, producing an empty result path.",
            "relevance": "direct",
            "lines": "38-59"
          },
          {
            "file": "externals/skia/src/c/sk_font.cpp",
            "finding": "C API shim sk_text_utils_get_path() is a thin wrapper calling SkTextUtils::GetPath \u2014 no additional logic or fallback for missing paths.",
            "relevance": "direct",
            "lines": "191-193"
          },
          {
            "file": "binding/SkiaSharp/SKFont.cs",
            "finding": "C# GetTextPath creates a new SKPath and passes it to sk_text_utils_get_path. Returns the path regardless of content \u2014 no empty-check or warning.",
            "relevance": "context",
            "lines": "748-756"
          },
          {
            "file": "binding/SkiaSharp/SKFont.cs",
            "finding": "MeasureText with out SKRect bounds parameter provides glyph bounds including for color emoji \u2014 viable workaround for measurement/layout.",
            "relevance": "related",
            "lines": "269-310"
          }
        ],
        "rationale": "This is a real behavioral defect \u2014 GetTextPath returns an empty path for valid, renderable glyphs. Classified as type/bug because the API silently fails rather than returning useful data. Area is area/SkiaSharp (core font API, not views). Severity is medium: the workaround (use DrawText or MeasureText for bounds) exists, but the behavior is surprising and breaks text-to-path workflows that include emoji. Not classified as regression because the underlying Skia limitation has always existed for color emoji \u2014 the 2.88.x behavior was likely coincidental.",
        "keySignals": [
          {
            "text": "path.Bounds.ToString() shows 0 width and 0 height",
            "source": "issue body",
            "interpretation": "GetTextPath returns a valid but empty SKPath object \u2014 the emoji glyph is silently dropped."
          },
          {
            "text": "Last Known Good Version: 2.88.9",
            "source": "issue body",
            "interpretation": "Reporter claims regression from 2.88.x. However, color emoji lack vector outlines in all Skia versions \u2014 the old version may have resolved to a different font or had different getPaths fallback."
          },
          {
            "text": "if (src) { ... rec-\u003EfDst-\u003EaddPath(*src, m); }",
            "source": "SkTextUtils.cpp:52-56",
            "interpretation": "Root cause: Skia only adds glyph path when src is non-null. Color emoji glyphs return nullptr from getPaths, so they are silently skipped."
          },
          {
            "text": "PR #3484 attempts to fix by adding bounding-box rectangles as fallback",
            "source": "PR #3484 body",
            "interpretation": "A fix has been proposed (adding rect fallback in SkTextUtils.cpp) but not merged. The approach modifies upstream Skia code rather than the C API shim."
          }
        ],
        "workarounds": [
          "Use SKCanvas.DrawText or DrawShapedText to render emoji directly to a surface instead of converting to a path first.",
          "Use SKFont.MeasureText(text, out SKRect bounds) to get accurate bounds for emoji text (works for layout/hit-testing).",
          "Use SKFont.GetGlyphWidths(text, out SKRect[] bounds) to get per-glyph bounding rectangles for measurement."
        ],
        "nextQuestions": [
          "Exactly what behavior did 2.88.9 produce? Did it actually return vector outline paths for emoji, or did the user\u0027s workflow happen to not hit this code path?",
          "Should GetTextPath return bounding-box rectangles for non-outline glyphs (as PR #3484 proposes), or should it remain outline-only with better documentation?",
          "Does this affect all color emoji fonts or only specific formats (COLR vs CBDT vs sbix)?"
        ],
        "resolution": {
          "hypothesis": "Color emoji glyphs use bitmap/COLR formats without vector outlines. Skia\u0027s SkFont::getPaths() returns nullptr for these, and SkTextUtils::GetPath silently skips them. The fix requires either modifying the path retrieval to provide a fallback (e.g., bounding box rectangles) or documenting the limitation.",
          "proposals": [
            {
              "description": "Instead of converting emoji to paths, render them directly to an SKCanvas using DrawText or DrawShapedText. These methods handle color emoji correctly via Skia\u0027s text rendering pipeline. For layout, use MeasureText with bounds.",
              "title": "Use DrawText for emoji rendering (workaround)",
              "codeSnippet": "// Instead of GetTextPath, render emoji directly:\nusing var surface = SKSurface.Create(new SKImageInfo(200, 100));\nvar typeface = SKTypeface.FromFamilyName(\u0022Segoe UI Emoji\u0022);\nif (typeface == null)\n    typeface = SKTypeface.Default; // fallback if font not found\nusing var font = new SKFont(typeface, 48);\nusing var paint = new SKPaint { Color = SKColors.Black };\nsurface.Canvas.DrawText(\u0022\uD83D\uDE0A\u0022, 10, 60, SKTextAlign.Left, font, paint);\n\n// For bounds/measurement:\nfloat width = font.MeasureText(\u0022\uD83D\uDE0A\u0022, out SKRect bounds);",
              "confidence": 0.85,
              "effort": "trivial"
            },
            {
              "description": "In sk_font.cpp, wrap the SkTextUtils::GetPath call with pre-computed glyph bounds via SkFont::getBounds(). When getPaths returns nullptr for a glyph, add the bounds rectangle to the path instead. This keeps the fix in the SkiaSharp shim layer (not upstream Skia), reducing merge-conflict risk compared to PR #3484\u0027s approach.",
              "title": "Add bounding-box fallback in C API shim",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "PR #3484 modifies upstream SkTextUtils.cpp to add bounds-rectangle fallback. The approach works but modifies upstream Skia code, creating merge-conflict risk. If accepted, it should be cleaned up (remove FIX_SUMMARY.md, TESTING_NOTES.md) and the fix should be moved to the C API shim layer instead.",
              "title": "Accept PR #3484 with modifications",
              "confidence": 0.6,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Use DrawText for emoji rendering (workaround)",
          "recommendedReason": "Provides an immediate solution the reporter can use today. Color emoji are inherently bitmap-based and don\u0027t have vector outlines \u2014 DrawText is the correct API for rendering them. The path-based fix proposals change GetTextPath\u0027s semantic contract and need design discussion."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.8,
          "reason": "Real bug with complete repro. The root cause is understood (Skia getPaths returns nullptr for color emoji), but the fix approach needs design discussion: should GetTextPath return bounding-box rectangles or remain outline-only?"
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm type/bug, add area and platform labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain root cause and provide DrawText workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the clear repro.\n\nThis happens because color emoji fonts (Segoe UI Emoji, Noto Color Emoji, etc.) store their glyphs as bitmaps or COLR/CPAL data rather than vector outlines. Skia\u0027s underlying \u0060getPaths()\u0060 returns null for these glyphs, so \u0060GetTextPath\u0060 produces an empty path.\n\nHere\u0027s a workaround \u2014 render emoji directly to a canvas instead of converting to a path:\n\n\u0060\u0060\u0060csharp\n// Render emoji directly (handles color emoji correctly)\nvar typeface = SKTypeface.FromFamilyName(\u0022Segoe UI Emoji\u0022);\nif (typeface == null)\n    typeface = SKTypeface.Default; // fallback if font not found\nusing var font = new SKFont(typeface, 48);\nusing var paint = new SKPaint { Color = SKColors.Black };\ncanvas.DrawText(\u0022\uD83D\uDE0A\u0022, 10, 60, SKTextAlign.Left, font, paint);\n\n// For measurement/layout:\nfloat width = font.MeasureText(\u0022\uD83D\uDE0A\u0022, out SKRect bounds);\n\u0060\u0060\u0060\n\n\u0060DrawText\u0060 and \u0060DrawShapedText\u0060 go through Skia\u0027s full text rendering pipeline which handles color emoji correctly. \u0060MeasureText\u0060 returns accurate bounds for layout and hit-testing.\n\nNote: \u0060FromFamilyName\u0060 can return null if the font isn\u0027t installed, so a null check is good practice.\n\nWe\u0027re aware of PR #3484 which proposes adding bounding-box fallback rectangles for non-outline glyphs \u2014 we\u0027ll evaluate the best approach for a proper fix."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related emoji rendering issue",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 3244
          },
          {
            "type": "link-related",
            "description": "Cross-reference existing fix PR",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 3484
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3327,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-13T00:36:37Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SkiaSharp.Views.WinUI.Native.Projection produces IL2026/IL2104 trim warnings due to outdated CsWinRT 2.0.4 dependency, breaking NativeAOT/trimmed WinUI apps",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.9
        },
        "platforms": [
          "os/Windows-WinUI"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a WinUI3 app referencing SkiaSharp.Views.WinUI 3.119.0",
            "Set PublishAot=true in the project file",
            "Build in Release mode",
            "Observe IL2104 warning from SkiaSharp.Views.WinUI.Native.Projection.dll",
            "Optionally set TrimmerSingleWarn=false for detailed IL2026 breakdown"
          ],
          "environmentDetails": "WinUI 3, SkiaSharp 3.119.0, PublishAot=true, Visual Studio (Windows)",
          "relatedIssues": [
            3042,
            3238,
            3433
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "build-warning",
          "errorMessage": "Assembly \u0027SkiaSharp.Views.WinUI.Native.Projection\u0027 produced trim warnings (IL2104); IL2026: WinRT.WinrtModule.GetActivationFactory using RequiresUnreferencedCode member",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-windows10.0.19041.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.119.0"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "CsWinRT is still at 2.0.4 on main branch. No changes have been merged to update it."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.85,
          "reason": "PR #3433 proposes updating CsWinRT from 2.0.4 to 2.2.0 which would resolve the trim warnings, but it is still open and not merged. The fix is straightforward but has an open concern about CsWinRTWindowsMetadata side effects.",
          "relatedPRs": [
            3433
          ]
        }
      },
      "analysis": {
        "summary": "The WinUI native projection assembly uses CsWinRT 2.0.4, which contains non-trimming-safe code paths (WinRT.WinrtModule.GetActivationFactory and WinRT.DllModule.GetActivationFactory call RequiresUnreferencedCode members). Updating CsWinRT to \u22652.1.x resolves these warnings. A community PR (#3433) exists to bump to 2.2.0 but is pending review.",
        "codeInvestigation": [
          {
            "file": "native/winui/SkiaSharp.Views.WinUI.Native/SkiaSharp.Views.WinUI.Native.Projection/SkiaSharp.Views.WinUI.Native.Projection.csproj",
            "finding": "PackageReference to Microsoft.Windows.CsWinRT is pinned at Version=\u00222.0.4\u0022. This is the direct cause of the trim warnings.",
            "relevance": "direct",
            "lines": "19"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SkiaSharp.Views.WinUI.csproj",
            "finding": "The main WinUI views project also sets CsWinRTIncludes=SkiaSharp.Views.WinUI.Native and references CsWinRT 2.0.4. Both projects need the version bump.",
            "relevance": "direct",
            "lines": "15-19"
          },
          {
            "file": "binding/SkiaSharp/Properties/SkiaSharpAssemblyInfo.cs",
            "finding": "Core SkiaSharp assembly already declares IsTrimmable=True, confirming trimming support is intended for the overall library. The WinUI projection is the outlier.",
            "relevance": "context",
            "lines": "55"
          }
        ],
        "rationale": "This is clearly a bug (not a question or feature request): the reporter describes build warnings that indicate SkiaSharp is not safe for trimming/AOT scenarios, and reports crash telemetry that may be related. The root cause is a pinned dependency version (CsWinRT 2.0.4) in the WinUI native projection project. The area is SkiaSharp.Views because the warnings come from the WinUI view layer\u0027s projection assembly, not core SkiaSharp. Severity is medium: the warnings don\u0027t always cause runtime failures, but the reporter sees production crashes that may be attributable to trimming unsafety.",
        "keySignals": [
          {
            "text": "Assembly \u0027SkiaSharp.Views.WinUI.Native.Projection\u0027 produced trim warnings",
            "source": "issue body",
            "interpretation": "The Projection assembly \u2014 generated by CsWinRT \u2014 contains non-trim-safe code. This is a CsWinRT version problem, not a SkiaSharp code problem."
          },
          {
            "text": "IL2026: WinRT.WinrtModule.GetActivationFactory ... RequiresUnreferencedCodeAttribute",
            "source": "issue body (TrimmerSingleWarn=false output)",
            "interpretation": "CsWinRT 2.0.4 uses reflection-based activation that the trimmer cannot prove safe. Newer CsWinRT versions have source generators that eliminate this."
          },
          {
            "text": "This is because SkiaSharp is relying on an outdated version of CsWinRT (specifically, 2.0.4)",
            "source": "comment by dongle-the-gadget",
            "interpretation": "Community confirms root cause. CsWinRT 2.1\u002B added trim/AOT safety."
          },
          {
            "text": "I am seeing a lot of crash reports that might be related to these warnings",
            "source": "issue body",
            "interpretation": "Reporter sees production crashes \u2014 trimming may actually be removing code needed at runtime, not just producing warnings."
          }
        ],
        "workarounds": [
          "No user-side workaround exists because the trim warnings originate from the pre-built SkiaSharp.Views.WinUI.Native.Projection.dll shipped in the NuGet package. Users cannot override the CsWinRT version used to generate that assembly."
        ],
        "nextQuestions": [
          "Does updating CsWinRT to 2.2.0 require CsWinRTWindowsMetadata pinning to avoid the IBufferMethods.IID build error (microsoft/CsWinRT#2214)?",
          "Are the production crashes the reporter mentions actually caused by the trim warnings, or unrelated?",
          "Should the SkiaSharp.Views.WinUI csproj also be updated in the same change?"
        ],
        "resolution": {
          "hypothesis": "CsWinRT 2.0.4 generates WinRT interop code that uses reflection-based activation (RequiresUnreferencedCode). Updating to CsWinRT \u22652.1.x, which uses source generators for trim-safe interop, eliminates the warnings.",
          "proposals": [
            {
              "description": "Community PR #3433 by @wangfys updates CsWinRT from 2.0.4 to 2.2.0 in the Projection csproj and adds CsWinRTWindowsMetadata=10.0.17763.57 to work around a CsWinRT 2.2.0 code-gen issue. This is the correct fix.",
              "title": "Merge PR #3433 (update CsWinRT to 2.2.0)",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "As a stopgap, users could add \u003CNoWarn\u003EIL2026;IL2104\u003C/NoWarn\u003E to suppress the warnings. This hides the symptom but does not fix potential runtime failures from trimmed code.",
              "title": "Suppress warnings with NoWarn",
              "confidence": 0.6,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Merge PR #3433 (update CsWinRT to 2.2.0)",
          "recommendedReason": "Directly addresses the root cause. The PR already exists, has been confirmed as the right approach by a community member, and the CsWinRT maintainers have documented the metadata workaround."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.8,
          "reason": "A community PR (#3433) exists but needs review and CI verification. The CsWinRTWindowsMetadata workaround needs validation for side effects on end-user packages."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views, WinUI, compatibility labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-WinUI",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference PR #3433 which directly addresses this issue",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 3433
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the report, confirm root cause, point to PR #3433",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed warning breakdown. The root cause is confirmed: the WinUI native projection assembly is built with CsWinRT 2.0.4, which predates trimming/AOT safety improvements added in CsWinRT 2.1\u002B.\n\nThere\u0027s no user-side workaround for this since the warnings come from a pre-built assembly in the NuGet package. Suppressing with \u0060\u003CNoWarn\u003EIL2026;IL2104\u003C/NoWarn\u003E\u0060 hides the warnings but doesn\u0027t eliminate the underlying risk for trimmed/AOT apps.\n\nPR #3433 updates CsWinRT to 2.2.0, which should resolve this. We\u0027ll review and validate that PR."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3279,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:53:59Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "User upgraded from SkiaSharp 2.88.9 to 3.119.0 and is getting compiler errors (CS0117, CS1501) because several SKMatrix static methods (MakeIdentity, MakeTranslation, MakeScale, MakeRotation, PostConcat with ref) were marked [Obsolete] in v2.80 and fully removed in v3.0.0. They were replaced by Create* methods and an instance PostConcat. This is a migration question, not a bug.",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/WASM"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "SKMatrix.PostConcat(ref Matrix, matrix44.Matrix);",
            "SKMatrix.PostConcat(ref Matrix, SKMatrix.MakeTranslation(GuaSkiaGfx.DisplaySize.Width / 2.0f, GuaSkiaGfx.DisplaySize.Height / 2.0f));",
            "SKMatrix.PostConcat(ref Matrix, SKMatrix.MakeScale(GfxScale, GfxScale, Center.X, Center.Y));",
            "SKMatrix.PostConcat(ref Matrix, SKMatrix.MakeRotation((float)zAngle, Center.X, Center.Y));",
            "Matrix = SKMatrix.MakeIdentity();"
          ],
          "environmentDetails": "WASM/Blazor, Windows 11, Visual Studio, Dell laptop"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.9",
            "3.119.0",
            "3.118.0-preview.2"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.0.0",
          "currentRelevance": "likely",
          "relevanceReason": "The Make* methods were removed in v3.0.0 and the Create* replacements are the current API. The user needs to migrate their code."
        }
      },
      "analysis": {
        "summary": "The user is hitting compiler errors after upgrading from SkiaSharp 2.88.x to 3.x. The SKMatrix API was refactored: Make* static factory methods were renamed to Create*, and PostConcat/PreConcat changed from static ref-parameter methods to instance methods returning a new SKMatrix. These were obsoleted in v2.80 and removed in v3.0.0. The maintainer has already responded confirming this and pointing to updated docs.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKMatrix.cs",
            "finding": "Current API has CreateIdentity(), CreateTranslation(), CreateScale(), CreateRotation(), CreateRotationDegrees() \u2014 all direct replacements for the removed Make* methods with identical parameters.",
            "relevance": "direct",
            "lines": "119-205"
          },
          {
            "file": "binding/SkiaSharp/SKMatrix.cs",
            "finding": "PostConcat is now an instance method \u0027public readonly SKMatrix PostConcat(SKMatrix matrix)\u0027 returning a new matrix. PreConcat follows the same pattern. The old static \u0027PostConcat(ref target, matrix)\u0027 was removed.",
            "relevance": "direct",
            "lines": "276-295"
          },
          {
            "file": "changelogs/SkiaSharp/3.0.0/SkiaSharp.breaking.md",
            "finding": "All Make* methods and static PostConcat/PreConcat overloads are listed under \u0027Removed methods\u0027 with [Obsolete] annotations \u2014 confirming this was an intentional, documented breaking change in v3.0.0.",
            "relevance": "direct",
            "lines": "456-495"
          }
        ],
        "rationale": "Classified as type/question (not bug) because the APIs were intentionally removed as a breaking change documented in changelogs/SkiaSharp/3.0.0/SkiaSharp.breaking.md. The user is asking how to migrate, not reporting broken behavior. The area is core SkiaSharp (SKMatrix). The community member and maintainer both confirmed this is an API migration issue.",
        "keySignals": [
          {
            "text": "CS0117: \u0027SKMatrix\u0027 does not contain a definition for \u0027MakeTranslation\u0027",
            "source": "issue body",
            "interpretation": "Compiler error confirms the Make* methods no longer exist in v3 \u2014 expected behavior after intentional API removal."
          },
          {
            "text": "CS1501: No overload for method \u0027PostConcat\u0027 takes 2 arguments",
            "source": "issue body",
            "interpretation": "PostConcat changed from static 2-arg (ref target, matrix) to instance 1-arg method. Not a missing method \u2014 signature changed."
          },
          {
            "text": "This isn\u0027t a bug. The API has changed - you need to update your code.",
            "source": "comment #1 (molesmoke)",
            "interpretation": "Community member correctly identified this as an intentional API change, not a defect."
          },
          {
            "text": "Some of those apis were obsolete and were replaced.",
            "source": "comment #5 (mattleibow, maintainer)",
            "interpretation": "Maintainer confirmed the APIs were deliberately obsoleted and replaced. Updated API docs are now available."
          }
        ],
        "workarounds": [
          "Replace SKMatrix.MakeIdentity() with SKMatrix.CreateIdentity()",
          "Replace SKMatrix.MakeTranslation(x, y) with SKMatrix.CreateTranslation(x, y)",
          "Replace SKMatrix.MakeScale(sx, sy, px, py) with SKMatrix.CreateScale(sx, sy, px, py)",
          "Replace SKMatrix.MakeRotation(radians, px, py) with SKMatrix.CreateRotation(radians, px, py)",
          "Replace SKMatrix.PostConcat(ref matrix, other) with matrix = matrix.PostConcat(other)"
        ],
        "resolution": {
          "hypothesis": "The user needs to rename Make* to Create* and change PostConcat from a static ref call to an instance method call. This is a straightforward find-and-replace migration.",
          "proposals": [
            {
              "description": "Replace all Make* calls with Create* equivalents and change PostConcat from static to instance method. The parameter lists are identical \u2014 only the method names changed.",
              "title": "Rename Make* to Create* and update PostConcat usage",
              "codeSnippet": "// Old v2.88 \u2192 New v3.x\n\n// 1. MakeIdentity \u2192 CreateIdentity\nMatrix = SKMatrix.CreateIdentity();\n\n// 2. MakeTranslation \u2192 CreateTranslation\nvar translation = SKMatrix.CreateTranslation(\n    GuaSkiaGfx.DisplaySize.Width / 2.0f,\n    GuaSkiaGfx.DisplaySize.Height / 2.0f);\n\n// 3. MakeScale \u2192 CreateScale\nvar scale = SKMatrix.CreateScale(GfxScale, GfxScale, Center.X, Center.Y);\n\n// 4. MakeRotation \u2192 CreateRotation\nvar rotation = SKMatrix.CreateRotation((float)zAngle, Center.X, Center.Y);\n\n// 5. PostConcat: static ref \u2192 instance method\nMatrix = Matrix.PostConcat(translation);\nMatrix = Matrix.PostConcat(scale);\nMatrix = Matrix.PostConcat(rotation);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "The .NET API browser at https://learn.microsoft.com/en-us/dotnet/api/skiasharp.skmatrix now documents the current v3.x API surface. Any remaining Make* calls can be found via IntelliSense which will suggest the Create* replacements.",
              "title": "Use API docs browser for complete migration reference",
              "confidence": 0.9,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Rename Make* to Create* and update PostConcat usage",
          "recommendedReason": "Direct find-and-replace with exact code examples matching the reporter\u0027s original code. No ambiguity."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.95,
          "reason": "The maintainer already responded confirming this is an intentional API rename. The migration is a trivial find-and-replace. Updated docs are available."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Change type from bug to question, add WASM and compatibility labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/question",
              "area/SkiaSharp",
              "os/WASM",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post migration guide with code examples for each renamed method",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for reporting this. These APIs were renamed in SkiaSharp 3.0 \u2014 the \u0060Make*\u0060 static methods became \u0060Create*\u0060, and \u0060PostConcat\u0060 changed from a static method to an instance method.\n\nHere\u0027s the mapping for your code:\n\n\u0060\u0060\u0060csharp\n// 1. MakeIdentity \u2192 CreateIdentity\nMatrix = SKMatrix.CreateIdentity();\n\n// 2. MakeTranslation \u2192 CreateTranslation\nvar translation = SKMatrix.CreateTranslation(\n    GuaSkiaGfx.DisplaySize.Width / 2.0f,\n    GuaSkiaGfx.DisplaySize.Height / 2.0f);\n\n// 3. MakeScale \u2192 CreateScale\nvar scale = SKMatrix.CreateScale(GfxScale, GfxScale, Center.X, Center.Y);\n\n// 4. MakeRotation \u2192 CreateRotation\nvar rotation = SKMatrix.CreateRotation((float)zAngle, Center.X, Center.Y);\n\n// 5. PostConcat: now an instance method\nMatrix = Matrix.PostConcat(translation);\n\u0060\u0060\u0060\n\nThe parameters are identical \u2014 only the method names changed. The [API docs](https://learn.microsoft.com/en-us/dotnet/api/skiasharp.skmatrix) have been updated to reflect the current API."
          },
          {
            "type": "close-issue",
            "description": "Close as answered \u2014 maintainer already confirmed and docs are updated",
            "risk": "medium",
            "confidence": 0.9
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3188,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:05:45Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "DrawVertices outputs black triangle instead of colored gradient in v3 due to upstream Skia behavior change \u2014 default paint color (black) is now modulated with vertex colors",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an SKSurface with RGBA8888 color type",
            "Clear the canvas to white",
            "Create an SKPaint with IsAntialias = true (default color is black)",
            "Call DrawVertices with SKVertexMode.Triangles, 3 vertices, and RGB colors (Red, Green, Blue)",
            "Snapshot and encode to PNG",
            "Observe output is a solid black triangle instead of a gradient"
          ],
          "codeSnippets": [
            "surface.Canvas.DrawVertices(SKVertexMode.Triangles, vertices, colors, paint);"
          ],
          "screenshots": [
            {
              "url": "https://github.com/user-attachments/assets/afa656d4-1966-496c-be0f-50d3d325f554",
              "description": "Expected: gradient triangle (v2.88.9)"
            },
            {
              "url": "https://github.com/user-attachments/assets/5a9f1421-92d4-49f6-8f65-e7fb990cb82f",
              "description": "Actual: black triangle (v3.116.1)"
            }
          ],
          "environmentDetails": "Windows 11, .NET 8, Visual Studio, SkiaSharp 3.116.1",
          "relatedIssues": [
            3319
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "wrong-output",
          "errorMessage": "DrawVertices produces a solid black triangle instead of a gradient triangle with vertex colors",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.1",
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "3.116.0",
          "currentRelevance": "likely",
          "relevanceReason": "The DrawVertices overloads still hardcode SKBlendMode.Modulate, and Skia\u0027s behavior for drawVertices with opaque paint color has not changed back."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Upstream Skia changed how drawVertices interacts with the paint color. In newer Skia (used by SkiaSharp v3), drawVertices blends the paint\u0027s opaque color (src) with vertex colors (dst) using the blend mode. Since SkPaint defaults to opaque black and the blend mode is Modulate (src \u00D7 dst), black \u00D7 anything = black. Older Skia (used by v2.88) handled vertex colors differently.",
          "workedInVersion": "2.88.9",
          "brokeInVersion": "3.116.0"
        }
      },
      "analysis": {
        "summary": "DrawVertices produces black output in SkiaSharp v3 because all convenience overloads hardcode SKBlendMode.Modulate, and Skia now modulates the paint\u0027s opaque color (default = black) with vertex colors. Black \u00D7 any color = black.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCanvas.cs",
            "finding": "All 3 convenience DrawVertices overloads hardcode SKBlendMode.Modulate. The 4th overload (line 930) accepts a blend mode parameter. The core method (line 936) passes vertices, mode, and paint directly to the C API.",
            "relevance": "direct",
            "lines": "912-942"
          },
          {
            "file": "externals/skia/src/core/SkPaint.cpp",
            "finding": "SkPaint default constructor initializes fColor4f to {0,0,0,1} (opaque black). This is the src color for Modulate blending in drawVertices.",
            "relevance": "direct",
            "lines": "38-39"
          },
          {
            "file": "externals/skia/include/core/SkCanvas.h",
            "finding": "Skia docs specify: drawVertices combines \u0027the opaque SkPaint color\u0027 (when no shader) as src with \u0027interpolated vertex colors\u0027 as dst using the blend mode. Modulate = src \u00D7 dst.",
            "relevance": "direct",
            "lines": "1938-1955"
          },
          {
            "file": "externals/skia/src/c/sk_canvas.cpp",
            "finding": "C API passes through to Skia\u0027s drawVertices without modification: AsCanvas(ccanvas)-\u003EdrawVertices(AsVertices(vertices), (SkBlendMode)mode, *AsPaint(paint))",
            "relevance": "context",
            "lines": "244-246"
          },
          {
            "file": "binding/SkiaSharp/SKVertices.cs",
            "finding": "SKVertices.CreateCopy correctly passes vertex colors to Skia. No color transformation or loss occurs in the C# wrapper.",
            "relevance": "context",
            "lines": "25-54"
          }
        ],
        "rationale": "This is a real regression from v2 to v3 caused by an upstream Skia behavior change in how drawVertices blends paint color with vertex colors. The SkiaSharp wrapper code itself hasn\u0027t changed \u2014 it still passes Modulate as the blend mode \u2014 but Skia now uses the paint\u0027s opaque color as the blend source. Since SKPaint defaults to opaque black {0,0,0,1}, and Modulate = src \u00D7 dst, the result is always black. The area is core SkiaSharp (SKCanvas.DrawVertices), not views or native. Severity is medium because there\u0027s a straightforward workaround (set paint color to white), but it\u0027s a breaking change that affects all DrawVertices users who relied on v2 behavior.",
        "keySignals": [
          {
            "text": "Passing in a color array works fine in v2.88.9 but after updating to 3.116.1 the output is simply black",
            "source": "issue body",
            "interpretation": "Confirms regression \u2014 same code, different results between v2 and v3."
          },
          {
            "text": "SkPaint::SkPaint() : fColor4f{0, 0, 0, 1}  // opaque black",
            "source": "externals/skia/src/core/SkPaint.cpp:38-39",
            "interpretation": "Default paint color is opaque black \u2014 this is the root cause when modulated with vertex colors."
          },
          {
            "text": "the opaque SkPaint color if SkPaint does not contain SkShader as the src of the blend and the interpolated vertex colors as the dst",
            "source": "externals/skia/include/core/SkCanvas.h:1943-1944",
            "interpretation": "Skia documentation confirms paint color is used as blend source for drawVertices when no shader is set."
          },
          {
            "text": "DrawVertices(vert, SKBlendMode.Modulate, paint)",
            "source": "binding/SkiaSharp/SKCanvas.cs:915",
            "interpretation": "All convenience overloads hardcode Modulate blend mode \u2014 no way to override without using the lower-level overload."
          },
          {
            "text": "This will give you the result you were after: Shader = SKShader.CreateColor(SKColors.White)",
            "source": "comment by @molesmoke",
            "interpretation": "Community-provided workaround confirmed \u2014 setting a white shader makes modulate preserve vertex colors."
          }
        ],
        "workarounds": [
          "Set paint.Color = SKColors.White before calling DrawVertices \u2014 white (1,1,1,1) modulated with vertex colors preserves the original colors",
          "Set paint.Shader = SKShader.CreateColor(SKColors.White) to achieve the same result via a shader",
          "Use the overload DrawVertices(SKVertexMode, SKPoint[], SKPoint[], SKColor[], SKBlendMode, UInt16[], SKPaint) with SKBlendMode.Dst to ignore paint color entirely"
        ],
        "nextQuestions": [
          "Should SkiaSharp add a compatibility shim in the convenience overloads to default paint color to white when only vertex colors are provided?",
          "Is this a deliberate upstream Skia change or an unintended side effect of Skia refactoring?",
          "Should the SkiaSharp v3 migration guide document this behavior change?"
        ],
        "resolution": {
          "hypothesis": "Upstream Skia changed drawVertices blending semantics. The paint\u0027s opaque color is now used as the src in blend mode, and default SKPaint color is black. Modulate(black, vertex_color) = black.",
          "proposals": [
            {
              "description": "The simplest workaround: set paint.Color = SKColors.White before calling DrawVertices. Since Modulate = src \u00D7 dst, white (1,1,1,1) \u00D7 vertex_color = vertex_color, preserving the original gradient.",
              "title": "Set paint color to white",
              "codeSnippet": "var paint = new SKPaint\n{\n    IsAntialias = true,\n    Color = SKColors.White\n};",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Set paint.Shader = SKShader.CreateColor(SKColors.White) to provide a white shader that gets modulated with vertex colors. Functionally equivalent to setting Color to white.",
              "title": "Use white shader on paint",
              "codeSnippet": "var paint = new SKPaint\n{\n    IsAntialias = true,\n    Shader = SKShader.CreateColor(SKColors.White)\n};",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Use the lower-level DrawVertices overload with SKBlendMode.Dst to ignore the paint color entirely and render only vertex colors.",
              "title": "Use Dst blend mode",
              "codeSnippet": "var vert = SKVertices.CreateCopy(SKVertexMode.Triangles, vertices, colors);\ncanvas.DrawVertices(vert, SKBlendMode.Dst, paint);",
              "confidence": 0.8,
              "effort": "trivial"
            },
            {
              "description": "Add this behavior change to the v3 migration guide. DrawVertices now requires paint color or shader to be set appropriately since Skia blends it with vertex colors via the blend mode.",
              "title": "Document as v3 breaking change",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Set paint color to white",
          "recommendedReason": "Simplest fix \u2014 one property change. Directly addresses the root cause (black paint color being modulated) without requiring API changes or overload switching."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "Root cause identified as upstream Skia behavior change. Workaround is trivial (set paint.Color = SKColors.White). Community comment already provided a working solution. Could alternatively keep open to track as a breaking change for documentation."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm type/bug and add compatibility tenet and Windows platform labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Confirm root cause, provide workaround with paint.Color = White, and acknowledge as v3 behavior change",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the clear repro \u2014 this is a behavior change in the upstream Skia library used by SkiaSharp v3.\n\nIn v3, \u0060drawVertices\u0060 blends the paint\u0027s color (src) with vertex colors (dst) using the blend mode. The convenience \u0060DrawVertices\u0060 overloads use \u0060SKBlendMode.Modulate\u0060 (src \u00D7 dst), and since \u0060SKPaint\u0060 defaults to opaque black, the result is \u0060black \u00D7 vertex_color = black\u0060.\n\nHere\u0027s a workaround \u2014 set the paint color to white so modulate preserves vertex colors:\n\n\u0060\u0060\u0060csharp\nvar paint = new SKPaint\n{\n    IsAntialias = true,\n    Color = SKColors.White\n};\n\u0060\u0060\u0060\n\nAlternatively, as @molesmoke noted, you can use \u0060Shader = SKShader.CreateColor(SKColors.White)\u0060 which achieves the same result.\n\nThis is documented in the [Skia \u0060drawVertices\u0060 API](https://api.skia.org/classSkCanvas.html): \u0022the opaque SkPaint color if SkPaint does not contain SkShader as the src of the blend.\u0022"
          },
          {
            "type": "link-related",
            "description": "Link to PR #3319 which addresses DrawVertices disposal of temporary vertices",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 3319
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 3175,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:05:45Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SKBitmap.Decode reads only a single chunk from chunked/network streams (Azure Blob), producing truncated images for large PNG/BMP files \u2014 duplicate of #1962",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.97
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Linux",
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Download a PNG/BMP image larger than 4MB from Azure Blob Storage (default chunk size is 4MB)",
            "Pass the blob stream directly to SKBitmap.Decode(stream)",
            "Observe that only the first ~4MB of image data is decoded \u2014 the image dimensions are correct but pixel data is truncated",
            "Workaround: copy the blob stream to a MemoryStream first, then decode from the MemoryStream"
          ],
          "environmentDetails": "SkiaSharp 3.116.0, Azure Blob Storage stream, Linux and Windows"
        },
        "bugSignals": {
          "severity": "high",
          "isRegression": true,
          "errorType": "wrong-output",
          "errorMessage": "Only specific data length downloads into image for png/bmp \u2014 image created from first chunk only, but image size is correct",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "3.116.0",
            "2.88.9"
          ],
          "workedIn": "2.88.9",
          "brokeIn": "2.80.3",
          "currentRelevance": "likely",
          "relevanceReason": "The incomplete stream reading bug in SKManagedStream.OnReadManagedStream was introduced in PR #1510 (v2.80.3) and has not been fixed. The reporter claims 2.88.9 worked, which may indicate they used a different code path or MemoryStream in the older version."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "The root cause was introduced in PR #1510 (commit 61b71d6e4893) which changed from BinaryReader.ReadBytes() (loops until all bytes read) to a single stream.Read() call that can return partial data. Reporter states 2.88.9 worked but bug was introduced in 2.80.3.",
          "brokeInVersion": "2.80.3"
        }
      },
      "analysis": {
        "summary": "SKManagedStream.OnReadManagedStream performs a single stream.Read() call which can return fewer bytes than requested per the .NET Stream contract. Chunked streams (Azure Blob, network streams) commonly return partial reads. This causes Skia\u0027s codec to receive truncated data, producing images with correct dimensions but incomplete pixel data.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKManagedStream.cs",
            "finding": "OnReadManagedStream performs a single stream.Read() call at line 99. Per the .NET Stream contract, Read() may return fewer bytes than requested even when more data is available. Network and chunked streams commonly do this. The method should loop until all bytes are read or the stream ends.",
            "relevance": "direct",
            "lines": "89-111"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "WrapManagedStream wraps seekable streams with SKManagedStream directly, and non-seekable streams with SKFrontBufferedManagedStream (which itself wraps SKManagedStream). Both paths are affected since the underlying Read is in SKManagedStream.",
            "relevance": "direct",
            "lines": "278-290"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(Stream) creates an SKCodec from the stream, which goes through WrapManagedStream \u2192 SKManagedStream \u2192 single stream.Read() call.",
            "relevance": "context",
            "lines": "461-472"
          },
          {
            "file": "binding/SkiaSharp/SKFrontBufferedManagedStream.cs",
            "finding": "SKFrontBufferedManagedStream.OnRead also calls stream.Read() without looping (lines 91, 111) though this wraps an SKStream not a .NET Stream, so the inner SKManagedStream is the actual issue.",
            "relevance": "related",
            "lines": "64-124"
          }
        ],
        "rationale": "This is clearly a bug \u2014 Stream.Read() returning fewer bytes than requested is normal .NET behavior, and the caller must loop to read the full amount. The issue exactly matches #1962 (incomplete stream reading in SKManagedStream introduced in 2.80.3) and #2514 (partial reads from non-seekable streams). Classification as type/bug in area/SkiaSharp core is straightforward since the defect is in SKManagedStream, not in any view or platform layer.",
        "keySignals": [
          {
            "text": "Default stream downloading chunk size is 4mb. When png is larger than 4mb it looks like image creates only for first 4mb",
            "source": "issue body",
            "interpretation": "Azure Blob stream returns data in chunks; stream.Read() returns only the first chunk without looping for the rest."
          },
          {
            "text": "When I\u0027m copying blob stream into memory stream it works correctly",
            "source": "issue body",
            "interpretation": "MemoryStream.Read() returns all requested bytes since data is already in memory \u2014 confirms the issue is in how SkiaSharp reads from the stream, not in decoding."
          },
          {
            "text": "Even if I change default size of stream chunk for example into 50mb png/bmp images below 50mb downloads correctly",
            "source": "issue body",
            "interpretation": "Increasing chunk size makes the single read.Read() call return all data in one shot, bypassing the missing loop. This confirms the root cause."
          },
          {
            "text": "var len = stream.Read(managedBuffer.Array, 0, managedBuffer.Length);",
            "source": "SKManagedStream.cs:99",
            "interpretation": "Single Read() call without retry loop \u2014 violates Stream contract which allows partial reads."
          }
        ],
        "workarounds": [
          "Copy the source stream to a MemoryStream before decoding: await stream.CopyToAsync(memoryStream); memoryStream.Seek(0, SeekOrigin.Begin); SKBitmap.Decode(memoryStream);",
          "Use SKBitmap.Decode(SKData) instead: read all bytes first with await BinaryData.FromStreamAsync(stream), then decode from the byte array or SKData."
        ],
        "nextQuestions": [
          "Should the fix be a read loop in OnReadManagedStream, or should WrapManagedStream always copy non-seekable streams to memory first?",
          "Does the same issue affect SKImage.FromEncodedData(Stream)?",
          "Should SKFrontBufferedManagedStream also be fixed to loop on reads from the underlying stream?"
        ],
        "resolution": {
          "hypothesis": "SKManagedStream.OnReadManagedStream performs a single stream.Read() instead of looping until the requested number of bytes is read or the stream ends. This causes chunked/network streams to produce truncated data.",
          "proposals": [
            {
              "description": "Copy the source stream to a MemoryStream before passing to SKBitmap.Decode. This is what the reporter already discovered.",
              "title": "Copy to MemoryStream first (workaround)",
              "codeSnippet": "await using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var bitmap = SKBitmap.Decode(memoryStream);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Read all bytes into memory first, then use SKBitmap.Decode(byte[]) or SKBitmap.Decode(SKData) to avoid the stream reading issue entirely.",
              "title": "Use SKData.Create from byte array (workaround)",
              "codeSnippet": "using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nusing var bitmap = SKBitmap.Decode(memoryStream.ToArray());",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Replace the single stream.Read() call in SKManagedStream.OnReadManagedStream with a loop that reads until all requested bytes are obtained or the stream truly ends. This is the proper fix matching the old BinaryReader.ReadBytes() behavior.",
              "title": "Add read loop in OnReadManagedStream (fix)",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Copy to MemoryStream first (workaround)",
          "recommendedReason": "The reporter already found this workaround. It\u0027s reliable and trivial to implement. The proper fix requires a code change in SKManagedStream that should be done as part of addressing #1962."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.9,
          "reason": "This is a duplicate of #1962 (incomplete stream reading in SKManagedStream introduced in 2.80.3). The same root cause \u2014 single stream.Read() instead of a loop \u2014 and the same workaround (copy to MemoryStream). Also related to #2514 and #2249."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and platform labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Linux",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug, confirm it\u0027s a known issue, provide workaround context",
            "risk": "high",
            "confidence": 0.9,
            "comment": "Thanks for the report. This is a known issue with how SkiaSharp reads from chunked or network streams \u2014 \u0060SKManagedStream.OnReadManagedStream\u0060 performs a single \u0060stream.Read()\u0060 call instead of looping until all requested bytes are read. Azure Blob streams return data in chunks, so only the first chunk gets decoded.\n\nYou\u0027ve already found the correct workaround: copy to a \u0060MemoryStream\u0060 first. Alternatively, you can read all bytes and use \u0060SKBitmap.Decode(byte[])\u0060 to avoid the stream path entirely.\n\nThis is a duplicate of #1962, which tracks the root cause (introduced in v2.80.3 when \u0060BinaryReader.ReadBytes()\u0060 was replaced with a single \u0060stream.Read()\u0060 call). See also #2514 for the same issue with non-seekable streams."
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #1962 (incomplete stream reading in SKManagedStream)",
            "risk": "medium",
            "confidence": 0.9,
            "linkedIssue": 1962
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #1962",
            "risk": "medium",
            "confidence": 0.88
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2997,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:58:59Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SKMatrix.MapRect normalizes (sorts) the output rectangle \u2014 this is upstream Skia behavior, not a SkiaSharp bug",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.35
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an SKRect with Left=25, Right=15, Bottom=2, Top=10 (non-standard/inverted coordinates)",
            "Call SKMatrix.CreateIdentity().MapRect(inputRect)",
            "Observe that resultRect has Left/Right and Top/Bottom swapped compared to input"
          ],
          "environmentDetails": "SkiaSharp 2.88.3, Windows, Visual Studio"
        },
        "bugSignals": {
          "severity": "low",
          "isRegression": false,
          "errorType": "wrong-output",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3",
            "2.88.2"
          ],
          "workedIn": "2.88.2",
          "brokeIn": "2.88.3",
          "currentRelevance": "likely",
          "relevanceReason": "The behavior is inherent to Skia\u0027s SkMatrix::mapRect which calls sort_as_rect() to normalize the output. This has been Skia behavior since at least 2020; the reporter\u0027s regression claim is likely inaccurate or based on a different code path in 2.88.2."
        }
      },
      "analysis": {
        "summary": "SKMatrix.MapRect delegates to Skia\u0027s SkMatrix::mapRect which intentionally normalizes the output rectangle via sort_as_rect(). This ensures left\u2264right and top\u2264bottom in the result. This is upstream Skia behavior by design, not a SkiaSharp wrapper bug.",
        "codeInvestigation": [
          {
            "file": "externals/skia/src/core/SkMatrix.cpp",
            "finding": "sort_as_rect() takes LTRB float4, computes min/max pairs, returns sorted LTRB. Called by both mapRect and mapRectScaleTranslate. This is the function that normalizes the output rect.",
            "relevance": "direct",
            "lines": "1120-1127"
          },
          {
            "file": "externals/skia/src/core/SkMatrix.cpp",
            "finding": "SkMatrix::mapRect has three code paths (translate-only, scale-translate, general). All three produce normalized output \u2014 translate/scale paths use sort_as_rect, general path uses setBoundsNoCheck on mapped quad points.",
            "relevance": "direct",
            "lines": "1142-1169"
          },
          {
            "file": "externals/skia/src/c/sk_matrix.cpp",
            "finding": "sk_matrix_map_rect is a direct pass-through to SkMatrix::mapRect \u2014 no SkiaSharp-specific normalization added.",
            "relevance": "direct",
            "lines": "47-49"
          },
          {
            "file": "binding/SkiaSharp/SKMatrix.cs",
            "finding": "C# MapRect method calls SkiaApi.sk_matrix_map_rect and returns the result. No C#-side normalization. The behavior comes entirely from upstream Skia.",
            "relevance": "direct",
            "lines": "299-306"
          },
          {
            "file": "binding/SkiaSharp/MathTypes.cs",
            "finding": "SKRect.Standardized property exists and explicitly normalizes a rect. Reporter already knows about it \u2014 their expectation is that MapRect should NOT auto-standardize.",
            "relevance": "context",
            "lines": "382-398"
          }
        ],
        "rationale": "Classified as low-confidence bug because the behavior is intentional in upstream Skia \u2014 sort_as_rect (SkMatrix.cpp:1120-1127) explicitly sorts coordinates to produce a normalized rect. The SkiaSharp C API (sk_matrix_map_rect) and C# wrapper (SKMatrix.MapRect) are thin pass-throughs with no additional normalization logic. The community comment from molesmoke correctly identifies this as Skia behavior. The reporter\u0027s expectation that MapRect preserves inverted coordinates is understandable but conflicts with Skia\u0027s rect invariant. The regression claim (2.88.2\u21922.88.3) is unsubstantiated \u2014 no changes to SKMatrix.MapRect or sk_matrix_map_rect appear in the git history.",
        "keySignals": [
          {
            "text": "sort_as_rect(skvx::float4::Load(\u0026src.fLeft) \u002B trans).store(\u0026dst-\u003EfLeft)",
            "source": "externals/skia/src/core/SkMatrix.cpp:1149",
            "interpretation": "Skia\u0027s mapRect always sorts the output coordinates via sort_as_rect, which computes min/max of left/right and top/bottom. This is the root cause of the \u0027standardization\u0027 the reporter observes."
          },
          {
            "text": "void sk_matrix_map_rect(sk_matrix_t *matrix, sk_rect_t *dest, sk_rect_t *source) { AsMatrix(matrix).mapRect(AsRect(dest), *AsRect(source)); }",
            "source": "externals/skia/src/c/sk_matrix.cpp:47-49",
            "interpretation": "The C API is a direct pass-through to Skia\u0027s mapRect with no additional logic \u2014 the normalization comes from upstream."
          },
          {
            "text": "That\u0027s what Skia does, it\u0027s not really an issue with the bindings themselves",
            "source": "comment by molesmoke",
            "interpretation": "Community member correctly identified this as upstream Skia behavior and linked to the Skia source."
          }
        ],
        "workarounds": [
          "Use SKMatrix.MapPoints to transform the four corners of the rect individually, then construct a new SKRect from the mapped points without sorting.",
          "Map the TopLeft and BottomRight points separately using SKMatrix.MapPoint, then construct the result rect preserving the original coordinate ordering."
        ],
        "nextQuestions": [
          "Should SkiaSharp document that MapRect always returns a normalized rect?",
          "Is the reporter\u0027s regression claim accurate, or did their code path change between 2.88.2 and 2.88.3?"
        ],
        "resolution": {
          "hypothesis": "This is upstream Skia behavior by design. SkMatrix::mapRect always normalizes the output rectangle. SkiaSharp cannot change this without diverging from Skia\u0027s behavior.",
          "proposals": [
            {
              "description": "Instead of MapRect, transform the rect corners individually using MapPoint to preserve the original coordinate ordering.",
              "title": "Use MapPoint for corner-preserving transformation",
              "codeSnippet": "var matrix = SKMatrix.CreateIdentity(); // or your actual matrix\nvar topLeft = matrix.MapPoint(inputRect.Left, inputRect.Top);\nvar bottomRight = matrix.MapPoint(inputRect.Right, inputRect.Bottom);\nvar resultRect = new SKRect(topLeft.X, topLeft.Y, bottomRight.X, bottomRight.Y);",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Add documentation to SKMatrix.MapRect noting that the output rect is always normalized (sorted), consistent with upstream Skia behavior. Suggest MapPoint as an alternative for coordinate-preserving transforms.",
              "title": "Document MapRect normalization behavior",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Use MapPoint for corner-preserving transformation",
          "recommendedReason": "Provides an immediate workaround that preserves coordinate ordering while being fully supported and correct."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "This is upstream Skia behavior by design. The SkiaSharp wrapper correctly delegates to Skia. A workaround using MapPoint exists. The issue could be closed as by-design with an explanation and workaround."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply area label, keep existing type/bug pending maintainer review of by-design classification",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain upstream Skia behavior and provide MapPoint workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the detailed repro.\n\nThis is upstream Skia behavior \u2014 \u0060SkMatrix::mapRect\u0060 always normalizes (sorts) the output rectangle so that \u0060left \u2264 right\u0060 and \u0060top \u2264 bottom\u0060. The SkiaSharp wrapper delegates directly to Skia with no additional processing. The \u0060sort_as_rect\u0060 function in Skia\u0027s \u0060SkMatrix.cpp\u0060 handles this normalization. As @molesmoke noted, this isn\u0027t a binding issue.\n\nHere\u0027s a workaround that preserves coordinate ordering by transforming the corners individually:\n\n\u0060\u0060\u0060csharp\nvar topLeft = matrix.MapPoint(inputRect.Left, inputRect.Top);\nvar bottomRight = matrix.MapPoint(inputRect.Right, inputRect.Bottom);\nvar resultRect = new SKRect(topLeft.X, topLeft.Y, bottomRight.X, bottomRight.Y);\n\u0060\u0060\u0060\n\nThis gives you the transformed coordinates without the normalization step. Would this approach work for your use case?"
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2853,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:55:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "TIFF decoding returns null / throws \u2014 TIFF is not a supported format in Skia. Duplicate of #433, related to feature request #2993.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.4
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Attempt to load a .tif file using SKImage.FromEncodedData() or SKBitmap.Decode()",
            "Observe null return from SKImage.FromEncodedData() or ArgumentNullException from SKBitmap.Decode()"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/15253367/C.7.142.18-0002.zip",
              "filename": "C.7.142.18-0002.zip",
              "description": "Sample TIFF file that fails to decode"
            }
          ],
          "environmentDetails": "SkiaSharp 2.88.3, Windows 10/11, Visual Studio",
          "relatedIssues": [
            433,
            2993,
            1950
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "wrong-output",
          "errorMessage": "Value cannot be null. (Parameter \u0027codec\u0027) at SkiaSharp.SKBitmap.Decode(SKCodec codec)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net8.0-windows"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "TIFF has never been supported by Skia\u0027s codec system. No TIFF codec exists in any version of Skia or SkiaSharp."
        }
      },
      "analysis": {
        "summary": "Reporter attempts to decode TIFF files using SkiaSharp. TIFF is not and has never been a supported image format in Skia. The SKEncodedImageFormat enum does not include TIFF, and there is no SkTiffCodec in the Skia codec directory. SKCodec.Create() returns null for unrecognized formats, causing SKImage.FromEncodedData() to return null and SKBitmap.Decode(SKCodec) to throw ArgumentNullException when passed the null codec.",
        "codeInvestigation": [
          {
            "file": "externals/skia/src/codec/",
            "finding": "No SkTiffCodec.cpp or SkTiffCodec.h exists. The only TIFF reference is in SkRawCodec.cpp which checks for TIFF headers as part of DNG (raw photo) format detection, not general TIFF decoding.",
            "relevance": "direct"
          },
          {
            "file": "externals/skia/include/codec/SkEncodedImageFormat.h",
            "finding": "Supported formats: BMP, GIF, ICO, JPEG, PNG, WBMP, WEBP, PKM, KTX, ASTC, DNG, HEIF, AVIF, JPEGXL. TIFF is not listed.",
            "relevance": "direct",
            "lines": "17-30"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(Stream) calls SKCodec.Create(stream) which returns null for unsupported formats, then returns null. But SKBitmap.Decode(SKCodec) at line 436-437 throws ArgumentNullException if codec is null \u2014 this is the crash path when user manually creates a null codec.",
            "relevance": "direct",
            "lines": "461-471"
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "finding": "SKImage.FromEncodedData(SKData) calls sk_image_new_from_encoded which returns IntPtr.Zero for unsupported formats, causing GetObject to return null. This is the expected factory-returns-null pattern.",
            "relevance": "direct",
            "lines": "166-173"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create() delegates to sk_codec_new_from_stream/sk_codec_new_from_data. Returns null when Skia cannot identify the format, which is the case for TIFF.",
            "relevance": "direct",
            "lines": "229-264"
          }
        ],
        "rationale": "This is not a bug in SkiaSharp \u2014 it is expected behavior for an unsupported image format. The type is classified as type/bug with low confidence because the reporter filed it as a bug, but it is actually a known limitation / feature request. The area is area/SkiaSharp (core codec). Issue #433 was closed in 2018 with the maintainer explicitly stating TIFF is not supported, and #2993 is an open feature request for TIFF support. The ArgumentNullException path through SKBitmap.Decode(byte[]) \u2192 SKCodec.Create() returning null \u2192 SKBitmap.Decode(SKCodec) receiving null is the standard unsupported-format behavior.",
        "keySignals": [
          {
            "text": "I tried to load large .tif files, but they all fail",
            "source": "issue body",
            "interpretation": "Reporter expects TIFF to be a supported format. It is not."
          },
          {
            "text": "ArgumentNullException: Value cannot be null. (Parameter \u0027codec\u0027)",
            "source": "issue body",
            "interpretation": "SKCodec.Create() returns null for unrecognized formats. When passed directly to SKBitmap.Decode(SKCodec), it throws. The stream/byte[]/string overloads of Decode null-check the codec and return null gracefully."
          },
          {
            "text": "Unfortunately, TIFF files are not supported by skia, and thus SkiaSharp.",
            "source": "#433 comment by mattleibow",
            "interpretation": "Maintainer explicitly confirmed this in 2018. No TIFF codec has been added since."
          }
        ],
        "workarounds": [
          "Use BitMiracle.LibTiff.NET to decode TIFF files to raw pixel data, then create an SKBitmap from the pixels.",
          "Use ImageSharp or System.Drawing to convert TIFF to PNG/JPEG first, then load with SkiaSharp.",
          "Use Magick.NET to convert TIFF to a supported format before passing to SkiaSharp."
        ],
        "nextQuestions": [
          "Should this be closed as duplicate of #433, or linked to the feature request #2993?"
        ],
        "resolution": {
          "hypothesis": "TIFF is not a supported codec in Skia. This is by design, not a bug. The reporter needs to use an external library to decode TIFF.",
          "proposals": [
            {
              "description": "Decode TIFF files with BitMiracle.LibTiff.NET, extract raw pixel data, and create an SKBitmap from the pixels. This is the workaround recommended by the maintainer in #433.",
              "title": "Use LibTiff.NET for TIFF decoding",
              "codeSnippet": "// Install: dotnet add package BitMiracle.LibTiff.NET\nusing BitMiracle.LibTiff;\nusing SkiaSharp;\n\nusing var tiff = Tiff.Open(\u0022image.tif\u0022, \u0022r\u0022);\nint width = tiff.GetField(TiffTag.IMAGEWIDTH)[0].ToInt();\nint height = tiff.GetField(TiffTag.IMAGELENGTH)[0].ToInt();\nvar raster = new int[width * height];\ntiff.ReadRGBAImageOriented(width, height, raster, Orientation.TOPLEFT);\n\nvar info = new SKImageInfo(width, height, SKColorType.Rgba8888, SKAlphaType.Unpremul);\nusing var bitmap = new SKBitmap(info);\nvar ptr = bitmap.GetPixels();\nSystem.Runtime.InteropServices.Marshal.Copy(raster, 0, ptr, raster.Length);\nbitmap.NotifyPixelsChanged();",
              "confidence": 0.65,
              "effort": "small"
            },
            {
              "description": "Use SixLabors.ImageSharp to load the TIFF and save as PNG to a MemoryStream, then load the PNG with SkiaSharp.",
              "title": "Convert TIFF to PNG with ImageSharp",
              "codeSnippet": "// Install: dotnet add package SixLabors.ImageSharp\nusing SixLabors.ImageSharp;\nusing SixLabors.ImageSharp.Formats.Png;\nusing SkiaSharp;\n\nusing var image = Image.Load(\u0022image.tif\u0022);\nusing var ms = new MemoryStream();\nimage.Save(ms, new PngEncoder());\nms.Position = 0;\nusing var skImage = SKImage.FromEncodedData(ms);",
              "confidence": 0.75,
              "effort": "small"
            },
            {
              "description": "Track feature request #2993 for native TIFF codec support in Skia/SkiaSharp. This would require upstream Skia changes.",
              "title": "TIFF support in SkiaSharp",
              "confidence": 0.3,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Convert TIFF to PNG with ImageSharp",
          "recommendedReason": "ImageSharp has robust TIFF support and the conversion approach is simpler and more reliable than manual pixel extraction with LibTiff.NET."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.85,
          "reason": "This is the same issue as #433 (TIFF not supported). The feature request is tracked separately in #2993."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Relabel as feature request since TIFF non-support is by design, not a bug",
            "risk": "low",
            "confidence": 0.8,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain TIFF is unsupported and provide workaround",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. TIFF is not a supported image format in Skia (the underlying C\u002B\u002B library), and so SkiaSharp cannot decode it \u2014 \u0060SKCodec.Create()\u0060 returns null for unrecognized formats, which is why \u0060FromEncodedData\u0060 returns null and \u0060Decode\u0060 throws.\n\nHere\u0027s a workaround you can use: convert the TIFF to PNG with a library like ImageSharp, then load the PNG with SkiaSharp:\n\n\u0060\u0060\u0060csharp\n// dotnet add package SixLabors.ImageSharp\nusing SixLabors.ImageSharp;\nusing SixLabors.ImageSharp.Formats.Png;\n\nusing var image = Image.Load(\u0022image.tif\u0022);\nusing var ms = new MemoryStream();\nimage.Save(ms, new PngEncoder());\nms.Position = 0;\nusing var skImage = SKImage.FromEncodedData(ms);\n// skImage may be null if encoding failed\n\u0060\u0060\u0060\n\nAlternatively, BitMiracle.LibTiff.NET can decode TIFF to raw pixels which you can pass directly to \u0060SKBitmap\u0060.\n\nNative TIFF support is tracked in #2993. Closing this as a duplicate of #433."
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #433 (TIFF not supported)",
            "risk": "medium",
            "confidence": 0.85,
            "linkedIssue": 433
          },
          {
            "type": "link-related",
            "description": "Cross-reference feature request #2993 for TIFF support",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 2993
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #433",
            "risk": "medium",
            "confidence": 0.85
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2759,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:00:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "Reporter claims SKBitmap.Decode returns null when decoding a PNG file on SkiaSharp 2.88.3 (also mentions 2.88.6). Filed as a follow-up to #933, which was closed as a duplicate of #1981. The #1981 fix (zlib update for SSE decompression bugs) shipped in v2.88.1. No sample image, stack trace, or reproduction project is provided, making it impossible to verify whether this is the same zlib issue or a different PNG decoding problem.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.8
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.9
        },
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "codeSnippets": [
            "SkiaSharp.SKBitmap bmp = SkiaSharp.SKBitmap.Decode(@\u0022C:\\Temp\\image1.png\u0022);\nAssert.IsNotNull(bmp);"
          ],
          "environmentDetails": "Visual Studio (Windows), all platforms (claimed)",
          "relatedIssues": [
            933,
            1981,
            2429
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "silent failure",
          "errorMessage": "SKBitmap.Decode returns null",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3",
            "2.88.6",
            "2.88.2"
          ],
          "workedIn": "2.88.2",
          "brokeIn": "2.88.3",
          "currentRelevance": "unknown",
          "relevanceReason": "The reporter is on 2.88.x. The zlib fix shipped in 2.88.1. Without the actual PNG file, we cannot determine whether this is still reproducible on 3.x. The current main branch uses a significantly newer Skia with updated native dependencies."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.6,
          "reason": "Reporter claims it worked in 2.88.2 but not 2.88.3. However, the zlib fix for #1981 shipped in 2.88.1, so 2.88.2 should have had the fix. The version info is internally inconsistent \u2014 the body says 2.88.6 but the version field says 2.88.3. Low confidence because no sample image is provided.",
          "workedInVersion": "2.88.2",
          "brokeInVersion": "2.88.3"
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.45,
          "reason": "The zlib/SSE fix from #1981 shipped in v2.88.1 and should have been present in 2.88.2\u002B. Either: (a) this is a different PNG decoding issue not fixed by that zlib update, or (b) the reporter\u0027s version info is inaccurate. Without the actual image file, we cannot determine if this specific PNG triggers a different code path.",
          "fixedInVersion": "2.88.1"
        }
      },
      "analysis": {
        "summary": "SKBitmap.Decode returning null for a PNG. The decode path is: SKBitmap.Decode(string) \u2192 SKCodec.Create(string) \u2192 sk_codec_new_from_stream. If SKCodec.Create returns null (meaning Skia\u0027s codec can\u0027t parse the image), the method returns null. The original #933/#1981 bug was traced to a zlib SSE decompression bug and fixed in 2.88.1 by updating zlib. The reporter claims the issue persists in 2.88.3/2.88.6, but provides no sample image to verify this claim.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(string) creates an SKCodec from the filename and returns null if codec creation fails. No error information is surfaced to the caller \u2014 the null return is completely opaque.",
            "relevance": "direct",
            "lines": "539-550"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(string) opens an SKFileStream and delegates to SKCodec.Create(SKStream). The overload with \u0027out SKCodecResult\u0027 would provide the failure reason, but SKBitmap.Decode doesn\u0027t use it.",
            "relevance": "direct",
            "lines": "229-241"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(SKStream) calls sk_codec_new_from_stream. If Skia cannot create a codec for the image format, it returns null. The SKCodecResult out parameter would reveal why (e.g., InvalidInput, IncompleteInput).",
            "relevance": "related",
            "lines": "252-264"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(SKCodec, SKImageInfo) calls codec.GetPixels and returns null if result is not Success or IncompleteInput. This is a second failure point after codec creation.",
            "relevance": "related",
            "lines": "446-458"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes a decode failure (null return) that is clearly unintended behavior. Area is area/SkiaSharp because the failing API is SKBitmap.Decode in the core library, not a view or native-loading issue. Severity is medium (not critical) because it\u0027s a silent null return, not a crash, and only affects specific PNGs. The regression claim has low confidence because the version information is inconsistent (body says 2.88.6, template says 2.88.3, and the fix was already in 2.88.1).",
        "keySignals": [
          {
            "text": "This is follow-up of #933 issue, which is closed as resolved, but the problem is still there 2.88.6 version",
            "source": "issue body",
            "interpretation": "Reporter believes the zlib fix in 2.88.1 did not resolve their specific PNG. Without the image, we can\u0027t verify."
          },
          {
            "text": "Version with issue: 2.88.3 (Current), Last Known Good: 2.88.2 (Previous)",
            "source": "issue template fields",
            "interpretation": "Inconsistent with body text (2.88.6). The zlib fix shipped in 2.88.1, so 2.88.2 should include it. This suggests a different root cause or inaccurate version info."
          },
          {
            "text": "#1981 closed \u2014 \u0027I think it was a bug in zlib so updating to a later version fixes the issue\u0027",
            "source": "mattleibow comment on #1981",
            "interpretation": "The parent issue was definitively diagnosed as a zlib SSE decompression bug. If this reporter\u0027s PNG is different, it\u0027s a new bug."
          },
          {
            "text": "#2429 also open: SKBitmap.Decode always returns null for a specific image",
            "source": "issue search",
            "interpretation": "Another open issue with the same symptom on a JPG. There may be a pattern of specific images failing to decode."
          }
        ],
        "errorFingerprint": "SKBitmap.Decode-null-PNG",
        "workarounds": [
          "Use SKCodec.Create(filename, out SKCodecResult result) to get the specific failure reason before calling Decode",
          "Re-save the PNG with a different tool (Paint.NET, ImageMagick) to re-encode with standard compression \u2014 worked for #1981 reporters",
          "Try SKImage.FromEncodedData() as an alternative decode path"
        ],
        "nextQuestions": [
          "What specific PNG characteristics trigger the failure? (bit depth, compression method, metadata)",
          "Is this the same PNG referenced in #933, or a different file?",
          "Does SKCodec.Create with out SKCodecResult give InvalidInput or IncompleteInput?",
          "Does the issue reproduce on 3.x (SkiaSharp 3.116\u002B) with the newer Skia engine?",
          "Does converting the PNG to 8-bit resolve the issue (as reported in #1981)?"
        ],
        "resolution": {
          "hypothesis": "Either (a) the reporter\u0027s specific PNG triggers a different libpng/zlib code path not fixed by the 2.88.1 zlib update, or (b) the reporter hasn\u0027t actually tested with the fixed version. Without the sample image, we cannot distinguish between these two possibilities.",
          "proposals": [
            {
              "description": "Ask the reporter to attach the actual PNG file and run SKCodec.Create with the out SKCodecResult parameter to get the specific failure reason. This is the blocking prerequisite for any further investigation.",
              "title": "Request sample image and diagnostic output",
              "codeSnippet": "var codec = SKCodec.Create(@\u0022C:\\Temp\\image1.png\u0022, out SKCodecResult result);\nConsole.WriteLine($\u0022Codec: {codec != null}, Result: {result}\u0022);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "SkiaSharp 3.x uses a significantly newer Skia engine with updated libpng and zlib. If this is a native decoding bug, upgrading may resolve it.",
              "title": "Upgrade to SkiaSharp 3.x",
              "confidence": 0.6,
              "effort": "small"
            },
            {
              "description": "Re-save the problematic PNG using a tool like Paint.NET, GIMP, or ImageMagick to normalize compression. This was a successful workaround for #1981.",
              "title": "Re-save PNG with standard encoder",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Request sample image and diagnostic output",
          "recommendedReason": "Cannot make progress without the actual PNG file and diagnostic data. Every other proposal is speculative without knowing what\u0027s unique about this image."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "request-info",
          "confidence": 0.9,
          "reason": "No sample image attached, inconsistent version info, no error details. The original #933/#1981 issue was fixed in 2.88.1, so we need to understand why the reporter still sees the problem. Cannot investigate without the actual PNG file."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Keep type/bug, add area/SkiaSharp and tenet/compatibility",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Link to #1981 (parent issue with zlib fix) and #2429 (similar Decode-returns-null symptom)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 1981
          },
          {
            "type": "link-related",
            "description": "Link to #2429 (similar SKBitmap.Decode returns null symptom)",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 2429
          },
          {
            "type": "add-comment",
            "description": "Request sample PNG and diagnostic output to continue investigation",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. The original #933 was closed as a duplicate of #1981, which was traced to a zlib decompression bug and fixed in v2.88.1. Since you\u0027re on 2.88.3\u002B, we\u0027d need to understand what\u0027s different about your PNG.\n\nTo help us investigate, would you be able to:\n\n1. **Attach the actual PNG file** (\u0060image1.png\u0060) \u2014 without it, we can\u0027t reproduce or diagnose the failure.\n2. **Run this diagnostic** to get the specific failure reason:\n\n\u0060\u0060\u0060csharp\nvar codec = SKCodec.Create(@\u0022C:\\Temp\\image1.png\u0022, out SKCodecResult result);\nConsole.WriteLine($\u0022Codec created: {codec != null}, Result: {result}\u0022);\n\u0060\u0060\u0060\n\n3. **Confirm your exact SkiaSharp version** \u2014 the issue body mentions 2.88.6 but the version field says 2.88.3.\n\nAs a workaround, re-saving the PNG with a tool like Paint.NET or ImageMagick may resolve the issue \u2014 that worked for reporters on #1981. You could also try upgrading to SkiaSharp 3.x, which uses a significantly updated Skia engine."
          }
        ],
        "missingInfo": [
          "The actual PNG file that fails to decode (image1.png is not attached)",
          "Output of SKCodec.Create(filename, out SKCodecResult result) showing the specific failure reason",
          "Confirmation of exact SkiaSharp version (body says 2.88.6, template says 2.88.3)",
          "Whether upgrading to SkiaSharp 3.x resolves the issue"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2511,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T16:00:00Z",
        "currentLabels": []
      },
      "summary": "AccessViolationException in NonAlertableWin32Lock.EnterCriticalSection during finalizer-driven handle deregistration on WinForms app close \u2014 duplicate of #2194, fixed in v2.88.1 by #2195",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Run a WinForms application that uses SkiaSharp",
            "Close the application",
            "Observe AccessViolationException in the finalizer thread"
          ],
          "environmentDetails": "Windows, WinForms application",
          "relatedIssues": [
            2194,
            2195,
            1383,
            1817
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "crash",
          "errorMessage": "System.AccessViolationException: An attempt was made to read or write protected memory.",
          "stackTrace": "at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterCriticalSection(IntPtr lpCriticalSection)\n   at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterWriteLock()\n   at SkiaSharp.HandleDictionary.DeregisterHandle(IntPtr handle, SKObject instance)\n   at SkiaSharp.SKObject.DeregisterHandle(IntPtr handle, SKObject instance)\n   at SkiaSharp.SKObject.set_Handle(IntPtr value)\n   at SkiaSharp.SKNativeObject.Dispose(Boolean disposing)\n   at SkiaSharp.SKNativeObject.Finalize()",
          "reproQuality": "partial",
          "targetFrameworks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "Fixed in v2.88.1 by PR #2195. The current code in PlatformLock.cs includes null-checks before entering/leaving the critical section. Reporter did not mention a version, but the stack trace exactly matches the known bug #2194 that was fixed."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.92,
          "reason": "PR #2195 (commit dc54fa5cd) added null-checks for _cs before calling EnterCriticalSection/LeaveCriticalSection, preventing the crash when the NonAlertableWin32Lock finalizer runs before SKObject finalizers during app shutdown. The fix was included in v2.88.1.",
          "relatedPRs": [
            2195
          ],
          "fixedInVersion": "2.88.1"
        }
      },
      "analysis": {
        "summary": "Classic finalizer ordering bug on Windows. During WinForms app shutdown, the GC finalizes both SKObject instances and the static NonAlertableWin32Lock. If the lock\u0027s finalizer runs first (deleting the CRITICAL_SECTION native memory), subsequent SKObject finalizers crash when trying to enter the already-freed critical section during handle deregistration. This exact bug was reported as #2194 and fixed by #2195 in v2.88.1.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/PlatformLock.cs",
            "finding": "NonAlertableWin32Lock allocates a CRITICAL_SECTION via Marshal.AllocHGlobal in the constructor and frees it in the finalizer (~NonAlertableWin32Lock). The Enter() method (line 122) now has a null-check \u0027if (_cs != IntPtr.Zero)\u0027 before calling EnterCriticalSection \u2014 this is the fix from PR #2195. Without this check (pre-v2.88.1), the freed pointer would be passed directly to EnterCriticalSection, causing the exact AccessViolationException in the reporter\u0027s stack trace.",
            "relevance": "direct",
            "lines": "99-174"
          },
          {
            "file": "binding/SkiaSharp/HandleDictionary.cs",
            "finding": "DeregisterHandle calls instancesLock.EnterWriteLock() (line 184). The instancesLock is a static readonly field (line 27) created by PlatformLock.Create(). During AppDomain unload, the static NonAlertableWin32Lock instance can be finalized before all SKObject instances that reference it through the static dictionary.",
            "relevance": "direct",
            "lines": "176-227"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKObject.Handle setter: when set to IntPtr.Zero (during disposal), it first calls DeregisterHandle(Handle, this) which triggers the lock acquisition. This is the entry point from the Dispose path into the lock that crashes.",
            "relevance": "direct",
            "lines": "59-70"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "SKNativeObject finalizer sets fromFinalizer=true then calls Dispose(false), which sets Handle=IntPtr.Zero, triggering DeregisterHandle. This confirms the crash path originates from GC finalization.",
            "relevance": "direct",
            "lines": "229-234"
          }
        ],
        "rationale": "The stack trace is identical to #2194: Finalize \u2192 Dispose(false) \u2192 set_Handle(Zero) \u2192 DeregisterHandle \u2192 EnterWriteLock \u2192 EnterCriticalSection. This is a known finalizer ordering race condition specific to the Win32 CRITICAL_SECTION lock used on Windows (introduced to fix #1383\u0027s STA re-entrancy issue). The reporter does not mention a SkiaSharp version, but since the fix shipped in v2.88.1 (August 2022) and this was reported June 2023, they were likely on v2.88.0 or earlier. The current code has the null-check guard from #2195. Classified as type/bug, area/SkiaSharp (HandleDictionary/PlatformLock is core infrastructure), Windows-Classic (WinForms), medium severity (crash on exit, not during normal operation).",
        "keySignals": [
          {
            "text": "at SkiaSharp.Internals.PlatformLock.NonAlertableWin32Lock.EnterCriticalSection(IntPtr lpCriticalSection)",
            "source": "issue body",
            "interpretation": "Crash in the Win32 CRITICAL_SECTION P/Invoke \u2014 the native memory backing the critical section has been freed by the NonAlertableWin32Lock finalizer before this SKObject\u0027s finalizer ran."
          },
          {
            "text": "at SkiaSharp.SKNativeObject.Finalize()",
            "source": "issue body",
            "interpretation": "Crash occurs during GC finalization, not during normal operation. This is a finalizer ordering problem during app shutdown."
          },
          {
            "text": "When I close my winform program, this error will be reported",
            "source": "issue body",
            "interpretation": "Trigger is app close \u2014 AppDomain unload causes non-deterministic finalizer ordering, explaining the race condition."
          }
        ],
        "workarounds": [
          "Upgrade to SkiaSharp v2.88.1 or later, which includes the fix from PR #2195",
          "Explicitly dispose all SkiaSharp objects before the application exits to avoid finalizer-based cleanup"
        ],
        "nextQuestions": [
          "What SkiaSharp version was the reporter using? If v2.88.1\u002B then the TOCTOU race in the null-check is still theoretically possible."
        ],
        "resolution": {
          "hypothesis": "The reporter was using a SkiaSharp version prior to v2.88.1 which lacked the null-check guard in NonAlertableWin32Lock.Enter(). During WinForms app shutdown, non-deterministic finalizer ordering caused the CRITICAL_SECTION to be freed before all SKObjects were finalized.",
          "proposals": [
            {
              "description": "Upgrade to SkiaSharp v2.88.1 or later which includes the null-check fix from PR #2195. This prevents the AccessViolationException by skipping the critical section entry when the lock has already been finalized.",
              "title": "Upgrade SkiaSharp to v2.88.1\u002B",
              "confidence": 0.92,
              "effort": "trivial"
            },
            {
              "description": "Dispose all SkiaSharp objects explicitly (via using statements or Dispose() calls) before the application exits. This avoids relying on the GC finalizer, which has non-deterministic ordering during AppDomain unload.",
              "title": "Explicit disposal before exit",
              "confidence": 0.8,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Upgrade SkiaSharp to v2.88.1\u002B",
          "recommendedReason": "The fix is trivial (NuGet version bump) and directly addresses the root cause. The fix has been shipping since August 2022."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-duplicate",
          "confidence": 0.92,
          "reason": "Identical stack trace and root cause as #2194, fixed by PR #2195 in v2.88.1. Reporter provided no version info but the crash signature matches exactly. Issue was already closed with no comments."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, core area, and Windows labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic"
            ]
          },
          {
            "type": "link-duplicate",
            "description": "Mark as duplicate of #2194 \u2014 same AccessViolationException in NonAlertableWin32Lock finalizer race",
            "risk": "medium",
            "confidence": 0.92,
            "linkedIssue": 2194
          },
          {
            "type": "add-comment",
            "description": "Post explanation of the known issue and the fix version",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for reporting this. This is a known finalizer ordering issue on Windows where the native CRITICAL_SECTION used by SkiaSharp\u0027s handle dictionary can be freed before all SkiaSharp objects are finalized during app shutdown.\n\nThis was fixed in SkiaSharp v2.88.1 (PR #2195). If you\u0027re on an earlier version, upgrading should resolve the crash. As a general best practice, explicitly disposing SkiaSharp objects (via \u0060using\u0060 statements) before your application exits will also prevent finalizer-related issues.\n\nClosing as duplicate of #2194."
          },
          {
            "type": "close-issue",
            "description": "Close as duplicate of #2194",
            "risk": "medium",
            "confidence": 0.9
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2421,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:53:00Z",
        "currentLabels": []
      },
      "summary": "DllNotFoundException for libSkiaSharp.framework on real iOS device \u2014 works on simulator and Android. Likely iOS managed linker stripping the native framework or Hot Restart limitation.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.85
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.92
        },
        "platforms": [
          "os/iOS"
        ],
        "tenets": [
          "tenet/compatibility"
        ],
        "partner": "partner/maui"
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a .NET MAUI app using OxyPlot.Maui.Skia (or any SkiaSharp consumer)",
            "Add SkiaSharp.Views.Maui.Controls 2.88.3 and SkiaSharp.HarfBuzz 2.88.3",
            "Deploy to iOS simulator \u2014 works",
            "Deploy to real iOS device \u2014 crashes with DllNotFoundException"
          ],
          "environmentDetails": "SkiaSharp 2.88.3, .NET MAUI, iOS real device (specific device/version unknown)",
          "relatedIssues": [
            2437,
            1129,
            1264,
            1770
          ],
          "repoLinks": [
            {
              "url": "https://github.com/iniceice88/OxyPlot.Maui.Skia",
              "description": "Third-party OxyPlot MAUI library using SkiaSharp"
            }
          ]
        },
        "bugSignals": {
          "severity": "high",
          "errorType": "crash",
          "errorMessage": "@rpath/libSkiaSharp.framework/libSkiaSharp",
          "stackTrace": "at SkiaSharp.SKPaint..ctor() \u2192 OxyPlot.Maui.Skia.SkiaRenderContext..ctor()",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net7.0-ios"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.3"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "SkiaSharp 2.88.x is superseded by 3.x which has improved MAUI integration and iOS packaging. The underlying cause (linker stripping or Hot Restart) may still affect 3.x in certain configurations, but the version is very outdated."
        }
      },
      "analysis": {
        "summary": "DllNotFoundException on real iOS device but not simulator. The native framework libSkiaSharp.framework is not being loaded at runtime. Three known causes match: (1) iOS managed linker stripping the native framework, (2) Windows Hot Restart not supporting native frameworks, (3) third-party library not propagating NativeAssets correctly.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SkiaApi.cs",
            "finding": "iOS uses \u0060@rpath/libSkiaSharp.framework/libSkiaSharp\u0060 as the P/Invoke library name. This requires the .framework bundle to be embedded in the app\u0027s Frameworks/ directory with correct rpath.",
            "relevance": "direct",
            "lines": "9-13"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.iOS/SkiaSharp.NativeAssets.iOS.csproj",
            "finding": "Package includes framework bundles for both \u0060runtimes/ios/native/\u0060 and \u0060runtimes/iossimulator/native/\u0060. The packaging is correct \u2014 the issue is downstream (linker or deployment tool).",
            "relevance": "direct",
            "lines": "8-10"
          },
          {
            "file": "binding/IncludeNativeAssets.SkiaSharp.targets",
            "finding": "iOS framework is included via NativeReference with Kind=\u0027Framework\u0027, conditioned on RuntimeIdentifier. For non-simulator (real device), uses \u0060ios/libSkiaSharp.framework\u0060. This is the standard approach for iOS native framework bundling.",
            "relevance": "context",
            "lines": "28-31"
          },
          {
            "file": "binding/SkiaSharp.NativeAssets.iOS/buildTransitive/SkiaSharp.targets",
            "finding": "The buildTransitive targets file is empty \u2014 no additional MSBuild logic for ensuring the framework survives linker passes. This may contribute to the linker stripping issue.",
            "relevance": "related"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes a crash (DllNotFoundException) that prevents SkiaSharp from functioning on real iOS devices. Area is libSkiaSharp.native because the root cause is native library deployment/loading, not the managed wrapper. The \u0027works on simulator, fails on device\u0027 pattern is a strong signal for linker stripping \u2014 the simulator uses a different code signing and linking pipeline. Issue #2437 (identical error, same SkiaSharp version, filed 3 weeks later) was resolved by community identifying two root causes: MtouchLink stripping the framework, and Windows Hot Restart not supporting native frameworks. Severity is high because the app is completely non-functional on physical iOS devices.",
        "keySignals": [
          {
            "text": "\u0027@rpath/libSkiaSharp.framework/libSkiaSharp\u0027",
            "source": "issue body (stack trace)",
            "interpretation": "The iOS-specific P/Invoke path for libSkiaSharp. DllNotFoundException here means the .framework bundle is not in the app bundle at runtime."
          },
          {
            "text": "it works in the emulator but not on a real device",
            "source": "issue body",
            "interpretation": "Classic signal for iOS linker stripping native frameworks. The simulator uses a different build pipeline (no signing, different linking) that preserves the framework."
          },
          {
            "text": "it works good on android and iOS simulator but not on a real IOS device",
            "source": "issue body",
            "interpretation": "Cross-platform confirmation rules out a SkiaSharp code bug. The managed code is correct \u2014 the native binary isn\u0027t being deployed."
          },
          {
            "text": "I have built a release build since I saw one post claiming you need to build it in release mode for the DLL to show up",
            "source": "issue body",
            "interpretation": "Reporter tried release mode, still fails. This rules out debug-only configuration issues but not linker behavior (which is typically more aggressive in release)."
          }
        ],
        "errorFingerprint": "DllNotFoundException:@rpath/libSkiaSharp.framework/libSkiaSharp:ios-device",
        "workarounds": [
          "Add \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E to the iOS .csproj to disable the managed linker (prevents framework stripping)",
          "For release builds, use \u003CMtouchLink\u003ESdkOnly\u003C/MtouchLink\u003E instead of full linking to preserve the native framework",
          "Ensure you are NOT using Windows Hot Restart for iOS deployment \u2014 it doesn\u0027t support native framework embedding. Deploy from a Mac.",
          "Add SkiaSharp.Views.Maui.Controls as a direct PackageReference in the application project (not just in the library) to ensure NativeAssets flow correctly",
          "Upgrade to SkiaSharp 3.x which has improved .NET MAUI integration"
        ],
        "nextQuestions": [
          "Is the reporter using Windows Hot Restart or deploying from a Mac?",
          "What specific iOS device and iOS version is being used?",
          "Does adding \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E resolve the issue?",
          "Is the NativeAssets.iOS package present in the build output?"
        ],
        "resolution": {
          "hypothesis": "The iOS managed linker strips the libSkiaSharp.framework from the app bundle during the build for real devices. The simulator build pipeline doesn\u0027t perform the same linking, which is why it works there. Alternatively, deploying via Windows Hot Restart doesn\u0027t embed native frameworks at all.",
          "proposals": [
            {
              "description": "Add \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E to the .csproj for the iOS target. This prevents the managed linker from stripping the native framework. For release builds, use \u003CMtouchLink\u003ESdkOnly\u003C/MtouchLink\u003E instead.",
              "title": "Disable iOS linker",
              "codeSnippet": "\u003CPropertyGroup Condition=\u0022$(TargetFramework.Contains(\u0027-ios\u0027))\u0022\u003E\n  \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E\n\u003C/PropertyGroup\u003E",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "If using Visual Studio on Windows with Hot Restart, switch to deploying from a Mac. Hot Restart does not support embedding native frameworks.",
              "title": "Deploy from Mac instead of Hot Restart",
              "confidence": 0.6,
              "effort": "trivial"
            },
            {
              "description": "Add SkiaSharp and SkiaSharp.Views.Maui.Controls as direct PackageReference in the executable MAUI project, not just via the OxyPlot.Maui.Skia transitive reference. This ensures NativeAssets.iOS is properly resolved.",
              "title": "Direct PackageReference in app project",
              "codeSnippet": "\u003CPackageReference Include=\u0022SkiaSharp.Views.Maui.Controls\u0022 Version=\u00222.88.3\u0022 /\u003E",
              "confidence": 0.65,
              "effort": "trivial"
            },
            {
              "description": "SkiaSharp 3.x includes improved MAUI integration and iOS packaging. Upgrading may resolve the deployment issue.",
              "title": "Upgrade to SkiaSharp 3.x",
              "confidence": 0.55,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Disable iOS linker",
          "recommendedReason": "This was confirmed as working by a community member in #2437. Simplest change with immediate effect. For production, can be refined to SdkOnly linking."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.78,
          "reason": "This is a well-understood iOS deployment issue with multiple workarounds identified in #2437. The issue is 3 years old with no comments, using outdated SkiaSharp 2.88.3. The same issue was already reported and resolved in #2437."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, native, iOS, MAUI labels",
            "risk": "low",
            "confidence": 0.92,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "os/iOS",
              "partner/maui"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #2437 (identical error, has community workarounds)",
            "risk": "low",
            "confidence": 0.95,
            "linkedIssue": 2437
          },
          {
            "type": "add-comment",
            "description": "Post diagnosis with workarounds from #2437",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the report. This is a known issue with the iOS managed linker stripping the native \u0060libSkiaSharp.framework\u0060 from the app bundle when deploying to real devices. The simulator uses a different build pipeline that doesn\u0027t have this problem.\n\nHere are workarounds you can try:\n\n1. **Disable the iOS linker** \u2014 add this to your \u0060.csproj\u0060:\n\n\u0060\u0060\u0060xml\n\u003CPropertyGroup Condition=\u0022$(TargetFramework.Contains(\u0027-ios\u0027))\u0022\u003E\n  \u003CMtouchLink\u003ENone\u003C/MtouchLink\u003E\n\u003C/PropertyGroup\u003E\n\u0060\u0060\u0060\n\nFor release builds, use \u0060\u003CMtouchLink\u003ESdkOnly\u003C/MtouchLink\u003E\u0060 instead.\n\n2. **If deploying from Windows with Hot Restart** \u2014 switch to deploying from a Mac. Hot Restart doesn\u0027t support embedding native frameworks.\n\n3. **Add a direct PackageReference** to \u0060SkiaSharp.Views.Maui.Controls\u0060 in your application project (not just via OxyPlot.Maui.Skia).\n\nSee also #2437 which has the same error and additional discussion. Additionally, upgrading to SkiaSharp 3.x may help as it has improved MAUI packaging."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 2383,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:53:16Z",
        "currentLabels": []
      },
      "summary": "Question: Does SkiaSharp support a 24-bit RGB color type (Format24bppRgb equivalent from System.Drawing)?",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        }
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            1176
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "Skia\u0027s color type set has never included a 24-bit (3 bytes per pixel) type. Rgb888x is still 32-bit. This limitation is inherent to the Skia library and hasn\u0027t changed."
        }
      },
      "analysis": {
        "summary": "User asks whether SkiaSharp supports a 24-bit pixel format equivalent to System.Drawing.Imaging.PixelFormat.Format24bppRgb. Skia (and therefore SkiaSharp) does not support a true 24-bit (3 bytes per pixel) color type. The closest option is SKColorType.Rgb888x, which stores R, G, B in 8 bits each but uses a 32-bit word (4 bytes per pixel with the alpha byte ignored). The user can convert 24bpp data to 32bpp by expanding each pixel with a padding byte.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "SKColorType enum has no 24-bit (3 bytes per pixel) entry. Smallest RGB type with 8 bits per channel is Rgb888x at 4 bytes per pixel.",
            "relevance": "direct",
            "lines": "36-63"
          },
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "GetBytesPerPixel confirms Rgb888x returns 4 bytes, not 3. No color type returns 3 bytes per pixel.",
            "relevance": "direct",
            "lines": "79-115"
          },
          {
            "file": "externals/skia/include/core/SkColorType.h",
            "finding": "Upstream Skia defines kRGB_888x_SkColorType as \u0027pixel with 8 bits each for red, green, blue; in 32-bit word\u0027 \u2014 confirms the padding byte at C\u002B\u002B level.",
            "relevance": "context",
            "lines": "25"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "InstallPixels accepts SKImageInfo with custom colorType and rowBytes \u2014 user can use this with Rgb888x after converting pixel data from 24bpp to 32bpp.",
            "relevance": "direct",
            "lines": "591-615"
          }
        ],
        "rationale": "Classified as question because the user asks \u0027does skia support...\u0027 \u2014 there is no bug or feature request. Area is core SkiaSharp since SKColorType and SKImageInfo are in the binding/SkiaSharp layer. Issue #1176 asked the same question about BGR888 and was answered by the maintainer confirming no 24-bit type exists.",
        "keySignals": [
          {
            "text": "I want to convert an image which is in 24-bit color type to SKBitmap",
            "source": "issue body",
            "interpretation": "User has raw 24bpp pixel data and needs to load it into SkiaSharp. This is a usage question, not a bug."
          },
          {
            "text": "use 8 bits for each colors, no alpha, necessary to specify width, height and stride",
            "source": "issue body",
            "interpretation": "User understands the format requirements. They need to know the closest SKColorType and how to use InstallPixels."
          },
          {
            "text": "Does SKColorType support BGR888 type? \u2014 Unfortunately not at this point. There is a RGB 888x, but that is still 32-bit pixels.",
            "source": "issue #1176, mattleibow comment",
            "interpretation": "Identical question previously answered. Confirms Skia has no 24-bit color type."
          }
        ],
        "workarounds": [
          "Use SKColorType.Rgb888x with SKAlphaType.Opaque \u2014 this uses 4 bytes per pixel (R, G, B \u002B padding byte). Convert 24bpp source data to 32bpp by inserting a 0xFF padding byte after every 3 bytes.",
          "Use SKBitmap.Decode or SKImage.FromEncodedData to load encoded image files (PNG, JPEG, BMP) \u2014 Skia automatically converts from the file\u0027s pixel format to an appropriate internal format."
        ],
        "resolution": {
          "hypothesis": "User needs to load raw 24bpp pixel data into an SKBitmap. Since Skia has no 24-bit color type, the data must be expanded to 32bpp first.",
          "proposals": [
            {
              "description": "Convert the 24-bit pixel data to 32-bit by inserting a padding byte (0xFF) for each pixel, then use SKBitmap with SKColorType.Rgb888x and SKAlphaType.Opaque.",
              "title": "Expand 24bpp to Rgb888x",
              "codeSnippet": "// Convert 24bpp RGB data to 32bpp for SKBitmap\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex];     // R\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex \u002B 2]; // B\n            dest[3] = 0xFF;                   // padding\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();",
              "confidence": 0.9,
              "effort": "small"
            },
            {
              "description": "Alternatively, expand to BGRA format with alpha set to 0xFF. This is the platform-native format on most systems and may perform better for drawing.",
              "title": "Use Bgra8888 with Opaque alpha",
              "codeSnippet": "var info = new SKImageInfo(width, height, SKColorType.Bgra8888, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex \u002B 2]; // B\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex];     // R\n            dest[3] = 0xFF;                   // A\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "If the source is an image file (not raw pixels), use SKBitmap.Decode() which handles format conversion automatically.",
              "title": "Load from encoded file",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Expand 24bpp to Rgb888x",
          "recommendedReason": "Most direct translation of the user\u0027s requirements. Preserves the RGB channel order and is the closest SkiaSharp type to Format24bppRgb."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.9,
          "reason": "This is a usage question fully answerable from existing API knowledge. Same question was answered in #1176. No code change needed."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply question and core SkiaSharp labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/question",
              "area/SkiaSharp"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post answer explaining no 24-bit type exists and provide workaround code",
            "risk": "high",
            "confidence": 0.9,
            "comment": "SkiaSharp (and the underlying Skia library) does not have a true 24-bit (3 bytes per pixel) color type. All pixel formats use 1, 2, 4, 8, or 16 bytes per pixel.\n\nThe closest equivalent is \u0060SKColorType.Rgb888x\u0060, which stores 8 bits each for red, green, and blue in a **32-bit word** (the 4th byte is padding). To load 24bpp data, expand it to 32bpp by writing directly into the bitmap\u0027s pixel buffer:\n\n\u0060\u0060\u0060csharp\nvar info = new SKImageInfo(width, height, SKColorType.Rgb888x, SKAlphaType.Opaque);\nvar bitmap = new SKBitmap(info);\nvar destPtr = bitmap.GetPixels();\n\nunsafe\n{\n    byte* dest = (byte*)destPtr;\n    int srcIndex = 0;\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n    {\n        for (int x = 0; x \u003C width; x\u002B\u002B)\n        {\n            dest[0] = pixels24[srcIndex];     // R\n            dest[1] = pixels24[srcIndex \u002B 1]; // G\n            dest[2] = pixels24[srcIndex \u002B 2]; // B\n            dest[3] = 0xFF;                   // padding\n            dest \u002B= 4;\n            srcIndex \u002B= 3;\n        }\n    }\n}\nbitmap.NotifyPixelsChanged();\n\u0060\u0060\u0060\n\nIf you\u0027re loading an encoded image file (PNG, JPEG, BMP), \u0060SKBitmap.Decode()\u0060 handles format conversion automatically \u2014 no manual pixel expansion needed.\n\nSee also #1176 which covers the same topic."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1176 (same question about 24-bit color type)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 1176
          },
          {
            "type": "close-issue",
            "description": "Close as answered",
            "risk": "medium",
            "confidence": 0.85
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 1898,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:53:16Z",
        "currentLabels": []
      },
      "summary": "Reporter observes that SkiaSharp.Views.Forms 2.88.0-preview.179 has an empty netcoreapp3.1 directory in NuGet Package Explorer. The directory actually contains _._placeholder files, which is a standard NuGet convention for declaring TFM support without dedicated assemblies \u2014 the netstandard2.0 assembly is used at runtime. Both netcoreapp3.1 (EOL Dec 2022) and Xamarin.Forms (superseded by MAUI) are obsolete, and SkiaSharp 3.x removed Views.Forms entirely.",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Install SkiaSharp.Views.Forms 2.88.0-preview.179",
            "Open the package in NuGet Package Explorer",
            "Observe the netcoreapp3.1 directory appears empty"
          ],
          "relatedIssues": [
            1561,
            1774
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "2.88.0-preview.127",
            "2.88.0-preview.179"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "The issue concerns netcoreapp3.1 support in SkiaSharp.Views.Forms, both of which are obsolete. netcoreapp3.1 reached EOL December 2022. Xamarin.Forms has been superseded by .NET MAUI. SkiaSharp 3.x removed Views.Forms entirely (PR #2505)."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.9,
          "reason": "The _._files in the netcoreapp3.1 directory are intentional NuGet packaging \u2014 they declare TFM support while falling back to netstandard2.0 assemblies. The stable 2.88.0 release shipped with the same packaging and netcoreapp3.1 WPF apps worked. The perceived \u0027missing DLLs\u0027 were never actually missing; the netstandard2.0 assembly provides the runtime support. Additionally, the entire Views.Forms package was removed in SkiaSharp 3.x.",
          "relatedPRs": [
            1774
          ]
        }
      },
      "analysis": {
        "summary": "The reporter misidentified NuGet _._placeholder files as missing DLL content. The netcoreapp3.1 support in SkiaSharp.Views.Forms was added via PR #1774 using the standard NuGet convention: _._placeholders in lib/netcoreapp3.1/ declare TFM compatibility while the netstandard2.0 assembly provides the actual runtime implementation. The .targets file in build/netcoreapp3.1/ handles WPF build integration. This is working-as-designed NuGet packaging, not a bug.",
        "codeInvestigation": [
          {
            "file": "nuget/SkiaSharp.Views.Forms.nuspec",
            "finding": "At v2.88.0-preview.179, the nuspec includes: dependency group for netcoreapp3.1 (with Xamarin.Forms and Xamarin.Forms.Platform.WPF), _._placeholder files in lib/netcoreapp3.1/ and ref/netcoreapp3.1/, and the SkiaSharp.Views.Forms.targets file copied to build/netcoreapp3.1/. This is the correct NuGet packaging pattern for declaring TFM support via netstandard fallback.",
            "relevance": "direct"
          },
          {
            "file": "nuget/SkiaSharp.Views.Forms.nuspec",
            "finding": "The nuspec was completely removed in commit bc5020b9e (PR #2505 \u2014 \u0027Modernize the repository and prepare SkiaSharp 3.0\u0027). SkiaSharp 3.x does not include Views.Forms at all, making this issue moot for current versions.",
            "relevance": "related"
          }
        ],
        "rationale": "Classified as type/question because the reporter describes expected behavior (empty directory in NuGet Package Explorer) as a bug, but the _._files ARE the intended support mechanism. The nuspec at v2.88.0-preview.179 correctly declares netcoreapp3.1 with _._placeholders, dependency groups, and .targets files \u2014 matching the pattern added in PR #1774. This is area/SkiaSharp.Views.Forms as it concerns the Views.Forms NuGet package specifically. Platform is Windows-Classic because netcoreapp3.1 \u002B Xamarin.Forms.WPF is the WPF desktop scenario.",
        "keySignals": [
          {
            "text": "netcoreapp3.1 directory is empty in Nuget Package Explorer",
            "source": "issue body",
            "interpretation": "Reporter is viewing _._placeholder files, which NuGet Package Explorer may display as empty. This is standard NuGet packaging for declaring TFM support without dedicated assemblies."
          },
          {
            "text": "Support for netcore 3.1 was added in 2.88.0-preview.127",
            "source": "issue body",
            "interpretation": "Correctly identifies PR #1774. The support WAS added \u2014 via _._placeholders \u002B netstandard2.0 fallback, not dedicated assemblies."
          },
          {
            "text": "nuspec includes _._in lib/netcoreapp3.1/ and ref/netcoreapp3.1/, plus .targets file",
            "source": "code search (v2.88.0-preview.179:nuget/SkiaSharp.Views.Forms.nuspec)",
            "interpretation": "Confirms the packaging is intentional and correct. The _._marker \u002B .targets file is the standard pattern for framework compatibility."
          }
        ],
        "workarounds": [
          "The netcoreapp3.1 support is working as designed \u2014 the _._files are NuGet placeholders that cause the netstandard2.0 assembly to be used at runtime. No workaround needed.",
          "For modern development, migrate to SkiaSharp.Views.Maui (for .NET MAUI) or SkiaSharp.Views.WPF (for WPF on .NET 6\u002B)."
        ],
        "resolution": {
          "hypothesis": "The reporter misunderstood NuGet _._placeholder files as missing content. The netcoreapp3.1 directory intentionally contains only _._files because the actual assembly comes from netstandard2.0 fallback resolution.",
          "proposals": [
            {
              "description": "The _._files are the standard NuGet mechanism for declaring TFM support without dedicated assemblies. The netstandard2.0 assembly provides the runtime implementation for netcoreapp3.1. Both TFMs (netcoreapp3.1 and Xamarin.Forms) are now obsolete.",
              "title": "Close as by-design",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Migrate from Xamarin.Forms \u002B netcoreapp3.1 to .NET MAUI \u002B net8.0 (or later) with SkiaSharp.Views.Maui. This is the supported path forward.",
              "title": "Upgrade to modern stack",
              "confidence": 0.95,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Close as by-design",
          "recommendedReason": "The packaging is correct \u2014 _._files are intentional NuGet convention. The issue doesn\u0027t describe any actual runtime failure. Both netcoreapp3.1 and Xamarin.Forms are EOL."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.88,
          "reason": "The _._files are working-as-designed NuGet packaging. No runtime issue was reported. Both netcoreapp3.1 and Xamarin.Forms are EOL, and SkiaSharp 3.x has removed Views.Forms entirely."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply question and Views.Forms labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/question",
              "area/SkiaSharp.Views.Forms",
              "os/Windows-Classic",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Explain NuGet _._convention and obsolescence of netcoreapp3.1 \u002B Xamarin.Forms",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report. The \u0060netcoreapp3.1\u0060 directory in the NuGet package intentionally contains \u0060_._\u0060 placeholder files \u2014 this is a standard NuGet convention that declares framework compatibility while using the \u0060netstandard2.0\u0060 assembly at runtime. The \u0060.targets\u0060 file in \u0060build/netcoreapp3.1/\u0060 handles the WPF build integration. So the package does support netcoreapp3.1; it just doesn\u0027t need a dedicated assembly for it.\n\nThat said, both \u0060netcoreapp3.1\u0060 and \u0060Xamarin.Forms\u0060 have reached end-of-life. For new projects, SkiaSharp 3.x with \u0060SkiaSharp.Views.Maui\u0060 (for .NET MAUI) or \u0060SkiaSharp.Views.WPF\u0060 (for WPF on .NET 8\u002B) is the supported path forward."
          },
          {
            "type": "close-issue",
            "description": "Close as answered \u2014 packaging is by-design and both technologies are EOL",
            "risk": "medium",
            "confidence": 0.85
          },
          {
            "type": "link-related",
            "description": "Cross-reference original netcoreapp3.1 support issue",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 1561
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 1773,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:47:00Z",
        "currentLabels": []
      },
      "summary": "Accidental/test issue with no technical content \u2014 self-closed immediately by reporter",
      "classification": {
        "type": {
          "value": "type/question",
          "confidence": 0.4
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.3
        }
      },
      "evidence": {
        "versionAnalysis": {
          "currentRelevance": "unlikely",
          "relevanceReason": "Issue has no technical content \u2014 title is \u0027TO DELETE PLEASE\u0027 with an empty body. Reporter self-closed within 26 minutes."
        }
      },
      "analysis": {
        "summary": "Empty issue opened accidentally or as a test. Title is \u0027TO DELETE PLEASE\u0027, body is empty, no comments. Reporter (vd3d) closed it themselves within 26 minutes. Issue is now locked with reason \u0027resolved\u0027.",
        "codeInvestigation": [
          {
            "file": "N/A",
            "finding": "No code investigation possible \u2014 issue contains no technical content, no types, no methods, no error messages, and no description of any behavior.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/question with low confidence because no type label fits an empty/accidental issue. Area defaults to area/SkiaSharp since no component is mentioned. No investigation is possible \u2014 there is zero technical content to analyze.",
        "keySignals": [
          {
            "text": "TO DELETE PLEASE",
            "source": "issue title",
            "interpretation": "Reporter explicitly indicates this issue was created in error and should be removed."
          },
          {
            "text": "Body is empty string",
            "source": "issue body",
            "interpretation": "No bug report, question, or feature request was ever filed."
          },
          {
            "text": "Closed by same user (vd3d) within 26 minutes",
            "source": "issue metadata",
            "interpretation": "Self-closed \u2014 reporter recognized the mistake immediately."
          }
        ]
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.99,
          "reason": "Issue is already closed and locked. It was an accidental creation with no technical content \u2014 no further action needed."
        },
        "actions": []
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 911,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:46:26Z",
        "currentLabels": []
      },
      "summary": "Feature request to add a \u0027Getting Started\u0027 section to README.md with curated links to introductory tutorials, platform-specific guides (Xamarin Forms, WPF, etc.), and API documentation to help new users find resources quickly.",
      "classification": {
        "type": {
          "value": "type/documentation",
          "confidence": 0.92
        },
        "area": {
          "value": "area/Docs",
          "confidence": 0.95
        }
      },
      "evidence": {
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The README still lacks a dedicated \u0027Getting Started\u0027 section. While badge links to API docs and guides exist in the header, there is no curated section with introductory tutorials or platform-specific guides."
        }
      },
      "analysis": {
        "summary": "The reporter requests a \u0027Getting Started\u0027 section in README.md to centralize learning resources for new users. The README currently has badge links to API docs and guides in the header and a \u0027Using SkiaSharp\u0027 section with NuGet install instructions, but no curated onboarding section with tutorials or platform-specific guides. The request is straightforward documentation improvement.",
        "codeInvestigation": [
          {
            "file": "README.md",
            "finding": "Badge links to SkiaSharp API Docs, HarfBuzzSharp API Docs, and SkiaSharp Guides exist but are small badges in the header \u2014 easy to miss for newcomers.",
            "relevance": "direct",
            "lines": "11-13"
          },
          {
            "file": "README.md",
            "finding": "The \u0027Using SkiaSharp\u0027 section only covers NuGet installation. No tutorial links, no getting started guidance, no platform-specific setup instructions.",
            "relevance": "direct",
            "lines": "38-55"
          },
          {
            "file": "README.md",
            "finding": "The \u0027Building SkiaSharp\u0027 section links to documentation/building.md \u2014 shows precedent for linking to detailed guides from README.",
            "relevance": "context",
            "lines": "57-64"
          },
          {
            "file": "documentation/",
            "finding": "Contains architecture, building, packages, and API design docs. No \u0027getting-started.md\u0027 or tutorial content exists in the repo.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/documentation (not feature-request) because the ask is specifically about improving documentation content in README.md \u2014 no code changes needed. Area is area/Docs since it\u0027s purely about documentation structure. The request remains relevant: while the README has some doc links as badges, it still lacks the kind of curated \u0027Getting Started\u0027 section the reporter describes. Note that some of the specific links suggested by the reporter (Xamarin-era tutorials) may now be outdated and would need updating to current .NET/MAUI equivalents.",
        "keySignals": [
          {
            "text": "I am just starting with using SkiaSharp and the first thing I noticed was it wasn\u0027t obvious as to where to go to get started",
            "source": "issue body",
            "interpretation": "New user perspective \u2014 onboarding friction is real. README is the first thing users see."
          },
          {
            "text": "Could we add a \u0027Getting Started\u0027 to the readme.md?",
            "source": "issue body",
            "interpretation": "Concrete, actionable proposal with example content structure."
          },
          {
            "text": "I\u0027d be happy to collaborate on this and help out",
            "source": "issue body",
            "interpretation": "Reporter offered to contribute \u2014 could be invited to submit a PR."
          }
        ],
        "nextQuestions": [
          "Which tutorials and guides should be linked? The Xamarin-era links suggested in 2019 may be outdated.",
          "Should the Getting Started section link to Microsoft Learn docs for MAUI/SkiaSharp integration?",
          "Should the repo include its own getting-started guide, or just link to external resources?"
        ],
        "resolution": {
          "hypothesis": "The README lacks a discoverable \u0027Getting Started\u0027 section. Adding one with curated links to current documentation would improve the new user experience.",
          "proposals": [
            {
              "description": "Add a \u0027Getting Started\u0027 section between the introductory paragraph and \u0027Using SkiaSharp\u0027, with links to the Microsoft Learn SkiaSharp guides, API documentation, and platform-specific setup guides. Update the suggested links from the 2019 issue to current .NET/MAUI equivalents.",
              "title": "Add Getting Started section to README",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Since the reporter offered to collaborate, invite them to submit a PR with their proposed Getting Started section. This leverages their newcomer perspective for the best onboarding content.",
              "title": "Invite reporter to submit PR",
              "confidence": 0.7,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Add Getting Started section to README",
          "recommendedReason": "Low effort, high impact for new users. Can be done by maintainer or invited contributor. The reporter\u0027s template is a good starting point but needs updated links."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Valid documentation improvement that hasn\u0027t been addressed. The README still lacks a Getting Started section. Low effort to implement."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply documentation and docs area labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/documentation",
              "area/Docs"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the request and note that links need updating for current .NET ecosystem",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for this suggestion \u2014 a Getting Started section in the README would definitely help new users find their way.\n\nThe README currently has badge links to the API docs and guides, but they\u0027re easy to miss. A dedicated section with curated links would be a nice improvement.\n\nNote that some of the links you suggested (the Xamarin-era tutorials) have been superseded by newer .NET/MAUI resources. An updated version would want to link to the current Microsoft Learn documentation. If you\u0027re still interested in contributing this, a PR would be welcome."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 754,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:54:00Z",
        "currentLabels": [
          "type/bug"
        ]
      },
      "summary": "SKBitmap.Decode with SKColorType.Gray8 returns null because SKImageInfo constructor defaults AlphaType to Premul \u2014 Gray8 requires Opaque",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Load a grayscale 8-bit PNG into a MemoryStream",
            "Create an SKCodec from the stream",
            "Create SKImageInfo with SKColorType.Gray8 (using 3-param constructor: width, height, colorType)",
            "Call SKBitmap.Decode(codec, imageInfo)",
            "bitmap is null"
          ],
          "screenshots": [
            {
              "url": "https://user-images.githubusercontent.com/5593825/51076794-aecf2b80-169d-11e9-9b9b-1c01eeb20467.png",
              "description": "Test grayscale 8-bit PNG image"
            }
          ],
          "environmentDetails": "SkiaSharp 1.68.0 originally, confirmed still present in 3.119.1",
          "relatedIssues": [
            694,
            2787,
            806,
            3385
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "wrong-output",
          "errorMessage": "SKBitmap.Decode returns null when decoding Gray8 PNG with SKColorType.Gray8",
          "reproQuality": "complete",
          "targetFrameworks": [
            "netcoreapp3.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.60.3",
            "1.68.0",
            "3.119.1"
          ],
          "workedIn": "1.60.3",
          "brokeIn": "1.68.0",
          "currentRelevance": "likely",
          "relevanceReason": "The SKImageInfo constructor still defaults AlphaType to Premul in the 3-param overload, and SKBitmap.Decode does not correct the alpha type for Gray8. The code path is unchanged."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.85,
          "reason": "Reporter states Gray8 decoding worked in 1.60.3 (BytesPerPixel == 1) but broke in 1.68.0. Skia\u0027s codec behavior changed to validate alpha type more strictly \u2014 the SkiaSharp wrapper didn\u0027t adapt.",
          "workedInVersion": "1.60.3",
          "brokeInVersion": "1.68.0"
        }
      },
      "analysis": {
        "summary": "SKBitmap.Decode returns null for Gray8 images because the SKImageInfo 3-param constructor defaults AlphaType to Premul, which is invalid for Gray8. Skia\u0027s SkColorTypeValidateAlphaType requires Gray8 to use Opaque. The codec\u0027s getPixels rejects the Premul\u002BGray8 combination and returns an error, causing SkiaSharp to dispose the bitmap and return null.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKImageInfo.cs",
            "finding": "SKImageInfo(int, int, SKColorType) constructor always sets AlphaType = SKAlphaType.Premul, regardless of color type. This is invalid for Gray8 which requires Opaque.",
            "relevance": "direct",
            "lines": "77-84"
          },
          {
            "file": "binding/SkiaSharp/Definitions.cs",
            "finding": "GetAlphaType() extension method correctly maps Gray8 \u2192 Opaque (line 187-197), but this validation is NOT called by SKImageInfo constructors or SKBitmap.Decode.",
            "relevance": "direct",
            "lines": "155-198"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "Decode(codec, bitmapInfo) calls codec.GetPixels(bitmapInfo, pixels). When getPixels returns non-Success (due to invalid Premul\u002BGray8 combo), bitmap is disposed and null returned. No alpha type correction.",
            "relevance": "direct",
            "lines": "446-459"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "Decode(codec) only corrects Unpremul\u2192Premul but never checks if the color type requires Opaque alpha. Would still fail for Gray8 default path.",
            "relevance": "related",
            "lines": "434-444"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "GetPixels passes SKImageInfo directly to native sk_codec_get_pixels with no alpha type fixup. Native Skia rejects Gray8\u002BPremul.",
            "relevance": "related",
            "lines": "119-137"
          },
          {
            "file": "externals/skia/src/c/sk_codec.cpp",
            "finding": "sk_codec_get_pixels is a thin wrapper over SkCodec::getPixels \u2014 no validation is added at the C layer.",
            "relevance": "context",
            "lines": "54-55"
          }
        ],
        "rationale": "This is a clear bug: the user follows the documented pattern (create codec, create imageInfo with desired color type, decode), but SKImageInfo doesn\u0027t validate the alpha type against the color type. The 3-param constructor always sets Premul, which is correct for RGBA types but invalid for Gray8, Rgb565, and other opaque-only formats. Skia validates this constraint natively and fails silently. The existing GetAlphaType() method already contains the correct validation logic but isn\u0027t called by the constructor or Decode methods.",
        "keySignals": [
          {
            "text": "bitmap == null",
            "source": "issue body",
            "interpretation": "SKBitmap.Decode returns null \u2014 the decode itself fails, not just a wrong format."
          },
          {
            "text": "In SkiaSharp 1.60.3 loading an 8bit png would result in a bitmap with BytesPerPixel == 1. In 1.68.0, BytesPerPixel == 4",
            "source": "issue body",
            "interpretation": "Regression introduced when Skia dropped Index8 support and tightened codec validation around 1.68."
          },
          {
            "text": "now we need to pass in the codec when decoding to tell Skia it is an 8 bit image",
            "source": "issue body",
            "interpretation": "User followed advice from #694 to use codec\u002BimageInfo pattern, but the alpha type mismatch causes failure."
          },
          {
            "text": "This issue still persists in version 3.119.1",
            "source": "comment by liu7923032",
            "interpretation": "Bug confirmed present in latest version \u2014 the fundamental code path hasn\u0027t changed."
          }
        ],
        "workarounds": [
          "Use the 4-param SKImageInfo constructor with SKAlphaType.Opaque: new SKImageInfo(width, height, SKColorType.Gray8, SKAlphaType.Opaque)"
        ],
        "nextQuestions": [
          "Should SKImageInfo constructors auto-correct alpha type based on color type using GetAlphaType()?",
          "Should SKBitmap.Decode validate/fix alpha type before passing to codec, similar to how it fixes Unpremul\u2192Premul?",
          "Are other opaque-only color types (Rgb565, Rgb888x, etc.) affected by the same issue?"
        ],
        "resolution": {
          "hypothesis": "SKImageInfo defaults AlphaType to Premul for all color types. Gray8 requires Opaque per Skia\u0027s SkColorTypeValidateAlphaType. The mismatch causes codec.getPixels to fail, returning null.",
          "proposals": [
            {
              "description": "Use the 4-parameter SKImageInfo constructor to explicitly set SKAlphaType.Opaque when decoding Gray8 images.",
              "title": "Workaround: explicit Opaque alpha",
              "codeSnippet": "using var stream = new MemoryStream(bytes);\nusing var codec = SKCodec.Create(stream);\nif (codec == null) return;\nvar imageInfo = new SKImageInfo(codec.Info.Width, codec.Info.Height, SKColorType.Gray8, SKAlphaType.Opaque);\nusing var bitmap = SKBitmap.Decode(codec, imageInfo);",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "In SKBitmap.Decode(codec, bitmapInfo), call bitmapInfo.ColorType.GetAlphaType(bitmapInfo.AlphaType) to validate and correct the alpha type before passing to the codec. This matches the pattern already used for Unpremul\u2192Premul correction.",
              "title": "Fix: auto-correct alpha in SKBitmap.Decode",
              "codeSnippet": "// In SKBitmap.Decode(SKCodec codec, SKImageInfo bitmapInfo):\nbitmapInfo.AlphaType = bitmapInfo.ColorType.GetAlphaType(bitmapInfo.AlphaType);",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Have the SKImageInfo constructors call GetAlphaType() to auto-correct invalid alpha types based on the color type. This is a broader fix that prevents the issue at the source.",
              "title": "Fix: validate alpha in SKImageInfo constructors",
              "confidence": 0.65,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Workaround: explicit Opaque alpha",
          "recommendedReason": "Immediate fix the reporter can apply now. The proper code fix should also be pursued, but the workaround is trivially correct and validated."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.9,
          "reason": "Real bug with clear root cause. Workaround available. A proper fix should validate alpha types in SKBitmap.Decode or SKImageInfo constructors."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Existing type/bug label is correct. Add area label.",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post workaround with explanation of root cause",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the report \u2014 this is still a valid issue in current versions.\n\nThe root cause is that \u0060new SKImageInfo(width, height, SKColorType.Gray8)\u0060 defaults \u0060AlphaType\u0060 to \u0060Premul\u0060, but Gray8 requires \u0060Opaque\u0060. Skia\u0027s codec rejects the Premul\u002BGray8 combination and returns an error, which surfaces as \u0060null\u0060 from \u0060SKBitmap.Decode\u0060.\n\nHere\u0027s a workaround you can use now \u2014 explicitly specify \u0060SKAlphaType.Opaque\u0060:\n\n\u0060\u0060\u0060csharp\nusing var stream = new MemoryStream(bytes);\nusing var codec = SKCodec.Create(stream);\nif (codec == null) return;\nvar imageInfo = new SKImageInfo(codec.Info.Width, codec.Info.Height, SKColorType.Gray8, SKAlphaType.Opaque);\nusing var bitmap = SKBitmap.Decode(codec, imageInfo);\n\u0060\u0060\u0060\n\nWe should fix this properly by having \u0060SKBitmap.Decode\u0060 validate the alpha type against the color type before passing to the codec."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related Gray8 issues",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 2787
          },
          {
            "type": "link-related",
            "description": "Cross-reference Gray8 pixel copy issue",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 806
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 736,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:49:23Z",
        "currentLabels": [
          "type/bug",
          "type/enhancement",
          "os/macOS",
          "area/SkiaSharp.Views",
          "area/Build",
          "status/blocked"
        ]
      },
      "summary": "When switching a Cocoa app from \u0027Xamarin.Mac Modern\u0027 to \u0027Xamarin.Mac Full\u0027 target framework in Visual Studio for Mac, NuGet fails to resolve the SkiaSharp.Views.Mac namespace. The root cause was a NuGet Client limitation that treated Xamarin.Mac Full apps as .NET Framework apps, preventing correct resolution of platform-specific assemblies. Reported against SkiaSharp v1.68 on macOS 10.14.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.9
        },
        "platforms": [
          "os/macOS"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a fresh Cocoa project in Visual Studio for Mac",
            "Add SkiaSharp and SkiaSharp.Views NuGet packages (works with default \u0027Xamarin.Mac Modern\u0027)",
            "Edit the project, change General \u003E Target Framework from \u0027Xamarin.Mac Modern\u0027 to \u0027Xamarin.Mac Full\u0027",
            "Observe that SkiaSharp.Views.Mac namespace can no longer be found"
          ],
          "codeSnippets": [
            "using SkiaSharp.Views.Mac;"
          ],
          "screenshots": [
            {
              "url": "https://user-images.githubusercontent.com/756446/50108227-01e7c700-0235-11e9-9014-11f4837b2ab4.png",
              "description": "Project settings showing Xamarin.Mac Modern framework"
            },
            {
              "url": "https://user-images.githubusercontent.com/756446/50108043-8b4ac980-0234-11e9-833b-9cc401787fee.png",
              "description": "Build error showing namespace not found after switching to Xamarin.Mac Full"
            }
          ],
          "environmentDetails": "Visual Studio for Mac, macOS 10.14, SkiaSharp v1.68, Xamarin.Mac Full framework",
          "relatedIssues": [
            913
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "build-error",
          "errorMessage": "SkiaSharp.Views.Mac namespace does not exist",
          "reproQuality": "complete",
          "targetFrameworks": [
            "Xamarin.Mac Full"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.68"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "Xamarin.Mac was deprecated in May 2024. Modern SkiaSharp (v3.x) targets net8.0-macos/net9.0-macos via .NET for macOS and no longer uses Xamarin.Mac TFMs. The \u0027Xamarin.Mac Full\u0027 vs \u0027Modern\u0027 distinction no longer exists."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.92,
          "reason": "The Xamarin.Mac platform has been deprecated and replaced by .NET for macOS. SkiaSharp no longer ships Xamarin.Mac-specific assemblies \u2014 the csproj now targets net8.0-macos/net9.0-macos, which resolves the SkiaSharp.Views.Mac namespace correctly. Additionally, the NuGet Client PR (NuGet/NuGet.Client#2572) and the MigrateToNewXMIdentifier workaround addressed this for users still on Xamarin."
        }
      },
      "analysis": {
        "summary": "This was a NuGet Client packaging limitation where switching to \u0027Xamarin.Mac Full\u0027 caused NuGet to misidentify the app as a plain .NET Framework app, preventing resolution of Xamarin.Mac-specific assemblies. The maintainer diagnosed this in Dec 2018 and filed NuGet/NuGet.Client#2572 to fix it upstream. A workaround using MigrateToNewXMIdentifier was later identified. The entire issue class is now moot because Xamarin.Mac was deprecated in 2024 and SkiaSharp has migrated to modern .NET TFMs.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/SkiaSharp.Views.csproj",
            "finding": "macOS configuration uses Condition=\u0022$(TargetFramework.Contains(\u0027-macos\u0027))\u0022 to set RootNamespace=SkiaSharp.Views.Mac and AssemblyName=SkiaSharp.Views.Mac. No Xamarin.Mac TFMs remain \u2014 modern .NET resolves correctly.",
            "relevance": "direct",
            "lines": "16-19"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/macOS/SKCanvasView.cs",
            "finding": "SKCanvasView is in namespace SkiaSharp.Views.Mac and inherits from AppKit.NSView. The code itself was never broken \u2014 only NuGet\u0027s assembly resolution for Xamarin.Mac Full failed.",
            "relevance": "related",
            "lines": "1-9"
          },
          {
            "file": "source/SkiaSharp.Build.props",
            "finding": "PlatformTargetFrameworks are defined using modern .NET TFMs (net8.0-macos, net9.0-macos). No Xamarin.Mac TFMs exist anywhere in the build system.",
            "relevance": "context"
          }
        ],
        "rationale": "Classified as type/bug because the namespace resolution failure was broken behavior triggered by a valid project configuration change, not a usage question. Area is SkiaSharp.Views because the symptom was the Views.Mac namespace not resolving (though root cause was in NuGet\u0027s framework resolution). tenet/compatibility applies because this was a cross-framework compatibility issue. Severity is medium \u2014 the build broke but workarounds existed. The issue is no longer relevant due to Xamarin deprecation.",
        "keySignals": [
          {
            "text": "When you select the full framework option, the app actually \u0027transitions\u0027 from a \u0027mac app\u0027 to a \u0027.net framework app\u0027 and NuGet does not know that this particular app is actually both",
            "source": "comment #1 (mattleibow)",
            "interpretation": "Root cause diagnosed by maintainer \u2014 NuGet framework identification bug, not a SkiaSharp defect."
          },
          {
            "text": "Created a new PR that hopefully gets this in: NuGet/NuGet.Client#2572",
            "source": "comment #1 (mattleibow)",
            "interpretation": "Fix was pursued upstream in NuGet, not in SkiaSharp itself."
          },
          {
            "text": "You can add \u003CMigrateToNewXMIdentifier\u003Etrue\u003C/MigrateToNewXMIdentifier\u003E in your project",
            "source": "comment #2 (mattleibow)",
            "interpretation": "A project-level workaround was eventually found via NuGet improvements."
          },
          {
            "text": "SkiaSharp.Views.csproj targets net8.0-macos with RootNamespace SkiaSharp.Views.Mac",
            "source": "code search",
            "interpretation": "Modern SkiaSharp resolves this namespace correctly using .NET TFMs, making the Xamarin-era issue moot."
          }
        ],
        "workarounds": [
          "Use packages.config and change the HintPath to the Xamarin.Mac version of the assembly",
          "Don\u0027t reference the SkiaSharp.Views package; manually add a reference to SkiaSharp.Views.Mac.dll",
          "Add \u003CMigrateToNewXMIdentifier\u003Etrue\u003C/MigrateToNewXMIdentifier\u003E to the project file"
        ],
        "resolution": {
          "hypothesis": "NuGet\u0027s framework identification treated Xamarin.Mac Full apps as .NET Framework apps, so platform-specific assemblies (like SkiaSharp.Views.Mac) were not resolved. This was an upstream NuGet limitation, not a SkiaSharp code defect.",
          "proposals": [
            {
              "description": "Xamarin.Mac has been deprecated since May 2024. Modern SkiaSharp (v3.x) uses .NET for macOS TFMs which resolve correctly. Users should migrate to .NET 8\u002B for macOS.",
              "title": "Close as resolved by platform migration",
              "confidence": 0.92,
              "effort": "trivial"
            },
            {
              "description": "For users still on legacy Xamarin.Mac, adding \u003CMigrateToNewXMIdentifier\u003Etrue\u003C/MigrateToNewXMIdentifier\u003E to the csproj causes NuGet to correctly identify the project as a macOS app.",
              "title": "MigrateToNewXMIdentifier workaround",
              "codeSnippet": "\u003CMigrateToNewXMIdentifier\u003Etrue\u003C/MigrateToNewXMIdentifier\u003E",
              "confidence": 0.8,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Close as resolved by platform migration",
          "recommendedReason": "Xamarin.Mac is deprecated and the root cause no longer exists in modern .NET. The MigrateToNewXMIdentifier workaround serves anyone still stuck on legacy Xamarin."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.9,
          "reason": "The root cause (NuGet misidentifying Xamarin.Mac Full apps) is no longer relevant \u2014 Xamarin.Mac is deprecated and SkiaSharp now targets modern .NET TFMs. Workarounds were provided by the maintainer for legacy users."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Correct labels to single type and area",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/macOS",
              "tenet/compatibility"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #913 (same NuGet/Xamarin.Mac Full root cause for core SkiaSharp)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 913
          },
          {
            "type": "add-comment",
            "description": "Explain resolution and close",
            "risk": "high",
            "confidence": 0.85,
            "comment": "This issue was caused by a NuGet Client limitation in resolving platform-specific assemblies for Xamarin.Mac Full projects. Since then, Xamarin.Mac has been deprecated (May 2024), and SkiaSharp v3.x targets modern .NET for macOS (\u0060net8.0-macos\u0060 / \u0060net9.0-macos\u0060), where this namespace resolution works correctly.\n\nFor anyone still on legacy Xamarin.Mac, the workarounds from the earlier comments remain valid:\n- Add \u0060\u003CMigrateToNewXMIdentifier\u003Etrue\u003C/MigrateToNewXMIdentifier\u003E\u0060 to your project file\n- Or manually reference \u0060SkiaSharp.Views.Mac.dll\u0060\n\nClosing as resolved by the platform migration to .NET for macOS."
          },
          {
            "type": "close-issue",
            "description": "Close as resolved \u2014 root cause eliminated by Xamarin deprecation and .NET migration",
            "risk": "medium",
            "confidence": 0.88
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 731,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:49:23Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Classic",
          "backend/Raster"
        ]
      },
      "summary": "Performance regression in SKShader.CreateRadialGradient between SkiaSharp 1.60.3 and 1.68.0 on raster backend",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.9
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.92
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/Raster"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a WinForms .NET Framework 4.6.1 app with SkiaSharp",
            "Use SKShader.CreateRadialGradient with center (50,50), radius 100, Black-to-White colors, Clamp mode",
            "Assign shader to paint.Shader and call canvas.DrawRect(info.Rect, paint)",
            "Compare rendering time between SkiaSharp 1.60.3 and 1.68.0"
          ],
          "environmentDetails": "Windows, .NET Framework 4.6.1, WinForms, CPU/raster rendering, SkiaSharp 1.68.0",
          "relatedIssues": [
            543
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "performance",
          "reproQuality": "partial",
          "targetFrameworks": [
            "net461"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.68.0",
            "1.68.0-preview28",
            "1.60.3"
          ],
          "workedIn": "1.60.3",
          "brokeIn": "1.68.0",
          "currentRelevance": "unlikely",
          "relevanceReason": "Filed in 2018 for SkiaSharp 1.68.0. Current SkiaSharp is 3.x with a completely different Skia engine. Issue #543 (related shader performance regression) was confirmed fixed in v1.69.0. The upstream Skia radial gradient code has been extensively rewritten since then."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.9,
          "reason": "Reporter explicitly states v1.60.3 was fast and v1.68.0 is slow for the same code. Only radial gradient affected \u2014 linear and sweep gradients are not slow.",
          "workedInVersion": "1.60.3",
          "brokeInVersion": "1.68.0"
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.8,
          "reason": "Issue #543 reported a similar shader performance regression (sweep gradient in v1.60/1.61) and mattleibow confirmed it was fixed in v1.69.0. The radial gradient uses the same SkGradientShader code path in upstream Skia. Current SkiaSharp 3.x ships Skia m128\u002B which has had extensive gradient performance improvements.",
          "relatedPRs": [],
          "relatedCommits": []
        }
      },
      "analysis": {
        "summary": "Performance regression in radial gradient rendering between SkiaSharp 1.60.3 and 1.68.0 on raster backend. The C# wrapper and C API are thin pass-throughs \u2014 the issue is in upstream Skia\u0027s SkGradientShader::MakeRadial code path. A related shader performance issue (#543) was fixed in v1.69.0.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKShader.cs",
            "finding": "CreateRadialGradient is a thin wrapper: validates parameters then calls SkiaApi.sk_shader_new_radial_gradient. No SkiaSharp-specific logic that could affect performance.",
            "relevance": "direct",
            "lines": "189-199"
          },
          {
            "file": "externals/skia/src/c/sk_shader.cpp",
            "finding": "sk_shader_new_radial_gradient directly calls SkGradientShader::MakeRadial with the same parameters. The performance regression is in upstream Skia, not in the C API shim.",
            "relevance": "direct",
            "lines": "77-82"
          },
          {
            "file": "externals/skia/include/c/sk_shader.h",
            "finding": "C header declares both sk_shader_new_radial_gradient and sk_shader_new_radial_gradient_color4f \u2014 the 4f variant is an alternative if color precision matters.",
            "relevance": "context",
            "lines": "36-37"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes degraded performance of existing functionality between versions \u2014 a clear regression, not a feature request or question. Area is area/SkiaSharp since the affected API (SKShader.CreateRadialGradient) is in the core library. Severity is medium: the app still works but is noticeably slow. The regression is upstream in Skia, not in the SkiaSharp C# or C API layers, which are trivial pass-throughs (SKShader.cs:189-199 \u2192 sk_shader.cpp:77-82 \u2192 SkGradientShader::MakeRadial). Very likely fixed in current versions given the v1.69.0 fix for #543 and the massive Skia engine updates since then.",
        "keySignals": [
          {
            "text": "using the SKShader.CreateRadialGradient in paint.Shader leads to very slow work, which was not observed in the version 1.60.3",
            "source": "issue body",
            "interpretation": "Clear performance regression between specific versions. Only radial gradient affected, not linear or sweep."
          },
          {
            "text": "I tested the SKShader.CreateSweepGradient and SKShader.CreateLinearGradient using them does not slow down",
            "source": "issue body",
            "interpretation": "Isolates the problem to radial gradient specifically. Different gradient types take different Skia code paths."
          },
          {
            "text": "I believe this was fixed in v1.69.0",
            "source": "issue #543 comment by mattleibow",
            "interpretation": "Maintainer confirmed a related shader performance regression was fixed in the next version (1.69.0). The radial gradient issue at 1.68.0 may be the same root cause or a closely related one."
          }
        ],
        "workarounds": [
          "Upgrade to SkiaSharp 3.x \u2014 the underlying Skia engine has been updated many times since 1.68.0 and performance regressions in gradient rendering have been fixed",
          "As an interim measure on 1.68.0, pre-render the gradient to an SKImage/SKBitmap and reuse the cached result instead of recreating the shader each frame"
        ],
        "nextQuestions": [
          "Can the reporter confirm if upgrading to SkiaSharp 2.x or 3.x resolves the performance issue?",
          "What are the canvas dimensions? A large canvas with a small gradient radius could amplify the performance difference."
        ],
        "resolution": {
          "hypothesis": "The Skia engine version bundled with SkiaSharp 1.68.0 introduced a performance regression in the radial gradient raster code path (SkGradientShader::MakeRadial). This was likely addressed by the same Skia update that fixed #543 in v1.69.0, and certainly by the many Skia updates since then.",
          "proposals": [
            {
              "description": "Upgrade from SkiaSharp 1.68.0 to the latest 3.x release. The underlying Skia engine has been updated extensively and the shader performance regression is very likely resolved.",
              "title": "Upgrade to latest SkiaSharp",
              "confidence": 0.8,
              "effort": "medium"
            },
            {
              "description": "Pre-render the radial gradient to an SKBitmap/SKImage once, then draw the cached image instead of applying the shader on every paint call. This avoids the slow shader evaluation entirely.",
              "title": "Cache gradient as bitmap",
              "codeSnippet": "// Render gradient once to a bitmap\nusing var surface = SKSurface.Create(new SKImageInfo(width, height));\nvar tempCanvas = surface.Canvas;\nusing var paint = new SKPaint();\npaint.Shader = SKShader.CreateRadialGradient(\n    new SKPoint(50, 50), 100,\n    new SKColor[] { SKColors.Black, SKColors.White },\n    null, SKShaderTileMode.Clamp);\ntempCanvas.DrawRect(new SKRect(0, 0, width, height), paint);\nusing var cachedImage = surface.Snapshot();\n// Then draw cachedImage instead of using the shader directly",
              "confidence": 0.7,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Upgrade to latest SkiaSharp",
          "recommendedReason": "The issue is in the upstream Skia engine and was likely fixed in v1.69.0 or later. Upgrading resolves the root cause rather than working around it."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.75,
          "reason": "Very old issue (2018) for SkiaSharp 1.68.0. A related shader performance regression (#543) was confirmed fixed in v1.69.0. Current SkiaSharp 3.x uses a much newer Skia. Issue is almost certainly resolved by upgrading. No reporter activity since 2019."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add performance tenet label to existing labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "os/Windows-Classic",
              "backend/Raster",
              "tenet/performance"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis noting the issue is likely fixed in newer versions and suggest upgrading",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for reporting this. The performance regression you observed in radial gradient rendering was in the upstream Skia engine bundled with SkiaSharp 1.68.0, not in the SkiaSharp wrapper itself.\n\nA related shader performance regression (#543) was confirmed fixed in v1.69.0, and the Skia engine has been extensively updated since then. Upgrading to the latest SkiaSharp (currently 3.x) should resolve this.\n\nIf upgrading isn\u0027t feasible and you\u0027re still on 1.68.0, you can work around the issue by pre-rendering the gradient to an \u0060SKImage\u0060 and reusing the cached result:\n\n\u0060\u0060\u0060csharp\nusing var surface = SKSurface.Create(new SKImageInfo(width, height));\nusing var paint = new SKPaint();\npaint.Shader = SKShader.CreateRadialGradient(\n    new SKPoint(50, 50), 100,\n    new SKColor[] { SKColors.Black, SKColors.White },\n    null, SKShaderTileMode.Clamp);\nsurface.Canvas.DrawRect(new SKRect(0, 0, width, height), paint);\nusing var cached = surface.Snapshot();\n// Draw cached image instead of using shader directly\n\u0060\u0060\u0060\n\nClosing as this is likely resolved in current versions. If you\u0027re still seeing this on a recent SkiaSharp release, please reopen with updated details."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related shader performance issue",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 543
          },
          {
            "type": "close-issue",
            "description": "Close as likely fixed in newer versions",
            "risk": "medium",
            "confidence": 0.7
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 730,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:50:00Z",
        "currentLabels": [
          "type/bug",
          "os/Windows-Universal-UWP",
          "area/SkiaSharp.Views",
          "area/SkiaSharp.Views.Forms",
          "backend/OpenGL"
        ]
      },
      "summary": "SKGLView crashes with \u0027Failed to create EGL surface\u0027 when RotateYTo is applied to parent view in Xamarin Forms UWP",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.92
        },
        "platforms": [
          "os/Windows-Universal-UWP"
        ],
        "backends": [
          "backend/OpenGL"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Xamarin Forms UWP app with a Grid containing an SKGLView",
            "Call ViewExtensions.RotateYTo on the Grid from 180 to 0 with 300ms duration",
            "Repeat several times \u2014 usually crashes on first try"
          ],
          "environmentDetails": "SkiaSharp 1.68.0-preview28, VS2017, UWP",
          "relatedIssues": [
            1573,
            1155,
            1377
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "crash",
          "errorMessage": "System.Exception: Failed to create EGL surface",
          "stackTrace": "System.Exception: Failed to create EGL surface\n   at SkiaSharp.Views.GlesInterop.GlesContext.CreateSurface(SwapChainPanel panel, Nullable\u00601 renderSurfaceSize, Nullable\u00601 resolutionScale)\n   at SkiaSharp.Views.UWP.AngleSwapChainPanel.EnsureRenderSurface()\n   at SkiaSharp.Views.UWP.AngleSwapChainPanel.OnCompositionChanged(SwapChainPanel sender, Object args)",
          "reproQuality": "partial",
          "targetFrameworks": [
            "uap10.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.68.0-preview28"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "PR #1642 (merged 2021-03-30) addressed the root cause by making the EGL display static/shared with initialize-once semantics and adding composition scale change deduplication. Additionally, UWP and Xamarin.Forms are now deprecated platforms."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.8,
          "reason": "PR #1642 by gmurray81 addressed the EGL display lifecycle issue. The static eglDisplay with initialize-once pattern prevents termination of the shared display when one panel is destroyed. The composition scale deduplication in OnCompositionChanged prevents unnecessary surface recreation. SKSwapChainPanel.OnDestroyingContext now uses AbandonContext(false) instead of true. However, the PR author noted the fix was partial \u2014 the GRContext cleanup was deliberately weakened.",
          "relatedPRs": [
            1642
          ]
        }
      },
      "analysis": {
        "summary": "EGL surface creation fails when a 3D CSS-like transform (RotateYTo) is applied to the parent view of an SKGLView in UWP. The CompositionScaleChanged event fires during the rotation, triggering EnsureRenderSurface(), which fails because the EGL display state is corrupted by interleaved panel lifecycle operations.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/GlesContext.cs",
            "finding": "eglDisplay is now static (shared across all instances) with initialize-once guard in InitializeDisplay(). CreateSurface throws on line 110 when eglCreateWindowSurface fails. No eglTerminate call exists \u2014 display is never destroyed once initialized. This was the fix from PR #1642.",
            "relevance": "direct",
            "lines": "29, 107-113, 155-157"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "finding": "OnCompositionChanged now deduplicates by checking lastCompositionScaleX/Y before destroying and recreating the surface (PR #1642 fix). EnsureRenderSurface creates the surface only when glesContext.HasSurface is false and the panel has positive dimensions.",
            "relevance": "direct",
            "lines": "163-181, 191-205"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKSwapChainPanel.cs",
            "finding": "OnDestroyingContext now calls AbandonContext(false) instead of AbandonContext(true) \u2014 prevents premature destruction of shared GL resources. This was changed in PR #1642.",
            "relevance": "direct",
            "lines": "100-123"
          }
        ],
        "rationale": "This is clearly a bug \u2014 the reporter describes a crash with a stack trace during a legitimate UI operation (3D rotation on a parent view). Classified as area/SkiaSharp.Views because the crash is in the ANGLE/EGL surface management layer (GlesContext and AngleSwapChainPanel), not in core SkiaSharp or Xamarin.Forms itself. Severity is medium because there\u0027s a workaround (use SKCanvasView instead of SKGLView) and a partial fix was merged. The OpenGL backend label is appropriate since this is specific to the ANGLE-based GL rendering path on UWP.",
        "keySignals": [
          {
            "text": "System.Exception: Failed to create EGL surface",
            "source": "issue body",
            "interpretation": "eglCreateWindowSurface returned EGL_NO_SURFACE \u2014 ANGLE\u0027s D3D11 backend failed to create the surface, likely due to the SwapChainPanel being in an invalid state during the 3D transform."
          },
          {
            "text": "CompositionScaleChanged fires during RotateYTo",
            "source": "stack trace",
            "interpretation": "The 3D rotation triggers XAML composition scale changes, which cause the panel to destroy and recreate the EGL surface mid-animation."
          },
          {
            "text": "gmurray81 opened #1573 for the same root cause (navigation between pages)",
            "source": "comment 2",
            "interpretation": "Same underlying issue \u2014 interleaved EGL display lifecycle when multiple SKSwapChainPanels exist or when panel is destroyed/recreated."
          },
          {
            "text": "PR #1642 merged with static eglDisplay, composition scale dedup, AbandonContext(false)",
            "source": "PR #1642",
            "interpretation": "Partial fix applied: prevents eglTerminate race and unnecessary surface recreation. PR author noted it was not complete \u2014 GRContext cleanup was weakened."
          }
        ],
        "workarounds": [
          "Use SKCanvasView (CPU rendering) instead of SKGLView to avoid the ANGLE/EGL surface management entirely",
          "Upgrade to SkiaSharp 2.80\u002B which includes PR #1642\u0027s fixes for the EGL display lifecycle"
        ],
        "nextQuestions": [
          "Is the GRContext cleanup in OnDestroyingContext still too aggressive even after the AbandonContext(false) change?",
          "Does WinUI 3 (the successor to UWP XAML) exhibit the same issue with SwapChainPanel composition changes?"
        ],
        "resolution": {
          "hypothesis": "The 3D rotation (RotateYTo) triggers XAML CompositionScaleChanged events, which cause the ANGLE swap chain panel to destroy and recreate the EGL surface. When the EGL display was instance-scoped, interleaved lifecycle operations (or mid-animation state) corrupted the display, causing surface creation to fail.",
          "proposals": [
            {
              "description": "Upgrade to SkiaSharp 2.80 or later which includes PR #1642\u0027s fixes: static shared EGL display, composition scale deduplication, and safer GRContext cleanup.",
              "title": "Upgrade to 2.80\u002B",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Replace SKGLView with SKCanvasView to use CPU rendering instead of the ANGLE-based GL path. This avoids the EGL surface management entirely at the cost of GPU acceleration.",
              "title": "Use SKCanvasView instead",
              "confidence": 0.9,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Upgrade to 2.80\u002B",
          "recommendedReason": "PR #1642\u0027s fixes directly address the root cause. Upgrading is the lowest-effort solution and retains GPU acceleration."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.75,
          "reason": "PR #1642 (merged 2021-03-30) addressed the core EGL display lifecycle issue. The fix is in all releases since 2.80. UWP and Xamarin.Forms are also now deprecated platforms. Issue has had no activity since 2021."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Keep existing labels, remove duplicate area label (should have single area)",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Universal-UWP",
              "backend/OpenGL"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis explaining the fix in PR #1642 and suggest closing",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for reporting this. The root cause was in the EGL display lifecycle management in \u0060AngleSwapChainPanel\u0060 / \u0060GlesContext\u0060 \u2014 the 3D rotation triggered \u0060CompositionScaleChanged\u0060 events that caused surface recreation to fail due to interleaved panel lifecycle operations.\n\nThis was addressed in PR #1642 (merged into 2.80), which:\n- Made the EGL display static and shared across all panel instances (initialize-once)\n- Added composition scale deduplication to prevent unnecessary surface recreation\n- Changed \u0060GRContext.AbandonContext(true)\u0060 to \u0060AbandonContext(false)\u0060 to avoid destroying shared GL resources\n\nUpgrading to SkiaSharp 2.80 or later should resolve this. If you\u0027re still experiencing issues on a newer version, please open a new issue with updated details.\n\nNote: UWP and Xamarin.Forms are now deprecated \u2014 the equivalent in modern SkiaSharp is \u0060SKSwapChainPanel\u0060 in SkiaSharp.Views.WinUI with .NET MAUI."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1573 (same root cause, navigation scenario)",
            "risk": "low",
            "confidence": 0.9,
            "linkedIssue": 1573
          },
          {
            "type": "close-issue",
            "description": "Close as fixed by PR #1642 in SkiaSharp 2.80\u002B",
            "risk": "medium",
            "confidence": 0.75
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 655,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:49:23Z",
        "currentLabels": [
          "type/bug",
          "status/skia-update-required",
          "area/libSkiaSharp.native"
        ]
      },
      "summary": "SKPath.Op(other, SKPathOp.Intersect) returns a path with 0 points for specific float-encoded coordinates on SkiaSharp 1.60.3. The same operation produces correct results in Skia\u0027s C\u002B\u002B fiddle, indicating a bug in the older Skia pathops engine bundled with that version. The reporter provides a complete C# console repro with SkBits2Float-encoded path data and a working C\u002B\u002B fiddle link for comparison.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.98
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create two SKPath objects with specific float-encoded coordinates (SkBits2Float hex values)",
            "Set path_a fill type to Winding and path_b fill type to EvenOdd",
            "Call path_a.Op(path_b, SKPathOp.Intersect)",
            "Check path_r.PointCount \u2014 returns 0 instead of expected intersection points"
          ],
          "codeSnippets": [
            "SKPath path_r = path_a.Op(path_b, SKPathOp.Intersect);\nif (path_r != null) {\n    Console.WriteLine(path_r.PointCount); // prints 0\n}"
          ],
          "environmentDetails": "SkiaSharp 1.60.3, Visual Studio 2017 15.8.7, .NET Core 2.1, Windows 10",
          "repoLinks": [
            {
              "url": "https://fiddle.skia.org/c/cde611c02e7cfb956670649610eb40d3",
              "description": "C\u002B\u002B Skia fiddle showing correct intersection result (green path)"
            }
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "wrong-output",
          "errorMessage": "Path intersection returns 0 points instead of expected intersection geometry",
          "reproQuality": "complete",
          "targetFrameworks": [
            "netcoreapp2.1"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.60.3"
          ],
          "currentRelevance": "unlikely",
          "relevanceReason": "SkiaSharp 1.60.3 used a 2018-era Skia. Current SkiaSharp 3.x uses a much newer Skia fork with 437\u002B commits to pathops since then. Skia\u0027s pathops engine has received extensive bug fixes and rewrites."
        },
        "fixStatus": {
          "likelyFixed": true,
          "confidence": 0.8,
          "reason": "The bug is in Skia\u0027s native pathops engine, not in SkiaSharp\u0027s C# or C API wrappers. Since 2018, Skia\u0027s pathops directory has received 437\u002B commits including bug fixes, root-finding rewrites, and structural improvements. The issue\u0027s own label \u0027status/skia-update-required\u0027 confirms it was understood to need a Skia update, which has since occurred multiple times."
        }
      },
      "analysis": {
        "summary": "SKPath.Op() is a thin C# wrapper over Skia\u0027s native Op() function. The SkiaSharp C API (sk_pathop_op) directly calls Skia\u0027s Op() with no transformation. The bug is entirely in Skia\u0027s pathops engine for specific coordinate values. The reporter confirmed the same operation works in C\u002B\u002B Skia fiddle, meaning the fiddle ran a newer Skia version that already had the fix.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKPath.cs",
            "finding": "Op() is a thin wrapper: validates null arguments, calls SkiaApi.sk_pathop_op, returns null if native call returns false. No coordinate transformation or modification \u2014 passes handles directly to native code.",
            "relevance": "direct",
            "lines": "417-436"
          },
          {
            "file": "externals/skia/src/c/sk_path.cpp",
            "finding": "sk_pathop_op() directly calls Skia\u0027s Op(*AsPath(one), *AsPath(two), (SkPathOp)op, AsPath(result)) with no additional logic. The bug is entirely in Skia\u0027s upstream Op() implementation.",
            "relevance": "direct",
            "lines": "252-254"
          },
          {
            "file": "externals/skia/include/pathops/SkPathOps.h",
            "finding": "Skia\u0027s Op() declaration and SkPathOp enum. kIntersect_SkPathOp is the operation used. The function signature has not changed, confirming ABI compatibility with current SkiaSharp.",
            "relevance": "context",
            "lines": "22-46"
          }
        ],
        "rationale": "Classified as type/bug because the code produces incorrect output (0 intersection points) for valid overlapping paths. Area is libSkiaSharp.native because the bug is in the upstream Skia pathops engine, not in the SkiaSharp C# or C API layer. Severity is medium \u2014 wrong output but not a crash. The skia-update-required label was already correctly applied.",
        "keySignals": [
          {
            "text": "path_r.PointCount returns 0",
            "source": "issue body",
            "interpretation": "Intersection operation produces empty result for paths that visibly overlap \u2014 incorrect output from Skia\u0027s pathops engine."
          },
          {
            "text": "Same example in C\u002B\u002B is working well",
            "source": "issue body",
            "interpretation": "The C\u002B\u002B Skia fiddle uses a newer Skia version that handles these coordinates correctly, confirming the bug is version-dependent in Skia\u0027s native code."
          },
          {
            "text": "SkBits2Float encoded coordinates with very small/negative values",
            "source": "issue body",
            "interpretation": "The coordinates include near-zero float values (0xB6D27CA9 \u2248 -6.27e-6, 0x36CCD0F6 \u2248 6.13e-6) which are edge cases for pathops numerical stability."
          },
          {
            "text": "skia-discuss thread on pathop issues",
            "source": "comment by yisibl (2025-06-17)",
            "interpretation": "Community-referenced discussion confirming pathops bugs are a known class of issues in older Skia versions."
          }
        ],
        "workarounds": [
          "Upgrade to latest SkiaSharp 3.x which bundles a much newer Skia with extensive pathops fixes"
        ],
        "nextQuestions": [
          "Has anyone verified this specific reproduction case passes on current SkiaSharp 3.x?",
          "Are there other pathops edge cases that still fail with near-zero float values?"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s pathops engine in the version bundled with SkiaSharp 1.60.3 had numerical precision issues with near-zero float coordinate values, causing intersection calculations to fail. This has been fixed in newer Skia versions.",
          "proposals": [
            {
              "description": "Upgrade to latest SkiaSharp 3.x which uses a much newer Skia version with extensive pathops bug fixes. The pathops directory has received 437\u002B commits since the version used in 1.60.3.",
              "title": "Upgrade to SkiaSharp 3.x",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Close the issue as fixed, since multiple major Skia updates have been incorporated into SkiaSharp since 1.60.3. If anyone can reproduce on current SkiaSharp 3.x, they should open a new issue.",
              "title": "Close as fixed by Skia update",
              "confidence": 0.75,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Close as fixed by Skia update",
          "recommendedReason": "The issue is 7\u002B years old, filed against SkiaSharp 1.60.3 with a very old Skia. Hundreds of pathops fixes have been upstreamed since. The \u0027status/skia-update-required\u0027 label confirms the team already understood the fix required a Skia update, which has occurred."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.8,
          "reason": "Bug was in Skia\u0027s native pathops engine. SkiaSharp has since upgraded Skia multiple times, incorporating hundreds of pathops fixes. The issue\u0027s own label confirms this was waiting for a Skia update."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm existing labels are correct",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post explanation that this is likely fixed by Skia updates in SkiaSharp 3.x",
            "risk": "high",
            "confidence": 0.8,
            "comment": "This bug was in Skia\u0027s native pathops engine, which SkiaSharp wraps directly without modification. Since version 1.60.3, SkiaSharp has upgraded the bundled Skia multiple times \u2014 the pathops module alone has received over 400 commits of bug fixes and improvements.\n\nIf you\u0027re still encountering incorrect path intersection results on the latest SkiaSharp 3.x, please open a new issue with a reproduction case and we\u0027ll investigate further."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related SKPath boolean operation issue",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 2325
          },
          {
            "type": "close-issue",
            "description": "Close as fixed by Skia updates incorporated in newer SkiaSharp versions",
            "risk": "medium",
            "confidence": 0.8
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 648,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T23:49:23Z",
        "currentLabels": [
          "type/bug",
          "status/skia-update-required",
          "area/libSkiaSharp.native"
        ]
      },
      "summary": "Large images (14034\u00D79921) produce blank output when drawn onto an SKSurface, and SKBitmap allocation fails with \u0027Unable to allocate pixels\u0027 \u2014 root cause is native memory exhaustion for very large pixel buffers",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.92
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.88
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Load a large image (\u003E6MB, 14034\u00D79921 pixels) using SKImage.FromEncodedData",
            "Create an SKSurface with the target resize dimensions",
            "Draw the image onto the surface using DrawImage",
            "Snapshot and encode the surface \u2014 the output is blank (white canvas only)",
            "Alternatively, try SKBitmap.FromImage which throws \u0027Unable to allocate pixels for the bitmap\u0027"
          ],
          "codeSnippets": [
            "using (SKImage image = SKImage.FromEncodedData(SKData.Create(sourceStream)))\n{\n    var info = new SKImageInfo(newWidth, newHeight);\n    using (SKSurface surface = SKSurface.Create(info))\n    {\n        surface.Canvas.DrawImage(image, rect, paint);\n        // Resulting snapshot is blank\n    }\n}"
          ],
          "environmentDetails": "Reported in 2018 (SkiaSharp version not specified). Reproduced by multiple users with various image sizes including 5286\u00D73555 and 4K\u00D74K (multiple bitmaps).",
          "relatedIssues": [
            1249
          ],
          "repoLinks": [
            {
              "url": "https://stackoverflow.com/questions/52206463/large-image-resizing-shows-blank",
              "description": "StackOverflow question from original reporter"
            },
            {
              "url": "https://groups.google.com/forum/#!topic/skia-discuss/886WuVcQUGo",
              "description": "Skia discussion confirming upstream limitation"
            }
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": false,
          "errorType": "wrong-output",
          "errorMessage": "Unable to allocate pixels for the bitmap",
          "reproQuality": "complete",
          "targetFrameworks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.68.2.1"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The core issue is Skia\u0027s native memory allocation limits for very large pixel buffers. SkiaSharp still does not use GC.AddMemoryPressure for native allocations, and Skia\u0027s raster surface allocation silently fails (returns null or blank surface) when memory is insufficient. Skia has been updated many times since 2018 but the fundamental memory constraint for very large raster images persists."
        }
      },
      "analysis": {
        "summary": "When drawing a very large encoded image (14034\u00D79921 = ~557MB uncompressed RGBA) onto an SKSurface, Skia silently fails to decode/rasterize the source image, producing a blank canvas. SKBitmap allocation fails explicitly with \u0027Unable to allocate pixels\u0027. The root cause is native memory exhaustion \u2014 Skia cannot allocate the ~557MB pixel buffer needed to decode the source image for drawing. SkiaSharp does not call GC.AddMemoryPressure, so the .NET GC is unaware of these large native allocations and cannot proactively collect.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap constructor calls TryAllocPixels and throws generic Exception(\u0027Unable to allocate pixels for the bitmap\u0027) on failure. No OutOfMemoryException, no diagnostic detail about how much memory was requested vs available.",
            "relevance": "direct",
            "lines": "52-56"
          },
          {
            "file": "externals/skia/src/core/SkImageInfoPriv.h",
            "finding": "Skia\u0027s max dimension limit is SK_MaxS32 \u003E\u003E 2 = 536870911 pixels. The reporter\u0027s 14034px image is well within this limit, so the issue is not a dimension cap but rather practical memory allocation failure.",
            "relevance": "direct",
            "lines": "193-194"
          },
          {
            "file": "externals/skia/src/image/SkImage_RasterFactories.cpp",
            "finding": "Raster image factory validates dimensions against the same SK_MaxS32\u003E\u003E2 limit and validates rowBytes via SkBitmap.setInfo. The validation passes for the reporter\u0027s image size; the failure is at allocation time.",
            "relevance": "related",
            "lines": "33-46"
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "finding": "FromEncodedData creates a deferred/lazy image via sk_image_new_from_encoded \u2014 no pixel buffer is allocated until the image is drawn or rasterized. This explains why FromEncodedData succeeds but DrawImage produces blank output.",
            "relevance": "direct",
            "lines": "166-172"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.GetScaledDimensions(float desiredScale) exists and can be used to decode at a reduced resolution, avoiding the need to allocate the full pixel buffer. This is the basis for a workaround.",
            "relevance": "context",
            "lines": "42-47"
          }
        ],
        "rationale": "This is a bug in the sense that the operation fails silently (blank output instead of an error). The maintainer confirmed it\u0027s an upstream Skia limitation and labeled it status/skia-update-required. The area is correctly area/libSkiaSharp.native since the failure is in native memory allocation. Severity is medium: it affects a specific use case (very large images) and has a straightforward workaround (subsample decoding). The lack of GC.AddMemoryPressure is a separate but related SkiaSharp-side issue raised by a commenter.",
        "keySignals": [
          {
            "text": "the image itself doesn\u0027t show upon save, only the white background canvas",
            "source": "issue body",
            "interpretation": "Silent failure \u2014 DrawImage on the surface produces no error but the source image pixels are never rasterized, likely because decoding the large source image failed internally."
          },
          {
            "text": "Unable to allocate pixels for the bitmap",
            "source": "issue body",
            "interpretation": "Explicit failure path when using SKBitmap \u2014 TryAllocPixels returns false for the large pixel buffer (14034\u00D79921\u00D74 = ~557MB)."
          },
          {
            "text": "I belive this issue is actually a skia one",
            "source": "mattleibow comment",
            "interpretation": "Maintainer confirmed upstream Skia limitation. SkiaSharp cannot fix until Skia addresses the underlying memory handling."
          },
          {
            "text": "I am not sure if SkiaSharp adds native memory pressure, so the GC knows about it",
            "source": "ziriax comment",
            "interpretation": "SkiaSharp does NOT call GC.AddMemoryPressure \u2014 confirmed by searching binding/SkiaSharp/. This means the GC cannot proactively free native memory when large allocations are needed."
          },
          {
            "text": "I realize I am stressing the system quite a bit here: Manage 10 SKBitmap instances in memory. Each SKBitmap is 4Kx4K (~64MB)",
            "source": "perumaal comment",
            "interpretation": "Commenter confirmed the issue is practical memory limits, not a code bug. Multiple large bitmaps exhaust available memory."
          }
        ],
        "workarounds": [
          "Use SKCodec.GetScaledDimensions() with a fractional scale to decode the image at a smaller resolution before drawing, avoiding the large pixel buffer allocation.",
          "Pre-resize using SKBitmap.Resize() or SKImage.Subset() on smaller tiles to avoid allocating the full source image in memory at once."
        ],
        "nextQuestions": [
          "Has upstream Skia improved large image handling or added streaming/tiled decode support since the 2018 Skia discussion?",
          "Should SkiaSharp add GC.AddMemoryPressure calls when allocating large pixel buffers to help the GC manage native memory?"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s raster backend cannot allocate the ~557MB pixel buffer needed to decode a 14034\u00D79921 image for drawing. SKImage.FromEncodedData creates a lazy image, but when DrawImage attempts to rasterize it, the internal decode fails silently. SKBitmap allocation fails explicitly. This is compounded by SkiaSharp not using GC.AddMemoryPressure, preventing the GC from reclaiming native memory proactively.",
          "proposals": [
            {
              "description": "Use SKCodec.GetScaledDimensions() to compute a reduced decode size, then decode at that size to avoid the massive pixel buffer. This lets you resize during decode rather than after.",
              "title": "Subsample decode with SKCodec",
              "codeSnippet": "using var codec = SKCodec.Create(stream);\nvar scale = Math.Min((float)maxWidth / codec.Info.Width, (float)maxHeight / codec.Info.Height);\nvar scaledSize = codec.GetScaledDimensions(scale);\nvar info = new SKImageInfo(scaledSize.Width, scaledSize.Height);\nusing var bitmap = new SKBitmap(info);\ncodec.GetPixels(info, bitmap.GetPixels());",
              "confidence": 0.8,
              "effort": "small"
            },
            {
              "description": "Add GC.AddMemoryPressure/RemoveMemoryPressure calls in SKBitmap, SKSurface, and other types that allocate large native pixel buffers. This helps the .NET GC make better collection decisions when native memory usage is high.",
              "title": "Add GC.AddMemoryPressure to SkiaSharp",
              "confidence": 0.6,
              "effort": "medium"
            },
            {
              "description": "When TryAllocPixels fails in the SKBitmap constructor, throw OutOfMemoryException with diagnostic detail (requested size) instead of a generic Exception. This gives callers better error handling options.",
              "title": "Throw OutOfMemoryException instead of generic Exception",
              "confidence": 0.9,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Subsample decode with SKCodec",
          "recommendedReason": "This is the most practical workaround for the reporter\u0027s immediate problem. It avoids the massive pixel buffer entirely by decoding directly at the target resolution. The other proposals are SkiaSharp-side improvements that help but don\u0027t solve the fundamental memory constraint."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The upstream Skia limitation may have been improved in newer Skia versions. The status/skia-update-required label is still valid \u2014 needs investigation into whether current Skia handles large raster images better. The GC.AddMemoryPressure and error reporting improvements are actionable SkiaSharp-side fixes."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Confirm existing labels are correct \u2014 type/bug and area/libSkiaSharp.native match the issue",
            "risk": "low",
            "confidence": 0.92,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with subsample decode workaround and note about GC memory pressure",
            "risk": "high",
            "confidence": 0.8,
            "comment": "This issue is still relevant. The root cause is that decoding a 14034\u00D79921 image requires ~557MB of uncompressed pixel data, which can exhaust native memory \u2014 causing either blank output (silent failure in DrawImage) or the explicit \u0027Unable to allocate pixels\u0027 error.\n\nHere\u0027s a workaround using subsample decoding to resize during decode rather than after:\n\n\u0060\u0060\u0060csharp\nusing var stream = new SKMemoryStream(imageData);\nusing var codec = SKCodec.Create(stream);\nvar scale = Math.Min((float)maxWidth / codec.Info.Width, (float)maxHeight / codec.Info.Height);\nvar scaledSize = codec.GetScaledDimensions(scale);\nvar info = new SKImageInfo(scaledSize.Width, scaledSize.Height);\nusing var bitmap = new SKBitmap(info);\ncodec.GetPixels(info, bitmap.GetPixels());\n// bitmap now contains the resized image without needing the full pixel buffer\n\u0060\u0060\u0060\n\nThis avoids allocating the full-resolution pixel buffer entirely. On the SkiaSharp side, two improvements would help: (1) using \u0060GC.AddMemoryPressure\u0060 so the .NET GC is aware of large native allocations, and (2) throwing \u0060OutOfMemoryException\u0060 instead of a generic \u0060Exception\u0060 when pixel allocation fails."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1249 which involves similar large image allocation failure",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 1249
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 607,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:46:27Z",
        "currentLabels": [
          "type/enhancement",
          "os/iOS",
          "os/Android",
          "area/SkiaSharp.Views",
          "type/feature-request"
        ]
      },
      "summary": "SKTouchAction.Entered and SKTouchAction.Exited events are not fired on iOS and Android \u2014 only implemented on Windows and Tizen",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.9
        },
        "area": {
          "value": "area/SkiaSharp.Views.Maui",
          "confidence": 0.88
        },
        "platforms": [
          "os/iOS",
          "os/Android"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Subscribe to Touch event on SKCanvasView on iOS or Android",
            "Observe that SKTouchAction.Entered and SKTouchAction.Exited are never raised when touch enters/exits the view bounds",
            "Same code works on Windows where PointerEntered/PointerExited are wired up"
          ],
          "environmentDetails": "Originally filed against Xamarin.Forms (2018). Still applies to MAUI as of current main branch.",
          "relatedIssues": [
            2106,
            2722,
            2493,
            309
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.x (Xamarin.Forms era, 2018)"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The MAUI-era Android and Apple SKTouchHandler classes still do not fire Entered/Exited events. The gap has persisted through the Xamarin.Forms to MAUI migration."
        }
      },
      "analysis": {
        "summary": "The SKTouchAction enum defines Entered and Exited values, but the iOS (Apple) and Android platform touch handlers never produce these actions. Windows fully implements them via PointerEntered/PointerExited, and Tizen partially implements Exited via PointStateType.Leave. This creates an inconsistent cross-platform API surface where developers write code expecting Entered/Exited on all platforms but it silently never fires on mobile.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/SKTouchEventArgs.cs",
            "finding": "SKTouchAction enum defines Entered (line 62) and Exited (line 67) as valid values, establishing the API contract.",
            "relevance": "direct",
            "lines": "60-69"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Windows/SKTouchHandler.cs",
            "finding": "Windows handler wires up PointerEntered to SKTouchAction.Entered and PointerExited to SKTouchAction.Exited. Full implementation.",
            "relevance": "direct",
            "lines": "59-66"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "finding": "Android handler only maps MotionEventActions Down/PointerDown/Move/Up/PointerUp/Cancel. No Entered/Exited handling. Would need to track touch position relative to view bounds during Move events.",
            "relevance": "direct",
            "lines": "63-108"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "finding": "Apple handler only maps TouchesBegan/TouchesMoved/TouchesEnded/TouchesCancelled. UIKit has no native entered/exited gesture \u2014 would need manual hit-testing during TouchesMoved.",
            "relevance": "direct",
            "lines": "54-95"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Tizen/SKTouchHandler.cs",
            "finding": "Tizen partially implements: PointStateType.Leave maps to SKTouchAction.Exited, but no Entered equivalent.",
            "relevance": "related",
            "lines": "65-73"
          }
        ],
        "rationale": "This is a feature request, not a bug \u2014 the enum values exist by design but were never wired up on iOS and Android. The reporter correctly identifies the inconsistency: UWP/Windows fires these events, but iOS/Android silently don\u0027t. The original Xamarin.Forms issue from 2018 still applies to MAUI because the same gap exists in the current platform touch handlers. Area is SkiaSharp.Views.Maui (not the older Forms package) since MAUI is the current implementation. The tenet/compatibility label applies because this is a cross-platform consistency gap.",
        "keySignals": [
          {
            "text": "Currently iOS is implemented only on UWP (because it is connected as a passthrough)",
            "source": "issue body",
            "interpretation": "Reporter identified that Entered/Exited only works on UWP, not iOS/Android."
          },
          {
            "text": "their absence isn\u0027t noted and is a bit confusing",
            "source": "issue body",
            "interpretation": "The API surface implies cross-platform support (enum values exist) but behavior differs silently."
          },
          {
            "text": "I spent a few hours fixing the behavior... then discovering that entered/exited wouldn\u0027t fire",
            "source": "comment #2",
            "interpretation": "Silent failure causes significant debugging time for developers who assume cross-platform parity."
          },
          {
            "text": "This is something that we will be looking at in the future.",
            "source": "comment #4 (mattleibow, maintainer)",
            "interpretation": "Maintainer acknowledged the request in Dec 2018 but it remains unimplemented."
          }
        ],
        "workarounds": [
          "Track touch position relative to canvas size during SKTouchAction.Moved events and synthesize Entered/Exited logic in application code (as reporter demonstrates in comment #3)"
        ],
        "nextQuestions": [
          "Should the implementation use the reporter\u0027s approach (track bounds during Move events) or platform-specific hover/pointer APIs?",
          "Should Entered/Exited also work for mouse hover (not just touch) on platforms that support it?",
          "Does SKGLView need the same treatment?"
        ],
        "resolution": {
          "hypothesis": "iOS and Android native touch APIs don\u0027t have direct Entered/Exited equivalents. Implementation requires manual hit-testing during move events to detect when the touch crosses view bounds.",
          "proposals": [
            {
              "description": "In the Android and Apple SKTouchHandler classes, track whether the touch is inside the view bounds. During Move events, compare current position to view bounds and fire SKTouchAction.Entered or SKTouchAction.Exited when the inside/outside state changes. This matches the reporter\u0027s pseudocode and the approach they used as a workaround.",
              "title": "Synthesize Entered/Exited during Move events",
              "confidence": 0.75,
              "effort": "small"
            },
            {
              "description": "Developers can track entered/exited state themselves in their Touch event handler by comparing touch coordinates to canvas bounds during Moved events, as demonstrated by the reporter in comment #3. Use CanvasSize from OnPaintSurface for accurate bounds that account for DPI scaling.",
              "title": "Application-level workaround",
              "codeSnippet": "// Store canvas size from OnPaintSurface:\nSKSize _canvasSize;\nvoid OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    _canvasSize = e.Info.Size;\n    // ... drawing code\n}\n\n// Track entered/exited in Touch handler:\nbool _wasInside = true;\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    if (e.ActionType == SKTouchAction.Moved)\n    {\n        var inside = e.Location.X \u003E= 0 \u0026\u0026 e.Location.Y \u003E= 0\n            \u0026\u0026 e.Location.X \u003C _canvasSize.Width\n            \u0026\u0026 e.Location.Y \u003C _canvasSize.Height;\n        if (inside != _wasInside)\n        {\n            _wasInside = inside;\n            // Handle entered/exited logic here\n        }\n    }\n    e.Handled = true;\n}",
              "confidence": 0.75,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Application-level workaround",
          "recommendedReason": "Immediate solution reporters can use today. The framework-level fix requires changes to platform handlers and should be a separate PR."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "Well-understood gap with clear implementation path. Needs design decision on hover vs touch-only semantics before implementation."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Update labels to reflect current MAUI area and add compatibility tenet",
            "risk": "low",
            "confidence": 0.88,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views.Maui",
              "os/iOS",
              "os/Android",
              "tenet/compatibility"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the gap persists in MAUI, provide workaround with canvas-size-based bounds, note related issues",
            "risk": "high",
            "confidence": 0.75,
            "comment": "Thanks for reporting this \u2014 the gap still exists in the MAUI-era codebase. The Windows handler wires up \u0060PointerEntered\u0060/\u0060PointerExited\u0060 to \u0060SKTouchAction.Entered\u0060/\u0060Exited\u0060, but the Android and iOS handlers don\u0027t synthesize these during move events.\n\nAs a workaround, you can track entered/exited state in your Touch handler by comparing the touch location to canvas bounds during \u0060Moved\u0060 events. Use \u0060CanvasSize\u0060 from \u0060OnPaintSurface\u0060 for accurate bounds that respect DPI scaling:\n\n\u0060\u0060\u0060csharp\nSKSize _canvasSize;\nbool _wasInside = true;\n\nvoid OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    _canvasSize = e.Info.Size;\n    // ... drawing code\n}\n\nvoid OnTouch(object sender, SKTouchEventArgs e)\n{\n    if (e.ActionType == SKTouchAction.Moved)\n    {\n        var inside = e.Location.X \u003E= 0 \u0026\u0026 e.Location.Y \u003E= 0\n            \u0026\u0026 e.Location.X \u003C _canvasSize.Width\n            \u0026\u0026 e.Location.Y \u003C _canvasSize.Height;\n        if (inside != _wasInside)\n        {\n            _wasInside = inside;\n            // Handle entered/exited logic here\n        }\n    }\n    e.Handled = true;\n}\n\u0060\u0060\u0060\n\nNote: this only detects entry/exit during active touch-move gestures \u2014 it won\u0027t fire if the touch is released outside without a preceding move. For full coverage, also check bounds on \u0060Pressed\u0060 and \u0060Released\u0060.\n\nRelated: #2106, #2722, #2493."
          },
          {
            "type": "link-related",
            "description": "Cross-reference pointer events issue on iOS/Android",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 2106
          },
          {
            "type": "link-related",
            "description": "Cross-reference Touch not firing all events on iOS",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 2722
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 576,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:38:00Z",
        "currentLabels": [
          "type/bug",
          "area/SkiaSharp",
          "backend/OpenGL"
        ]
      },
      "summary": "GPU-backed SKSurface memory leak on Intel HD Graphics 520 caused by not disposing SKImage instances returned by Snapshot() before overwriting references. The reporter creates a GPU surface with GRContext/OpenGL, calls Snapshot() to capture the rendered content, and stores the resulting SKImage \u2014 but overwrites the previous SKImage reference without disposing it first, causing 30-40MB memory step-ups per iteration until crash.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.65
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.95
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create GPU-backed SKSurface with GRContext (OpenGL) and SKImageInfo",
            "Draw to the surface\u0027s Canvas",
            "Call surface.Snapshot() and store the resulting SKImage in a collection",
            "Dispose the surface but NOT the previous SKImage at the same dictionary key",
            "Repeat \u2014 observe 30-40MB memory growth per iteration"
          ],
          "codeSnippets": [
            "var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n//var surface = SKSurface.Create(new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\nsurface.Dispose();\n_skiaMain.DisplayPlaneRecompose[plane] = false;"
          ],
          "screenshots": [
            {
              "url": "https://user-images.githubusercontent.com/41022806/42469527-fdefdc92-8385-11e8-96d5-cfa8b693ae34.png",
              "description": "Visual Studio memory usage showing escalating memory consumption"
            }
          ],
          "environmentDetails": "Intel HD Graphics 520, Windows, OpenGL backend",
          "relatedIssues": [
            705,
            1244,
            3388
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "memory-leak",
          "errorMessage": "30-40MB step ups in memory usage until eventually it crashes",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The Snapshot() method still returns a new SKImage that the caller must dispose. The fundamental pattern of GPU-backed SKImage requiring explicit disposal hasn\u0027t changed. However, the root cause was user code not disposing \u2014 SkiaSharp itself does not leak."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.85,
          "reason": "This is not a SkiaSharp bug \u2014 it\u0027s a usage issue. The reporter confirmed the leak was caused by overwriting SKImage references without disposing the previous image. The \u0027fix\u0027 is in user code, not in SkiaSharp. No code change is needed."
        }
      },
      "analysis": {
        "summary": "The memory leak is caused by the reporter\u0027s code overwriting SKImage references (from Snapshot()) without first disposing the previous image. Each GPU-backed SKImage holds a GPU texture that is only released when Dispose is called (or the finalizer runs, which is non-deterministic and insufficient for GPU resources). The maintainer correctly identified the cause, and the reporter confirmed it.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKSurface.cs",
            "finding": "Snapshot() creates a new SKImage via sk_surface_new_image_snapshot. Returns a new owned object \u2014 caller is responsible for disposal. No caching or reuse of previous snapshot.",
            "relevance": "direct",
            "lines": "274-278"
          },
          {
            "file": "binding/SkiaSharp/SKImage.cs",
            "finding": "SKImage implements ISKReferenceCounted. Dispose calls SafeUnRef to decrement the Skia refcount. Finalizer will eventually release, but GC timing is non-deterministic \u2014 especially insufficient for GPU textures that consume VRAM.",
            "relevance": "direct",
            "lines": "16-24"
          },
          {
            "file": "binding/SkiaSharp/SKObject.cs",
            "finding": "DisposeNative for ISKReferenceCounted objects calls SafeUnRef. This is the mechanism that releases the underlying GPU resource when Dispose is called.",
            "relevance": "related",
            "lines": "94-98"
          },
          {
            "file": "binding/SkiaSharp/GRContext.cs",
            "finding": "GRContext exposes PurgeResources(), PurgeUnusedResources(), and PurgeUnlockedResources() \u2014 these can be used as additional mitigation to force GPU resource cleanup.",
            "relevance": "related",
            "lines": "159-169"
          }
        ],
        "rationale": "Classified as type/bug with reduced confidence (0.65) because the root cause is user code not following proper disposal patterns, not a defect in SkiaSharp. The area is area/SkiaSharp since the core SKSurface/SKImage APIs are involved. The backend is OpenGL since the reporter explicitly mentions GPU rendering via GRContext. The issue was reopened (state_reason: reopened) despite being resolved in comments, suggesting it may need a formal close with explanation. The severity is medium because while memory exhaustion and crash occur, the fix is straightforward user-side disposal.",
        "keySignals": [
          {
            "text": "_skiaMain.DisplayImages[plane] = surface.Snapshot();",
            "source": "issue body",
            "interpretation": "Overwrites dictionary entry without disposing previous SKImage \u2014 classic leak of IDisposable GPU resource."
          },
          {
            "text": "when I would overwrite the SkImage without disposing first then the ref was getting lost and when it was getting lost in the GPU memory GC.Collect was not cleaning up the lost reference",
            "source": "comment by mclose90 (reporter)",
            "interpretation": "Reporter confirmed root cause is not disposing SKImage before overwriting. GC finalizer alone is insufficient for timely GPU resource release."
          },
          {
            "text": "This line: _skiaMain.DisplayImages[plane] = surface.Snapshot(); may be the cause. What is happening here is that you are making a copy of the surface, and storing it in memory.",
            "source": "comment by mattleibow (maintainer)",
            "interpretation": "Maintainer correctly diagnosed the issue as user-side disposal problem."
          },
          {
            "text": "The the issue only occurs when my laptop is attempting to run my application using Intels HD Graphics 520 to render.",
            "source": "issue body",
            "interpretation": "Intel integrated GPU may have tighter memory constraints making the leak more visible, but the fundamental cause is disposal, not driver-specific."
          }
        ],
        "errorFingerprint": "memory-leak-SKImage-Snapshot-GPU-OpenGL",
        "workarounds": [
          "Dispose the previous SKImage before overwriting the reference: if (_skiaMain.DisplayImages.TryGetValue(plane, out var old)) old?.Dispose();",
          "Call GRContext.PurgeUnusedResources() periodically to reclaim GPU memory from unreferenced resources",
          "Use \u0027using\u0027 statements or try/finally blocks to ensure SKImage disposal"
        ],
        "nextQuestions": [
          "Is the issue still open because the reporter has a remaining leak even after fixing disposal, or was it reopened automatically?",
          "Should SkiaSharp warn or document the pattern of disposing previous Snapshot results more prominently?"
        ],
        "resolution": {
          "hypothesis": "The user\u0027s code overwrites SKImage references returned by Snapshot() without disposing the previous instance, leaking GPU texture memory. On Intel integrated GPUs with limited VRAM, this manifests as rapid 30-40MB growth until crash. The GC finalizer eventually decrements the Skia refcount, but not fast enough to prevent VRAM exhaustion.",
          "proposals": [
            {
              "description": "Before assigning a new Snapshot to the dictionary, dispose the existing image at that key. This is the direct fix for the leak.",
              "title": "Dispose previous SKImage before overwriting",
              "codeSnippet": "// Before: _skiaMain.DisplayImages[plane] = surface.Snapshot();\n// After:\nif (_skiaMain.DisplayImages.TryGetValue(plane, out var previousImage))\n    previousImage?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Call GRContext.Flush() followed by PurgeUnusedResources() periodically as a supplemental safety net. This is NOT a substitute for explicit disposal \u2014 use in addition to Proposal 1.",
              "title": "Periodic GPU resource purge",
              "codeSnippet": "// Supplemental \u2014 use in addition to explicit disposal:\n_skiaGlControl.GRContext.Flush();\n_skiaGlControl.GRContext.PurgeUnusedResources(5000);",
              "confidence": 0.6,
              "effort": "trivial"
            },
            {
              "description": "Restructure the code to use \u0027using\u0027 statements or try/finally to ensure deterministic cleanup of both surfaces and images.",
              "title": "Use using pattern for surface and snapshot",
              "confidence": 0.85,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Dispose previous SKImage before overwriting",
          "recommendedReason": "Directly addresses the confirmed root cause. The reporter themselves confirmed this was the issue. Trivial code change with near-certain fix."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-with-docs",
          "confidence": 0.8,
          "reason": "Root cause was confirmed by both maintainer and reporter as user-side disposal issue. The fix is to dispose SKImage before overwriting. No SkiaSharp code change needed. Issue was reopened but the resolution in comments is complete."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Labels are already correct \u2014 type/bug, area/SkiaSharp, backend/OpenGL all match",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "backend/OpenGL"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post closing comment summarizing the confirmed root cause and workaround",
            "risk": "high",
            "confidence": 0.8,
            "comment": "This issue was diagnosed in the original discussion \u2014 the memory leak occurs because \u0060SKImage\u0060 instances returned by \u0060Snapshot()\u0060 are overwritten in the dictionary without disposing the previous image first.\n\nHere\u0027s the fix:\n\n\u0060\u0060\u0060csharp\nif (_skiaMain.DisplayImages.TryGetValue(plane, out var previousImage))\n    previousImage?.Dispose();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\n\u0060\u0060\u0060\n\nGPU-backed \u0060SKImage\u0060 objects hold GPU texture memory that is only released when \u0060Dispose()\u0060 is called. The GC finalizer will eventually run, but not fast enough to prevent VRAM exhaustion \u2014 especially on integrated GPUs with limited memory like Intel HD Graphics 520.\n\nAs a supplemental safety measure, you can periodically flush and purge unused GPU resources (this is not a substitute for explicit disposal):\n\n\u0060\u0060\u0060csharp\ngrContext.Flush();\ngrContext.PurgeUnusedResources(5000);\n\u0060\u0060\u0060\n\n**Note:** If you access \u0060DisplayImages\u0060 from multiple threads, protect dictionary access with a lock to prevent race conditions.\n\nClosing as the root cause was confirmed by the original reporter."
          },
          {
            "type": "close-issue",
            "description": "Close as resolved \u2014 root cause identified and confirmed by reporter",
            "risk": "medium",
            "confidence": 0.8
          },
          {
            "type": "link-related",
            "description": "Related GPU memory management issue in SKGLView",
            "risk": "low",
            "confidence": 0.65,
            "linkedIssue": 705
          },
          {
            "type": "link-related",
            "description": "Related GPU memory leak report with AccessViolationException",
            "risk": "low",
            "confidence": 0.6,
            "linkedIssue": 1244
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 552,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:33:51Z",
        "currentLabels": [
          "type/enhancement",
          "area/SkiaSharp.Views"
        ]
      },
      "summary": "Maintainer-filed enhancement to investigate reusing SKSurface instances across draw calls in all SkiaSharp view implementations. Constructing SKSurface each frame is reported as expensive, and related issue #534 identified slow GTK rendering from this pattern. Currently, most views (WPF, WinForms, WinUI, Blazor, Android, Apple) create a new SKSurface per frame even though they reuse the underlying backing buffer. Only the GTK3 SKDrawingArea actually caches and reuses the SKSurface object itself.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.98
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "relatedIssues": [
            534,
            1251,
            1617,
            2190
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "Most view implementations still create a new SKSurface per frame. Only GTK3 reuses the surface. The core pattern has not changed since the issue was filed, though #1617 refactored the Android surface factory without addressing surface reuse."
        },
        "fixStatus": {
          "likelyFixed": false,
          "confidence": 0.9,
          "reason": "Code investigation shows most platforms still create SKSurface per frame. GTK3 is the only view that reuses the SKSurface object. #1617 refactored Android but didn\u0027t add surface reuse.",
          "relatedPRs": [
            1617
          ]
        }
      },
      "analysis": {
        "summary": "All SkiaSharp view implementations except GTK3 create a new SKSurface per draw frame via SKSurface.Create(). The backing memory (bitmaps, pixel buffers) is already reused when the size doesn\u0027t change, but the SKSurface object itself is allocated and disposed each frame. GTK3\u0027s SKDrawingArea demonstrates the reuse pattern \u2014 it stores the surface as a field and only recreates it when dimensions change. Applying this pattern across all views would eliminate per-frame SKSurface allocations, reducing GC pressure in high-frame-rate scenarios.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Gtk3/SKDrawingArea.cs",
            "finding": "GTK3 stores SKSurface as field \u0027surface\u0027, only recreates when pix dimensions change (line 78-88). This is the ONLY view that reuses SKSurface. Model to follow for other platforms.",
            "relevance": "direct",
            "lines": "12-87"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Apple/SKCGSurfaceFactory.cs",
            "finding": "CreateSurface() reuses the bitmapData/dataProvider when memory size matches, but always calls SKSurface.Create() returning a new surface per frame (line 66). Surface itself is not cached.",
            "relevance": "direct",
            "lines": "25-66"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SurfaceFactory.cs",
            "finding": "CreateSurface() reuses the Android Bitmap when dimensions match, but calls SKSurface.Create() every frame with bitmap.LockPixels() (line 50). Surface not cached.",
            "relevance": "direct",
            "lines": "30-50"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "finding": "OnRender creates SKSurface in a using block every frame (line 73). WriteableBitmap is reused but surface is not.",
            "relevance": "direct",
            "lines": "71-84"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "OnPaint creates SKSurface in a using block every frame (line 46). System.Drawing.Bitmap reused, surface not.",
            "relevance": "direct",
            "lines": "43-52"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.Blazor/SKCanvasView.razor.cs",
            "finding": "OnRenderFrame creates SKSurface in a using block every frame (line 95). Pixel buffer reused, surface not.",
            "relevance": "direct",
            "lines": "93-106"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/SKXamlCanvas.cs",
            "finding": "DoInvalidate creates SKSurface in a using block every frame (line 195). WriteableBitmap reused, surface not.",
            "relevance": "direct",
            "lines": "193-206"
          }
        ],
        "rationale": "Classified as enhancement (not bug) because the existing code works correctly \u2014 this is a performance optimization opportunity. The issue was filed by the maintainer (mattleibow) and explicitly labeled as type/enhancement. The area is clearly SkiaSharp.Views since all affected code is in the view layer. The performance tenet applies since this is about reducing per-frame allocations.",
        "keySignals": [
          {
            "text": "constructing a SKSurface is expensive, so we should see if we can reuse instances across draws",
            "source": "issue body",
            "interpretation": "Maintainer identifies per-frame SKSurface construction as a performance concern."
          },
          {
            "text": "PR that was created to improve drawing: #534",
            "source": "issue body",
            "interpretation": "GTK slow rendering was the original catalyst \u2014 #534 was about flickering/slow resize on Linux."
          },
          {
            "text": "GTK3 SKDrawingArea stores surface as a field and only recreates on resize",
            "source": "code search",
            "interpretation": "One platform already implements the reuse pattern, proving feasibility."
          },
          {
            "text": "SkSwapChainPanel makes unnecessary per-frame heap allocations (#1251)",
            "source": "related issue",
            "interpretation": "Community also reports per-frame allocation as a performance issue in WinUI view."
          }
        ],
        "nextQuestions": [
          "How expensive is SKSurface.Create() when given pre-allocated memory? Need benchmarks comparing new-per-frame vs reuse.",
          "For views using LockPixels/BackBuffer patterns (Android, WPF), can a cached SKSurface be re-pointed at the locked memory each frame, or does a new surface need to be created?",
          "Does SKSurface.Create with the same memory pointer return an internally cached surface, or always allocate a new Skia object?",
          "Should SKPaintSurfaceEventArgs also be reused per #1251\u0027s suggestion to further reduce per-frame allocations?"
        ],
        "resolution": {
          "hypothesis": "SKSurface.Create() has non-trivial cost even when wrapping pre-allocated memory, because it creates a new SkSurface C\u002B\u002B object each call. Caching the SKSurface and reusing it when the backing memory and dimensions haven\u0027t changed would eliminate this cost.",
          "proposals": [
            {
              "description": "Store SKSurface as a field in each factory/view. Only recreate when dimensions change (like GTK3\u0027s SKDrawingArea already does). For Apple\u0027s SKCGSurfaceFactory: cache the surface alongside bitmapData. For Android\u0027s SurfaceFactory: cache alongside bitmap. For WPF/WinForms/WinUI/Blazor: promote from local using-block to field with disposal on resize.",
              "title": "Apply GTK3 pattern to all factory classes",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "Before changing all views, benchmark SKSurface.Create() with pre-allocated memory to quantify the actual cost. If trivial, the optimization may not be worth the added complexity. Use BenchmarkDotNet to compare new-per-frame vs reuse patterns.",
              "title": "Benchmark first, then optimize",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Create a surface pool keyed by SKImageInfo. Views check out a surface, use it, and return it. More complex but handles dynamic sizing better than per-field caching.",
              "title": "Pool SKSurface instances",
              "confidence": 0.5,
              "effort": "large"
            }
          ],
          "recommendedProposal": "Benchmark first, then optimize",
          "recommendedReason": "Without benchmarks, it\u0027s unclear if SKSurface.Create() with pre-allocated memory is truly expensive. The GTK3 pattern works but adding cached state to all views increases complexity and risk of use-after-dispose bugs. Measure first, then apply the GTK3 pattern selectively to views where the cost is meaningful."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Valid performance enhancement filed by maintainer. Most views still exhibit the per-frame SKSurface allocation pattern. Related issue #1251 also reports per-frame allocation concerns. The issue remains actionable."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add performance tenet label; existing type/enhancement and area/SkiaSharp.Views labels are already correct",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "tenet/performance"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference #1251 which reports the same per-frame allocation concern for SKSwapChainPanel",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 1251
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 533,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:25:36Z",
        "currentLabels": [
          "type/bug",
          "type/enhancement",
          "status/help-wanted",
          "os/Android",
          "area/SkiaSharp.Views",
          "backend/OpenGL"
        ]
      },
      "summary": "Android SKGLView renders at uncapped framerate (300\u002B FPS) after switch from GLSurfaceView to GLTextureView in v1.60.1. The custom GLTextureView does not call eglSwapInterval, so VSync is not enforced, causing excessive CPU/GPU/battery drain when HasRenderLoop is enabled.",
      "classification": {
        "type": {
          "value": "type/enhancement",
          "confidence": 0.85
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Android"
        ],
        "backends": [
          "backend/OpenGL"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create an Android app with SKGLView (or SKGLTextureView)",
            "Set HasRenderLoop = true (or RenderMode = Rendermode.Continuously)",
            "Measure FPS using Stopwatch in PaintSurface handler",
            "Observe FPS of 300-1200\u002B instead of display-capped 60 FPS"
          ],
          "environmentDetails": "Originally reported on Samsung Galaxy S7 Edge, Android 7 API 24, SkiaSharp 1.60.1. Confirmed on emulators (1200 FPS) and Motorola Moto g6 (140 FPS), Galaxy Note 3 (230 FPS).",
          "relatedIssues": [
            729
          ]
        },
        "bugSignals": {
          "severity": "medium",
          "isRegression": true,
          "errorType": "performance",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net7.0-android",
            "net8.0-android"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.59.3",
            "1.60.1"
          ],
          "workedIn": "1.59.3",
          "brokeIn": "1.60.1",
          "currentRelevance": "likely",
          "relevanceReason": "The GLTextureView code is still in the current codebase and still does not call eglSwapInterval. The same Rendermode.Continuously loop runs without any frame pacing. SKGLTextureView is the default GL view for Android in both Xamarin.Forms and MAUI."
        },
        "regression": {
          "isRegression": true,
          "confidence": 0.95,
          "reason": "GLSurfaceView (used in v1.59.3) internally calls eglSwapInterval(1) which enforces VSync. The replacement GLTextureView (v1.60.1\u002B) does not, so the render loop runs uncapped.",
          "workedInVersion": "1.59.3",
          "brokeInVersion": "1.60.1"
        }
      },
      "analysis": {
        "summary": "When SkiaSharp switched from Android\u0027s GLSurfaceView to a custom GLTextureView in v1.60.1, VSync-based frame pacing was lost. GLSurfaceView internally uses eglSwapInterval(1), capping rendering to the display\u0027s refresh rate. The custom GLTextureView never calls eglSwapInterval, so Rendermode.Continuously loops as fast as the GPU can render \u2014 300-1200\u002B FPS, wasting battery and CPU/GPU resources.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "finding": "EglHelper.Swap() calls egl.EglSwapBuffers but never calls eglSwapInterval. Without eglSwapInterval(1), EGL swap does not block on VSync, so the render loop runs uncapped.",
            "relevance": "direct",
            "lines": "634-641"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/GLTextureView.cs",
            "finding": "IsReadyToDraw() returns true continuously when renderMode == Rendermode.Continuously, with no frame-pacing delay. The while loop in GuardedRun spins as fast as swap\u002Brender allows.",
            "relevance": "direct",
            "lines": "1081-1083"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLTextureView.cs",
            "finding": "SKGLTextureView.Initialize() does not set any frame pacing \u2014 just sets EGL version, config, and renderer. No Choreographer or eglSwapInterval setup.",
            "relevance": "direct",
            "lines": "36-43"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKGLSurfaceView.cs",
            "finding": "SKGLSurfaceView extends Android.Opengl.GLSurfaceView which internally manages eglSwapInterval. This was the previous implementation that DID have VSync.",
            "relevance": "related",
            "lines": "9"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Handlers/SKGLView/SKGLViewHandler.Android.cs",
            "finding": "MAUI handler maps HasRenderLoop to Rendermode.Continuously/WhenDirty on the same SKGLTextureView \u2014 confirming MAUI apps are also affected by the uncapped framerate.",
            "relevance": "related",
            "lines": "61-68"
          }
        ],
        "rationale": "Classified as enhancement rather than bug because the maintainer explicitly stated \u0027SkiaSharp will always render as fast as possible\u0027 and that frame-rate limiting was never an intentional feature. However, this is a regression in practical behavior (VSync was inherited from GLSurfaceView) and causes real resource waste. The area is SkiaSharp.Views (Android GL view layer), with performance tenet due to battery drain. Medium severity \u2014 not a crash but a significant resource problem for render-loop apps.",
        "keySignals": [
          {
            "text": "Application framerate went from a capped 60fps to a ~300fps",
            "source": "issue body",
            "interpretation": "Clear regression in frame pacing behavior after the GLSurfaceView to TextureView switch."
          },
          {
            "text": "I _see_ the change, and I think it has to do with the fact that we are no longer using the old GLSurfaceView but the new TextureView",
            "source": "comment #2 (mattleibow)",
            "interpretation": "Maintainer confirmed root cause is the view type change."
          },
          {
            "text": "Having uncapped is nice, but a heavy drain. Also, it is no point having the updates faster than the screen - that wastes resources.",
            "source": "comment #8 (mattleibow)",
            "interpretation": "Maintainer agrees this should be fixed \u2014 rendering faster than display refresh is wasteful."
          },
          {
            "text": "We might be able to look at Choreographer",
            "source": "comment #9 (mattleibow)",
            "interpretation": "Maintainer identified Android Choreographer as the proper fix approach for display-synced rendering."
          },
          {
            "text": "Noticing 1.2K FPS in some emulators",
            "source": "comment #6 (mattleibow)",
            "interpretation": "Problem persists and is extreme in some environments."
          }
        ],
        "workarounds": [
          "Use time-based animation (delta-time) instead of frame-based animation to decouple logic from frame rate",
          "Implement a manual frame limiter using Stopwatch to skip rendering when elapsed time is less than target interval (e.g., 1000/60 ms)",
          "Use RenderMode = Rendermode.WhenDirty and call RequestRender() from a timer at the desired interval"
        ],
        "nextQuestions": [
          "Would adding eglSwapInterval(1) to the EglHelper.CreateSurface path be sufficient, or would it break apps that want uncapped rendering?",
          "Should frame pacing be opt-in (new property like TargetFrameRate) or opt-out (VSync by default with an option to disable)?",
          "Is Android Choreographer the right approach, or is eglSwapInterval(1) simpler and sufficient for most use cases?"
        ],
        "resolution": {
          "hypothesis": "The GLTextureView never calls eglSwapInterval(1), so EGL swap buffers returns immediately instead of blocking until VSync. Adding eglSwapInterval or integrating Android Choreographer would cap rendering to the display refresh rate.",
          "proposals": [
            {
              "description": "Call eglSwapInterval(display, 1) in the EglHelper after creating the EGL surface. This is the simplest fix and mirrors what GLSurfaceView does internally. It caps rendering to the display\u0027s refresh rate via VSync.",
              "title": "Add eglSwapInterval(1) to EglHelper",
              "confidence": 0.75,
              "effort": "small"
            },
            {
              "description": "Use Android\u0027s Choreographer.postFrameCallback to schedule rendering at the display\u0027s refresh rate. This is the approach recommended by the maintainer and provides better frame pacing than eglSwapInterval alone. The Frame Pacing Library (games SDK) is an even more sophisticated option but harder to integrate.",
              "title": "Integrate Android Choreographer for frame pacing",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "As a workaround, set RenderMode to WhenDirty and use a timer to call RequestRender() at the desired frame rate. Note: System.Timers.Timer may not be ideal on Android \u2014 consider using Android.OS.Handler or View.PostDelayed() instead. Be sure to dispose the timer when the view is destroyed, and call OnPause/OnResume for proper lifecycle management.",
              "title": "Use WhenDirty mode with timer-based invalidation",
              "codeSnippet": "// Set the view to only render on demand\nskglView.RenderMode = Rendermode.WhenDirty;\n\n// Timer-based invalidation at ~60 FPS\n// Note: store timer as a field and dispose on cleanup\nvar timer = new System.Timers.Timer(16.67);\ntimer.Elapsed \u002B= (s, e) =\u003E skglView.RequestRender();\ntimer.Start();\n\n// In cleanup/Dispose:\n// timer.Stop();\n// timer.Dispose();",
              "confidence": 0.7,
              "effort": "trivial"
            },
            {
              "description": "Decouple animation from frame rate by using elapsed time between frames. This doesn\u0027t reduce GPU usage but makes animations correct regardless of FPS. Initialize lastFrame before first use to avoid a large delta on the first frame.",
              "title": "Use delta-time for animation logic",
              "codeSnippet": "Stopwatch sw = Stopwatch.StartNew();\nTimeSpan lastFrame = sw.Elapsed; // Initialize to avoid large first-frame delta\n\nvoid OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = sw.Elapsed;\n    var deltaTime = (now - lastFrame).TotalSeconds;\n    lastFrame = now;\n    \n    // Use deltaTime for all animation:\n    position \u002B= velocity * (float)deltaTime;\n}",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Use WhenDirty mode with timer-based invalidation",
          "recommendedReason": "Gives immediate relief with no engine changes needed. Users can control exact frame rate. The proper fix (eglSwapInterval or Choreographer) requires engine-level changes and design decisions about opt-in vs opt-out."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.8,
          "reason": "Root cause is well-understood (missing eglSwapInterval/Choreographer in GLTextureView), but the fix requires a design decision: should VSync be default, opt-in, or configurable? The maintainer has been tracking this since 2018 and identified Choreographer as the approach."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Normalize labels to single type (enhancement, not bug \u2014 maintainer confirmed uncapped was by design)",
            "risk": "low",
            "confidence": 0.85,
            "labels": [
              "type/enhancement",
              "area/SkiaSharp.Views",
              "os/Android",
              "backend/OpenGL",
              "tenet/performance"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround for frame pacing",
            "risk": "high",
            "confidence": 0.75,
            "comment": "This issue is still relevant in the current codebase. The root cause is confirmed: \u0060GLTextureView\u0060 (which replaced \u0060GLSurfaceView\u0060 in v1.60.1) does not call \u0060eglSwapInterval\u0060, so the render loop runs uncapped when using \u0060Rendermode.Continuously\u0060.\n\nHere\u0027s a workaround you can use: switch to \u0060Rendermode.WhenDirty\u0060 and drive rendering from a timer at your target frame rate:\n\n\u0060\u0060\u0060csharp\n// Set the view to only render on demand\nskglView.RenderMode = Rendermode.WhenDirty;\n\n// Timer-based invalidation at ~60 FPS\n// Store timer as a field and dispose on cleanup\nvar timer = new System.Timers.Timer(16.67);\ntimer.Elapsed \u002B= (s, e) =\u003E skglView.RequestRender();\ntimer.Start();\n\n// In cleanup/Dispose:\n// timer.Stop();\n// timer.Dispose();\n\u0060\u0060\u0060\n\n**Note:** On Android, \u0060Android.OS.Handler\u0060 or \u0060View.PostDelayed()\u0060 may be more reliable than \u0060System.Timers.Timer\u0060 for frame timing. Be sure to call \u0060OnPause()\u0060/\u0060OnResume()\u0060 for proper lifecycle management.\n\nFor animation correctness regardless of frame rate, use delta-time (initialize \u0060lastFrame\u0060 to avoid a large first-frame delta):\n\n\u0060\u0060\u0060csharp\nvar sw = Stopwatch.StartNew();\nvar lastFrame = sw.Elapsed;\n\nvoid OnPaint(object sender, SKPaintGLSurfaceEventArgs e)\n{\n    var now = sw.Elapsed;\n    var deltaTime = (now - lastFrame).TotalSeconds;\n    lastFrame = now;\n    position \u002B= velocity * (float)deltaTime;\n}\n\u0060\u0060\u0060\n\nA proper engine-level fix would involve either adding \u0060eglSwapInterval(1)\u0060 to the EGL setup, or integrating Android\u0027s Choreographer API for display-synced rendering. Both approaches have tradeoffs around whether VSync should be default or opt-in."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 528,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:18:16Z",
        "currentLabels": [
          "status/help-wanted",
          "os/Android"
        ]
      },
      "summary": "SKShaper.Shape() returns all-zero Codepoints on Android when the typeface is loaded via SKTypeface.FromStream(). The issue is Android-specific \u2014 WPF and iOS work correctly with the same code. The reporter discovered that switching to SKTypeface.FromData(SKData.Create(stream)) resolves the problem, suggesting a bug in how stream-based typefaces interact with HarfBuzz\u0027s font table reading on Android.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.HarfBuzz",
          "confidence": 0.92
        },
        "platforms": [
          "os/Android"
        ],
        "tenets": [
          "tenet/compatibility"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Load a custom font via SKTypeface.FromStream(stream) on Android",
            "Create an SKShaper with that typeface",
            "Call shaper.Shape(text, x, y, paint)",
            "Observe that result.Codepoints are all 0 (works on WPF and iOS)"
          ],
          "codeSnippets": [
            "var shaper = new SKShaper(paint.Typeface);\nvar result = shaper.Shape(\u0022Hello world!\u0022, 10, 300, paint); // result.Codepoints are all 0"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/2035982/HarfBuzzDemo.zip",
              "filename": "HarfBuzzDemo.zip",
              "description": "Complete repro project demonstrating the issue"
            }
          ],
          "environmentDetails": "Android emulator (x86) and LG G4 (ARMv8), tested with arial/Roboto/SF-UI-Display fonts in otf and ttf"
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "wrong-output",
          "errorMessage": "SKShaper.Result.Codepoints are all 0 on Android",
          "reproQuality": "complete",
          "targetFrameworks": [
            "monoandroid"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.60.x"
          ],
          "currentRelevance": "unknown",
          "relevanceReason": "Issue is from 2018 (SkiaSharp 1.x era). HarfBuzz has been updated significantly since then, but the core code path (SKShaper constructor calling Typeface.OpenStream().ToHarfBuzzBlob()) hasn\u0027t fundamentally changed. Needs verification with SkiaSharp 3.x."
        }
      },
      "analysis": {
        "summary": "The SKShaper constructor calls Typeface.OpenStream() to get font data, then converts it to a HarfBuzz blob via ToHarfBuzzBlob(). When a typeface is created via FromStream() on Android, the subsequent OpenStream() call may return invalid or empty data, causing HarfBuzz\u0027s hb_shape() to fail silently \u2014 it produces zero codepoints because it can\u0027t read the font tables. FromData() avoids this by keeping the font data fully in memory as an SKData object, which OpenStream() can reliably return.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/SKShaper.cs",
            "finding": "Constructor calls Typeface.OpenStream(out index).ToHarfBuzzBlob() to create the HarfBuzz font. If OpenStream returns invalid data on Android for stream-created typefaces, HarfBuzz gets an empty/bad blob.",
            "relevance": "direct",
            "lines": "19-30"
          },
          {
            "file": "source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
            "finding": "ToHarfBuzzBlob() first checks GetMemoryBase() \u2014 if non-null, wraps that pointer directly. Otherwise allocates and reads. If the stream asset from OpenStream is empty/invalid, this produces a zero-length or garbage blob.",
            "relevance": "direct",
            "lines": "10-36"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "FromStream converts SKManagedStream to memory stream, calls sk_typeface_create_from_stream which takes ownership of the stream. The native Skia code may not preserve the stream data for later OpenStream calls on some platforms.",
            "relevance": "direct",
            "lines": "100-113"
          },
          {
            "file": "binding/SkiaSharp/SKTypeface.cs",
            "finding": "FromData calls sk_typeface_create_from_data which keeps the data in memory via native reference counting. OpenStream on this typeface reliably returns the font data because it\u0027s backed by an SKData (in-memory buffer), not a consumed stream.",
            "relevance": "related",
            "lines": "115-121"
          }
        ],
        "rationale": "This is clearly a bug: the same code produces correct output on WPF/iOS but all-zero codepoints on Android. The area is SkiaSharp.HarfBuzz because the problem manifests in SKShaper.Shape() and traces back to the SKShaper constructor\u0027s interaction with typeface streams. The root cause is in the FromStream/OpenStream code path on Android, not in HarfBuzz itself. Severity is medium because there\u0027s a reliable workaround (FromData) and it\u0027s not a crash.",
        "keySignals": [
          {
            "text": "result.Codepoints are all 0 on Android",
            "source": "issue body",
            "interpretation": "HarfBuzz shaping silently fails \u2014 returns placeholder zeros instead of glyph IDs, indicating it can\u0027t read the font tables."
          },
          {
            "text": "When testing on WPF or iOS, everything seems ok",
            "source": "issue body",
            "interpretation": "Android-specific. The typeface data is valid (works elsewhere), so the problem is in how Android handles the stream-based typeface."
          },
          {
            "text": "hb_shape(Handle, buffer.Handle, IntPtr.Zero, 0) set all buffer.GlipInfo.CodePoints from utf8 to 0",
            "source": "comment #2",
            "interpretation": "Confirms the HarfBuzz C\u002B\u002B hb_shape call itself is the point of failure. The HB font blob must be empty or invalid."
          },
          {
            "text": "Using SKData.Create(stream) then SKTypeface.FromData(data) works",
            "source": "comment #10",
            "interpretation": "Confirms the stream data is valid. The bug is specifically in FromStream\u0027s interaction with OpenStream on Android."
          },
          {
            "text": "SKTypeface.FromFamilyName(\u0027Times New Roman\u0027) works",
            "source": "comment #5 (mattleibow)",
            "interpretation": "System-installed fonts work \u2014 the issue is limited to fonts loaded from streams/files."
          }
        ],
        "errorFingerprint": "HarfBuzz-Shape-ZeroCodes-Android-FromStream",
        "workarounds": [
          "Use SKTypeface.FromData(SKData.Create(stream)) instead of SKTypeface.FromStream(stream)"
        ],
        "nextQuestions": [
          "Is this still reproducible with SkiaSharp 3.x and the updated HarfBuzz?",
          "Does OpenStream() on a FromStream-created typeface actually return different data on Android vs other platforms?",
          "Was this partially addressed by HarfBuzz updates (issue #904)?"
        ],
        "resolution": {
          "hypothesis": "SKTypeface.FromStream() on Android creates a typeface where the native stream data is consumed/released after typeface construction. When SKShaper later calls OpenStream() to extract font data for HarfBuzz, the returned stream is empty or invalid on Android. FromData() avoids this because SKData keeps the font bytes in memory indefinitely via reference counting.",
          "proposals": [
            {
              "description": "Replace SKTypeface.FromStream(stream) with SKTypeface.FromData(SKData.Create(stream)) to ensure font data persists for HarfBuzz. Validated: reporter and another user confirmed this works.",
              "title": "Use FromData workaround",
              "codeSnippet": "using var data = SKData.Create(stream);\nvar typeface = SKTypeface.FromData(data);\nif (typeface == null)\n    throw new InvalidOperationException(\u0022Failed to load typeface\u0022);\nusing var shaper = new SKShaper(typeface);",
              "confidence": 0.95,
              "effort": "trivial"
            },
            {
              "description": "Modify SKTypeface.FromStream to internally convert to SKData before creating the typeface, ensuring OpenStream always has valid data. This would make FromStream behave identically to FromData on all platforms.",
              "title": "Fix FromStream to preserve data for OpenStream",
              "confidence": 0.7,
              "effort": "medium"
            },
            {
              "description": "Test whether the issue persists in SkiaSharp 3.x, which includes significant HarfBuzz updates and internal changes to stream handling.",
              "title": "Verify with SkiaSharp 3.x",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Use FromData workaround",
          "recommendedReason": "Confirmed working by the reporter and another user. Trivial code change with no side effects."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.75,
          "reason": "The workaround is well-established, but the underlying bug in FromStream\u002BOpenStream on Android has never been root-caused or fixed. The issue is also very old (2018) and needs verification with SkiaSharp 3.x before deciding whether to fix or close."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug and HarfBuzz area labels, keep Android platform label",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp.HarfBuzz",
              "os/Android"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the long-standing bug, confirm the workaround, and ask whether it still reproduces on SkiaSharp 3.x",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the thorough investigation on this, and apologies it\u0027s been open so long.\n\nThe workaround @michaldobrodenka found is the right approach \u2014 use \u0060SKTypeface.FromData\u0060 instead of \u0060SKTypeface.FromStream\u0060:\n\n\u0060\u0060\u0060csharp\nusing var data = SKData.Create(stream);\nvar typeface = SKTypeface.FromData(data);\nif (typeface == null)\n    throw new InvalidOperationException(\u0022Failed to load typeface\u0022);\nusing var shaper = new SKShaper(typeface);\n\u0060\u0060\u0060\n\nThe underlying cause appears to be that \u0060SKTypeface.FromStream()\u0060 on Android doesn\u0027t reliably preserve the font data for later \u0060OpenStream()\u0060 calls \u2014 which \u0060SKShaper\u0060 depends on to extract font tables for HarfBuzz. \u0060FromData()\u0060 keeps the bytes in memory via reference counting, so \u0060OpenStream()\u0060 always returns valid data.\n\nA lot has changed since 2018 \u2014 both SkiaSharp and HarfBuzz have had major updates. Would anyone be able to confirm whether this still reproduces with SkiaSharp 3.x? If the issue persists, we should look at having \u0060FromStream\u0060 internally use \u0060FromData\u0060 to avoid this class of bug."
          },
          {
            "type": "link-related",
            "description": "Link to RTL text support issue which motivated the original report",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 272
          }
        ],
        "missingInfo": [
          "Whether this issue still reproduces with SkiaSharp 3.x on modern Android"
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 425,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:09:01Z",
        "currentLabels": [
          "type/bug",
          "status/skia-update-required"
        ]
      },
      "summary": "SKCodecOrigin (now SKEncodedOrigin) returns TopLeft for DNG and CR2 RAW files instead of their actual EXIF orientation",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/libSkiaSharp.native",
          "confidence": 0.9
        }
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Open a DNG or CR2 file with SKCodec.Create()",
            "Read codec.EncodedOrigin (formerly codec.Origin)",
            "Observe it returns TopLeft regardless of actual EXIF orientation",
            "Compare with Chrome browser which correctly auto-orients these files"
          ],
          "attachments": [
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616452/APC_0316.zip",
              "filename": "APC_0316.zip",
              "description": "DNG sample with incorrect orientation"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1616453/APC_0193.zip",
              "filename": "APC_0193.zip",
              "description": "DNG sample with incorrect orientation"
            },
            {
              "url": "https://github.com/mono/SkiaSharp/files/1645431/IMG_1361.zip",
              "filename": "IMG_1361.zip",
              "description": "CR2 sample reported as TopLeft but should be LeftBottom"
            }
          ],
          "environmentDetails": "Cross-platform, all SkiaSharp versions",
          "relatedIssues": [
            836
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "wrong-output",
          "errorMessage": "SKCodecOrigin reports TopLeft for DNG/CR2 files that have non-TopLeft EXIF orientation",
          "reproQuality": "complete",
          "targetFrameworks": []
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "likely",
          "relevanceReason": "The SkRawCodec constructor still does not pass EXIF orientation to the base SkCodec class. The default kTopLeft_SkEncodedOrigin is hardcoded in the SkCodec base constructor signature."
        }
      },
      "analysis": {
        "summary": "Skia\u0027s SkRawCodec constructor does not extract or pass EXIF orientation data from DNG/CR2 files. The base SkCodec constructor defaults the origin parameter to kTopLeft_SkEncodedOrigin when not provided. Only JPEG and WebP codecs parse and pass EXIF orientation.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.EncodedOrigin directly wraps sk_codec_get_origin(). The C# binding is correct \u2014 it faithfully returns whatever Skia reports.",
            "relevance": "context",
            "lines": "36-37"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "SkRawCodec constructor calls INHERITED(SkEncodedInfo::Make(...), skcms_PixelFormat_RGBA_8888, nullptr) \u2014 only 3 args. The 4th param (SkEncodedOrigin) defaults to kTopLeft_SkEncodedOrigin. This is the root cause.",
            "relevance": "direct",
            "lines": "826-831"
          },
          {
            "file": "externals/skia/include/codec/SkCodec.h",
            "finding": "SkCodec constructor has default parameter SkEncodedOrigin = kTopLeft_SkEncodedOrigin, confirming RAW codec never provides orientation.",
            "relevance": "direct",
            "lines": "765-768"
          },
          {
            "file": "externals/skia/src/codec/SkJpegCodec.cpp",
            "finding": "SkJpegCodec correctly parses EXIF orientation via SkParseEncodedOrigin and passes it to the base SkCodec constructor. This is the model for how RAW should work.",
            "relevance": "related",
            "lines": "245-250"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "SkDngImage class has access to dng_negative (fNegative) which contains EXIF metadata after SynchronizeMetadata(). The orientation could potentially be extracted from fNegative but is not implemented.",
            "relevance": "direct",
            "lines": "456-642"
          },
          {
            "file": "externals/skia/src/codec/SkRawCodec.cpp",
            "finding": "MakeFromStream has a PIEX fast path that returns SkJpegCodec for JPEG-compressed previews (which WOULD have correct orientation). The bug only manifests when the full DNG decode path is used (line 714).",
            "relevance": "related",
            "lines": "649-715"
          }
        ],
        "rationale": "This is confirmed as a bug by the maintainer. The reporter provides sample DNG and CR2 files and demonstrates that SKCodecOrigin always returns TopLeft. The root cause is in upstream Skia\u0027s SkRawCodec, not in SkiaSharp\u0027s C# bindings \u2014 the C# wrapper correctly exposes whatever value Skia returns. The existing label status/skia-update-required is accurate. Severity is low because RAW file orientation is a niche use case and workarounds exist (read EXIF manually).",
        "keySignals": [
          {
            "text": "The following sample code results in SKCodecOrigin.TopLeft, which is incorrect",
            "source": "issue body",
            "interpretation": "Reporter confirms the origin value is wrong for DNG files."
          },
          {
            "text": "not limited to just dng. Here\u0027s a sample cr2 that is also affected. It is reported as TopLeft but it should be LeftBottom",
            "source": "comment 1 by OP",
            "interpretation": "Bug affects multiple RAW formats, not just DNG. Confirms expected value (LeftBottom vs TopLeft)."
          },
          {
            "text": "the DNG codec ignores this. The only ones that appear to respect this are jpeg and webp",
            "source": "comment 2 by mattleibow",
            "interpretation": "Maintainer confirms this is an upstream Skia limitation in the RAW codec."
          }
        ],
        "workarounds": [
          "Use a separate EXIF library (e.g., MetadataExtractor for .NET) to read orientation from DNG/CR2 files, then apply the rotation transform manually using SKCanvas",
          "For DNG files with embedded JPEG previews, extract the preview JPEG and decode that instead \u2014 it will report correct orientation via the JPEG codec path"
        ],
        "nextQuestions": [
          "Does the DNG SDK expose orientation metadata via dng_negative that could be passed to the SkCodec base constructor?",
          "Would an upstream Skia patch be accepted to extract orientation in SkRawCodec?",
          "Does the PIEX fast path (returning SkJpegCodec) correctly handle orientation for the reporter\u0027s specific files?"
        ],
        "resolution": {
          "hypothesis": "SkRawCodec in Skia does not extract EXIF orientation from DNG/CR2 metadata and does not pass it to the base SkCodec constructor, causing it to default to TopLeft for all RAW files.",
          "proposals": [
            {
              "description": "Install the MetadataExtractor NuGet package to read EXIF orientation from RAW files independently, then use the orientation value to transform the decoded image.",
              "title": "Use MetadataExtractor to read EXIF orientation",
              "codeSnippet": "// NuGet: MetadataExtractor\nusing MetadataExtractor;\nusing MetadataExtractor.Formats.Exif;\n\nvar directories = ImageMetadataReader.ReadMetadata(path);\nvar ifd0 = directories.OfType\u003CExifIfd0Directory\u003E().FirstOrDefault();\nif (ifd0 != null \u0026\u0026 ifd0.TryGetUInt16(ExifDirectoryBase.TagOrientation, out var orientation))\n{\n    var origin = (SKEncodedOrigin)orientation;\n    // Use origin to apply the correct rotation transform\n}",
              "confidence": 0.85,
              "effort": "small"
            },
            {
              "description": "Modify SkRawCodec to extract EXIF orientation from the DNG SDK\u0027s dng_negative metadata after SynchronizeMetadata(), then pass it to the SkCodec base constructor. This matches the pattern used by SkJpegCodec.",
              "title": "Upstream Skia fix to SkRawCodec",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Use MetadataExtractor to read EXIF orientation",
          "recommendedReason": "This workaround is independent of the upstream Skia fix and gives the reporter a solution today. The upstream fix requires changes to Skia\u0027s SkRawCodec which is outside SkiaSharp\u0027s direct control."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.9,
          "reason": "Confirmed bug in Skia\u0027s SkRawCodec \u2014 the orientation is never extracted from DNG/CR2 EXIF metadata. Requires changes in upstream Skia code. The existing status/skia-update-required label is already correct."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Add area/libSkiaSharp.native to existing labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/libSkiaSharp.native",
              "status/skia-update-required"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround using MetadataExtractor for EXIF orientation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the detailed report and sample files.\n\nThis is a limitation in Skia\u0027s RAW codec (\u0060SkRawCodec\u0060). The codec does not extract EXIF orientation from DNG or CR2 metadata \u2014 it always defaults to \u0060TopLeft\u0060. By contrast, the JPEG and WebP codecs do parse EXIF orientation correctly.\n\nAs a workaround, you can use a .NET EXIF library like [MetadataExtractor](https://www.nuget.org/packages/MetadataExtractor) to read the orientation independently:\n\n\u0060\u0060\u0060csharp\nusing MetadataExtractor;\nusing MetadataExtractor.Formats.Exif;\n\nvar directories = ImageMetadataReader.ReadMetadata(path);\nvar ifd0 = directories.OfType\u003CExifIfd0Directory\u003E().FirstOrDefault();\nif (ifd0 != null \u0026\u0026 ifd0.TryGetUInt16(ExifDirectoryBase.TagOrientation, out var orientation))\n{\n    var origin = (SKEncodedOrigin)orientation;\n    // Use origin to apply the correct rotation transform\n}\n\u0060\u0060\u0060\n\nA proper fix would require changes to Skia\u0027s \u0060SkRawCodec\u0060 to extract orientation from the DNG SDK metadata and pass it to the base codec constructor."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #836 (Image auto orientation method) \u2014 related feature request for auto-orient",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 836
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 315,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:03:53Z",
        "currentLabels": []
      },
      "summary": "Pinch and pan gestures conflict with SkiaSharp touch events on Android in Xamarin.Forms",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.7
        },
        "area": {
          "value": "area/SkiaSharp.Views.Forms",
          "confidence": 0.9
        },
        "platforms": [
          "os/Android"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a Xamarin.Forms app with SKCanvasView and touch events enabled",
            "Add PinchGestureRecognizer and PanGestureRecognizer to the containing view",
            "Attempt to draw (finger paint) on Android while using pinch/pan gestures",
            "Observe that touch events do not work correctly on Android (works on iOS)"
          ],
          "environmentDetails": "Xamarin.Forms, Android, SkiaSharp circa 2017 (pre-1.x era)",
          "relatedIssues": [
            309,
            909,
            1048
          ],
          "repoLinks": [
            {
              "url": "https://github.com/JavedAppdevelopment/DrawTrackingForms",
              "description": "Reporter\u0027s Xamarin.Forms finger-paint sample with pinch/pan"
            }
          ]
        },
        "bugSignals": {
          "severity": "low",
          "errorType": "incorrect-behavior",
          "reproQuality": "partial",
          "targetFrameworks": [
            "xamarinandroid"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [],
          "currentRelevance": "unlikely",
          "relevanceReason": "Xamarin.Forms is end-of-life. SkiaSharp.Views.Forms has been removed from the codebase, replaced by SkiaSharp.Views.Maui. The Android touch handler has been rewritten for MAUI with a different architecture. The underlying gesture conflict between native touch handling and framework gesture recognizers is an inherent platform integration challenge that may still exist in MAUI, but the specific code paths are entirely different."
        }
      },
      "analysis": {
        "summary": "Reporter describes Xamarin.Forms pinch/pan gesture recognizers interfering with SkiaSharp touch events on Android. Drawing with touch works on iOS but not Android when combined with gesture recognizers. Issue #909 describes the identical problem from the iOS perspective. This is a known limitation of mixing native touch handling with framework-level gesture recognizers \u2014 Android\u0027s View.Touch event and Xamarin.Forms gesture recognizers compete for touch ownership via the Handled flag.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Android/SKTouchHandler.cs",
            "finding": "Current MAUI Android SKTouchHandler hooks into View.Touch and sets e.Handled = args.Handled. When Handled is true, the parent gesture recognizers (pan/pinch) are starved of touch events. When false, SkiaSharp doesn\u0027t track the touch. This mutual exclusion is the root of the gesture conflict \u2014 it exists in both the old Forms and new MAUI implementations.",
            "relevance": "direct",
            "lines": "41-109"
          },
          {
            "file": "source/SkiaSharp.Views.Maui/SkiaSharp.Views.Maui.Core/Platform/Apple/SKTouchHandler.cs",
            "finding": "iOS SKTouchHandler extends UIGestureRecognizer directly, which participates in iOS gesture recognition system and can coexist with other recognizers. This architectural difference explains why iOS handles the combination better than Android.",
            "relevance": "related",
            "lines": "10-111"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views/Platform/Android/SKCanvasView.cs",
            "finding": "Legacy Android SKCanvasView (non-Forms) extends android.view.View directly. No touch handling built in \u2014 the Xamarin.Forms renderer layer would have added touch support. SkiaSharp.Views.Forms source has been fully removed from the codebase.",
            "relevance": "context",
            "lines": "1-156"
          }
        ],
        "rationale": "Classified as type/bug because the reporter describes behavior that works on iOS but not Android \u2014 a platform-specific defect in gesture handling, not a usage question. Area is SkiaSharp.Views.Forms since the issue is specifically about the Xamarin.Forms SKCanvasView and gesture recognizer interaction. Severity is low because (1) SkiaSharp.Views.Forms has been removed from the codebase in favor of MAUI, (2) the issue is from 2017 with only one follow-up comment from 2019, and (3) Xamarin.Forms itself is end-of-life.",
        "keySignals": [
          {
            "text": "Pinch and Pan with Touch works in iOS version but not work in Android version",
            "source": "issue body",
            "interpretation": "Platform-specific behavior difference in how Android dispatches touch events when gesture recognizers are attached. On Android, View.Touch handler and gesture recognizers compete for touch ownership."
          },
          {
            "text": "#309 introduces TouchEvents but somehow they interfere with Xamarin.Forms GestureRecognizers on Android",
            "source": "comment #1 (nor0x)",
            "interpretation": "Confirms this is a known interaction issue between SkiaSharp\u0027s touch event system (added in #309) and Xamarin.Forms gesture recognizers."
          },
          {
            "text": "Issue filed 2017-06-16, last community comment 2019-03-26, no maintainer response",
            "source": "issue metadata",
            "interpretation": "Nearly 9 years old with no maintainer engagement. The underlying platform (Xamarin.Forms) is now end-of-life."
          }
        ],
        "nextQuestions": [
          "Does the same gesture conflict still exist in MAUI with the new SKTouchHandler?",
          "Could Android\u0027s requestDisallowInterceptTouchEvent() help coordinate touch ownership?"
        ],
        "resolution": {
          "hypothesis": "On Android, SkiaSharp\u0027s touch handler and Xamarin.Forms gesture recognizers (Pan/Pinch) compete for touch event ownership. Setting e.Handled=true in the touch handler prevents gestures from receiving events; setting it false prevents SkiaSharp from tracking touches. iOS doesn\u0027t have this problem because its SKTouchHandler is a UIGestureRecognizer that participates in the native gesture recognition system.",
          "proposals": [
            {
              "description": "Xamarin.Forms is end-of-life. Migrate to .NET MAUI with SkiaSharp.Views.Maui, which has a rewritten touch handler. This is the recommended path forward.",
              "title": "Migrate to .NET MAUI",
              "confidence": 0.7,
              "effort": "large"
            },
            {
              "description": "Instead of mixing Xamarin.Forms gesture recognizers with SkiaSharp touch events, implement pinch and pan detection entirely within the SKTouchAction handler. Track multiple touch points manually: compute distance between points for pinch, track centroid movement for pan.",
              "title": "Use only SkiaSharp touch events for all gestures",
              "confidence": 0.8,
              "effort": "medium"
            },
            {
              "description": "The Xamarin.Forms platform is end-of-life and SkiaSharp.Views.Forms has been removed from the codebase. This issue cannot be fixed in the current codebase. Close with guidance to migrate to MAUI.",
              "title": "Close as stale \u2014 Xamarin.Forms EOL",
              "confidence": 0.85,
              "effort": "trivial"
            }
          ],
          "recommendedProposal": "Close as stale \u2014 Xamarin.Forms EOL",
          "recommendedReason": "Xamarin.Forms is end-of-life and SkiaSharp.Views.Forms has been entirely removed from the codebase. There is no code to fix. The reporter should migrate to MAUI."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "close-as-fixed",
          "confidence": 0.85,
          "reason": "Xamarin.Forms is end-of-life, SkiaSharp.Views.Forms has been removed from the codebase, and the touch handler has been rewritten for MAUI. The specific code paths causing this issue no longer exist."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, views.forms, and android labels",
            "risk": "low",
            "confidence": 0.9,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views.Forms",
              "os/Android"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post closure guidance with migration recommendation",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for reporting this. The underlying issue was a conflict between Android\u0027s touch event dispatch and Xamarin.Forms gesture recognizers \u2014 SkiaSharp\u0027s touch handler and Pan/Pinch gesture recognizers compete for touch ownership on Android (unlike iOS, where the touch handler participates in the native gesture recognition system).\n\nXamarin.Forms has reached end-of-life and SkiaSharp.Views.Forms has been removed from the codebase, so this can\u0027t be addressed in current versions. If you\u0027re still working with SkiaSharp, we recommend migrating to .NET MAUI with \u0060SkiaSharp.Views.Maui\u0060, which has a rewritten touch handler.\n\nIf the gesture conflict persists in MAUI, please open a new issue with a MAUI reproduction project.\n\nClosing as the affected platform is no longer supported."
          },
          {
            "type": "link-related",
            "description": "Cross-reference #909 (same gesture conflict on iOS/Forms)",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 909
          },
          {
            "type": "close-issue",
            "description": "Close \u2014 Xamarin.Forms is end-of-life and code has been removed",
            "risk": "medium",
            "confidence": 0.85
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 310,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T15:00:19Z",
        "currentLabels": [
          "type/enhancement",
          "status/low-priority",
          "os/Windows-Classic",
          "area/SkiaSharp.Views"
        ]
      },
      "summary": "Re-entrant OnPaint in WinForms SKControl causes ExternalException in Bitmap.UnlockBits. When the user resizes the SKControl from within the PaintSurface event handler, a parent container (DevExpress XtraScrollableControl) can trigger a nested OnPaint call. The re-entrant call disposes and recreates the GDI\u002B bitmap via CreateBitmap(), so when the outer OnPaint tries to call UnlockBits on the now-disposed bitmap, GDI\u002B throws. The code still has no re-entrancy guard.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.88
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.98
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Place an SKControl inside a scrollable container (e.g., DevExpress XtraScrollableControl)",
            "Resize the SKControl.Height from within the PaintSurface event handler",
            "Scroll the container so the SKControl is partially or fully offscreen",
            "Trigger a content change that causes the height resize during paint"
          ],
          "environmentDetails": "Windows, WinForms, .NET Framework (2017-era report)"
        },
        "bugSignals": {
          "severity": "medium",
          "errorType": "ExternalException",
          "errorMessage": "A generic error occurred in GDI\u002B.",
          "stackTrace": "System.Runtime.InteropServices.ExternalException (0x80004005): A generic error occurred in GDI\u002B.\n   at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata)\n   at SkiaSharp.Views.Desktop.SKControl.OnPaint(PaintEventArgs e)\n   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer)\n   at System.Windows.Forms.Control.WmPaint(Message\u0026 m)\n   at System.Windows.Forms.Control.WndProc(Message\u0026 m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)",
          "reproQuality": "partial"
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "The SKControl.OnPaint code path has not changed since the issue was filed. No re-entrancy guard has been added. The bitmap LockBits/UnlockBits pattern is still identical."
        }
      },
      "analysis": {
        "summary": "The WinForms SKControl.OnPaint locks a GDI\u002B bitmap, fires the user\u0027s PaintSurface event, then unlocks the bitmap. If the user\u0027s PaintSurface handler triggers a re-entrant OnPaint (e.g. by resizing the control, causing a parent container to synchronously repaint), the re-entrant call disposes and recreates the bitmap, and the outer call crashes on UnlockBits. The reporter investigated this thoroughly and confirmed the re-entrancy as the root cause. A simple boolean re-entrancy guard would prevent the crash.",
        "codeInvestigation": [
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "OnPaint calls LockBits (line 43), then OnPaintSurface (line 49), then UnlockBits (line 55). No re-entrancy guard exists. If OnPaintSurface triggers a nested OnPaint, CreateBitmap() (line 38) disposes the locked bitmap and creates a new one, causing UnlockBits to fail on the disposed bitmap.",
            "relevance": "direct",
            "lines": "30-57"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "CreateBitmap() calls FreeBitmap() which disposes the existing bitmap when size changes. During re-entrant OnPaint after a resize, this disposes the bitmap that is still locked by the outer OnPaint call.",
            "relevance": "direct",
            "lines": "72-85"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs",
            "finding": "WPF SKElement uses the same Lock/OnPaintSurface/Unlock pattern with WriteableBitmap. Could be similarly vulnerable to re-entrancy, though WPF\u0027s rendering pipeline makes synchronous re-entrant OnRender less likely.",
            "relevance": "related",
            "lines": "45-88"
          }
        ],
        "rationale": "Classified as type/bug (not enhancement) because the control crashes due to lack of defensive coding \u2014 re-entrant OnPaint should be handled gracefully, not crash. The current type/enhancement label is incorrect. The area is clearly SkiaSharp.Views (WinForms SKControl). Severity is medium: it\u0027s a crash, but only triggered by modifying the control during paint, which is an unusual (though not invalid) pattern. The WPF SKElement has the same Lock/Unlock pattern and could be similarly vulnerable.",
        "keySignals": [
          {
            "text": "OnPaint event is being called from within the OnPaint event (due to my height resize code)",
            "source": "comment #2",
            "interpretation": "Re-entrant OnPaint is the root cause. The bitmap is locked in the outer call and disposed/recreated in the inner call."
          },
          {
            "text": "I am changing the SKControl.Height value from within the PaintSurface event, which is inside the bitmap lock/unlock",
            "source": "comment #1",
            "interpretation": "The user is resizing during paint, which causes the parent container to trigger a synchronous repaint."
          },
          {
            "text": "It would be easy enough to handle this situation in the SKControl itself so it doesn\u0027t crash",
            "source": "comment #2",
            "interpretation": "Reporter suggests a defensive fix in SKControl. A re-entrancy guard is straightforward."
          },
          {
            "text": "This issue serves to act as a note for further investigation",
            "source": "comment #5 (mattleibow)",
            "interpretation": "Maintainer acknowledged the issue and kept it open for investigation. No fix has been applied since."
          }
        ],
        "errorFingerprint": "ExternalException-GDI-UnlockBits-SKControl-OnPaint-reentrant",
        "workarounds": [
          "Do not resize the SKControl from within the PaintSurface event handler. Calculate layout dimensions separately and apply the resize outside of the paint event.",
          "Reset the parent scrollable container\u0027s scroll position before resizing the SKControl to avoid the parent triggering a synchronous repaint."
        ],
        "nextQuestions": [
          "Should a re-entrancy guard be added to SKControl.OnPaint (e.g. a bool _painting field that causes early return on re-entry)?",
          "Is the WPF SKElement vulnerable to the same re-entrancy issue?",
          "Should the bitmap be captured in a local variable before LockBits so UnlockBits always uses the same reference?"
        ],
        "resolution": {
          "hypothesis": "Re-entrant OnPaint disposes the locked bitmap. The outer OnPaint then calls UnlockBits on a disposed bitmap, causing the GDI\u002B ExternalException.",
          "proposals": [
            {
              "description": "Add a boolean field (_painting) that is set to true at the start of OnPaint and cleared at the end. If OnPaint is called while _painting is true, return immediately. This prevents the nested call from disposing the bitmap.",
              "title": "Add re-entrancy guard",
              "codeSnippet": "private bool _painting;\n\nprotected override void OnPaint(PaintEventArgs e)\n{\n    if (designMode || _painting)\n        return;\n    _painting = true;\n    try\n    {\n        // existing OnPaint body\n    }\n    finally\n    {\n        _painting = false;\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Store the bitmap reference in a local variable after LockBits. Use the local variable for UnlockBits and DrawImage so that even if CreateBitmap disposes the field, the locked reference remains valid for the outer call to unlock.",
              "title": "Capture bitmap reference locally",
              "confidence": 0.65,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Add re-entrancy guard",
          "recommendedReason": "Simplest and most defensive fix. Prevents all re-entrancy issues, not just the bitmap disposal race. Trivial to implement and low risk."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.82,
          "reason": "The root cause is well-understood and the fix is straightforward, but the code hasn\u0027t changed since 2017. Needs a developer to add the re-entrancy guard and verify the WPF SKElement isn\u0027t similarly affected."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Correct type from enhancement to bug and add reliability tenet",
            "risk": "low",
            "confidence": 0.88,
            "labels": [
              "type/bug",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Acknowledge the bug is still present and describe the proposed fix",
            "risk": "high",
            "confidence": 0.85,
            "comment": "Thanks for the thorough investigation back in 2017, @Craig-TSS \u2014 your diagnosis was spot-on.\n\nThe \u0060SKControl.OnPaint\u0060 code path still has no re-entrancy guard. The \u0060LockBits\u0060 \u2192 \u0060OnPaintSurface\u0060 \u2192 \u0060UnlockBits\u0060 sequence is vulnerable whenever a nested \u0060OnPaint\u0060 is triggered during the paint event (e.g., by resizing the control from within \u0060PaintSurface\u0060).\n\nHere\u0027s a workaround you can use: avoid resizing the control from within the \u0060PaintSurface\u0060 handler. Calculate layout dimensions separately and apply resizes outside the paint event.\n\nThe fix on the SkiaSharp side would be a simple re-entrancy guard \u2014 a \u0060bool _painting\u0060 field that causes \u0060OnPaint\u0060 to return immediately if it\u0027s already executing. We\u0027ll also check whether the WPF \u0060SKElement\u0060 has the same vulnerability."
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 243,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T14:56:44Z",
        "currentLabels": [
          "os/Windows-Classic",
          "area/Build",
          "type/feature-request"
        ]
      },
      "summary": "Feature request to bundle ANGLE (OpenGL ES over DirectX) with SkiaSharp for Windows desktop runtimes (WPF/WinForms). Originally filed for Win7 with DX9 support, the discussion evolved into how SkiaSharp could ship GPU-accelerated views for classic Windows desktop by packaging ANGLE as a separate NuGet dependency. SkiaSharp already has ANGLE interop code (GRGlInterface.CreateAngle, AngleSwapChainPanel for WinUI) and a Direct3D backend (GRContext.CreateDirect3D), but no GPU-accelerated views ship for WPF/WinForms.",
      "classification": {
        "type": {
          "value": "type/feature-request",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp.Views",
          "confidence": 0.8
        },
        "platforms": [
          "os/Windows-Classic"
        ],
        "backends": [
          "backend/OpenGL",
          "backend/Direct3D"
        ],
        "tenets": [
          "tenet/performance"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "screenshots": [
            {
              "url": "https://i.imgur.com/DZWkJdg.png",
              "description": "ANGLE DX9 rendering support diagram"
            }
          ],
          "relatedIssues": [
            2817,
            2996,
            2104,
            2968
          ]
        },
        "versionAnalysis": {
          "currentRelevance": "likely",
          "relevanceReason": "SkiaSharp still has no GPU-accelerated views for WPF/WinForms. The ANGLE interop exists in WinUI views only. While Win7 is EOL, the broader need for GPU rendering on classic Windows desktop remains. The D3D backend exists but isn\u0027t surfaced in views."
        }
      },
      "analysis": {
        "summary": "This is a long-standing feature request to ship ANGLE with SkiaSharp for Windows desktop. SkiaSharp already has significant ANGLE infrastructure (GRGlInterface.CreateAngle, AngleSwapChainPanel, GlesContext/Egl interop) but only for WinUI/UWP. WPF/WinForms views use raster-only rendering. Since filing, Skia gained a native Direct3D backend (GRContext.CreateDirect3D), which could be an alternative to ANGLE for GPU-accelerated desktop views. The maintainer discussed packaging ANGLE as a separate NuGet but noted DLL conflict concerns with AMD\u0027s system-wide libEGL.dll.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/GRGlInterface.cs",
            "finding": "GRGlInterface.Create() already falls back to CreateAngle() on Windows. CreateAngle() loads ANGLE\u0027s libEGL/libGLESv2 via AngleLoader. The API exists but requires the ANGLE DLLs to be present at runtime.",
            "relevance": "direct",
            "lines": "27-48"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/AngleSwapChainPanel.cs",
            "finding": "Full ANGLE SwapChainPanel implementation exists for WinUI \u2014 creates GlesContext, manages render loop, handles composition scale. This is the model for what a WPF/WinForms equivalent would look like.",
            "relevance": "direct",
            "lines": "1-307"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WinUI/GlesInterop/Egl.cs",
            "finding": "Complete EGL interop with ANGLE-specific constants (D3D9, D3D11, WARP device types). Infrastructure for ANGLE is mature.",
            "relevance": "related",
            "lines": "60-80"
          },
          {
            "file": "binding/SkiaSharp/GRContext.cs",
            "finding": "GRContext.CreateDirect3D exists with GRD3DBackendContext. This provides a native D3D12 path that could bypass ANGLE entirely for GPU rendering on Windows.",
            "relevance": "related",
            "lines": "66-79"
          },
          {
            "file": "binding/SkiaSharp/GRD3DBackendContext.cs",
            "finding": "D3D backend context wraps IDXGIAdapter, ID3D12Device, and ID3D12CommandQueue \u2014 full D3D12 interop is available.",
            "relevance": "related",
            "lines": "1-37"
          },
          {
            "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs",
            "finding": "WinForms SKControl uses System.Drawing.Bitmap (raster only) \u2014 no GPU path exists. This is the gap the feature request targets.",
            "relevance": "direct",
            "lines": "1-50"
          }
        ],
        "rationale": "Classified as feature-request because no current SkiaSharp API or packaging is broken \u2014 the request is for new capability (GPU views for WPF/WinForms). Area is SkiaSharp.Views rather than Build because the core deliverable is GPU-accelerated view controls, not just packaging ANGLE. The existing label area/Build reflects the original framing but the discussion shows this is really about shipping new view infrastructure. Windows-Classic platform and OpenGL\u002BDirect3D backends reflect the target surface area.",
        "keySignals": [
          {
            "text": "Angle has support even for DX9-based rendering which is preinstalled on Win7",
            "source": "issue body",
            "interpretation": "Original motivation was Win7 GPU support via ANGLE\u0027s DX9 backend."
          },
          {
            "text": "Packaging ANGLE as a separate package and referencing it from WPF/Winforms views should work",
            "source": "comment by kekekeks (2020-04-25)",
            "interpretation": "Avalonia maintainer confirms the packaging approach is viable."
          },
          {
            "text": "AMD ships their own libEGL.dll in system32. Including ANGLE with Skia will break users who are using AMD EGL implementation",
            "source": "comment by kekekeks (2020-04-25)",
            "interpretation": "DLL naming conflicts are a real deployment risk that needs design work."
          },
          {
            "text": "Maybe skia will get a DX backend - I see some work on that now",
            "source": "comment by mattleibow (2020-04-25)",
            "interpretation": "Skia\u0027s native D3D backend has since materialized (GRContext.CreateDirect3D exists), providing an alternative path."
          },
          {
            "text": "GRGlInterface.Create() falls back to CreateAngle() on Windows",
            "source": "code search: binding/SkiaSharp/GRGlInterface.cs:28",
            "interpretation": "ANGLE GL interface creation is already built into SkiaSharp\u0027s API surface \u2014 the gap is packaging and view controls."
          }
        ],
        "workarounds": [
          "Use GRGlInterface.CreateAngle() with manually-supplied ANGLE DLLs (libEGL.dll, libGLESv2.dll) in the output directory",
          "Use GRContext.CreateDirect3D() with a manually-created D3D12 device for GPU-accelerated rendering without ANGLE",
          "Use Avalonia.Angle.Windows.Natives NuGet package to supply ANGLE binaries (as referenced in the discussion)"
        ],
        "nextQuestions": [
          "Should the solution use ANGLE (OpenGL ES over DX) or Skia\u0027s native Direct3D12 backend?",
          "Should ANGLE be a separate NuGet package or bundled with views?",
          "How to handle DLL naming conflicts with AMD\u0027s system libEGL.dll?",
          "Is a cross-platform GPU view (#2104) the right umbrella for this work?"
        ],
        "resolution": {
          "hypothesis": "SkiaSharp needs GPU-accelerated view controls for WPF/WinForms. Two viable paths exist: (1) package ANGLE as a separate NuGet and create ANGLE-based views mirroring AngleSwapChainPanel, or (2) use Skia\u0027s native D3D12 backend via GRContext.CreateDirect3D to build D3D-native views without ANGLE.",
          "proposals": [
            {
              "description": "Build GPU-accelerated WPF/WinForms views using GRContext.CreateDirect3D (already in SkiaSharp API). This avoids ANGLE entirely and uses Skia\u0027s native D3D12 support. Requires creating D3D12 device/queue in the view and managing swap chains via DXGI.",
              "title": "Native D3D12 backend views",
              "confidence": 0.65,
              "effort": "large"
            },
            {
              "description": "Package ANGLE binaries as SkiaSharp.NativeAssets.ANGLE NuGet, referenced by WPF/WinForms view packages. Mirror the AngleSwapChainPanel pattern for WPF/WinForms hosting. Address DLL conflicts by loading from app-local directory.",
              "title": "Separate ANGLE NuGet package",
              "confidence": 0.6,
              "effort": "large"
            },
            {
              "description": "Document using Avalonia.Angle.Windows.Natives or similar third-party ANGLE NuGet with GRGlInterface.CreateAngle() for GPU rendering in WPF/WinForms. Low effort workaround users can apply today.",
              "title": "Use third-party ANGLE package",
              "confidence": 0.5,
              "effort": "small"
            }
          ],
          "recommendedProposal": "Native D3D12 backend views",
          "recommendedReason": "Skia\u0027s native D3D12 backend avoids the ANGLE dependency, DLL conflict issues, and the maintenance burden of shipping ANGLE. It\u0027s the modern path forward for GPU rendering on Windows, aligned with #2817 and #2104."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "keep-open",
          "confidence": 0.85,
          "reason": "Legitimate feature gap \u2014 no GPU-accelerated views for WPF/WinForms. The underlying infrastructure (ANGLE interop, D3D backend) exists but isn\u0027t surfaced in view controls. Related to #2104 (cross-platform GPU views) which is the likely umbrella for this work."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Update area label from Build to Views \u2014 the feature is about GPU view controls, not build packaging",
            "risk": "low",
            "confidence": 0.8,
            "labels": [
              "type/feature-request",
              "area/SkiaSharp.Views",
              "os/Windows-Classic",
              "backend/OpenGL",
              "backend/Direct3D",
              "tenet/performance"
            ]
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #2104 (cross-platform GPU backend views) \u2014 this is a subset of that work",
            "risk": "low",
            "confidence": 0.85,
            "linkedIssue": 2104
          },
          {
            "type": "link-related",
            "description": "Cross-reference with #2817 (Direct3D support) \u2014 D3D backend is an alternative approach",
            "risk": "low",
            "confidence": 0.8,
            "linkedIssue": 2817
          }
        ]
      }
    },
    {
      "meta": {
        "schemaVersion": "1.0",
        "number": 209,
        "repo": "mono/SkiaSharp",
        "analyzedAt": "2026-02-12T14:50:00Z",
        "currentLabels": [
          "type/bug",
          "status/help-wanted"
        ]
      },
      "summary": "Concurrent calls to SKBitmap.Decode from multiple threads cause AccessViolationException crashes. Reported across IIS, ASP.NET Core, Azure Functions, and .NET console apps. The underlying Skia C\u002B\u002B codec is not thread-safe, and simultaneous decode operations on separate SKBitmap instances still crash. Multiple reporters confirm a SemaphoreSlim(1,1) workaround eliminates the crash but serializes decoding. The issue has persisted across SkiaSharp versions from 1.x through 2.88.5, with reports spanning 2016\u20132024.",
      "classification": {
        "type": {
          "value": "type/bug",
          "confidence": 0.95
        },
        "area": {
          "value": "area/SkiaSharp",
          "confidence": 0.92
        },
        "tenets": [
          "tenet/reliability"
        ]
      },
      "evidence": {
        "reproEvidence": {
          "stepsToReproduce": [
            "Create a multi-threaded application (IIS, Azure Functions, or console app with Task.Run)",
            "Call SKBitmap.Decode concurrently from multiple threads on separate byte arrays or files",
            "Observe AccessViolationException crash after a few iterations under concurrent load"
          ],
          "codeSnippets": [
            "const int numThreads = 100;\nconst int numIterationsPerThread = 1000;\nvar tasks = new List\u003CTask\u003E();\nfor (int i = 0; i \u003C numThreads; i\u002B\u002B) {\n    var task = Task.Run(() =\u003E {\n        for (int j = 0; j \u003C numIterationsPerThread; j\u002B\u002B) {\n            var imageData = ComputeThumbnail(referenceFile);\n        }\n    });\n    tasks.Add(task);\n}\nTask.WaitAll(tasks.ToArray());"
          ],
          "environmentDetails": "Windows (IIS), .NET Framework 4.x, .NET Core, .NET 5, .NET 7, Azure Functions Isolate Container",
          "relatedIssues": [
            235,
            1174,
            2194,
            2456
          ],
          "repoLinks": [
            {
              "url": "https://github.com/ncthbrt/skia-fsharp",
              "description": "F# repro project showing concurrent SKBitmap.Decode crash on .NET Core"
            }
          ]
        },
        "bugSignals": {
          "severity": "critical",
          "errorType": "AccessViolationException",
          "errorMessage": "Attempted to read or write protected memory. This is often an indication that other memory is corrupt.",
          "stackTrace": "at SkiaSharp.SkiaApi.sk_codec_get_info(IntPtr, SKImageInfo ByRef)\n  at SkiaSharp.SKBitmap.Decode(SKCodec)\n  at SkiaSharp.SKBitmap.Decode(SKStream)",
          "reproQuality": "complete",
          "targetFrameworks": [
            "net461",
            "netcoreapp2.0",
            "net5.0",
            "net7.0"
          ]
        },
        "versionAnalysis": {
          "mentionedVersions": [
            "1.56.2",
            "1.57.0",
            "2.80.2",
            "2.80.3",
            "2.88.5"
          ],
          "currentRelevance": "likely",
          "relevanceReason": "The SKBitmap.Decode code path has not changed structurally. It still creates an SKCodec per call, calls sk_codec_get_pixels, and there is no synchronization in the C# layer or the Skia C API layer. The SkiaSharp 3.x HandleDictionary uses locks for handle tracking but does not protect the underlying Skia codec operations."
        },
        "regression": {
          "isRegression": false,
          "confidence": 0.85,
          "reason": "This appears to be a longstanding limitation rather than a regression. Reporter in comment 25 states reverting to 2.80.2 fixed the issue for them, but others report the same crash on older versions. The core thread-safety limitation of Skia codecs has existed throughout all versions."
        }
      },
      "analysis": {
        "summary": "SKBitmap.Decode is not thread-safe because the underlying Skia C\u002B\u002B codec operations (sk_codec_get_info, sk_codec_get_pixels, sk_codec_new_from_stream) are not designed for concurrent use. Each call to SKBitmap.Decode creates its own SKCodec instance, but Skia\u0027s internal state (global allocators, codec registries) may have shared mutable state that is not protected by locks. The C# wrapper (SKBitmap.cs:434-458) has no synchronization, and the P/Invoke calls go directly to native code. The GC.KeepAlive fix (commit 643e1b4c5) addressed a related but different issue \u2014 premature GC of objects during P/Invoke calls. The fundamental thread-safety gap in concurrent codec operations remains.",
        "codeInvestigation": [
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "SKBitmap.Decode(SKCodec) and Decode(SKCodec, SKImageInfo) create a new SKBitmap, call codec.GetPixels to decode. No locking or synchronization. Each concurrent call gets its own codec and bitmap, but native Skia may share internal state.",
            "relevance": "direct",
            "lines": "434-458"
          },
          {
            "file": "binding/SkiaSharp/SKBitmap.cs",
            "finding": "All Decode overloads (Stream, SKStream, SKData, string, byte[], ReadOnlySpan\u003Cbyte\u003E) follow the same pattern: create SKCodec via SKCodec.Create, then call Decode(codec). No thread protection at any entry point.",
            "relevance": "direct",
            "lines": "461-586"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.Create(SKStream) calls sk_codec_new_from_stream, which goes to native Skia. The stream ownership is transferred (RevokeOwnership). No locking around the native call.",
            "relevance": "direct",
            "lines": "252-264"
          },
          {
            "file": "binding/SkiaSharp/SKCodec.cs",
            "finding": "SKCodec.GetPixels calls sk_codec_get_pixels \u2014 the native function where most AccessViolationExceptions occur in reporter stack traces. Parameters are local (nInfo, nOptions) but the native implementation may access global Skia state.",
            "relevance": "direct",
            "lines": "119-137"
          },
          {
            "file": "binding/SkiaSharp/HandleDictionary.cs",
            "finding": "HandleDictionary uses a PlatformLock (read-write lock) for instance tracking. This protects the C# handle dictionary but does not protect native Skia operations.",
            "relevance": "context",
            "lines": "21-27"
          }
        ],
        "rationale": "Classified as type/bug because multiple reporters demonstrate a consistent crash (AccessViolationException) during normal concurrent use of a public API. The area is area/SkiaSharp (core binding) rather than any View/Platform component since the crash is in SKBitmap.Decode and SKCodec \u2014 the core decoding pipeline. Severity is critical because it terminates the process without being catchable. The reliability tenet applies because server-side applications depend on concurrent image processing.",
        "keySignals": [
          {
            "text": "AccessViolationException at sk_codec_get_info during concurrent SKBitmap.Decode",
            "source": "issue body",
            "interpretation": "Native crash in Skia\u0027s codec layer proves this is a native thread-safety issue, not a C# bug."
          },
          {
            "text": "SemaphoreSlim with max count of 1 increases stability but sacrifices speed",
            "source": "issue body",
            "interpretation": "Serializing decode calls eliminates the crash \u2014 confirms the root cause is concurrent native access."
          },
          {
            "text": "Maintainer says SkiaSharp is \u0027thread safe\u0027 in that two threads can load a bitmap, but two threads shouldn\u0027t access the same object",
            "source": "comment 1",
            "interpretation": "The expectation is that separate instances should be safe concurrently. The crash contradicts this expectation, suggesting shared native state."
          },
          {
            "text": "Multiple reporters across versions 1.56.2 through 2.88.5 report the same crash",
            "source": "comments 9, 21, 23",
            "interpretation": "Longstanding issue across all major versions \u2014 not version-specific."
          },
          {
            "text": "Loading stream into byte array first makes the issue go away for some reporters",
            "source": "comment 24",
            "interpretation": "Suggests the managed stream wrapper (SKManagedStream) may have additional thread-safety issues beyond the codec itself."
          },
          {
            "text": "SKBitmap.Decode creates a new SKCodec per call with no shared state in C#",
            "source": "code search",
            "interpretation": "C# layer is clean \u2014 each call creates independent objects. The contention must be in native Skia code."
          }
        ],
        "errorFingerprint": "AccessViolationException-sk_codec-concurrent-decode",
        "workarounds": [
          "Use SemaphoreSlim(1,1) to serialize all SKBitmap.Decode calls \u2014 eliminates crashes but serializes throughput",
          "Load image data into a byte array before decoding instead of passing a stream \u2014 some reporters find this reduces (but may not eliminate) crashes",
          "Use SKImage.FromEncodedData(SKData) instead of SKBitmap.Decode \u2014 SKImage is immutable and may have better thread-safety characteristics for the decode path"
        ],
        "nextQuestions": [
          "Does Skia upstream document thread-safety guarantees for SkCodec? Is there a global mutex or codec registry that causes contention?",
          "Does SKImage.FromEncodedData truly avoid the same native thread-safety issue, or does it use the same codec path internally?",
          "Has the GC.KeepAlive fix (commit 643e1b4c5) or SkiaSharp 3.x\u0027s HandleDictionary locking partially mitigated this?",
          "Should SkiaSharp add an internal lock around codec creation/decode to protect against concurrent native access?"
        ],
        "resolution": {
          "hypothesis": "Skia\u0027s native codec implementation has shared mutable state (global codec registry, memory allocators, or image format decoders) that is not thread-safe. Even when each C# call creates independent SKCodec and SKBitmap objects, the underlying native code shares state that causes memory corruption under concurrent access.",
          "proposals": [
            {
              "description": "Use SemaphoreSlim(1,1) to serialize all SKBitmap.Decode calls. This is the proven workaround from the original reporter.",
              "title": "Serialize with SemaphoreSlim",
              "codeSnippet": "private static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try\n    {\n        return SKBitmap.Decode(data);\n    }\n    finally\n    {\n        _decodeLock.Release();\n    }\n}",
              "confidence": 0.9,
              "effort": "trivial"
            },
            {
              "description": "Use SKImage.FromEncodedData(SKData.CreateCopy(bytes)) for concurrent image loading. SKImage is immutable and uses deferred decoding, which may avoid the codec thread-safety issue. Pixels are decoded lazily on first access.",
              "title": "Use SKImage instead of SKBitmap",
              "codeSnippet": "using var data = SKData.CreateCopy(bytes);\nusing var image = SKImage.FromEncodedData(data);\n// Use image directly for drawing, or convert to bitmap when needed on a single thread:\nusing var bitmap = SKBitmap.FromImage(image);",
              "confidence": 0.65,
              "effort": "small"
            },
            {
              "description": "Add a static lock or SemaphoreSlim inside SKCodec.GetPixels to serialize native codec operations within the SkiaSharp library itself. This would protect all callers transparently but would limit throughput to single-threaded decoding.",
              "title": "Add internal codec lock in SkiaSharp",
              "confidence": 0.7,
              "effort": "medium"
            }
          ],
          "recommendedProposal": "Serialize with SemaphoreSlim",
          "recommendedReason": "Proven workaround from the original reporter and multiple commenters. Trivial to implement, eliminates crashes completely. While it serializes decode throughput, it\u0027s the safest option until the root cause in native Skia is resolved."
        }
      },
      "output": {
        "actionability": {
          "suggestedAction": "needs-investigation",
          "confidence": 0.85,
          "reason": "Real bug confirmed by multiple reporters across versions. Needs investigation into whether Skia upstream has addressed codec thread-safety, and whether SkiaSharp 3.x changes (HandleDictionary locking, GC.KeepAlive) have partially mitigated this."
        },
        "actions": [
          {
            "type": "update-labels",
            "description": "Apply bug, core area, and reliability labels",
            "risk": "low",
            "confidence": 0.95,
            "labels": [
              "type/bug",
              "area/SkiaSharp",
              "tenet/reliability"
            ]
          },
          {
            "type": "add-comment",
            "description": "Post analysis with workaround and status update",
            "risk": "high",
            "confidence": 0.8,
            "comment": "Thanks for the thorough investigation \u2014 this thread has been invaluable for understanding the scope of this issue.\n\nSkia\u0027s native codec operations are not designed for concurrent use, even when each call creates independent C# objects. The underlying native code shares state that can corrupt memory under concurrent access.\n\nHere\u0027s a workaround you can use while we investigate further:\n\n\u0060\u0060\u0060csharp\nprivate static readonly SemaphoreSlim _decodeLock = new SemaphoreSlim(1, 1);\n\npublic static async Task\u003CSKBitmap?\u003E DecodeSafeAsync(byte[] data)\n{\n    await _decodeLock.WaitAsync();\n    try\n    {\n        return SKBitmap.Decode(data);\n    }\n    finally\n    {\n        _decodeLock.Release();\n    }\n}\n\u0060\u0060\u0060\n\nNote that \u0060SKBitmap.Decode()\u0060 can return \u0060null\u0060 if decoding fails \u2014 callers should check the return value. The returned bitmap must be disposed by the caller when done.\n\nThis serializes decode operations and eliminates the crash, at the cost of concurrent throughput. We\u0027re evaluating whether an internal lock in SkiaSharp itself would be the right long-term fix, or whether Skia upstream has improved codec thread-safety in recent versions."
          },
          {
            "type": "link-related",
            "description": "Cross-reference related concurrent access issues",
            "risk": "low",
            "confidence": 0.75,
            "linkedIssue": 2456
          },
          {
            "type": "link-related",
            "description": "Cross-reference thread-safety discussion",
            "risk": "low",
            "confidence": 0.7,
            "linkedIssue": 1174
          }
        ]
      }
    }
  ]
}