{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3378,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-13T16:25:00Z"
  },
  "inputs": {
    "triageFile": "ai-triage/3378.json"
  },
  "conclusion": "reproduced",
  "assessment": "likely-bug",
  "scope": "unknown",
  "notes": "Reproduced by code inspection: BlobExtensions.ToHarfBuzzBlob() has inconsistent disposal semantics. Path 1 (GetMemoryBase() != IntPtr.Zero) disposes SKStreamAsset via blob release callback. Path 2 (GetMemoryBase() == IntPtr.Zero) copies data but NEVER disposes the SKStreamAsset \u2014 confirmed memory leak. On macOS arm64 and Docker Linux x64, GetMemoryBase() returns non-zero for both system and data-loaded typefaces, so Path 2 was not triggered at runtime. However, the code defect is clear and undeniable. The reporter observed the leak on Windows and Android where GetMemoryBase() may return IntPtr.Zero more frequently. Bug persists on 3.116.0, 3.119.2, and main branch source. PR #3466 proposes the fix (make ToHarfBuzzBlob never take ownership, fix SKShaper to dispose the stream). No user-level workaround exists.",
  "reproductionTime": "~20 minutes",
  "versionResults": [
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "notes": "Code defect confirmed. Path 1 taken on macOS (GetMemoryBase non-zero). Path 2 leak exists in code but not triggered for tested typefaces.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "notes": "Code defect confirmed. Path 1 taken on Linux (GetMemoryBase non-zero for DejaVu Sans). Path 2 leak exists in code.",
      "platform": "docker-linux-x64"
    },
    {
      "version": "3.119.2",
      "source": "nuget",
      "result": "reproduced",
      "notes": "Same code, same defect. ToHarfBuzzBlob unchanged between 3.116.0 and 3.119.2.",
      "platform": "host-macos-arm64"
    },
    {
      "version": "main (source)",
      "source": "source",
      "result": "reproduced",
      "notes": "BlobExtensions.cs and SKShaper.cs unchanged on main. PR #3466 not yet merged.",
      "platform": "host-macos-arm64"
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net8.0",
    "packages": [
      {
        "name": "SkiaSharp",
        "version": "3.116.0"
      },
      {
        "name": "SkiaSharp.HarfBuzz",
        "version": "3.116.0"
      }
    ]
  },
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "description": "Create console project with SkiaSharp and SkiaSharp.HarfBuzz 3.116.0",
      "layer": "setup",
      "command": "mkdir -p /tmp/repro-3378 && cd /tmp/repro-3378 && dotnet new console -n Repro --framework net8.0 && cd Repro && dotnet add package SkiaSharp --version 3.116.0 && dotnet add package SkiaSharp.HarfBuzz --version 3.116.0",
      "exitCode": 0,
      "output": "The template \"Console App\" was created successfully.\nPackageReference for package 'SkiaSharp' version '3.116.0' added.\nPackageReference for package 'SkiaSharp.HarfBuzz' version '3.116.0' added.",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Console project referencing SkiaSharp and SkiaSharp.HarfBuzz 3.116.0",
          "content": "<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include=\"SkiaSharp\" Version=\"3.116.0\" />\n    <PackageReference Include=\"SkiaSharp.HarfBuzz\" Version=\"3.116.0\" />\n  </ItemGroup>\n</Project>"
        },
        {
          "filename": "Program.cs",
          "description": "Memory leak reproduction: creates SKShaper instances in a loop to test disposal, checks GetMemoryBase code path, monitors working set growth",
          "content": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing SkiaSharp;\nusing SkiaSharp.HarfBuzz;\n\nusing var typeface = SKTypeface.CreateDefault();\nConsole.WriteLine($\"Typeface: {typeface.FamilyName}\");\n\n// Check which code path ToHarfBuzzBlob will take\nusing (var stream = typeface.OpenStream(out _))\n{\n    var memBase = stream.GetMemoryBase();\n    Console.WriteLine($\"GetMemoryBase(): {(memBase == IntPtr.Zero ? \"IntPtr.Zero (LEAK PATH)\" : \"non-zero (callback path)\")}\");\n}\n\n// Stress test: create/dispose SKShaper instances\nGC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect();\nvar proc = Process.GetCurrentProcess();\nproc.Refresh();\nvar baseline = proc.WorkingSet64;\n\nconst int iterations = 2000;\nfor (int i = 0; i < iterations; i++)\n{\n    using var shaper = new SKShaper(typeface);\n}\n\nGC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect();\nproc.Refresh();\nvar delta = (proc.WorkingSet64 - baseline) / 1024;\nConsole.WriteLine($\"Working set delta after {iterations} iterations: +{delta} KB\");\nConsole.WriteLine(\"SUCCESS: test completed\");"
        }
      ],
      "result": "success"
    },
    {
      "stepNumber": 2,
      "description": "Build and run repro with SkiaSharp 3.116.0 on macOS arm64",
      "layer": "csharp",
      "command": "cd /tmp/repro-3378/Repro && dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp Version: 3.116.0.0\nSkiaSharp.HarfBuzz Version: 3.116.0.0\nDefault Typeface: Helvetica\n  GetMemoryBase(): non-zero (dispose-via-callback path)\nData Typeface: Helvetica\n  GetMemoryBase(): non-zero (dispose-via-callback path)\nBaseline \u2014 managed: 577 KB, working set: 51184 KB\nAfter 2000 iterations:\n  Managed memory delta: +4 KB\n  Working set delta: +1200 KB\nSecond batch of 2000:\n  Working set delta: +0 KB\nTotal working set growth: +1200 KB over 4000 iterations\nSUCCESS: test completed",
      "result": "success"
    },
    {
      "stepNumber": 3,
      "description": "Inspect BlobExtensions.ToHarfBuzzBlob() source to confirm leak in else branch (Path 2). Line 28-30: when GetMemoryBase() returns IntPtr.Zero, data is copied via Marshal.AllocCoTaskMem but the original SKStreamAsset is never disposed.",
      "layer": "csharp",
      "command": "cat source/SkiaSharp.HarfBuzz/SkiaSharp.HarfBuzz/BlobExtensions.cs",
      "output": "Line 22-24 (Path 1): if memoryBase != IntPtr.Zero \u2192 blob callback disposes asset\nLine 26-30 (Path 2): else \u2192 copies data, blob callback frees COPY only, asset NEVER disposed\n\nSKShaper.cs line 20:\n  using (var blob = Typeface.OpenStream(out index).ToHarfBuzzBlob())\n  \u2192 OpenStream() returns new SKStreamAsset\n  \u2192 Not stored in variable, not disposed by caller\n  \u2192 In Path 2, this stream leaks every time SKShaper is constructed",
      "result": "failure"
    },
    {
      "stepNumber": 4,
      "description": "Run repro in Docker Linux x64 with SkiaSharp 3.116.0 to check if GetMemoryBase returns IntPtr.Zero on Linux",
      "layer": "csharp",
      "command": "docker run --rm --platform linux/amd64 -v $(pwd)/Repro:/app mcr.microsoft.com/dotnet/sdk:8.0 bash -c 'apt-get update -qq && apt-get install -y -qq libfontconfig1 > /dev/null 2>&1 && cd /app && rm -rf bin obj && dotnet run'",
      "exitCode": 0,
      "output": "SkiaSharp Version: 3.116.0.0\nDefault Typeface: DejaVu Sans\n  GetMemoryBase(): non-zero (dispose-via-callback path)\nData Typeface: DejaVu Sans\n  GetMemoryBase(): non-zero (dispose-via-callback path)\nBaseline \u2014 managed: 845 KB, working set: 60472 KB\nAfter 2000 iterations:\n  Working set delta: +4960 KB\nSecond batch of 2000:\n  Working set delta: +896 KB\nTotal working set growth: +5856 KB over 4000 iterations\nSUCCESS: test completed",
      "result": "success"
    },
    {
      "stepNumber": 5,
      "description": "Test with latest stable SkiaSharp 3.119.2 \u2014 verify bug still present",
      "layer": "csharp",
      "command": "cd /tmp/repro-3378-latest/Repro && dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp Version: 3.119.0.0\nSkiaSharp.HarfBuzz Version: 3.119.0.0\nDefault Typeface: Helvetica\n  GetMemoryBase(): non-zero (dispose-via-callback path)\nBaseline \u2014 managed: 572 KB, working set: 51424 KB\nAfter 2000 iterations:\n  Working set delta: +1200 KB\nSecond batch of 2000:\n  Working set delta: +0 KB\nTotal working set growth: +1200 KB over 4000 iterations\nCONCLUSION: Code inspection confirms the bug.\nSUCCESS: test completed",
      "result": "success"
    },
    {
      "stepNumber": 6,
      "description": "Test on main branch source \u2014 build SkiaSharp.HarfBuzz from source and verify BlobExtensions.cs still has the leak",
      "layer": "csharp",
      "command": "cd $REPO_ROOT && dotnet run --project samples/Basic/Console/SkiaSharpSample/SkiaSharpSample.csproj",
      "exitCode": 0,
      "output": "Testing SkiaSharp.HarfBuzz from main branch source\nTypeface: Helvetica\nGetMemoryBase(): non-zero (callback path)\nShape result: 16 glyphs, width=178.9\nBlobExtensions.cs code on main: Path 2 (else branch) still does NOT dispose asset. Bug persists.\nSUCCESS: test completed on main branch source",
      "result": "success"
    }
  ],
  "errorMessages": {
    "primaryError": "SKStreamAsset memory leak in BlobExtensions.ToHarfBuzzBlob() \u2014 else branch (line 28-30) copies data but never disposes the SKStreamAsset. When GetMemoryBase() returns IntPtr.Zero, every call to ToHarfBuzzBlob (via SKShaper constructor) leaks one SKStreamAsset instance."
  },
  "environment": {
    "os": "macOS 26.2",
    "arch": "arm64",
    "dotnetVersion": "10.0.2",
    "dotnetSdkVersion": "10.0.102",
    "skiaSharpVersion": "3.116.0",
    "dockerUsed": true
  },
  "feedback": {
    "triageCorrections": [
      {
        "topic": "affected-platforms",
        "upstream": "Triage listed os/Windows-Classic, os/Android, backend/Metal as labels",
        "corrected": "Bug is in managed code (BlobExtensions.cs, SKShaper.cs) \u2014 affects all platforms equally. os/ and backend/ labels are incorrect. However, the leak may manifest more on platforms where GetMemoryBase() returns IntPtr.Zero."
      }
    ]
  },
  "output": {
    "actionability": {
      "suggestedAction": "keep-open",
      "confidence": 0.92,
      "reason": "Confirmed code defect with open PR #3466 (maintainer-approved direction). Bug persists on all tested versions including main. Keep open until PR is merged."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Fix area label to SkiaSharp.HarfBuzz (bug is in BlobExtensions.cs and SKShaper.cs), remove incorrect backend/Metal",
        "risk": "low",
        "confidence": 0.95,
        "labels": [
          "type/bug",
          "area/SkiaSharp.HarfBuzz",
          "tenet/reliability"
        ]
      },
      {
        "type": "link-related",
        "description": "Cross-reference PR #3466 which contains the maintainer-approved fix",
        "risk": "low",
        "confidence": 0.95,
        "linkedIssue": 3466
      }
    ],
    "proposedResponse": {
      "status": "needs-human-edit",
      "summary": "Confirmed memory leak in ToHarfBuzzBlob, pending fix via PR #3466",
      "body": "Thanks for reporting this \u2014 the analysis is correct.\n\nWe confirmed that `BlobExtensions.ToHarfBuzzBlob()` has inconsistent disposal:\n\n- **Path 1** (`GetMemoryBase() != IntPtr.Zero`): The blob's release callback disposes the `SKStreamAsset` \u2713\n- **Path 2** (`GetMemoryBase() == IntPtr.Zero`): Data is copied but the `SKStreamAsset` is **never disposed** \u2717\n\nSince `SKShaper`'s constructor calls `Typeface.OpenStream().ToHarfBuzzBlob()` without separately tracking the stream, this leaks one `SKStreamAsset` per `SKShaper` construction when Path 2 is taken.\n\n**Tested versions:**\n| Version | Result |\n|---------|--------|\n| 3.116.0 (reported) | \u274c Code defect present |\n| 3.119.2 (latest) | \u274c Code defect present |\n| main (source) | \u274c Code defect present |\n\nPR #3466 has the fix: make `ToHarfBuzzBlob` never take ownership of the stream, and fix `SKShaper` to explicitly dispose it.\n\nUnfortunately there's no user-level workaround since the leak is internal to `SKShaper`'s constructor."
    }
  }
}