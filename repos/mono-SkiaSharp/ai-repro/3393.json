{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3393,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-12T19:01:50Z"
  },
  "conclusion": "partial",
  "notes": "This is a systemic GC race condition bug affecting ~910 P/Invoke call sites. The bug is inherently intermittent - it requires precise timing where the GC collects and finalizes an object while native Skia code is still using its handle. Despite 1000 iterations with aggressive GC on both SkiaSharp 3.116.0 and 3.119.2, no crashes were triggered, which is expected given the race window is small. However, code inspection confirms the vulnerable pattern exists: DrawPicture() and hundreds of other methods extract IntPtr handles and pass them to native code without any GC.KeepAlive() protection. The reporter (jonpryor, a .NET runtime expert) correctly identifies this as a violation of .NET P/Invoke safety rules per Chris Brumme's canonical blog post. Uno Platform encountered real-world crashes from this issue (unoplatform/uno#21660). The code pattern on main branch is unchanged: SKCanvas.cs line 537 calls SkiaApi.sk_canvas_draw_picture() with picture.Handle but never protects the managed picture object afterward - confirmed by grep showing 67 P/Invoke calls with 0 GC.KeepAlive calls in SKCanvas.cs.",
  "assessment": "likely-bug",
  "blockers": [
    "Race condition has a very small timing window - the GC must collect and finalize an object in the microseconds between handle extraction and P/Invoke completion. Even with 1000 iterations and aggressive GC, the race did not trigger. This doesn't invalidate the bug - it confirms what the reporter stated: this is a probabilistic failure that manifests under GC pressure in production, particularly on memory-constrained mobile devices."
  ],
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "layer": "setup",
      "description": "Create standalone console app with SkiaSharp 3.116.0 (reporter's version)",
      "command": "mkdir -p /tmp/repro-3393 && cd /tmp/repro-3393 && dotnet new console -n Repro --framework net8.0 && cd Repro && dotnet add package SkiaSharp --version 3.116.0",
      "result": "success",
      "exitCode": 0,
      "output": "Successfully created project and added SkiaSharp 3.116.0",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Project file with SkiaSharp 3.116.0 dependency",
          "content": "<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include=\"SkiaSharp\" Version=\"3.116.0\" />\n  </ItemGroup>\n</Project>"
        },
        {
          "filename": "Program.cs",
          "description": "Reproduction code that attempts to trigger GC race with DrawPicture and other vulnerable APIs",
          "content": "// Reproduction for SkiaSharp issue #3393\n// P/Invokes should protect parameters with GC.KeepAlive across invocations\n// This tests whether objects can be prematurely collected during P/Invoke calls\n\nusing SkiaSharp;\nusing System.Runtime;\nusing System.Runtime.InteropServices;\n\nConsole.WriteLine(\"SkiaSharp GC Race Condition Reproduction - Issue #3393\");\nConsole.WriteLine(\"========================================================\\n\");\n\n// Configure aggressive GC\nGCSettings.LatencyMode = GCLatencyMode.Batch;\n\nint iterations = 1000;\nint crashCount = 0;\nint successCount = 0;\n\nConsole.WriteLine($\"Running {iterations} iterations with aggressive GC...\");\nConsole.WriteLine(\"Attempting to trigger race condition between GC and P/Invoke\\n\");\n\nfor (int i = 0; i < iterations; i++)\n{\n    try\n    {\n        // Test case 1: DrawPicture - the example from the issue\n        using (var recorder = new SKPictureRecorder())\n        using (var canvas = recorder.BeginRecording(SKRect.Create(100, 100)))\n        {\n            var paint = new SKPaint { Color = SKColors.Red };\n            canvas.DrawRect(SKRect.Create(10, 10, 80, 80), paint);\n            paint.Dispose();\n            \n            var picture = recorder.EndRecording();\n            \n            using (var surface = SKSurface.Create(new SKImageInfo(100, 100)))\n            {\n                var drawCanvas = surface.Canvas;\n                drawCanvas.DrawPicture(picture); // Vulnerable call\n                \n                GC.Collect(2, GCCollectionMode.Forced, blocking: true);\n                GC.WaitForPendingFinalizers();\n                GC.Collect(2, GCCollectionMode.Forced, blocking: true);\n                \n                picture?.Dispose();\n            }\n        }\n        \n        // Test case 2: SKPaint with shader\n        using (var paint = new SKPaint())\n        {\n            var shader = SKShader.CreateColor(SKColors.Blue);\n            paint.Shader = shader; // Vulnerable call\n            \n            GC.Collect(2, GCCollectionMode.Forced, blocking: true);\n            GC.WaitForPendingFinalizers();\n            \n            shader?.Dispose();\n        }\n        \n        successCount++;\n        \n        if ((i + 1) % 100 == 0)\n        {\n            Console.WriteLine($\"Completed {i + 1}/{iterations} iterations...\");\n        }\n    }\n    catch (AccessViolationException ex)\n    {\n        crashCount++;\n        Console.WriteLine($\"\\n❌ AccessViolationException at iteration {i + 1}:\");\n        Console.WriteLine($\"   {ex.Message}\");\n    }\n    catch (SEHException ex)\n    {\n        crashCount++;\n        Console.WriteLine($\"\\n❌ SEHException at iteration {i + 1}:\");\n        Console.WriteLine($\"   {ex.Message}\");\n    }\n    catch (Exception ex)\n    {\n        crashCount++;\n        Console.WriteLine($\"\\n❌ Unexpected exception at iteration {i + 1}:\");\n        Console.WriteLine($\"   {ex.GetType().Name}: {ex.Message}\");\n    }\n}\n\nConsole.WriteLine($\"\\n\\nResults:\");\nConsole.WriteLine($\"========\");\nConsole.WriteLine($\"Total iterations:  {iterations}\");\nConsole.WriteLine($\"Successful:        {successCount}\");\nConsole.WriteLine($\"Crashes/Errors:    {crashCount}\");\n\nif (crashCount > 0)\n{\n    Console.WriteLine($\"\\n✅ REPRODUCED: GC race condition triggered {crashCount} time(s)\");\n    Environment.Exit(1);\n}\nelse\n{\n    Console.WriteLine($\"\\n⚠️  No crashes observed in {iterations} iterations.\");\n    Console.WriteLine(\"Note: This is a race condition - absence of crash doesn't mean absence of bug.\");\n    Console.WriteLine(\"The code pattern is inherently unsafe per .NET documentation.\");\n    Console.WriteLine(\"See: https://learn.microsoft.com/en-us/archive/blogs/cbrumme/lifetime-gc-keepalive-handle-recycling\");\n    Environment.Exit(0);\n}"
        }
      ]
    },
    {
      "stepNumber": 2,
      "layer": "csharp",
      "description": "Build repro project",
      "command": "cd /tmp/repro-3393/Repro && dotnet build",
      "result": "success",
      "exitCode": 0,
      "output": "Build succeeded. 0 Warning(s), 0 Error(s)"
    },
    {
      "stepNumber": 3,
      "layer": "csharp",
      "description": "Run repro with SkiaSharp 3.116.0 - attempt to trigger GC race with 1000 iterations",
      "command": "cd /tmp/repro-3393/Repro && dotnet run --no-build",
      "result": "success",
      "exitCode": 0,
      "output": "SkiaSharp GC Race Condition Reproduction - Issue #3393\n========================================================\n\nRunning 1000 iterations with aggressive GC...\nAttempting to trigger race condition between GC and P/Invoke\n\nCompleted 100/1000 iterations...\nCompleted 200/1000 iterations...\n[...truncated 600 lines...]\nCompleted 900/1000 iterations...\nCompleted 1000/1000 iterations...\n\n\nResults:\n========\nTotal iterations:  1000\nSuccessful:        1000\nCrashes/Errors:    0\n\n⚠️  No crashes observed in 1000 iterations.\nNote: This is a race condition - absence of crash doesn't mean absence of bug.\nThe code pattern is inherently unsafe per .NET documentation.\nSee: https://learn.microsoft.com/en-us/archive/blogs/cbrumme/lifetime-gc-keepalive-handle-recycling"
    },
    {
      "stepNumber": 4,
      "layer": "csharp",
      "description": "Update to latest release (3.119.2) and re-test",
      "command": "cd /tmp/repro-3393/Repro && dotnet add package SkiaSharp && dotnet run",
      "result": "success",
      "exitCode": 0,
      "output": "Updated to SkiaSharp 3.119.2\nCompleted 1000 iterations with 1000 successful, 0 crashes.\n⚠️  No crashes observed in 1000 iterations."
    },
    {
      "stepNumber": 5,
      "layer": "csharp",
      "description": "Verify issue exists on main branch - check SKCanvas.cs for missing GC.KeepAlive",
      "command": "cd $HOME/Documents/GitHub/SkiaSharp-2-worktrees/main && grep -c 'GC.KeepAlive' binding/SkiaSharp/SKCanvas.cs",
      "result": "success",
      "exitCode": 0,
      "output": "0"
    },
    {
      "stepNumber": 6,
      "layer": "csharp",
      "description": "Count total P/Invoke calls in SKCanvas.cs (vulnerable call sites)",
      "command": "cd $HOME/Documents/GitHub/SkiaSharp-2-worktrees/main && grep -c 'SkiaApi\\.' binding/SkiaSharp/SKCanvas.cs",
      "result": "success",
      "exitCode": 0,
      "output": "67"
    },
    {
      "stepNumber": 7,
      "layer": "csharp",
      "description": "Inspect DrawPicture method source code (line 537) to confirm vulnerable pattern",
      "command": "cd $HOME/Documents/GitHub/SkiaSharp-2-worktrees/main && sed -n '533,538p' binding/SkiaSharp/SKCanvas.cs",
      "result": "success",
      "exitCode": 0,
      "output": "public void DrawPicture (SKPicture picture, SKPaint paint = null)\n{\n\tif (picture == null)\n\t\tthrow new ArgumentNullException (nameof (picture));\n\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n}"
    },
    {
      "stepNumber": 8,
      "layer": "csharp",
      "description": "Count total existing GC.KeepAlive calls across all of binding/SkiaSharp",
      "command": "cd $HOME/Documents/GitHub/SkiaSharp-2-worktrees/main && grep -r 'GC.KeepAlive' binding/SkiaSharp/ --include='*.cs' | wc -l",
      "result": "success",
      "exitCode": 0,
      "output": "14"
    }
  ],
  "versionResults": [
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "not-reproduced",
      "notes": "Ran 1000 iterations with aggressive GC forcing - no crash triggered. However, code inspection confirms the vulnerable pattern exists: DrawPicture() and other methods do not call GC.KeepAlive() after P/Invoke calls."
    },
    {
      "version": "3.119.2",
      "source": "nuget",
      "result": "not-reproduced",
      "notes": "Same behavior as 3.116.0 - no crash in 1000 iterations but vulnerable code pattern persists."
    },
    {
      "version": "main",
      "source": "source",
      "result": "not-reproduced",
      "notes": "Confirmed via source inspection: SKCanvas.cs has 67 P/Invoke calls with 0 GC.KeepAlive calls. DrawPicture() at line 537 directly passes picture.Handle and paint.Handle to native code without any subsequent GC.KeepAlive(). Across all of binding/SkiaSharp/, only 14 GC.KeepAlive calls exist (mostly in SKData and SKImage from PR #1258), while triage data shows ~910 total P/Invoke call sites remain unprotected."
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net8.0",
    "packages": [
      {
        "name": "SkiaSharp",
        "version": "3.116.0"
      }
    ]
  },
  "inputs": {
    "triageFile": ".data-cache/repos/mono-SkiaSharp/ai-triage/3393.json"
  },
  "environment": {
    "os": "macOS",
    "arch": "arm64",
    "dotnetVersion": "8.0.417",
    "skiaSharpVersion": "3.116.0, 3.119.2, main (source)",
    "dockerUsed": false
  },
  "feedback": {
    "triageCorrections": [
      {
        "topic": "reproduction",
        "upstream": "Triage classified reproQuality as 'partial' with stepsToReproduce provided",
        "corrected": "Attempted systematic reproduction with 1000 iterations but did not trigger crash. This aligns with triage assessment - the bug is real (confirmed by code inspection) but intermittent. The reporter's description and Uno Platform's real-world crash (unoplatform/uno#21660) provide the evidence, not a synthetic repro. Code pattern is definitively unsafe per .NET documentation regardless of whether we can force the race."
      }
    ]
  }
}
