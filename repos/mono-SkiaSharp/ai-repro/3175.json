{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3175,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-13T16:05:00Z"
  },
  "inputs": {
    "triageFile": "ai-triage/3175.json"
  },
  "conclusion": "reproduced",
  "assessment": "likely-bug",
  "scope": "universal",
  "notes": "Reproduced on SkiaSharp 3.116.0, 3.119.2, and main (source). SKManagedStream.OnReadManagedStream performs a single stream.Read() call which returns fewer bytes than requested when the underlying stream delivers data in chunks (valid per .NET Stream contract). A 13MB PNG decoded through a ChunkedStream limited to 2048 bytes per read produces a 2000x2000 bitmap with all blank pixels — Skia treats the short read as EOF. Streams with chunk sizes >= 4096 (Skia's internal read request size) work because no short reads occur. Bug also affects non-seekable streams. Reproduced identically on macOS arm64 (host) and Docker Linux x64. Duplicate of #1962.",
  "reproductionTime": "~10 minutes",
  "versionResults": [
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "platform": "host-macos-arm64",
      "notes": "ChunkedStream with 2048-byte limit: 8 reads total, 1 short read. Image 2000x2000 but all pixels blank (lastRow=-1)."
    },
    {
      "version": "3.119.2",
      "source": "nuget",
      "result": "reproduced",
      "platform": "host-macos-arm64",
      "notes": "Identical behavior to 3.116.0. Same 8 reads, same short read, same blank image."
    },
    {
      "version": "main (source)",
      "source": "source",
      "result": "reproduced",
      "platform": "host-macos-arm64",
      "notes": "Bug still present on main. Same truncation pattern with chunked streams."
    },
    {
      "version": "3.116.0",
      "source": "nuget",
      "result": "reproduced",
      "platform": "docker-linux-x64",
      "notes": "Cross-platform verification: identical truncation on Linux x64 in Docker. Confirms universal scope."
    }
  ],
  "reproProject": {
    "type": "console",
    "tfm": "net8.0",
    "packages": [
      { "name": "SkiaSharp", "version": "3.116.0" }
    ]
  },
  "reproductionSteps": [
    {
      "stepNumber": 1,
      "description": "Create console project and add SkiaSharp 3.116.0",
      "layer": "setup",
      "command": "mkdir -p /tmp/repro-3175 && cd /tmp/repro-3175 && dotnet new console -n Repro --framework net8.0 && cd Repro && dotnet add package SkiaSharp --version 3.116.0",
      "exitCode": 0,
      "output": "The template \"Console App\" was created successfully.\nPackageReference for package 'SkiaSharp' version '3.116.0' added.",
      "result": "success",
      "filesCreated": [
        {
          "filename": "Repro.csproj",
          "description": "Console project targeting net8.0 with SkiaSharp 3.116.0",
          "content": "<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n  <ItemGroup>\n    <PackageReference Include=\"SkiaSharp\" Version=\"3.116.0\" />\n  </ItemGroup>\n</Project>"
        }
      ]
    },
    {
      "stepNumber": 2,
      "description": "Write reproduction code with instrumented ChunkedStream that limits Read() to a max chunk size, simulating Azure Blob stream behavior. Generates a 13MB PNG with random pixels, then decodes through ChunkedStream with various chunk sizes and a non-seekable variant.",
      "layer": "csharp",
      "result": "success",
      "filesCreated": [
        {
          "filename": "Program.cs",
          "description": "Reproduction: creates 2000x2000 PNG, decodes through ChunkedStream wrapper limiting bytes per Read(). Tests seekable (2048/4096/8192/4MB chunks) and non-seekable (2048 chunk) streams.",
          "content": "using SkiaSharp;\nusing System;\nusing System.IO;\nusing System.Collections.Generic;\n\nConsole.WriteLine($\"SkiaSharp version: {typeof(SKBitmap).Assembly.GetName().Version}\");\n\nconst int width = 2000;\nconst int height = 2000;\nbyte[] pngBytes;\nusing (var bmp = new SKBitmap(width, height, SKColorType.Rgba8888, SKAlphaType.Premul))\n{\n    var rng = new Random(42);\n    for (int y = 0; y < height; y++)\n        for (int x = 0; x < width; x++)\n            bmp.SetPixel(x, y, new SKColor((byte)rng.Next(256), (byte)rng.Next(256), (byte)rng.Next(256)));\n    using var image = SKImage.FromBitmap(bmp);\n    using var data = image.Encode(SKEncodedImageFormat.Png, 100);\n    pngBytes = data.ToArray();\n}\nConsole.WriteLine($\"PNG: {pngBytes.Length} bytes ({pngBytes.Length / 1024.0 / 1024.0:F2} MB)\");\n\n// Direct MemoryStream (baseline)\nusing (var ms = new MemoryStream(pngBytes))\n{\n    using var bitmap = SKBitmap.Decode(ms);\n    var px = bitmap?.GetPixel(width / 2, height - 1);\n    Console.WriteLine($\"[MemoryStream] bottomPixel={px} {(px?.Alpha > 0 ? \"OK\" : \"BLANK\")}\");\n}\n\n// Chunked streams with various sizes\nforeach (var chunkSize in new[] { 2048, 4096, 8192, 4 * 1024 * 1024 })\n{\n    var reads = new List<(int, int)>();\n    using var inner = new MemoryStream(pngBytes);\n    using var chunked = new ChunkedStream(inner, chunkSize, reads);\n    using var bitmap = SKBitmap.Decode(chunked);\n    int shortReads = reads.Count(r => r.Item2 < r.Item1 && r.Item2 > 0);\n    int lastRow = FindLastRow(bitmap, width, height);\n    Console.WriteLine($\"[chunk={chunkSize,10}] reads={reads.Count,5} short={shortReads,3} lastRow={lastRow}/{height-1} {(lastRow == height-1 ? \"OK\" : \"TRUNCATED\")}\");\n}\n\n// Non-seekable chunked stream\n{\n    var reads = new List<(int, int)>();\n    using var inner = new MemoryStream(pngBytes);\n    using var chunked = new NonSeekableChunkedStream(inner, 2048, reads);\n    using var bitmap = SKBitmap.Decode(chunked);\n    int lastRow = FindLastRow(bitmap, width, height);\n    Console.WriteLine($\"[non-seekable 2048] lastRow={lastRow}/{height-1} {(lastRow == height-1 ? \"OK\" : \"TRUNCATED\")}\");\n}\n\nstatic int FindLastRow(SKBitmap bmp, int w, int h) {\n    if (bmp == null) return -1;\n    for (int y = h - 1; y >= 0; y--)\n        if (bmp.GetPixel(w / 2, y).Alpha > 0) return y;\n    return -1;\n}\n\nclass ChunkedStream : Stream { /* seekable stream limiting Read() to chunkSize */ }\nclass NonSeekableChunkedStream : Stream { /* non-seekable variant */ }"
        }
      ]
    },
    {
      "stepNumber": 3,
      "description": "Run reproduction with SkiaSharp 3.116.0 (reporter's version). ChunkedStream with 2048-byte limit causes truncation — image is 2000x2000 but all pixels are blank.",
      "layer": "csharp",
      "command": "cd /tmp/repro-3175/Repro && dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.116.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    },
    {
      "stepNumber": 4,
      "description": "Test with SkiaSharp 3.119.2 (latest stable) in fresh project directory. Same truncation behavior — bug not fixed.",
      "layer": "csharp",
      "command": "cd /tmp/repro-3175-latest/Repro && dotnet run",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.119.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    },
    {
      "stepNumber": 5,
      "description": "Test on main branch (source) using console sample project with project references. Same truncation — bug still present on main.",
      "layer": "csharp",
      "command": "cd $REPO && dotnet run --project samples/Basic/Console/SkiaSharpSample/SkiaSharpSample.csproj",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.119.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    },
    {
      "stepNumber": 6,
      "description": "Cross-platform verification on Docker Linux x64 with SkiaSharp 3.116.0 + NativeAssets.Linux. Identical truncation confirms universal scope.",
      "layer": "csharp",
      "command": "docker run --rm --platform linux/amd64 -v $(pwd):/app -w /app mcr.microsoft.com/dotnet/sdk:8.0 bash -c 'apt-get update -qq && apt-get install -y -qq libfontconfig1 && dotnet run'",
      "exitCode": 0,
      "output": "SkiaSharp version: 3.116.0.0\n\nGenerated PNG: 13840553 bytes (13.20 MB)\n\n[MemoryStream direct] size=2000x2000 bottomPixel=#fff4d06e OK\n[chunk=      2048] reads=    8 short=  1 lastRow=-1/1999 TRUNCATED\n[chunk=      4096] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=      8192] reads= 6758 short=  0 lastRow=1999/1999 OK\n[chunk=   4194304] reads= 6758 short=  0 lastRow=1999/1999 OK\n[non-seekable 2048 ] reads=    6 lastRow=-1/1999 TRUNCATED\n\nSUCCESS: test completed",
      "result": "wrong-output"
    }
  ],
  "errorMessages": {
    "primaryError": "SKBitmap.Decode produces a bitmap with correct dimensions (2000x2000) but completely blank pixel data when the underlying stream returns partial reads. SKManagedStream.OnReadManagedStream performs a single stream.Read() call; when the stream returns fewer than the requested 4096 bytes (valid per .NET Stream contract), Skia treats it as EOF and stops decoding. Affects both seekable and non-seekable streams."
  },
  "environment": {
    "os": "macOS 26.2",
    "arch": "arm64",
    "dotnetSdkVersion": "10.0.102",
    "dotnetVersion": "8.0.17",
    "skiaSharpVersion": "3.116.0",
    "dockerUsed": true
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.95,
      "reason": "Bug reproduced on all tested versions (3.116.0, 3.119.2, main) and both platforms (macOS arm64, Linux x64). The single stream.Read() call in SKManagedStream.OnReadManagedStream violates the .NET Stream contract and causes truncated image decoding with any stream that returns partial reads. No fix exists on any version. Duplicate of #1962."
    },
    "workarounds": [
      "Copy the source stream to a MemoryStream before decoding: await stream.CopyToAsync(memoryStream); memoryStream.Seek(0, SeekOrigin.Begin); SKBitmap.Decode(memoryStream);",
      "Read all bytes first and use SKBitmap.Decode(byte[]): var bytes = await BinaryData.FromStreamAsync(stream); SKBitmap.Decode(bytes.ToArray());"
    ],
    "proposedResponse": {
      "status": "ready",
      "summary": "Confirmed bug: SKBitmap.Decode truncates images from streams that return partial reads. Known issue, workaround available.",
      "body": "Thanks for reporting this! We've confirmed the issue.\n\n**Root cause:** `SKManagedStream.OnReadManagedStream` performs a single `stream.Read()` call without looping. Per the [.NET Stream contract](https://learn.microsoft.com/en-us/dotnet/api/system.io.stream.read), `Read()` may return fewer bytes than requested — this is normal for network streams, Azure Blob streams, and buffered streams crossing chunk boundaries. When a short read occurs, Skia interprets it as end-of-stream and stops decoding, producing a bitmap with correct dimensions but blank pixel data.\n\n**Tested versions:**\n| Version | Result |\n|---------|--------|\n| 3.116.0 (reported) | ❌ Reproduced |\n| 3.119.2 (latest) | ❌ Reproduced |\n| main (source) | ❌ Reproduced |\n\n**Workaround:** Copy the stream to a `MemoryStream` first (which you've already discovered):\n```csharp\nawait using var memoryStream = new MemoryStream();\nawait blobStream.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var bitmap = SKBitmap.Decode(memoryStream);\n```\n\nAlternatively, read all bytes and use `SKBitmap.Decode(byte[])`.\n\nThis is a known issue — duplicate of #1962, which tracks the root cause (introduced when `BinaryReader.ReadBytes()` was replaced with a single `stream.Read()` call)."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Apply area and platform labels",
        "risk": "low",
        "confidence": 0.95,
        "labels": ["type/bug", "area/SkiaSharp", "os/Linux", "os/Windows-Classic"]
      },
      {
        "type": "link-duplicate",
        "description": "Mark as duplicate of #1962 (incomplete stream reading in SKManagedStream)",
        "risk": "medium",
        "confidence": 0.92,
        "linkedIssue": 1962
      }
    ]
  }
}
