{
  "meta": {
    "schemaVersion": "2.0",
    "number": 3393,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-08T15:00:00Z",
    "currentLabels": ["type/bug", "os/Android", "area/SkiaSharp", "tenet/reliability"]
  },
  "summary": "All P/Invoke wrapper methods lack GC.KeepAlive calls, allowing premature collection of managed objects while native code is using their handles",
  "classification": {
    "type": { "value": "type/bug", "confidence": 0.95 },
    "area": { "value": "area/SkiaSharp", "confidence": 0.95 },
    "backends": null,
    "platforms": null,
    "tenets": [{ "value": "tenet/reliability", "confidence": 0.95 }],
    "partner": { "value": "partner/unoplatform", "confidence": 0.75 }
  },
  "evidence": {
    "bugSignals": {
      "hasCrash": true,
      "hasStackTrace": false,
      "reproQuality": "partial",
      "hasWorkaround": true,
      "workaroundSummary": "Callers can manually add GC.KeepAlive() after SkiaSharp API calls, but this is fragile and shifts the burden to every consumer.",
      "targetFrameworks": ["net8.0-android"],
      "severity": "high",
      "severityReason": "Race condition between GC and native code can cause use-after-free crashes on any platform. Non-deterministic and hard to diagnose. Affects all P/Invoke wrappers across the entire binding surface."
    },
    "reproEvidence": {
      "relatedIssues": [3393],
      "repoLinks": [
        { "url": "https://github.com/unoplatform/uno/pull/21660", "description": "Uno Platform PR demonstrating the GC race with SkiaSharp canvas.DrawPicture" },
        { "url": "https://github.com/dotnet/java-interop/issues/719", "description": "Related .NET java-interop issue showing same GC.KeepAlive problem" }
      ],
      "codeSnippets": [
        {
          "language": "csharp",
          "code": "var canvas = …\nvar picture = …\ncanvas.DrawPicture(picture);\n// `picture` is not referenced after this point.",
          "context": "Demonstration of the GC race: after extracting picture.Handle, nothing keeps picture alive during the native call"
        },
        {
          "language": "csharp",
          "code": "public void DrawPicture (SKPicture picture, SKPaint paint = null)\n{\n\tif (picture == null)\n\t\tthrow new ArgumentNullException (nameof (picture));\n\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n\tGC.KeepAlive (picture);\n\tGC.KeepAlive (paint);\n}",
          "context": "Proposed fix: add GC.KeepAlive for all reference type parameters after the P/Invoke call"
        }
      ],
      "environmentDetails": "SkiaSharp 3.116.0, VS Code macOS, Android and all platforms affected"
    },
    "versionAnalysis": {
      "mentionedVersions": ["3.116.0"],
      "currentRelevance": "likely",
      "reason": "This is a latent bug present since the inception of the P/Invoke wrappers. It has never been systematically addressed — only a handful of methods (SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) have GC.KeepAlive calls."
    },
    "regression": {
      "isRegression": false,
      "confidence": 0.95,
      "reason": "This has always been the case. The GC race exists in every version of SkiaSharp — it was never systematically protected."
    },
    "fixStatus": null
  },
  "analysis": {
    "summary": "Well-documented GC race condition bug. When a managed SkiaSharp object's Handle is passed to a P/Invoke method, the .NET GC can collect the managed object (and run its finalizer, freeing native memory) before the native call completes. The reporter provides authoritative Microsoft documentation, a concrete Uno Platform reproduction, and a clear fix pattern.",
    "keySignals": [
      { "text": "[BUG] P/Invokes should protect parameters across invocations", "source": "title", "interpretation": "Clearly identifies a systematic bug in P/Invoke parameter lifetime management" },
      { "text": "this can be collected even while you are executing an instance method on that object", "source": "body", "interpretation": "Quotes Microsoft documentation confirming the GC behavior that causes the race" },
      { "text": "once execution hits SkiaApi.sk_canvas_draw_picture(), nothing ensures that picture is kept alive", "source": "body", "interpretation": "Identifies the exact point where the race can occur in SkiaSharp" },
      { "text": "The fix: audit the code (is there a generator?) such that all reference type parameters are explicitly kept alive across P/Invoke boundaries", "source": "body", "interpretation": "Reporter proposes systematic fix via GC.KeepAlive and asks about generator support" },
      { "text": "unoplatform/uno#21660 is a Skia-related example of this", "source": "body", "interpretation": "Real-world evidence from Uno Platform where this race was observed" },
      { "text": "Platform: Android, All", "source": "body", "interpretation": "Affects all platforms, not just Android — the GC race is a .NET runtime behavior" }
    ],
    "fieldRationales": [
      { "field": "type", "chosen": "type/bug", "expandedReason": "This is a real bug — a GC race condition that can cause use-after-free crashes. The reporter provides Microsoft documentation, a concrete reproduction scenario via Uno Platform, and a clear fix. This is not a feature request or question.", "alternatives": [{ "value": "type/enhancement", "whyRejected": "While the fix involves adding code, the underlying behavior (potential crash due to premature GC) is broken, not just suboptimal." }] },
      { "field": "area", "chosen": "area/SkiaSharp", "expandedReason": "The bug is in the core SkiaSharp binding layer where P/Invoke wrapper methods extract Handle properties without protecting the managed objects from GC. This spans all of binding/SkiaSharp/.", "alternatives": [{ "value": "area/SkiaSharp.Views", "whyRejected": "The Views layer is not the source of the problem — it's the core P/Invoke wrappers in SKCanvas, etc." }] },
      { "field": "classification.platforms", "chosen": "null", "expandedReason": "While Android is mentioned in the form, the reporter explicitly says 'All' platforms are affected. The GC race is a .NET runtime behavior, not platform-specific. Removing os/Android is appropriate since this is cross-platform." },
      { "field": "tenets", "chosen": "tenet/reliability", "expandedReason": "Use-after-free due to GC racing with native code causes crashes, data corruption, or undefined behavior. This is a reliability concern." },
      { "field": "partner", "chosen": "partner/unoplatform", "expandedReason": "The Uno Platform team discovered this in practice (uno#21660) and the reporter (jonpryor) references their PR as evidence. Flagging for partner visibility." },
      { "field": "bugSignals.severity", "chosen": "high", "expandedReason": "Non-deterministic use-after-free crash affecting the entire public API surface. The race is hard to reproduce but real, as demonstrated by the Uno Platform team. No easy workaround for consumers." },
      {
        "field": "actionability.suggestedAction",
        "chosen": "needs-investigation",
        "expandedReason": "Valid bug with a clear fix pattern (GC.KeepAlive), but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant.",
        "alternatives": [{ "value": "ready-to-fix", "whyRejected": "While the fix pattern is known, a full audit of hundreds of P/Invoke wrappers is needed before implementation can begin." }]
      },
      {
        "field": "regression.isRegression",
        "chosen": "false",
        "expandedReason": "This has always been the case — the GC race exists in every version of SkiaSharp. The P/Invoke wrappers were never systematically protected with GC.KeepAlive calls."
      },
      {
        "field": "versionAnalysis.currentRelevance",
        "chosen": "likely",
        "expandedReason": "This is a latent bug present since the inception of the P/Invoke wrappers and has never been systematically addressed. Only a handful of methods currently have GC.KeepAlive calls."
      }
    ],
    "uncertainties": [
      "How many of the ~hundreds of P/Invoke wrapper methods need GC.KeepAlive added — a full audit is needed",
      "Whether the code generator (utils/generate.ps1) can be extended to automatically emit GC.KeepAlive calls, or if hand-written wrappers must be individually patched",
      "Whether GC.KeepAlive(this) should also be added to instance methods, or if callers are expected to keep `this` alive"
    ],
    "assumptions": [
      "Assumed the handful of existing GC.KeepAlive calls (in SKData, SKImage, SKSurface, etc.) were added ad-hoc, not as part of a systematic effort",
      "Assumed the bug affects all .NET runtimes (CoreCLR, Mono, NativeAOT) since the GC behavior is specified by the ECMA CLI standard"
    ],
    "resolution": {
      "hypothesis": "The .NET GC can collect managed SkiaSharp objects after their Handle property is read but before the P/Invoke call completes, because the runtime cannot see into native code. If the finalizer runs during this window, it frees the native handle, causing use-after-free in Skia.",
      "proposals": [
        { "title": "Systematic GC.KeepAlive audit of all P/Invoke wrappers", "description": "Audit all public methods in binding/SkiaSharp/ that call SkiaApi.* and add GC.KeepAlive() for every reference-type parameter (including `this` for instance methods) after the P/Invoke call. This is the approach the reporter suggests and is the most thorough fix.", "confidence": 0.90, "effort": "high" },
        { "title": "Extend code generator to emit GC.KeepAlive", "description": "Modify the binding generator (utils/generate.ps1 or the underlying tool) to automatically emit GC.KeepAlive calls in generated P/Invoke wrappers. This prevents future regressions and reduces manual effort, but requires understanding the generator's architecture.", "confidence": 0.80, "effort": "high" },
        { "title": "Targeted fix for highest-risk methods first", "description": "Add GC.KeepAlive to the most commonly used methods (SKCanvas.Draw*, SKPaint, SKPath operations) as an incremental first step, with a follow-up for the full audit. Lower effort but leaves long-tail risk.", "confidence": 0.85, "effort": "medium" }
      ],
      "recommendedProposal": "Systematic GC.KeepAlive audit of all P/Invoke wrappers",
      "recommendedReason": "The reporter is an experienced .NET runtime engineer (jonpryor) who clearly understands the problem. A systematic fix is the only way to fully address this — partial fixes leave the same class of bug in less-used code paths."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.90,
      "reason": "Valid bug with clear fix pattern, but requires a full audit of the binding surface to determine scope. The fix is well-understood technically but the effort is significant."
    },
    "actions": [
      {
        "id": "labels-1", "type": "update-labels", "risk": "low",
        "description": "Add partner/unoplatform label and remove os/Android since issue affects all platforms",
        "reason": "Issue is cross-platform (reporter selected 'All'), and Uno Platform is directly involved via their PR #21660",
        "confidence": 0.85, "dependsOn": null,
        "payload": {
          "labelsToAdd": ["partner/unoplatform"],
          "labelsToRemove": ["os/Android"]
        }
      },
      {
        "id": "comment-1", "type": "add-comment", "risk": "high",
        "description": "Acknowledge the bug report and outline investigation plan",
        "reason": "High-quality report from a knowledgeable contributor deserves a substantive response confirming the issue is understood",
        "confidence": 0.85, "dependsOn": "labels-1",
        "payload": {
          "commentType": "request-info",
          "draftBody": "Thanks for the thorough write-up and the Microsoft documentation references — this is a well-documented GC race that we need to address systematically.\n\nA quick audit shows that only a handful of methods (in SKData, SKImage, SKSurface, SKBitmap, SKTextBlob, SKFontStyleSet) currently have `GC.KeepAlive` calls, so the vast majority of P/Invoke wrappers are unprotected.\n\nThe main question is whether to extend the code generator to emit these automatically, or do a manual audit. Do you have a sense of whether the Uno Platform team has hit this in practice beyond the `DrawPicture` case, or if that's been the primary trigger?",
          "requiresHumanEdit": true,
          "finalBody": null,
          "dedupeToken": "triage-3393-comment-1"
        }
      }
    ]
  }
}
