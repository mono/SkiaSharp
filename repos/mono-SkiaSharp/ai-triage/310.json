{
  "meta": {
    "schemaVersion": "2.1",
    "number": 310,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2025-07-25T06:00:00Z",
    "currentLabels": ["type/enhancement", "status/low-priority", "os/Windows-Classic", "area/SkiaSharp.Views"]
  },
  "summary": "GDI+ error in SKControl.OnPaint when control is resized during PaintSurface event due to reentrant OnPaint and bitmap state corruption",
  "classification": {
    "type": { "value": "type/bug", "confidence": 0.95 },
    "area": { "value": "area/SkiaSharp.Views", "confidence": 0.95 },
    "backends": null,
    "platforms": [{ "value": "os/Windows-Classic", "confidence": 0.95 }],
    "tenets": [{ "value": "tenet/reliability", "confidence": 0.90 }],
    "partner": null
  },
  "evidence": {
    "bugSignals": {
      "hasCrash": true,
      "hasStackTrace": true,
      "reproQuality": "steps-only",
      "hasWorkaround": true,
      "workaroundSummary": "Avoid resizing the SKControl from within the PaintSurface event handler. Perform layout calculations and control resizing outside the paint cycle, e.g. in a BeginInvoke callback.",
      "severity": "medium",
      "severityReason": "GDI+ exception crash but user-identified workaround exists (don't resize during paint). Affects a specific usage pattern, not all SKControl users."
    },
    "reproEvidence": {
      "stepsToReproduce": [
        "Place SKControl inside a scrollable container (e.g. DevExpress XtraScrollableControl)",
        "In the PaintSurface event handler, change the SKControl.Height based on content",
        "Scroll down so the bottom of SKControl is visible but top is offscreen",
        "Trigger a content change that resizes the SKControl smaller, causing the view to go offscreen"
      ],
      "codeSnippets": [
        {
          "code": "System.Runtime.InteropServices.ExternalException (0x80004005): A generic error occurred in GDI+.\n   at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata)\n   at SkiaSharp.Views.Desktop.SKControl.OnPaint(PaintEventArgs e)\n   at System.Windows.Forms.Control.PaintWithErrorHandling(PaintEventArgs e, Int16 layer)\n   at System.Windows.Forms.Control.WmPaint(Message& m)\n   at System.Windows.Forms.Control.WndProc(Message& m)\n   at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)",
          "language": "text",
          "context": "Stack trace from the GDI+ error"
        }
      ],
      "environmentDetails": "Windows, WinForms (System.Windows.Forms), DevExpress XtraScrollableControl container"
    },
    "versionAnalysis": {
      "reason": "Issue filed in 2017 against an early SkiaSharp version. The SKControl.OnPaint code path is unchanged — no reentrancy guard has been added. The bug is still present in the current codebase.",
      "currentRelevance": "likely"
    },
    "regression": null,
    "fixStatus": null
  },
  "analysis": {
    "summary": "The reporter triggers a reentrant OnPaint by resizing SKControl from within the PaintSurface event. The reentrant call to CreateBitmap() disposes and replaces the bitmap while the outer OnPaint still holds a LockBits handle on the old bitmap. When the outer OnPaint resumes and calls UnlockBits(data), the bitmap is already disposed/replaced, causing the GDI+ error.",
    "keySignals": [
      { "text": "A generic error occurred in GDI+. at System.Drawing.Bitmap.UnlockBits(BitmapData bitmapdata) at SkiaSharp.Views.Desktop.SKControl.OnPaint", "source": "body", "interpretation": "Crash in UnlockBits indicates bitmap state was corrupted between LockBits and UnlockBits — consistent with reentrancy" },
      { "text": "the OnPaint event is being called from within the OnPaint event (due to my height resize code), but only in rare circumstances", "source": "comment 2", "interpretation": "Reporter confirmed reentrancy via debugging — resize triggers a second OnPaint while first is still running" },
      { "text": "I am changing the SKControl.Height value from within the PaintSurface event", "source": "comment 2", "interpretation": "Root cause: layout change during paint cycle triggers reentrant paint" },
      { "text": "This issue was the result of the paint operation also resizing the view - possibly invalidating the canvas or causing an infinite loop/stack overflow", "source": "comment 5", "interpretation": "Maintainer acknowledged the root cause and left issue open for investigation" }
    ],
    "codeInvestigation": [
      { "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs", "lines": "30-57", "relevance": "OnPaint has no reentrancy guard. LockBits on line 43 acquires a handle on the bitmap, then OnPaintSurface on line 49 fires user code. If user code resizes the control, a reentrant OnPaint call will run CreateBitmap() which disposes and replaces the bitmap field. When the original OnPaint resumes at line 55, UnlockBits(data) operates on a disposed/replaced bitmap." },
      { "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs", "lines": "72-85", "relevance": "CreateBitmap() disposes the old bitmap via FreeBitmap() (line 78) and creates a new one (line 81) whenever Width/Height changes. This is the mutation that corrupts the outer OnPaint's LockBits handle." },
      { "file": "source/SkiaSharp.Views/SkiaSharp.Views.WindowsForms/SKControl.cs", "lines": "17-20", "relevance": "Constructor sets ControlStyles.ResizeRedraw = true (line 20), meaning any resize immediately triggers a repaint — enabling the reentrant OnPaint when the user resizes from within PaintSurface." },
      { "file": "source/SkiaSharp.Views/SkiaSharp.Views.WPF/SKElement.cs", "lines": "45-89", "relevance": "WPF SKElement.OnRender has same Lock/PaintSurface/Unlock pattern (lines 72-87) but WPF's rendering pipeline does not allow reentrant OnRender calls. WinForms' message pump does allow reentrant WM_PAINT handling, which is why only SKControl is affected." }
    ],
    "fieldRationales": [
      { "field": "type", "chosen": "type/bug", "expandedReason": "The issue describes a crash (ExternalException) with a stack trace during normal operation. The reporter and maintainer both confirmed reentrant OnPaint as the root cause. Currently labeled type/enhancement but this is a defect — the control should handle reentrancy gracefully rather than crashing.", "alternatives": [{ "value": "type/enhancement", "whyRejected": "Current label. While adding a reentrancy guard is an 'enhancement', the underlying problem is a crash — this is a bug, not a feature gap." }] },
      { "field": "area", "chosen": "area/SkiaSharp.Views", "expandedReason": "The crash occurs in SKControl.OnPaint, which is in the SkiaSharp.Views.WindowsForms package under the SkiaSharp.Views.Desktop namespace." },
      { "field": "bugSignals.severity", "chosen": "medium", "expandedReason": "GDI+ exception crashes the paint cycle, but a workaround exists (avoid resizing during paint). The pattern requires a specific trigger (resize from within PaintSurface) that is not the common usage path." },
      { "field": "platforms", "chosen": "os/Windows-Classic", "expandedReason": "SKControl is a WinForms control. WinForms is Windows-only, and the reentrancy behavior is specific to the WinForms message pump handling of WM_PAINT." },
      { "field": "tenets", "chosen": "tenet/reliability", "expandedReason": "Unhandled GDI+ exception during paint is a reliability issue — the control should not crash even if user code triggers reentrancy." },
      { "field": "versionAnalysis.currentRelevance", "chosen": "likely", "expandedReason": "The SKControl.OnPaint code has not changed since the issue was filed. No reentrancy guard has been added. The bug is still present in current main." },
      { "field": "actionability.suggestedAction", "chosen": "needs-investigation", "expandedReason": "The root cause is well understood (reentrant OnPaint corrupts bitmap state), but a proper fix needs design consideration — a simple boolean guard vs. queueing the resize vs. making CreateBitmap idempotent during locks. The issue label should be corrected from type/enhancement to type/bug." }
    ],
    "uncertainties": [
      "Whether a simple boolean reentrancy guard (skip reentrant OnPaint) is sufficient, or if the resize should be deferred and replayed",
      "Whether other WinForms container controls besides DevExpress XtraScrollableControl can trigger this reentrancy"
    ],
    "assumptions": [
      "Assumed the issue is still reproducible since no code changes have been made to SKControl.OnPaint since filing",
      "Assumed the reporter was using a relatively recent SkiaSharp version at the time (mid-2017)"
    ],
    "resolution": {
      "hypothesis": "Reentrant OnPaint corrupts GDI+ bitmap state because CreateBitmap disposes the locked bitmap. A reentrancy guard would prevent the crash.",
      "proposals": [
        {
          "title": "Add reentrancy guard to OnPaint",
          "description": "Add a boolean field (e.g., isPainting) that skips reentrant OnPaint calls. Set it true before LockBits, false after UnlockBits. If already true when OnPaint is entered, call Invalidate() to schedule a deferred repaint and return early.",
          "confidence": 0.85,
          "effort": "low",
          "category": "fix",
          "codeSnippet": "private bool isPainting;\n\nprotected override void OnPaint(PaintEventArgs e)\n{\n    if (designMode || isPainting)\n    {\n        if (isPainting) Invalidate();\n        return;\n    }\n    isPainting = true;\n    try\n    {\n        base.OnPaint(e);\n        var info = CreateBitmap();\n        if (info.Width == 0 || info.Height == 0) return;\n        var data = bitmap.LockBits(new Rectangle(0, 0, Width, Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);\n        using (var surface = SKSurface.Create(info, data.Scan0, data.Stride))\n        {\n            OnPaintSurface(new SKPaintSurfaceEventArgs(surface, info));\n            surface.Canvas.Flush();\n        }\n        bitmap.UnlockBits(data);\n        e.Graphics.DrawImage(bitmap, 0, 0);\n    }\n    finally\n    {\n        isPainting = false;\n    }\n}",
          "validated": "untested"
        },
        {
          "title": "Move resize logic outside PaintSurface event",
          "description": "Reporter's own workaround: perform control resizing outside the PaintSurface handler. Use BeginInvoke to defer the resize to after the paint cycle completes.",
          "confidence": 0.90,
          "effort": "low",
          "category": "workaround",
          "codeSnippet": "private void OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    // Draw content...\n    int newHeight = CalculateContentHeight();\n    // Defer resize to after paint completes\n    BeginInvoke(new Action(() => skControl.Height = newHeight));\n}",
          "validated": "untested"
        },
        {
          "title": "Wrap bitmap operations in try-catch",
          "description": "Catch ExternalException from UnlockBits and schedule an Invalidate() to retry the paint. Defensive but does not prevent the underlying reentrancy — masks the symptom.",
          "confidence": 0.60,
          "effort": "low",
          "category": "workaround",
          "validated": "untested"
        }
      ],
      "recommendedProposal": "Add reentrancy guard to OnPaint",
      "recommendedReason": "Addresses root cause with minimal code change. Prevents crash and schedules deferred repaint so no visual frames are lost."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.82,
      "reason": "Root cause is well understood from reporter's debugging and source analysis. Fix is straightforward (reentrancy guard) but needs testing and design review to ensure deferred repaints work correctly in all container scenarios."
    },
    "actions": [
      {
        "id": "labels-1",
        "type": "update-labels",
        "risk": "low",
        "description": "Correct type label from enhancement to bug, add reliability tenet",
        "reason": "Issue describes a crash (ExternalException) with stack trace — this is a bug, not an enhancement. Reliability tenet applies.",
        "confidence": 0.92,
        "dependsOn": null,
        "payload": {
          "labelsToAdd": ["type/bug", "tenet/reliability"],
          "labelsToRemove": ["type/enhancement"]
        }
      },
      {
        "id": "comment-1",
        "type": "add-comment",
        "risk": "high",
        "description": "Post analysis with workaround and proposed fix",
        "reason": "Issue has been open since 2017 with no code fix. Providing a workaround and proposed fix helps the reporter and documents the root cause.",
        "confidence": 0.82,
        "dependsOn": "labels-1",
        "payload": {
          "commentType": "workaround",
          "draftBody": "Thanks for the thorough investigation and stack trace.\n\nThe root cause is reentrant `OnPaint` — resizing the control from within `PaintSurface` triggers a second `OnPaint` call that disposes and recreates the bitmap while the first call still holds a `LockBits` handle. When the original `OnPaint` resumes, `UnlockBits` fails on the replaced bitmap.\n\nHere's a workaround you can use now: defer the resize to after the paint completes using `BeginInvoke`:\n\n```csharp\nprivate void OnPaintSurface(object sender, SKPaintSurfaceEventArgs e)\n{\n    // Draw content...\n    int newHeight = CalculateContentHeight();\n    // Defer resize to after paint completes\n    BeginInvoke(new Action(() => skControl.Height = newHeight));\n}\n```\n\nOn the SkiaSharp side, a reentrancy guard in `SKControl.OnPaint` would prevent this class of crashes. We'll investigate adding one.",
          "requiresHumanEdit": true,
          "finalBody": null,
          "dedupeToken": "triage-310-comment-1"
        }
      }
    ]
  }
}
