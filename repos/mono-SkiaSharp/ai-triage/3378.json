{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3378,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-08T19:00:00Z"
  },
  "summary": "Memory leak in ToHarfBuzzBlob() — SKStreamAsset not disposed in the non-memory-mapped code path",
  "classification": {
    "type": {
      "value": "type/bug",
      "confidence": 0.95
    },
    "area": {
      "value": "area/harfbuzz",
      "confidence": 0.95
    },
    "platforms": [
      "os/Android",
      "os/Windows-Classic"
    ]
  },
  "evidence": {
    "reproEvidence": {
      "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), first observed on Android but also reproduces on Windows",
      "codeSnippets": [
        "csharp: class TextSegmentShaper : IDisposable\n{\n    public SKPaint Paint { get; set; }\n    public SKShaper Shaper { get; set; }\n    ...\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposedValue)\n        {\n            Paint?.Dispose();\n            Shaper?.Dispose();\n            ...\n        }\n    }\n}"
      ]
    },
    "bugSignals": {
      "severity": "medium"
    },
    "versionAnalysis": {
      "mentionedVersions": [
        "3.116.0"
      ]
    }
  },
  "analysis": {
    "summary": "Confirmed memory leak in BlobExtensions.ToHarfBuzzBlob(). When the SKStreamAsset has no memory base (the else branch), data is copied to unmanaged memory but the SKStreamAsset is never disposed. The if branch correctly disposes via the Blob's destroy callback, but the else branch only frees the copied CoTaskMem allocation. Title says SKShader but the actual issue is about SKShaper (HarfBuzz).",
    "rationale": "type: Reporter describes a memory leak with code evidence pointing to a specific disposal path bug. This is broken behavior in the library, not a usage question. area: The leak is in BlobExtensions.ToHarfBuzzBlob() which is in the SkiaSharp.HarfBuzz package. SKShaper is also in this package. The current label area/SkiaSharp is incorrect. backends: This is a managed code memory leak in a HarfBuzz extension method. It has nothing to do with rendering backends. The existing backend/Metal label is incorrect. bugSignals.severity: Memory leak that grows with each SKShaper creation. Not a crash, but can cause OOM on constrained devices over time. The leak is in library code, not user code, so there is no straightforward workaround. actionability.suggestedAction: The code-level bug in ToHarfBuzzBlob() is confirmed by source analysis, but a memory profiling test should verify the leak and validate the proposed one-line disposal fix. platforms: Reporter first observed the leak on Android and confirmed it also reproduces on Windows. The bug is in managed code (BlobExtensions.cs) so it affects all platforms, but only Android and Windows are explicitly reported. tenets: Memory leak that grows with each SKShaper instantiation can degrade performance over time and eventually cause OOM, particularly on resource-constrained Android devices. regression.isRegression: The else branch in BlobExtensions.ToHarfBuzzBlob() has never disposed the SKStreamAsset since the extension was introduced. This is a latent bug, not a regression from a previously working state. versionAnalysis.currentRelevance: The leak exists in BlobExtensions.ToHarfBuzzBlob() which has not changed in recent versions; the else branch still does not dispose the SKStreamAsset.",
    "codeInvestigation": [],
    "nextQuestions": [
      "Whether the else branch (non-memory-mapped path) is commonly hit in practice — if most streams have a memory base, the leak may be rare",
      "Exact memory footprint per leak — depends on font file size, could be significant for large fonts",
      "Whether the title typo (SKShader vs SKShaper) has caused confusion in previous triage"
    ],
    "resolution": {
      "hypothesis": "In BlobExtensions.ToHarfBuzzBlob(), the else branch copies font data from the SKStreamAsset into unmanaged memory but never disposes the SKStreamAsset. The if branch correctly passes asset.Dispose() as the Blob destroy callback, but the else branch only frees the CoTaskMem copy.",
      "proposals": [
        {
          "description": "Add asset.Dispose() in the else branch of ToHarfBuzzBlob() after reading data, mirroring how the if branch handles disposal via the Blob callback. This is a one-line fix in BlobExtensions.cs.",
          "confidence": 0.92,
          "effort": "small"
        },
        {
          "description": "Capture the SKStreamAsset in a variable in the SKShaper constructor and wrap it in a using statement, rather than relying on ToHarfBuzzBlob() to manage its lifetime. Decouples disposal responsibility from the extension method.",
          "confidence": 0.8,
          "effort": "small"
        },
        {
          "description": "Simplify ToHarfBuzzBlob() to always copy data and always dispose the asset, removing the memory-mapped optimization. Trades minor performance for simpler, less error-prone code.",
          "confidence": 0.7,
          "effort": "small"
        }
      ]
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.88,
      "reason": "Code-level bug confirmed by source analysis. The fix is straightforward but should be verified with a memory profiling test to confirm the leak and validate the fix."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Correct area to SkiaSharp.HarfBuzz and remove incorrect Metal backend label",
        "risk": "low",
        "confidence": 0.95,
        "labels": [
          "area/SkiaSharp.HarfBuzz"
        ]
      },
      {
        "type": "add-comment",
        "description": "Acknowledge the bug report and confirm the root cause analysis",
        "risk": "high",
        "confidence": 0.85
      }
    ]
  }
}
