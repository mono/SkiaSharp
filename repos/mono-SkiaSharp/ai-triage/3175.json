{
  "meta": {
    "schemaVersion": "1.0",
    "number": 3175,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-11T22:12:00Z"
  },
  "summary": "SKBitmap.Decode returns incomplete/corrupt image when reading from Azure Blob stream due to single-call Stream.Read in SKManagedStream — duplicate of #1962",
  "classification": {
    "type": {
      "value": "type/bug",
      "confidence": 0.97
    },
    "area": {
      "value": "area/SkiaSharp",
      "confidence": 0.95
    },
    "platforms": [
      "os/Linux",
      "os/Windows-Classic"
    ]
  },
  "evidence": {
    "reproEvidence": {
      "environmentDetails": "Azure Blob Storage stream with 4MB default chunk size. Visual Studio on Windows. Targets Linux and Windows.",
      "codeSnippets": [
        "csharp: await using var image = await blobStorage.GetBlob(blobName, cancellationToken);\nawait using MemoryStream memoryStream = new();\nawait image.CopyToAsync(memoryStream, cancellationToken);\nmemoryStream.Seek(0, SeekOrigin.Begin);\nusing var originalImage = SKBitmap.Decode(memoryStream);"
      ]
    },
    "bugSignals": {
      "severity": "medium",
      "isRegression": true
    },
    "versionAnalysis": {
      "mentionedVersions": [
        "3.116.0",
        "2.88.9"
      ]
    }
  },
  "analysis": {
    "summary": "This is a duplicate of #1962 (and related to #2514, #2249, #1985, #335). The root cause is in SKManagedStream.OnReadManagedStream which calls stream.Read() once without looping. Per the .NET Stream.Read contract, a single call may return fewer bytes than requested even when more data is available (e.g., Azure Blob streams deliver data in chunks). Skia's native code interprets the short read as a signal that no more data is available, causing incomplete image decoding. The reporter's workaround of copying to MemoryStream first is correct — MemoryStream.Read always returns the full requested amount when data is available.",
    "rationale": "type: The reporter describes incorrect behavior — images decoded from Azure Blob streams are incomplete/corrupt while the same images decode correctly from MemoryStream. This is caused by a known code defect in SKManagedStream. area: The bug is in SKManagedStream.OnReadManagedStream in the core SkiaSharp binding. Not in Views or any other sub-package. bugSignals.severity: Produces corrupt output but doesn't crash. The workaround (MemoryStream copy) is simple and the reporter already found it. However, it's a correctness bug that affects many users with network/cloud streams. platforms: Reporter lists both Linux and Windows as affected. The bug is platform-independent (it's in managed C# code), but these are the platforms the reporter tested on. tenets: Decoding produces silently corrupt images from certain stream types — a reliability concern. regression.isRegression: PR #1510 changed from BinaryReader.ReadBytes (which loops internally) to stream.Read (which doesn't guarantee full reads). This was documented in detail by #1962. fixStatus.likelyFixed: Verified in current source: SKManagedStream.cs line 99 still uses a single stream.Read() call without a loop. versionAnalysis.currentRelevance: The buggy code path is unchanged in the current main branch. The issue remains relevant. actionability.suggestedAction: This is the same bug as #1962, which has a detailed root cause analysis and is still open. Closing as duplicate consolidates tracking.",
    "codeInvestigation": [
      {
        "file": "binding/SkiaSharp/SKManagedStream.cs",
        "lines": "89-112",
        "finding": "OnReadManagedStream calls stream.Read() once at line 99 without looping. Per .NET docs, Stream.Read may return fewer bytes than requested even when more data is available — this is the root cause. Azure Blob streams return data in chunks (default 4MB), so a single Read returns at most one chunk.",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKCodec.cs",
        "lines": "278-290",
        "finding": "WrapManagedStream decides the stream wrapper: seekable streams get SKManagedStream (the buggy path), non-seekable get SKFrontBufferedManagedStream. Azure Blob streams are seekable, so they hit the buggy SKManagedStream path.",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKBitmap.cs",
        "lines": "461-471",
        "finding": "SKBitmap.Decode(Stream) creates an SKCodec from the stream, which wraps it in SKManagedStream. The codec then reads through SKManagedStream during decoding, hitting the partial-read bug.",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKFrontBufferedManagedStream.cs",
        "lines": "64-124",
        "finding": "The non-seekable stream path also doesn't loop reads (line 91, 111), but passes through to SKManagedStream which has the same bug. Related issue #2514 reports partial reads on non-seekable streams too.",
        "relevance": "related"
      }
    ],
    "workarounds": [
      "Copy the Azure Blob stream to a MemoryStream before calling SKBitmap.Decode. The reporter already discovered this workaround independently."
    ],
    "nextQuestions": [
      "Reporter claims 2.88.9 was the last known good version, but #1962 documents the regression at 2.80.3 — the reporter may not have tested chunked streams on the older version",
      "Whether the reporter is using SKBitmap.Decode(Stream) directly on the blob stream or through another path — the code shown uses MemoryStream (the workaround)"
    ]
  },
  "output": {
    "actionability": {
      "suggestedAction": "close-as-duplicate",
      "confidence": 0.92,
      "reason": "This is the same root cause as #1962 — SKManagedStream.OnReadManagedStream uses a single stream.Read() call that doesn't loop to fill the buffer. Multiple other issues (#2514, #2249, #1985, #335) report the same problem with network/cloud streams."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Apply area, platform, and tenet labels",
        "risk": "low",
        "confidence": 0.95,
        "labels": [
          "area/SkiaSharp",
          "os/Linux",
          "os/Windows-Classic",
          "tenet/reliability"
        ]
      },
      {
        "type": "link-duplicate",
        "description": "Mark as duplicate of #1962",
        "risk": "medium",
        "confidence": 0.92
      },
      {
        "type": "add-comment",
        "description": "Acknowledge the bug, confirm workaround, and link to the canonical issue",
        "risk": "high",
        "confidence": 0.88
      },
      {
        "type": "close-issue",
        "description": "Close as duplicate of #1962",
        "risk": "medium",
        "confidence": 0.92
      }
    ]
  }
}
