{
  "meta": {
    "schemaVersion": "1.0",
    "number": 209,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-11T16:00:00Z"
  },
  "summary": "AccessViolationException in SKBitmap.Decode when decoding multiple images concurrently on IIS. SemaphoreSlim(1) workaround confirms native Skia thread safety issue.",
  "classification": {
    "type": {
      "value": "type/bug",
      "confidence": 0.92
    },
    "area": {
      "value": "area/SkiaSharp",
      "confidence": 0.9
    }
  },
  "evidence": {
    "bugSignals": {
      "severity": "high",
      "errorType": "crash"
    },
    "versionAnalysis": {
      "mentionedVersions": [
        ".NETFramework 4.x (implied by IIS/w3wp.exe context)"
      ]
    }
  },
  "analysis": {
    "summary": "The managed SKBitmap.Decode path creates an SKCodec via SKCodec.Create which calls native sk_codec_new_from_stream. There is zero thread synchronization in the managed layer — no locks, no ConcurrentDictionary usage, no Interlocked operations on the decode path. SKCodec implements ISKSkipObjectRegistration, bypassing the HandleDictionary entirely. The crash occurs in native sk_codec_get_info, suggesting the native Skia codec layer is not thread-safe for concurrent decode operations. The reporter's SemaphoreSlim(1) workaround confirms this: serializing access prevents the crash.",
    "rationale": "type: Reporter describes a crash (AccessViolationException) during normal concurrent usage. The SemaphoreSlim(1) workaround proves it's a real threading bug, not a usage error. area: The crash is in core SKBitmap/SKCodec decode path via native P/Invoke, not in a specific view or platform binding. tenets: AccessViolationException crashes the entire IIS process — this is a reliability issue. bugSignals.severity: Process crash (w3wp.exe termination) with no way to catch or handle the AccessViolationException. Affects all concurrent image processing scenarios. actionability.suggestedAction: The root cause is in native Skia's thread safety characteristics. Need to determine if SkiaSharp should add managed-side locking, document the limitation, or if upstream Skia has since made codecs thread-safe. versionAnalysis.currentRelevance: Code inspection confirms zero thread synchronization in the SKBitmap.Decode → SKCodec.Create → native path. No locks have been added since the issue was filed.",
    "codeInvestigation": [
      {
        "file": "binding/SkiaSharp/SKBitmap.cs",
        "lines": "461-471",
        "finding": "SKBitmap.Decode(Stream) creates SKCodec via SKCodec.Create(stream) then calls Decode(codec). No locking, no thread synchronization anywhere in this path.",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKCodec.cs",
        "lines": "252-264",
        "finding": "SKCodec.Create calls native sk_codec_new_from_stream via SkiaApi. No locking. SKCodec implements ISKSkipObjectRegistration, so it bypasses HandleDictionary tracking entirely.",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKObject.cs",
        "lines": "10-27",
        "finding": "Base class uses ConcurrentDictionary for owned objects and lock for lazy init, but SKCodec skips registration (ISKSkipObjectRegistration). The only Interlocked usage is in Dispose (line 261).",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SkiaApi.generated.cs",
        "lines": "3579-3595",
        "finding": "sk_codec_get_info is a direct P/Invoke to native Skia — no managed-side synchronization wrapper. This is the exact function in the reporter's crash stack trace.",
        "relevance": "related"
      }
    ],
    "workarounds": [
      "SemaphoreSlim(1) around SKBitmap.Decode calls serializes decoding, preventing the crash."
    ],
    "nextQuestions": [
      "Whether upstream Skia has since made codec operations thread-safe (would need to check Skia release notes)",
      "Whether the crash is in sk_codec_get_info specifically or in shared global state during codec initialization",
      "Whether SKImage.FromEncodedData has the same thread safety issue (uses different native path)"
    ],
    "resolution": {
      "hypothesis": "Native Skia codec operations are not thread-safe for concurrent decode of multiple images. The managed SkiaSharp wrapper does not add any synchronization, so the crash propagates as an AccessViolationException.",
      "proposals": [
        {
          "description": "Add XML doc comments to SKBitmap.Decode and SKCodec.Create noting that concurrent decode operations are not thread-safe and callers must synchronize access.",
          "confidence": 0.9,
          "effort": "small"
        },
        {
          "description": "Use SemaphoreSlim(1,1) around SKBitmap.Decode calls. Reporter has confirmed this works.",
          "confidence": 0.95,
          "effort": "small"
        },
        {
          "description": "Add a static lock or SemaphoreSlim in SKCodec.Create to serialize native codec creation. Would fix all callers transparently but reduces throughput.",
          "confidence": 0.7,
          "effort": "medium"
        }
      ]
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.85,
      "reason": "Thread safety limitation in native Skia codec layer — needs determination of whether to add managed-side locking or document the limitation."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Apply bug and reliability labels",
        "risk": "low",
        "confidence": 0.92,
        "labels": [
          "area/SkiaSharp",
          "tenet/reliability"
        ]
      },
      {
        "type": "add-comment",
        "description": "Acknowledge thread safety issue and provide workaround",
        "risk": "high",
        "confidence": 0.85
      }
    ]
  }
}
