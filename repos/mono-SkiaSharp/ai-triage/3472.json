{
  "meta": {
    "schemaVersion": "2.0",
    "number": 3472,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-08T19:00:00Z",
    "currentLabels": ["type/bug", "os/Windows-Classic", "area/SkiaSharp", "tenet/reliability"]
  },
  "summary": "HarfBuzzSharp Blob.FromStream uses a pinned managed array pointer that becomes invalid after the fixed block exits, causing potential GC-related crashes",
  "classification": {
    "type": { "value": "type/bug", "confidence": 0.95 },
    "area": { "value": "area/HarfBuzzSharp", "confidence": 0.95 },
    "backends": null,
    "platforms": null,
    "tenets": [
      { "value": "tenet/reliability", "confidence": 0.95 }
    ],
    "partner": null
  },
  "evidence": {
    "bugSignals": {
      "hasCrash": true,
      "hasStackTrace": false,
      "reproQuality": "partial",
      "hasWorkaround": false,
      "workaroundSummary": null,
      "severity": "high",
      "severityReason": "Memory safety bug: the fixed block exits before the Blob is used, so GC can relocate the managed byte array causing use-after-move crashes. No workaround exists short of avoiding FromStream entirely."
    },
    "reproEvidence": {
      "codeSnippets": [
        {
          "language": "csharp",
          "code": "public static unsafe Blob FromStream (Stream stream)\n{\n\tusing var ms = new MemoryStream ();\n\tstream.CopyTo (ms);\n\tvar data = ms.ToArray ();\n\n\tfixed (byte* dataPtr = data) {\n\t\treturn new Blob ((IntPtr)dataPtr, data.Length, MemoryMode.ReadOnly, () => ms.Dispose ());\n\t}\n}",
          "context": "Current buggy implementation in binding/HarfBuzzSharp/Blob.cs"
        },
        {
          "language": "csharp",
          "code": "public static unsafe Blob FromStream (Stream stream)\n{\n\tvar length = (int)(stream.Length - stream.Position);\n\n\tvar dataPtr = Marshal.AllocCoTaskMem (length);\n\n\tusing var ums = new UnmanagedMemoryStream ((byte*)dataPtr, length, length, FileAccess.ReadWrite);\n\tstream.CopyTo (ums);\n\n\treturn new Blob (dataPtr, length, MemoryMode.ReadOnly, () => Marshal.FreeCoTaskMem (dataPtr));\n}",
          "context": "Reporter's proposed fix using unmanaged memory allocation"
        }
      ],
      "environmentDetails": "SkiaSharp 3.116.0, Visual Studio (Windows), affects all platforms"
    },
    "versionAnalysis": {
      "mentionedVersions": ["3.116.0", "2.88.9"],
      "currentRelevance": "likely",
      "reason": "The buggy code pattern exists in the current source (binding/HarfBuzzSharp/Blob.cs lines 71-82). The issue was found by code inspection, not runtime testing, and the code has not changed."
    },
    "regression": {
      "isRegression": false,
      "confidence": 0.80,
      "reason": "The reporter lists 2.88.9 as 'Last Known Good Version' but this appears to be a latent bug present since the method was written — the fixed block has always exited before the Blob could be used. It likely manifests non-deterministically depending on GC timing."
    },
    "fixStatus": null
  },
  "analysis": {
    "summary": "Real memory safety bug in HarfBuzzSharp's Blob.FromStream. The fixed statement pins a managed byte array only for the duration of the block, but the resulting Blob holds the pointer beyond that scope. After the fixed block exits, the GC is free to relocate the managed array, leaving the Blob with a dangling pointer.",
    "keySignals": [
      { "text": "If GC runs after the blob is created, the managed array memory might be moved resulting in a crash", "source": "body", "interpretation": "Reporter correctly identifies the root cause: the fixed block scope is too narrow" },
      { "text": "fixed (byte* dataPtr = data) { return new Blob((IntPtr)dataPtr, ...); }", "source": "body", "interpretation": "The fixed block exits immediately after Blob construction, unpinning the managed array while the Blob still holds the pointer" },
      { "text": "Should copy via an UnmanagedMemoryStream", "source": "body", "interpretation": "Reporter provides a concrete fix using Marshal.AllocCoTaskMem for GC-safe unmanaged memory" },
      { "text": "TODO: check to see if we can avoid the second copy (the ToArray)", "source": "body", "interpretation": "Existing TODO comment in the code acknowledges the implementation is suboptimal" },
      { "text": "This should also improve performance since it removes the redundant copy", "source": "comment 2", "interpretation": "The proposed fix also eliminates an unnecessary buffer copy — stream → MemoryStream → byte[] becomes stream → unmanaged buffer" }
    ],
    "fieldRationales": [
      { "field": "type", "chosen": "type/bug", "expandedReason": "This is a real memory safety defect found by code inspection. The fixed keyword only pins memory within its block scope, but the Blob outlives that scope. This is not a feature request or enhancement — it's broken code that can crash.", "alternatives": [{ "value": "type/enhancement", "whyRejected": "While the fix also improves performance, the core issue is a use-after-unpin memory safety bug, not an optimization request." }] },
      { "field": "area", "chosen": "area/HarfBuzzSharp", "expandedReason": "The bug is in HarfBuzzSharp.Blob.FromStream (binding/HarfBuzzSharp/Blob.cs), not in the SkiaSharp core library. The existing label area/SkiaSharp is incorrect.", "alternatives": [{ "value": "area/SkiaSharp", "whyRejected": "The Blob class is in the HarfBuzzSharp namespace and assembly, not SkiaSharp." }] },
      { "field": "bugSignals.severity", "chosen": "high", "expandedReason": "Memory safety bug with potential for hard crashes. No workaround other than avoiding the API entirely. The crash is non-deterministic (depends on GC timing), making it difficult to diagnose in production." },
      { "field": "platforms", "chosen": "null", "expandedReason": "The reporter selected 'All' for platform. The bug is in managed C# code and affects all platforms equally since GC behavior is a .NET runtime concern, not platform-specific." }
    ],
    "uncertainties": [
      "Whether this has been observed as an actual crash in production, or only identified by code inspection",
      "Whether SkiaSharp's SKData or other classes have similar fixed-block scope issues"
    ],
    "assumptions": [
      "Assumed the reporter's version selection of 2.88.9 as 'Last Known Good' is likely a form field default rather than evidence of a regression, since the buggy pattern appears to have been present since the method was written"
    ],
    "resolution": {
      "hypothesis": "The fixed block in Blob.FromStream exits immediately after constructing the Blob, unpinning the managed byte array. The Blob holds a raw pointer to what was pinned memory, but after unpinning, the GC can relocate the array, leaving a dangling pointer. The fix is to use unmanaged memory that the GC cannot move.",
      "proposals": [
        {
          "title": "Use Marshal.AllocCoTaskMem with UnmanagedMemoryStream",
          "description": "Allocate unmanaged memory, copy stream data directly into it via UnmanagedMemoryStream, and pass the unmanaged pointer to Blob with a release delegate that calls Marshal.FreeCoTaskMem. This is the reporter's proposed fix. It eliminates the GC safety issue and removes one redundant buffer copy (stream → MemoryStream → ToArray becomes stream → unmanaged buffer).",
          "confidence": 0.90,
          "effort": "low"
        },
        {
          "title": "Use GCHandle.Alloc to pin the managed array",
          "description": "Instead of fixed, use GCHandle.Alloc(data, GCHandleType.Pinned) to pin the managed array for the lifetime of the Blob. Free the GCHandle in the release delegate. This is simpler but keeps the redundant copy and long-lived GC pinning can fragment the managed heap.",
          "confidence": 0.80,
          "effort": "low"
        },
        {
          "title": "Use NativeMemory.Alloc (modern .NET)",
          "description": "Use System.Runtime.InteropServices.NativeMemory.Alloc instead of Marshal.AllocCoTaskMem for a more modern API. Functionally equivalent but uses the newer .NET API surface. May require conditional compilation for older target frameworks.",
          "confidence": 0.75,
          "effort": "low"
        }
      ],
      "recommendedProposal": "Use Marshal.AllocCoTaskMem with UnmanagedMemoryStream",
      "recommendedReason": "Directly addresses the root cause, eliminates the redundant copy, uses well-established APIs available on all target frameworks, and matches the reporter's well-reasoned proposal."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "needs-investigation",
      "confidence": 0.85,
      "reason": "The bug is clearly identified by code inspection with a concrete fix proposal. Needs brief investigation to check for similar patterns elsewhere (e.g., SkiaSharp's SKData) before applying the fix."
    },
    "actions": [
      {
        "id": "labels-1",
        "type": "update-labels",
        "risk": "low",
        "description": "Correct area label from SkiaSharp to HarfBuzzSharp and remove incorrect Windows-Classic platform label",
        "reason": "Bug is in HarfBuzzSharp.Blob, not SkiaSharp core. Platform is All, not Windows-specific.",
        "confidence": 0.95,
        "dependsOn": null,
        "payload": {
          "labelsToAdd": ["area/HarfBuzzSharp"],
          "labelsToRemove": ["area/SkiaSharp", "os/Windows-Classic"]
        }
      },
      {
        "id": "comment-1",
        "type": "add-comment",
        "risk": "high",
        "description": "Acknowledge the bug report and confirm the analysis is correct",
        "reason": "Reporter provided excellent analysis with a concrete fix. Acknowledging and confirming encourages high-quality reports.",
        "confidence": 0.85,
        "dependsOn": "labels-1",
        "payload": {
          "commentType": "answer",
          "draftBody": "Thanks for the thorough analysis — you're right that the `fixed` block scope is too narrow here. Once the block exits, the managed array is unpinned and the GC is free to relocate it, leaving the `Blob` with a dangling pointer.\n\nYour proposed fix using `Marshal.AllocCoTaskMem` with `UnmanagedMemoryStream` looks correct and also has the nice side effect of eliminating the redundant `ToArray()` copy.\n\nWe should also check whether similar patterns exist elsewhere in the codebase before applying the fix.",
          "requiresHumanEdit": true,
          "finalBody": null,
          "dedupeToken": "triage-3472-comment-1"
        }
      }
    ]
  }
}
