{
  "meta": {
    "schemaVersion": "3.0",
    "number": 576,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2025-07-24T12:00:00Z"
  },
  "summary": "User reports GPU memory leaks with SKSurface.Snapshot() on Intel HD Graphics — resolved as user error (not disposing SKImage before overwriting reference)",
  "classification": {
    "type": {
      "value": "type/question",
      "confidence": 0.85
    },
    "area": {
      "value": "area/SkiaSharp",
      "confidence": 0.95
    },
    "backends": [
      "backend/OpenGL"
    ]
  },
  "evidence": {
    "reproEvidence": {
      "stepsToReproduce": [
        "Create a GPU-backed SKSurface using GRContext with OpenGL (Intel HD Graphics 520)",
        "Call surface.Snapshot() in a loop and store result in an array/dictionary",
        "Overwrite previous SKImage reference without calling Dispose() first",
        "Observe 30-40MB memory step-ups per iteration until crash"
      ],
      "environmentDetails": "Intel HD Graphics 520, Visual Studio, Windows (implied from VS usage)",
      "screenshots": [
        {
          "url": "https://user-images.githubusercontent.com/41022806/42469527-fdefdc92-8385-11e8-96d5-cfa8b693ae34.png"
        }
      ],
      "codeSnippets": [
        "csharp: var surface = SKSurface.Create(_skiaGlControl.GRContext, false, new SKImageInfo(Width, Height));\n_skiaMain.Compose(surface.Canvas, plane);\nsurface.Canvas.Flush();\n_skiaMain.DisplayImages[plane] = surface.Snapshot();\nsurface.Dispose();\n_skiaMain.DisplayPlaneRecompose[plane] = false;"
      ]
    }
  },
  "analysis": {
    "summary": "Reporter observed GPU memory leaks when repeatedly calling SKSurface.Snapshot() in a render loop. The root cause, confirmed by the reporter in comment 2, was overwriting the stored SKImage reference without disposing the previous one. Since SKImage is ISKReferenceCounted and GPU-backed, the finalizer alone cannot reliably reclaim GPU memory in a timely manner. This is expected behavior requiring explicit disposal, not a SkiaSharp bug.",
    "rationale": "type: Reporter initially believed this was a SkiaSharp bug, but comment 2 confirms the root cause is user error — not disposing SKImage before overwriting the reference. The maintainer's guidance resolved the issue. This is a usage/understanding question about GPU resource management, not broken behavior in SkiaSharp. area: The issue involves core SkiaSharp types SKSurface and SKImage, not view-layer components. backends: The issue is specific to GPU-backed surfaces created with a GRContext (OpenGL). The commented-out line in the code shows the user tried CPU surfaces without the leak, confirming the GPU-specific nature. versionAnalysis.currentRelevance: The underlying pattern — needing to explicitly dispose GPU-backed SKImage objects — remains true in current SkiaSharp. This is fundamental to how reference-counted GPU resources work. actionability.suggestedAction: The reporter confirmed the solution in comment 2. The maintainer provided correct diagnosis. The issue is resolved — the user needed to dispose SKImage before overwriting references. Can be closed as answered.",
    "codeInvestigation": [
      {
        "file": "binding/SkiaSharp/SKSurface.cs",
        "lines": "274-275",
        "finding": "Snapshot() creates a new SKImage via sk_surface_new_image_snapshot. Each call returns a new reference-counted object — caller is responsible for disposal.",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKImage.cs",
        "lines": "16-24",
        "finding": "SKImage implements ISKReferenceCounted and has a finalizer via SKNativeObject. However, GPU-backed images hold texture references that need timely release via explicit Dispose().",
        "relevance": "related"
      },
      {
        "file": "binding/SkiaSharp/SKObject.cs",
        "lines": "94-98",
        "finding": "DisposeNative() calls SafeUnRef() for ISKReferenceCounted objects. The finalizer (~SKNativeObject) at line 229 eventually calls this, but GC scheduling is non-deterministic — GPU resources may not be freed promptly.",
        "relevance": "related"
      }
    ],
    "nextQuestions": [
      "Whether the issue was specific to Intel HD Graphics 520 or affects all GPU backends equally (likely all, since the root cause is missing Dispose())"
    ],
    "resolution": {
      "hypothesis": "The user was creating GPU-backed SKImage objects via Snapshot() in a loop and overwriting the stored reference without disposing the previous SKImage. GPU texture memory is not reclaimed by the GC finalizer in a timely manner, requiring explicit Dispose() calls.",
      "proposals": [
        {
          "description": "Dispose the existing SKImage in DisplayImages[plane] before assigning the new Snapshot() result. This is the correct pattern for managing GPU-backed resources.",
          "confidence": 0.95,
          "effort": "small"
        },
        {
          "description": "Swap with a temporary variable and dispose old reference using a using pattern for safety.",
          "confidence": 0.9,
          "effort": "small"
        }
      ]
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "close-with-docs",
      "confidence": 0.88,
      "reason": "Reporter confirmed the root cause and solution in comment 2. Maintainer provided correct diagnosis. The issue is fully resolved as a usage question."
    },
    "actions": [
      {
        "type": "update-labels",
        "description": "Reclassify from type/bug to type/question — reporter confirmed user error",
        "risk": "low",
        "confidence": 0.85,
        "labels": [
          "type/question"
        ]
      },
      {
        "type": "add-comment",
        "description": "Post closing comment summarizing the resolution",
        "risk": "high",
        "confidence": 0.85
      },
      {
        "type": "close-issue",
        "description": "Close as resolved — reporter confirmed the fix",
        "risk": "medium",
        "confidence": 0.85
      }
    ]
  }
}
