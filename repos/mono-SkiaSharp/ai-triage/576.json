{
  "meta": {
    "schemaVersion": "2.0",
    "number": 576,
    "repo": "mono/SkiaSharp",
    "analyzedAt": "2026-02-11T13:49:00Z",
    "currentLabels": ["type/bug", "area/SkiaSharp", "backend/OpenGL"]
  },
  "summary": "GPU SKSurface memory leak on Intel HD Graphics — resolved as user code not disposing SKImage before overwriting reference",
  "classification": {
    "type": { "value": "type/question", "confidence": 0.75 },
    "area": { "value": "area/SkiaSharp", "confidence": 0.90 },
    "backends": [{ "value": "backend/OpenGL", "confidence": 0.90 }],
    "platforms": [{ "value": "os/Windows-Classic", "confidence": 0.70 }],
    "tenets": null,
    "partner": null
  },
  "evidence": {
    "bugSignals": null,
    "reproEvidence": null,
    "versionAnalysis": null,
    "regression": null,
    "fixStatus": null
  },
  "analysis": {
    "summary": "User reported 30-40MB memory leak steps when creating GPU-accelerated SKSurface with Intel HD Graphics 520. mattleibow identified the Snapshot() line storing large images. OP confirmed the root cause was not disposing SKImage before overwriting the reference in DisplayImages[plane]. This is a user code disposal pattern issue, not a SkiaSharp bug.",
    "keySignals": [
      { "text": "Memory leak of 30-40MB steps with GPU-accelerated SKSurface on Intel HD Graphics 520", "source": "body", "interpretation": "Symptom suggests GPU resource retention, but could be user-side disposal issue" },
      { "text": "mattleibow pointed to the Snapshot() line as storing large images", "source": "comment 1", "interpretation": "Maintainer identified likely root cause in user code — SKImage from Snapshot() not being disposed" },
      { "text": "OP confirmed: not disposing SKImage before overwriting DisplayImages[plane]", "source": "comment 2", "interpretation": "User confirmed root cause — GPU-backed SKImage references were leaked, preventing native memory cleanup" },
      { "text": "GC.Collect did not reclaim GPU resources", "source": "body", "interpretation": "GPU-backed objects require explicit disposal; GC cannot release native GPU memory deterministically" }
    ],
    "fieldRationales": [
      { "field": "type", "chosen": "type/question", "expandedReason": "The reported memory leak was caused by user code not disposing SKImage before overwriting the reference. OP confirmed this after mattleibow's guidance. This is a usage/disposal pattern question, not a SkiaSharp bug. Reclassifying from type/bug.", "alternatives": [{ "value": "type/bug", "whyRejected": "Root cause was user code not calling Dispose() on SKImage before overwriting reference. SkiaSharp behaved correctly — GPU resources need explicit disposal." }] },
      { "field": "area", "chosen": "area/SkiaSharp", "expandedReason": "The issue involves SKSurface, SKImage, and Snapshot() which are core SkiaSharp APIs, not view-layer components." },
      { "field": "backends", "chosen": "backend/OpenGL", "expandedReason": "Issue is specific to GPU-accelerated surfaces using OpenGL (GRContext/GRGlInterface). The memory leak pattern is GPU-specific since GPU resources require explicit disposal." },
      { "field": "platforms", "chosen": "os/Windows-Classic", "expandedReason": "Intel HD Graphics 520 is a desktop GPU implying Windows desktop environment. The OpenGL context and GPU memory management are platform-specific." },
      { "field": "actionability.suggestedAction", "chosen": "close-as-fixed", "expandedReason": "OP confirmed the root cause and resolution — dispose SKImage before overwriting references. Issue is fully resolved by user. No SkiaSharp code change needed." }
    ],
    "uncertainties": ["Whether the specific Intel HD Graphics 520 driver contributed to the severity of the leak or if this pattern affects all GPU backends equally"],
    "assumptions": ["Assumed Windows desktop based on Intel HD Graphics 520 mention, though this GPU exists in some Linux systems as well"],
    "resolution": {
      "hypothesis": "User was not disposing SKImage objects returned by Snapshot() before overwriting references in DisplayImages[plane], causing GPU-backed native memory to accumulate since GC.Collect cannot deterministically release GPU resources.",
      "proposals": [
        { "title": "Dispose SKImage before overwriting reference", "description": "Call Dispose() on the existing SKImage in DisplayImages[plane] before assigning the new Snapshot() result. This releases the GPU-backed native memory immediately.", "confidence": 0.95, "effort": "low", "category": "workaround", "codeSnippet": "// Before overwriting:\nDisplayImages[plane]?.Dispose();\nDisplayImages[plane] = surface.Snapshot();", "validated": "yes" },
        { "title": "Use using statement with temporary variable", "description": "Extract Snapshot() into a using block or swap pattern to ensure disposal even if exceptions occur.", "confidence": 0.90, "effort": "low", "category": "alternative", "codeSnippet": "var oldImage = DisplayImages[plane];\nDisplayImages[plane] = surface.Snapshot();\noldImage?.Dispose();", "validated": "untested" },
        { "title": "Implement IDisposable on containing class", "description": "Make the class holding DisplayImages implement IDisposable and dispose all SKImage entries in its Dispose method to catch any remaining references on cleanup.", "confidence": 0.85, "effort": "medium", "category": "alternative" }
      ],
      "recommendedProposal": "Dispose SKImage before overwriting reference",
      "recommendedReason": "Confirmed working by OP. Simplest fix that directly addresses the root cause."
    }
  },
  "output": {
    "actionability": {
      "suggestedAction": "close-as-fixed",
      "confidence": 0.90,
      "reason": "OP confirmed the root cause was user code not disposing SKImage before overwriting reference. Issue fully resolved."
    },
    "actions": [
      {
        "id": "labels-1", "type": "update-labels", "risk": "low",
        "description": "Reclassify from bug to question, add Windows platform label",
        "reason": "Root cause was user disposal pattern, not a SkiaSharp bug. Reclassify type and add platform.",
        "confidence": 0.85, "dependsOn": null,
        "payload": {
          "labelsToAdd": ["type/question", "os/Windows-Classic"],
          "labelsToRemove": ["type/bug"]
        }
      },
      {
        "id": "comment-1", "type": "add-comment", "risk": "high",
        "description": "Note OP-confirmed root cause and GPU disposal best practice",
        "reason": "Document the resolution for future visitors. GPU resource disposal is a common pitfall.",
        "confidence": 0.85, "dependsOn": "labels-1",
        "payload": {
          "commentType": "close-message",
          "draftBody": "Closing as resolved — OP confirmed the root cause was not disposing `SKImage` before overwriting the reference in `DisplayImages[plane]`.\n\nGPU-backed resources (like `SKImage` from `SKSurface.Snapshot()`) hold native GPU memory that the garbage collector cannot deterministically release. Always call `Dispose()` on the previous image before assigning a new one:\n\n```csharp\nDisplayImages[plane]?.Dispose();\nDisplayImages[plane] = surface.Snapshot();\n```\n\nThis is especially important with GPU surfaces where each snapshot can hold 30-40MB+ of GPU memory.",
          "requiresHumanEdit": true,
          "finalBody": null,
          "dedupeToken": "triage-576-comment-1"
        }
      },
      {
        "id": "close-1", "type": "close-issue", "risk": "medium",
        "description": "Close as completed — resolved by user",
        "reason": "OP confirmed root cause and fix. No SkiaSharp code change required.",
        "confidence": 0.90, "dependsOn": "comment-1",
        "payload": { "reason": "completed", "comment": null }
      }
    ]
  }
}
