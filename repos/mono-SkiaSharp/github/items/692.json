{
  "number": 692,
  "type": "issue",
  "state": "closed",
  "title": "Add SkiaTextBox to simplify text rendering and layouting",
  "body": "### Description\r\n\r\nThe SkiaTextBox is a C# version of [SKTextBox](https://github.com/servo/skia/blob/master/src/views/SkTextBox.cpp) that provies a simple API to help layouting text with SkiaSharp.\r\nWould you consider it for inclusing in SkiaSharp?\r\n\r\n### Code\r\n\r\n\u0060\u0060\u0060\r\n/// \u003Csummary\u003E\r\n\t/// A text box that handles multi-line text wrapping and layout.\r\n\t/// \u003C/summary\u003E\r\n\tpublic static class SkiaTextBox\r\n\t{\r\n\t\t/// \u003Csummary\u003E\r\n\t\t/// Draw the specified text in the region defined by x, y, width, height wrapping and breaking lines\r\n\t\t/// to fit in that region\r\n\t\t/// \u003C/summary\u003E\r\n\t\t/// \u003Creturns\u003EThe draw.\u003C/returns\u003E\r\n\t\t/// \u003Cparam name=\u0022text\u0022\u003EText.\u003C/param\u003E\r\n\t\t/// \u003Cparam name=\u0022x\u0022\u003EThe x coordinate.\u003C/param\u003E\r\n\t\t/// \u003Cparam name=\u0022y\u0022\u003EThe y coordinate.\u003C/param\u003E\r\n\t\t/// \u003Cparam name=\u0022width\u0022\u003EWidth.\u003C/param\u003E\r\n\t\t/// \u003Cparam name=\u0022height\u0022\u003EHeight.\u003C/param\u003E\r\n\t\t/// \u003Cparam name=\u0022canvas\u0022\u003ECanvas.\u003C/param\u003E\r\n\t\t/// \u003Cparam name=\u0022paint\u0022\u003EPaint.\u003C/param\u003E\r\n\t\tpublic static void Draw (string text, double x, double y, double width, double height, SKCanvas canvas, SKPaint paint, bool ellipsize)\r\n\t\t{\r\n\t\t\tif (text == null) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tdouble textY = 0, textX = 0;\r\n\r\n\t\t\tswitch (paint.TextAlign) {\r\n\t\t\tcase SKTextAlign.Center:\r\n\t\t\t\ttextX = x \u002B width / 2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SKTextAlign.Left:\r\n\t\t\t\ttextX = x;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SKTextAlign.Right:\r\n\t\t\t\ttextX = x \u002B width;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tvar lines = BreakLines (text, paint, width);\r\n\r\n\t\t\tvar metrics = paint.FontMetrics;\r\n\t\t\tvar lineHeight = metrics.Bottom - metrics.Top;\r\n\r\n\t\t\tfloat textHeight = lines.Count * lineHeight - metrics.Leading;\r\n\r\n\t\t\tif (textHeight \u003E height) {\r\n\t\t\t\ttextY = y - metrics.Top;\r\n\t\t\t} else {\r\n\t\t\t\ttextY = y - metrics.Top \u002B (height - textHeight) / 2;\r\n\t\t\t}\r\n\t\t\tif (ellipsize \u0026\u0026 lines.Count \u003E height / lineHeight) {\r\n\t\t\t\tvar ellipsizedLine = $\u0022{lines.FirstOrDefault ()}...\u0022;\r\n\t\t\t\tcanvas.DrawText (ellipsizedLine, (float)textX, (float)textY, paint);\r\n\t\t\t} else {\r\n\t\t\t\tfor (int i = 0; i \u003C lines.Count; i\u002B\u002B) {\r\n\t\t\t\t\tcanvas.DrawText (lines [i], (float)textX, (float)textY, paint);\r\n\t\t\t\t\ttextY \u002B= lineHeight;\r\n\t\t\t\t\tif (textY \u002B metrics.Descent \u003E y \u002B height) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstatic List\u003Cstring\u003E BreakLines (string text, SKPaint paint, double width)\r\n\t\t{\r\n\t\t\tList\u003Cstring\u003E lines = new List\u003Cstring\u003E ();\r\n\r\n\t\t\tstring remainingText = text.Trim ();\r\n\r\n\t\t\tdo {\r\n\t\t\t\tint idx = LineBreak (remainingText, paint, width);\r\n\t\t\t\tif (idx == 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tvar lastLine = remainingText.Substring (0, idx).Trim ();\r\n\t\t\t\tlines.Add (lastLine);\r\n\t\t\t\tremainingText = remainingText.Substring (idx).Trim ();\r\n\t\t\t} while (!string.IsNullOrEmpty (remainingText));\r\n\t\t\treturn lines;\r\n\t\t}\r\n\r\n\t\tstatic int LineBreak (string text, SKPaint paint, double width)\r\n\t\t{\r\n\t\t\tint idx = 0, last = 0;\r\n\t\t\tint lengthBreak = (int)paint.BreakText (text, (float)width);\r\n\r\n\t\t\twhile (idx \u003C text.Length) {\r\n\t\t\t\tint next = text.IndexOfAny (new char [] { \u0027 \u0027, \u0027\\n\u0027 }, idx);\r\n\t\t\t\tif (next == -1) {\r\n\t\t\t\t\tif (idx == 0) {\r\n\t\t\t\t\t\t// Word is too long, we will have to break it\r\n\t\t\t\t\t\treturn lengthBreak;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Ellipsize if it\u0027s the last line\r\n\t\t\t\t\t\tif (lengthBreak == text.Length\r\n\t\t\t\t\t\t// || text.IndexOfAny (new char [] { \u0027 \u0027, \u0027\\n\u0027 }, lengthBreak \u002B 1) == -1\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\treturn lengthBreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Split at the last word;\r\n\t\t\t\t\t\treturn last;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (text [idx] == \u0027\\n\u0027) {\r\n\t\t\t\t\treturn idx;\r\n\t\t\t\t}\r\n\t\t\t\tif (next \u003E lengthBreak) {\r\n\t\t\t\t\treturn idx;\r\n\t\t\t\t}\r\n\t\t\t\tlast = next;\r\n\t\t\t\tidx = next \u002B 1;\r\n\t\t\t}\r\n\t\t\treturn last;\r\n\t\t}\r\n\t}\r\n\u0060\u0060\u0060\r\n",
  "author": {
    "login": "ylatuya",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2018-11-19T20:59:36",
  "updatedAt": "2022-08-19T12:02:36",
  "closedAt": "2018-12-04T17:05:11",
  "commentCount": 5,
  "reactionCount": 0
}