{
  "number": 1982,
  "type": "issue",
  "state": "open",
  "title": "[BUG] SKObject does not dispose or release memory on linux",
  "body": "**Description**\r\n\r\nWhen I was using SkiaSharp on Linux, I noticed that the memory footprint didn\u0027t go down, it just kept going up with each call. When I tried to reproduce the bug on Windows, the memory usage didn\u0027t go up. \r\n\r\n**Code**\r\nI used following code to test on Windows11 x64, Debian 10 x64, and Debian 11 arm64.\r\n\u0060\u0060\u0060\r\nstatic int Main()\r\n    {\r\n        while (true)\r\n        {\r\n            var key = Console.ReadKey();\r\n            switch (key.Key)\r\n            {\r\n                case ConsoleKey.T:\r\n                    Test();\r\n                    break;\r\n\r\n                case ConsoleKey.D:\r\n                    TestWithDispose();\r\n                    break;\r\n\r\n                case ConsoleKey.G:\r\n                    GC.Collect();\r\n                    break;\r\n\r\n                case ConsoleKey.Q:\r\n                    return 0;\r\n\r\n                default:\r\n                    break;\r\n            }\r\n            Console.WriteLine($\u0022{Environment.WorkingSet / 1024 / 1024} MB\u0022);\r\n        }\r\n    }\r\n\r\n    static void Test()\r\n    {\r\n        SKBitmap bitmap = SKBitmap.Decode(\u0022sample.gif\u0022);\r\n        SKCanvas sKCanvas = new SKCanvas(bitmap);\r\n        return;\r\n    }\r\n\r\n    static void TestWithDispose()\r\n    {\r\n        SKBitmap bitmap = SKBitmap.Decode(\u0022sample.gif\u0022);\r\n        SKCanvas sKCanvas = new SKCanvas(bitmap);\r\n        bitmap.Dispose();\r\n        sKCanvas.Dispose();\r\n        return;\r\n    }\r\n\u0060\u0060\u0060\r\n\r\n**Expected Behavior**\r\n\r\nAfter every \u0060Test()\u0060 and \u0060GC.collect()\u0060, the memory footprint should be kept low.\r\n\r\n**Actual Behavior**\r\n\r\nOn Windows it works as it should be.\r\nBut on Linux, the memory footprint is always kept at a high level, even when \u0060GC.collect()\u0060 is called.\r\nJust like those objects are always cached and can\u0027t be released.\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  2.80.3\r\n\r\n- IDE:  Visual Studio 2022\r\n\r\n- Platform Target Frameworks:\r\n  - Linux:  Debian 10 x64, Debian 11 arm64\r\n  - Windows Classic:  Windows 11 x64\r\n\r\n**Screenshots**\r\nhere is my test on Windows \r\n![\u56FE\u7247](https://user-images.githubusercontent.com/33571798/160692669-d900ac20-4ceb-4a12-b7a4-d8483a254ce3.png)\r\n\r\nand here is my test on Debian 11 (Raspberry Pi 4B)\r\n![\u56FE\u7247](https://user-images.githubusercontent.com/33571798/160692612-fc52b8b2-240e-4925-bb9f-9b7b819b7af0.png)\r\n\r\n",
  "author": {
    "login": "ghost",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2022-03-29T19:33:30",
  "updatedAt": "2024-06-07T08:38:13",
  "commentCount": 8,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T12:53:34.5712825Z",
    "reactions": [],
    "comments": [
      {
        "id": 1121204990,
        "author": "ghost",
        "body": "Additionally, I did tests with SkiaSharp.NativeAssets.Linux 2.88.0-preview.179 and SkiaSharp 2.88.0-preview.179, which still resulted in consistently increasing memory usage.\r\n\r\nI think the problem is related to libSkiaSharp.so, because the problems that have occurred so far have been on the Linux platform.\r\n\r\nI don\u0027t have a device to test on macOS , if so, I\u0027ll update this issue.",
        "createdAt": "2022-05-09T14:50:22",
        "reactions": []
      },
      {
        "id": 1141831619,
        "author": "pardont",
        "body": "Is there any update?  Same problem with SkiaSharp 2.80.2  on Ubuntu 20.04.\r\n",
        "createdAt": "2022-05-31T08:27:07",
        "reactions": []
      },
      {
        "id": 1142169658,
        "author": "mattleibow",
        "body": "Are you testing with mono or .net core on linux? I wonder if there is just the fact that mono does not feel the need to clear things or does not reduce the indicated memory? Are you using .net framework or dotnet core on windows?",
        "createdAt": "2022-05-31T13:55:34",
        "reactions": []
      },
      {
        "id": 1142809169,
        "author": "ghost",
        "body": "\u003E Are you testing with mono or .net core on linux? I wonder if there is just the fact that mono does not feel the need to clear things or does not reduce the indicated memory? Are you using .net framework or dotnet core on windows?\r\n\r\nI\u0027m using dotnet 6.0 both on Windows and Linux.",
        "createdAt": "2022-06-01T00:07:20",
        "reactions": []
      },
      {
        "id": 1142853486,
        "author": "ghost",
        "body": "This bug confused me for weeks, until I found this, which mentioned that this is a problem with memory allocator.\r\n[https://github.com/dotnet/runtime/issues/13301#issuecomment-535641506](https://github.com/dotnet/runtime/issues/13301#issuecomment-535641506)\r\n\r\nAfter setting \u0060MALLOC_TRIM_THRESHOLD_\u0060 , I could control my memory usage in a acceptable range.\r\nBut unlike on Windows.and MacOS(i tested it on macos, same as windows) , the memory usage doesn\u0027t go down to a low level after calling ,\u0060GC.collect()\u0060, it seemed being limited at a certain level.In my case it goes up to as test going, then stuck at 300MB.\r\n\r\nFor somehow it did fixed my problem, but i wonder if there\u0027s a better solution.",
        "createdAt": "2022-06-01T00:25:38",
        "reactions": []
      },
      {
        "id": 1322328515,
        "author": "sharpSteff",
        "body": "I have the same issue with a quite similar setup =\u003E .NET 6 and Ubuntu 20.04.\r\n\r\nI just load a file from disk, copy it and dispose both instances.\r\nDotMemory shows following:\r\n\u003Cimg width=\u00221536\u0022 alt=\u0022memory\u0022 src=\u0022https://user-images.githubusercontent.com/30927510/203106119-9749cfbf-f4ec-42d2-85da-479087e85b33.PNG\u0022\u003E\r\n\r\nIt seems SKShader hangs arround and will be finalized by the GC. Is this the intended behavior? I expect SkiaSharp to free any resources immediatelly when calling Dispose().\r\n![image](https://user-images.githubusercontent.com/30927510/203107065-d7d197f5-d911-46d4-955e-9892b03b19f0.png)\r\n\r\n\u0060\u0060\u0060\r\nusing SkiaSharp; \r\nfor (int i = 0; i \u003C 10000; i\u002B\u002B)\r\n{\r\n    Console.WriteLine($\u0022Run: {i}\u0022);\r\n    Console.WriteLine(\u0022Load skiasharp from file!\u0022);\r\n    using var filestream = File.Open(\u0022navi.PNG\u0022, FileMode.Open);\r\n    var bitmap = SKBitmap.Decode(filestream);\r\n    var copy = bitmap.Copy();\r\n    bitmap.Dispose();\r\n    copy.Dispose();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nEdit:\r\nif I use my own copy implementation, which disposes the SKShader, the memory spikes are gone and everything is freed up:\r\n\r\n\u0060\u0060\u0060\r\nSKBitmap CopyFixed(SKBitmap bitmap, SKColorType colorType)\r\n{\r\n    using var srcPixmap = bitmap.PeekPixels ();\r\n\r\n    var temp = new SKBitmap ();\r\n\r\n    var dstInfo = srcPixmap.Info.WithColorType (colorType);\r\n    if (!temp.TryAllocPixels (dstInfo))\r\n        return null;\r\n\r\n    using var canvas = new SKCanvas (temp);\r\n\r\n    using var shader =  bitmap.ToShader();\r\n    using var paint = new SKPaint {\r\n        Shader = shader,\r\n        BlendMode = SKBlendMode.Src\r\n    };\r\n\r\n    canvas.DrawPaint (paint);\r\n    return temp;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI don\u0027t know if there are any edge-cases, in which this change might break something, but for me this is good enough.",
        "createdAt": "2022-11-21T16:26:08",
        "reactions": []
      },
      {
        "id": 1444175341,
        "author": "gktval",
        "body": "This seems related: I kept having problems with the bitmap being in use when calling bitmap.Copy(). This occurred in both Windows and Android. Calling GC.Collect() fixed the \u0027in use exception\u0027. It would only happened randomly though. about 1/4 of the time. Here is my relevant code:\r\n\r\n\u0060\u0060\u0060\r\nvar info = new SKImageInfo(width \u002B 1, height \u002B 1, SKImageInfo.PlatformColorType, SKAlphaType.Unpremul);\r\nvar outbmp = new SKBitmap(info);\r\nvar BMArray = new byte[(info.RowBytes * info.Height)];\r\n...load data into the array...\r\n// pin the managed array so that the GC doesn\u0027t move it\r\nvar handle = GCHandle.Alloc(BMArray, GCHandleType.Pinned);\r\n\r\n// install the pixels with the color type of the pixel data\r\noutbmp.InstallPixels(info, handle.AddrOfPinnedObject(), info.RowBytes);\r\nhandle.Free();\r\n... Sometime later call \r\nvar copyBitmap = outbmp.Copy();\r\n\u0060\u0060\u0060\r\n\r\nCalling GC.Collect(); after freeing the handle has fixed my issue. So, it seems that after freeing the handle, something was still being held onto the bitmap.\r\n",
        "createdAt": "2023-02-24T18:12:08",
        "reactions": []
      },
      {
        "id": 1701456479,
        "author": "ggolda",
        "body": "Have the same issue, on Ubuntu 22.04. Looks like calling Dispose is not freeing any resources and memory keeps growing until process is killed in the end.",
        "createdAt": "2023-08-31T17:25:46",
        "reactions": []
      }
    ]
  }
}