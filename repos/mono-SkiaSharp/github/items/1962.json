{
  "number": 1962,
  "type": "issue",
  "state": "open",
  "title": "[BUG] Image decoding failing caused by incomplete stream reading in SKManagedStream",
  "body": "**Description**\r\n\r\nThe PR #1510  (commit \u002261b71d6e4893\u0022) introduced a change in the behaviour of \u0060SKManagedStream.OnReadManagedStream(IntPtr buffer, IntPtr size)\u0060.\r\n\r\n**Previous Behavior**\r\n\r\nThe returned data had the length of \u0022size\u0022 or less if the stream is at the end.\r\n\r\n**Current Behavior**\r\n\r\nThe returned data has the length of \u0022size\u0022 or less (**even if the stream is not at the end**).\r\n\r\n**Basic Information**\r\n\r\n- Version with issue: 2.80.3\r\n- Last known good version: 2.80.2\r\n\r\n**Analysis**\r\n\r\nThe previous code used \u0060BinaryReader.ReadBytes((int)size) \u0060 to read the data.\r\n[Documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader.readbytes?view=netframework-4.6.2)\r\n\u003E \u0022A byte array containing data read from the underlying stream. This might be less than the number of bytes requested **if the end of the stream is reached**.\u0022\r\n\r\nThe current code uses \u0060stream.Read(managedBuffer.Array, 0, managedBuffer.Length)\u0060 to read the data.\r\n[Documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.stream.read?view=netframework-4.6.2)\r\n\r\n\u003E \u0022An implementation is free to return fewer bytes than requested **even if the end of the stream has not been reached**.\u0022\r\n\r\n**Result**\r\n\r\nCode relying on SKMangedStream to return the full requested length might fail, depending on the underlying stream.\r\n\r\n**Reproduction example**\r\nFull example: [SkiaSharpBlockStreamDemo.zip](https://github.com/mono/SkiaSharp/files/8148503/SkiaSharpBlockStreamDemo.zip)\r\n\r\nExample code:\r\n\r\n\u0060\u0060\u0060cs\r\nusing SkiaSharp;\r\nusing System;\r\nusing System.IO;\r\n\r\nnamespace SkiaSharpBlockStreamDemo\r\n{\r\n    internal class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // Load demo image to BlockMemoryStream\r\n            BlockMemoryStream blockMemoryStream = new BlockMemoryStream();\r\n            using (FileStream fs = new FileStream(\u0022SkiaSharpBlockStreamDemo.png\u0022, FileMode.Open))\r\n            {\r\n                fs.CopyTo(blockMemoryStream);\r\n            }\r\n            blockMemoryStream.Position = 0;\r\n\r\n            // Use BlockMemoryStream as underlying stream for SKCodec\r\n            using (SKCodec codec = SKCodec.Create(blockMemoryStream))\r\n            {\r\n                // SkiaSharp 2.80.2 -\u003E Output: {Width=100, Height=100}\r\n                // SkiaSharp 2.80.3 -\u003E codec is null -\u003E NullReferenceException\r\n                Console.WriteLine(codec.Info.Size);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// MemoryStream with maximum read size to simulate a stream that does not always return the requested byte count\r\n    /// \u003C/summary\u003E\r\n    internal class BlockMemoryStream : MemoryStream\r\n    {\r\n        const int BLOCK_SIZE = 10;\r\n\r\n        public override int Read(byte[] buffer, int offset, int count)\r\n        {\r\n            // Limit maximum read size to \u0022BLOCK_SIZE\u0022\r\n            return base.Read(buffer, offset, Math.Min(count, BLOCK_SIZE));\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nExample image (arbitrary): \r\n![SkiaSharpBlockStreamDemo-Image](https://user-images.githubusercontent.com/10390078/155879920-19078048-eee4-4628-85c0-c9064fd78ccd.png)",
  "author": {
    "login": "ChrisKris",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2022-02-21T15:44:34",
  "updatedAt": "2022-11-26T18:19:07",
  "commentCount": 2,
  "reactionCount": 2
}