{
  "number": 2514,
  "type": "issue",
  "state": "open",
  "title": "[BUG] Some images are only read partially from non-seekable streams",
  "body": "**Description**\r\n\r\nSome images, especially small ones (up to 20-30 Kb), are not read correctly if the source stream is non-seekable (CanSeek == false).\r\nI\u0027ve encountered problems with WEBP and PNG source formats, it looks like the problem is in stream reading logic, not decoding.\r\n\r\nThis file is processed incorrectly on Windows 11. There were problems with other small PNG files on Linux too, but I couldn\u0027t reproduce the bug with them on Windows.\r\n[test_image.zip](https://github.com/mono/SkiaSharp/files/11903424/test_image.zip)\r\n\r\nIf I try to resize a bitmap loaded directly from FileStream (seekable), it is converted correctly.\r\nConversion result looks like this:\r\n![target_seekable](https://github.com/mono/SkiaSharp/assets/28513129/bc521b7b-c217-475a-80b7-55b3647329eb)\r\n\r\nBut if I read the file from non-seekable stream, for example, the one that was returned by Amazon S3 client library, or by implementing stream wrapper that sets CanSeek to false for any underlying stream, conversion result is incorrect. It looks like the source data has only been read partially, for example, only first block has been read:\r\n![target_non_seekable](https://github.com/mono/SkiaSharp/assets/28513129/0de788e2-5fd3-48cb-b70f-ca05079a9590)\r\n\r\n**Code**\r\nRead from FileStream:\r\n\u0060\u0060\u0060csharp\r\nusing var fileStream = new FileStream(\u0022test_image.webp\u0022, FileMode.Open, FileAccess.Read);\r\n\r\nusing var codec = SKCodec.Create(fileStream, out var codecResult);\r\nif (codec == null)\r\n\tthrow new Exception(\u0022codec == null, \u0022 \u002B codecResult);\r\n\r\nusing var sourceBitmap = SKBitmap.Decode(codec);\r\nif (sourceBitmap == null)\r\n\tthrow new Exception(\u0022sourceBitmap == null\u0022);\r\n\r\nusing var targetBitmap = new SKBitmap(new SKImageInfo(200, 150));\r\nvar shrinkSucceeded = sourceBitmap.ScalePixels(targetBitmap, SKFilterQuality.High);\r\nif (!shrinkSucceeded)\r\n\tthrow new Exception(\u0022!shrinkSucceeded\u0022);\r\n\r\nusing var targetStream = new FileStream(\u0022target.jpg\u0022, FileMode.Create, FileAccess.Write);\r\n\r\nvar encodeSucceeded = targetBitmap.Encode(targetStream, SKEncodedImageFormat.Jpeg, 90);\r\nif (!encodeSucceeded)\r\n\tthrow new Exception(\u0022!encodeSucceeded\u0022);\r\n\r\ntargetStream.Flush();\r\ntargetStream.Close();\r\n\u0060\u0060\u0060\r\n\r\nRead from non-seekable stream wrapper:\r\n\u0060\u0060\u0060csharp\r\nusing var fileStream = new FileStream(\u0022test_image.webp\u0022, FileMode.Open, FileAccess.Read);\r\n\r\nusing var codec = SKCodec.Create(new NonSeekableStreamWrapper(fileStream), out var codecResult);\r\nif (codec == null)\r\n\tthrow new Exception(\u0022codec == null, \u0022 \u002B codecResult);\r\n\r\nusing var sourceBitmap = SKBitmap.Decode(codec);\r\nif (sourceBitmap == null)\r\n\tthrow new Exception(\u0022sourceBitmap == null\u0022);\r\n\r\nusing var targetBitmap = new SKBitmap(new SKImageInfo(200, 150));\r\nvar shrinkSucceeded = sourceBitmap.ScalePixels(targetBitmap, SKFilterQuality.High);\r\nif (!shrinkSucceeded)\r\n\tthrow new Exception(\u0022!shrinkSucceeded\u0022);\r\n\r\nusing var targetStream = new FileStream(\u0022target.jpg\u0022, FileMode.Create, FileAccess.Write);\r\n\r\nvar encodeSucceeded = targetBitmap.Encode(targetStream, SKEncodedImageFormat.Jpeg, 90);\r\nif (!encodeSucceeded)\r\n\tthrow new Exception(\u0022!encodeSucceeded\u0022);\r\n\r\ntargetStream.Flush();\r\ntargetStream.Close();\r\n\u0060\u0060\u0060\r\n\r\n\u0060NonSeekableStreamWrapper\u0060 code:\r\n\u0060\u0060\u0060csharp\r\nprivate sealed class NonSeekableStreamWrapper : Stream\r\n{\r\n\tpublic override bool CanRead\r\n\t\t=\u003E _underlyingStream.CanRead;\r\n\r\n\tpublic override bool CanSeek\r\n\t\t=\u003E false;\r\n\r\n\tpublic override bool CanWrite\r\n\t\t=\u003E _underlyingStream.CanWrite;\r\n\r\n\tpublic override long Length\r\n\t\t=\u003E _underlyingStream.Length;\r\n\r\n\tpublic override long Position\r\n\t{\r\n\t\tget =\u003E _underlyingStream.Position;\r\n\t\tset =\u003E _underlyingStream.Position = value;\r\n\t}\r\n\r\n\tprivate readonly Stream _underlyingStream;\r\n\r\n\tpublic NonSeekableStreamWrapper(Stream underlyingStream)\r\n\t\t=\u003E _underlyingStream = underlyingStream ?? throw new ArgumentNullException(nameof(underlyingStream));\r\n\r\n\tpublic override void Flush()\r\n\t\t=\u003E _underlyingStream.Flush();\r\n\r\n\tpublic override int Read(byte[] buffer, int offset, int count)\r\n\t\t=\u003E _underlyingStream.Read(buffer, offset, count);\r\n\r\n\tpublic override long Seek(long offset, SeekOrigin origin)\r\n\t\t=\u003E _underlyingStream.Seek(offset, origin);\r\n\r\n\tpublic override void SetLength(long value)\r\n\t\t=\u003E _underlyingStream.SetLength(value);\r\n\r\n\tpublic override void Write(byte[] buffer, int offset, int count)\r\n\t\t=\u003E _underlyingStream.Write(buffer, offset, count);\r\n\r\n\tpublic override Task FlushAsync(CancellationToken cancellationToken)\r\n\t\t=\u003E _underlyingStream.FlushAsync(cancellationToken);\r\n\r\n\tpublic override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)\r\n\t\t=\u003E _underlyingStream.CopyToAsync(destination, bufferSize, cancellationToken);\r\n\r\n\tpublic override Task\u003Cint\u003E ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)\r\n\t\t=\u003E _underlyingStream.ReadAsync(buffer, offset, count, cancellationToken);\r\n\r\n\tpublic override ValueTask\u003Cint\u003E ReadAsync(Memory\u003Cbyte\u003E buffer, CancellationToken cancellationToken = default)\r\n\t\t=\u003E _underlyingStream.ReadAsync(buffer, cancellationToken);\r\n\r\n\tpublic override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)\r\n\t\t=\u003E _underlyingStream.WriteAsync(buffer, offset, count, cancellationToken);\r\n\r\n\tpublic override ValueTask WriteAsync(ReadOnlyMemory\u003Cbyte\u003E buffer, CancellationToken cancellationToken = default)\r\n\t\t=\u003E _underlyingStream.WriteAsync(buffer, cancellationToken);\r\n\r\n\tpublic override ValueTask DisposeAsync()\r\n\t\t=\u003E _underlyingStream.DisposeAsync();\r\n\r\n\tprotected override void Dispose(bool disposing)\r\n\t{\r\n\t\tif (disposing)\r\n\t\t\t_underlyingStream.Dispose();\r\n\t}\r\n}\r\n\u0060\u0060\u0060\r\n\r\n**Expected Behavior**\r\n\r\nSKBitmap is read correctly from both the seekable (FileStream) and non-seekable streams.\r\n\r\n**Actual Behavior**\r\n\r\nSKBitmap is read correctly from seekable stream, but only read partially when source is non-seekable stream, which results in empty background instead of image data.\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  2.88.3\r\n- Last known good version:  unknown\r\n- IDE:  Microsoft Visual Studio Professional 2022 (64-bit) - Version 17.6.4\r\n- Platform Target Frameworks:\r\n  - Linux:  Docker image mcr.microsoft.com/dotnet/aspnet:7.0-alpine (.NET 7)\r\n  - Windows Classic:  Windows 11 (.NET 7)\r\n",
  "author": {
    "login": "msvprogs",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2023-06-29T08:24:05",
  "updatedAt": "2023-09-22T15:40:45",
  "commentCount": 1,
  "reactionCount": 1
}