{
  "number": 2779,
  "type": "issue",
  "state": "open",
  "title": "Remove the native interop in SKMatrix",
  "body": "### Description\r\n\r\nCurrently the \u0060SKMatrix\u0060 type is a semi-C# semi-interop type where the main 9 values are in C#, but to do anything meaningful it has to go ask C\u002B\u002B - and this is expensive..\r\n\r\nFor example, this benchmark:\r\n\r\n\u0060\u0060\u0060cs\r\nSKMatrix TheSKMatrix = SKMatrix.CreateRotation(0.7f, 10, 20);\r\nMatrix4x4 TheMatrix4x4 = Matrix4x4.CreateFromAxisAngle(new Vector3(10, 20, 30), 0.7f);\r\nSKMatrix44 TheSKMatrix44 = SKMatrix44.CreateRotation(10, 20, 30, 0.7f);\r\n\r\n[Benchmark(Baseline = true)]\r\npublic SKMatrix InvertUsingSKMatrix()\r\n{\r\n\tvar inverted = TheSKMatrix.Invert();\r\n\treturn inverted;\r\n}\r\n\r\n[Benchmark]\r\npublic Matrix4x4 InvertUsingMatrix4x4()\r\n{\r\n\tMatrix4x4.Invert(TheMatrix4x4, out var inverted);\r\n\treturn inverted;\r\n}\r\n\r\n[Benchmark]\r\npublic SKMatrix44 InvertUsingSKMatrix44()\r\n{\r\n\tvar inverted = TheSKMatrix44.Invert();\r\n\treturn inverted;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe can see the massive difference just calculating the invert:\r\n\r\n\u0060\u0060\u0060\r\n// * Summary *\r\n\r\n|                Method |     Mean |    Error |   StdDev | Ratio | Allocated | Alloc Ratio |\r\n|---------------------- |---------:|---------:|---------:|------:|----------:|------------:|\r\n|   InvertUsingSKMatrix | 45.30 ns | 0.902 ns | 1.482 ns |  1.00 |         - |          NA |\r\n|  InvertUsingMatrix4x4 | 19.20 ns | 0.409 ns | 0.573 ns |  0.42 |         - |          NA |\r\n| InvertUsingSKMatrix44 | 22.52 ns | 0.334 ns | 0.279 ns |  0.49 |         - |          NA |\r\n\r\n// * Hints *\r\nOutliers\r\n  TheBenchmark.InvertUsingSKMatrix: .NET 7.0   -\u003E 2 outliers were removed (50.70 ns, 52.08 ns)\r\n  TheBenchmark.InvertUsingSKMatrix44: .NET 7.0 -\u003E 2 outliers were removed (26.43 ns, 27.48 ns)\r\n\u0060\u0060\u0060\r\n\r\nBasically half the time - and \u0060SKMatrix44\u0060 is converting from \u0060SKMatrix44\u0060 to \u0060Matrix4x4\u0060, then running the invert, and then converting back to \u0060SKMatrix44\u0060. It is slower than raw \u0060Matrix4x4\u0060, but still 49% of the time.\r\n\r\nCompared to a simple C# operation benchmark:\r\n\r\n\u0060\u0060\u0060cs\r\n[Benchmark(Baseline = true)]\r\npublic SKMatrix CreateUsingSKMatrix()\r\n{\r\n\treturn SKMatrix.CreateRotation(0.7f, 10, 20);\r\n}\r\n\r\n[Benchmark]\r\npublic Matrix4x4 CreateUsingMatrix4x4()\r\n{\r\n\treturn Matrix4x4.CreateFromAxisAngle(new Vector3(10, 20, 30), 0.7f);\r\n}\r\n\r\n[Benchmark]\r\npublic SKMatrix44 CreateUsingSKMatrix44()\r\n{\r\n\treturn SKMatrix44.CreateRotation(10, 20, 30, 0.7f);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis has very similar results:\r\n\r\n\u0060\u0060\u0060\r\n// * Summary *\r\n\r\n|                Method |     Mean |    Error |   StdDev | Ratio | RatioSD | Allocated | Alloc Ratio |\r\n|---------------------- |---------:|---------:|---------:|------:|--------:|----------:|------------:|\r\n|   CreateUsingSKMatrix | 15.17 ns | 0.318 ns | 0.282 ns |  1.00 |    0.00 |         - |          NA |\r\n|  CreateUsingMatrix4x4 | 17.99 ns | 0.385 ns | 0.361 ns |  1.19 |    0.03 |         - |          NA |\r\n| CreateUsingSKMatrix44 | 18.40 ns | 0.389 ns | 0.463 ns |  1.22 |    0.04 |         - |          NA |\r\n\r\n// * Hints *\r\nOutliers\r\n  TheBenchmark.CreateUsingSKMatrix: .NET 7.0   -\u003E 1 outlier  was  removed (17.91 ns)\r\n  TheBenchmark.CreateUsingSKMatrix44: .NET 7.0 -\u003E 1 outlier  was  detected (18.98 ns)\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060\r\nBenchmarkDotNet=v0.13.5, OS=Windows 11 (10.0.22631.3155)\r\nIntel Core i9-9980HK CPU 2.40GHz, 1 CPU, 16 logical and 8 physical cores\r\n.NET SDK=8.0.200\r\n  [Host]   : .NET 7.0.16 (7.0.1624.6629), X64 RyuJIT AVX2\r\n  .NET 7.0 : .NET 7.0.16 (7.0.1624.6629), X64 RyuJIT AVX2\r\n\r\nJob=.NET 7.0  Runtime=.NET 7.0\r\n\u0060\u0060\u0060",
  "author": {
    "login": "mattleibow",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2024-03-02T19:54:59",
  "updatedAt": "2024-03-10T11:26:34",
  "commentCount": 4,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T12:56:18.9872173Z",
    "reactions": [],
    "comments": [
      {
        "id": 1975250130,
        "author": "mattleibow",
        "body": "I would like to use some new \u0060Matrix3x3\u0060 type, but that was rejected by the .NET runtime folks: https://github.com/dotnet/runtime/issues/16226\r\n\r\nIt may still be faster to convert between a 3x3 and 4x4 in the managed world as opposed to using native interop.",
        "createdAt": "2024-03-03T18:14:59",
        "reactions": []
      },
      {
        "id": 1979055827,
        "author": "mgood7123",
        "body": "if possible, 3x3 and 4x4 *might* be able to be vectorized for additional performance gains, have not looked at skia for a long time so im unsure",
        "createdAt": "2024-03-05T15:37:44",
        "reactions": []
      },
      {
        "id": 1987063667,
        "author": "Mikolaytis",
        "body": "In Lunacy, we\u0027ve improved memory footprint as well as performance by NOT using SKMatrix everywhere we can.\r\nWe\u0027ve created a 3x2 matrix struct that has 6 floats =\u003E 33% less memory.\r\nAll math are on the C# side =\u003E better performance.\r\nWhen calling SKCanvas we\u0027re trying to not use SetMatrix/SetTransform we\u0027re using Translate/Scale/Rotate functions.\r\nIf skia api needs SKMatrix - we have implicit cast to and from SKMatrix. \r\nIn complex rendering scenarios when layer count is way over 100k - we\u0027ve seen a significant 10-20% perf improvement.\r\nAlso we are using Vector2 for a long time...\r\n\r\nBenchmark\r\n\u0060\u0060\u0060\r\npublic class SKMatrixVsNumericsMatrixBench\r\n{\r\n    private readonly SKMatrix _skm1 = SKMatrix.CreateTranslation(500,-435);\r\n    private readonly SKMatrix _skm2 = SKMatrix.CreateScale(0.45354f,-1);\r\n    \r\n    private readonly Matrix _mat1 = Matrix.CreateTranslation(500,-435);\r\n    private readonly Matrix _mat2 = Matrix.CreateScale(0.45354f,-1);\r\n\r\n    private readonly SKRect _r = SKRect.Create(-300, 5445.4f, 3443, -495.545f);\r\n    \r\n    [Benchmark]\r\n    public SKRect SKMatrixBench() =\u003E _skm1.Invert().PreConcat(_skm2).Invert().MapRect(_r);\r\n    \r\n    [Benchmark]\r\n    public SKRect MatrixBench() =\u003E (_mat1.Invert() * _mat2).Invert().MapRect(_r);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nResults:\r\n|        Method |     Mean |    Error |   StdDev |\r\n|-------------- |---------:|---------:|---------:|\r\n| SKMatrixBench | 59.76 ns | 0.201 ns | 0.178 ns |\r\n|   MatrixBench | 32.64 ns | 0.058 ns | 0.051 ns |\r\n\r\n\r\nCheck it out. Feel free to use it.\r\n\u0060\u0060\u0060\r\nusing System.Numerics;\r\nusing System.Runtime.CompilerServices;\r\nusing SkiaSharp;\r\nusing static System.MathF;\r\n\r\nnamespace Lunacy.Maths;\r\n\r\npublic readonly struct Matrix : IEquatable\u003CMatrix\u003E\r\n{\r\n    private const float RotationEpsilon = 0.001f * PI / 180f;     // 0.1% of a degree\r\n\r\n    public static readonly Matrix Identity = new(\r\n        1f, 0f, 0f,\r\n        0f, 1f, 0f);\r\n\r\n    public readonly float ScaleX;\r\n    public readonly float SkewX;\r\n    public readonly float TransX;\r\n    public readonly float SkewY;\r\n    public readonly float ScaleY;\r\n    public readonly float TransY;\r\n\r\n    public Matrix(float scaleX, float skewX, float transX,\r\n                  float skewY, float scaleY, float transY)\r\n    {\r\n        ScaleX = scaleX;\r\n        SkewX = skewX;\r\n        TransX = transX;\r\n\r\n        SkewY = skewY;\r\n        ScaleY = scaleY;\r\n        TransY = transY;\r\n    }\r\n    \r\n    public bool IsIdentity\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        get =\u003E this == Identity;\r\n    }\r\n\r\n    public bool IsFlipped\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        get\r\n        {\r\n            if (ScaleX == 0 \u0026\u0026 ScaleY == 0)\r\n            {\r\n                return Sign(SkewX) == Sign(SkewY);\r\n            }\r\n\r\n            return Sign(ScaleX) != Sign(ScaleY);\r\n        }\r\n    }\r\n\r\n    public bool IsFlippedHorizontally =\u003E IsFlipped \u0026\u0026 Abs(Rotation) \u003E= Pi.Half;\r\n    public bool IsFlippedVertically =\u003E IsFlipped \u0026\u0026 Abs(Rotation) \u003C Pi.Half;\r\n\r\n    public bool IsOnlyTranslation =\u003E\r\n        (Abs(TransX) \u003E MathCore.Epsilon || Abs(TransY) \u003E MathCore.Epsilon)\r\n        \u0026\u0026 Abs(ScaleX - 1.0f) \u003C MathCore.Epsilon\r\n        \u0026\u0026 Abs(SkewY) \u003C MathCore.Epsilon\r\n        \u0026\u0026 Abs(SkewX) \u003C MathCore.Epsilon\r\n        \u0026\u0026 Abs(ScaleY - 1.0f) \u003C MathCore.Epsilon;\r\n\r\n    public bool IsOnlyScale =\u003E\r\n        (Abs(ScaleX - 1) \u003E MathCore.Epsilon || Abs(ScaleY - 1) \u003E MathCore.Epsilon)\r\n        \u0026\u0026 Abs(SkewY) \u003C MathCore.Epsilon\r\n        \u0026\u0026 Abs(TransX) \u003C MathCore.Epsilon\r\n        \u0026\u0026 Abs(SkewX) \u003C MathCore.Epsilon\r\n        \u0026\u0026 Abs(TransY) \u003C MathCore.Epsilon;\r\n\r\n    public Vector2 Translation\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)] \r\n        get =\u003E new(TransX, TransY);\r\n    }\r\n\r\n    public Vector2 Scale\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)] \r\n        get =\u003E new(ScaleX, ScaleY);\r\n    }\r\n\r\n    public Vector2 Skew\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)] \r\n        get =\u003E new(SkewX, SkewY);\r\n    }\r\n\r\n    public float Rotation\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)] \r\n        get =\u003E Atan2(SkewY, ScaleX);\r\n    }\r\n\r\n    public float RotationDeg\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)] \r\n        get =\u003E Atan2(SkewY, ScaleX) * 180f / Pi.Single;\r\n    }\r\n\r\n    public float Determinant\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)] \r\n        get =\u003E ScaleX * ScaleY - SkewY * SkewX;\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public Matrix WithPosition(Vector2 position) =\u003E new(ScaleX, SkewX, position.X, SkewY, ScaleY, position.Y);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public Matrix WithPosition(float x, float y) =\u003E new(ScaleX, SkewX, x, SkewY, ScaleY, y);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public Matrix WithScale(float x, float y) =\u003E new(x, SkewX, TransX, SkewY, y, TransY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public Matrix WithScale(float scale) =\u003E new(scale, SkewX, TransX, SkewY, scale, TransY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public Matrix WithScale(Vector2 scale) =\u003E new(scale.X, SkewX, TransX, SkewY, scale.Y, TransY);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    // Matrix * pt = |A B C| |x| = |Ax\u002BBy\u002BC Dx\u002BEy\u002BF|                \r\n    //               |D E F| |y|\r\n    public Vector2 MapPoint(float x, float y) =\u003E new(ScaleX * x \u002B SkewX * y \u002B TransX, SkewY * x \u002B ScaleY * y \u002B TransY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public Vector2 MapPoint(Vector2 p) =\u003E new(ScaleX * p.X \u002B SkewX * p.Y \u002B TransX, SkewY * p.X \u002B ScaleY * p.Y \u002B TransY);\r\n    \r\n    public SKRect MapRect(SKRect r)\r\n    {\r\n        var topLeftLocal = MapPoint(r.Left, r.Top);\r\n        var bottomRightLocal = MapPoint(r.Right, r.Bottom);\r\n        var leftBottom = MapPoint(r.Left, r.Bottom);\r\n        var topRight = MapPoint(r.Right, r.Top);\r\n\r\n        return new SKRect(\r\n            GdfMath.Min(topLeftLocal.X, bottomRightLocal.X, leftBottom.X, topRight.X),\r\n            GdfMath.Min(topLeftLocal.Y, bottomRightLocal.Y, topRight.Y, leftBottom.Y),\r\n            GdfMath.Max(topLeftLocal.X, bottomRightLocal.X, leftBottom.X, topRight.X),\r\n            GdfMath.Max(topLeftLocal.Y, bottomRightLocal.Y, topRight.Y, leftBottom.Y));\r\n    }\r\n    \r\n    public SKRect MapSize(SKSize size)\r\n    {\r\n        var topLeftLocal = MapPoint(0, 0);\r\n        var bottomRightLocal = MapPoint(size.Width, size.Height);\r\n        var leftBottom = MapPoint(0, size.Height);\r\n        var topRight = MapPoint(size.Width, 0);\r\n\r\n        return new SKRect(\r\n            GdfMath.Min(topLeftLocal.X, bottomRightLocal.X, leftBottom.X, topRight.X),\r\n            GdfMath.Min(topLeftLocal.Y, bottomRightLocal.Y, topRight.Y, leftBottom.Y),\r\n            GdfMath.Max(topLeftLocal.X, bottomRightLocal.X, leftBottom.X, topRight.X),\r\n            GdfMath.Max(topLeftLocal.Y, bottomRightLocal.Y, topRight.Y, leftBottom.Y));\r\n    }\r\n    \r\n    public Matrix FlipHorizontalKeepRotation(SKSize size) =\u003E this * CreateScale(-1, 1, size.Width / 2, 0);\r\n    public Matrix FlipVerticalKeepRotation(SKSize size) =\u003E this * CreateScale(1, -1, 0, size.Height / 2);\r\n\r\n    public Matrix FlipHorizontal(SKSize size)\r\n    {\r\n        var transform = FlipHorizontalKeepRotation(size);\r\n        var angle = transform.Rotation;\r\n        if (Abs(angle) \u003C= MathCore.EpsilonRotation)\r\n        {\r\n            return transform;\r\n        }\r\n\r\n        var target = (transform.IsFlipped ? 2 : -2) * angle;\r\n        return transform * CreateRotation(target, size.Width / 2, size.Height / 2);\r\n    }\r\n\r\n    public Matrix FlipVertical(SKSize size)\r\n    {\r\n        var transform = FlipVerticalKeepRotation(size);\r\n        var angle = transform.Rotation;\r\n        if (Abs(angle) \u003C= MathCore.EpsilonRotation)\r\n        {\r\n            return transform;\r\n        }\r\n        \r\n        var target = (transform.IsFlipped ? 2 : -2) * angle;\r\n        return transform * CreateRotation(target, size.Width / 2, size.Height / 2);\r\n    }\r\n    \r\n    public Matrix DeFlipKeepRotation(SKSize size)\r\n    {\r\n        if (!IsFlipped)\r\n        {\r\n            return this;\r\n        }\r\n        if (IsFlippedHorizontally)\r\n        {\r\n            return this * CreateScale(-1, 1, size.Width * 0.5f, 0);\r\n        }\r\n        return this * CreateScale(1, -1, 0, size.Height * 0.5f);\r\n    }\r\n    \r\n    public Matrix FlipKeepRotation(bool h, bool v, SKSize size)\r\n    {\r\n        if (!v \u0026\u0026 !h)\r\n        {\r\n            return this;\r\n        }\r\n        if (h)\r\n        {\r\n            return this * CreateScale(-1, 1, size.Width * 0.5f, 0);\r\n        }\r\n        return this * CreateScale(1, -1, 0, size.Height * 0.5f);\r\n    }\r\n\r\n    public Matrix ResetRotation()\r\n    {\r\n        var rotation = Rotation;\r\n        if (Abs(rotation) \u003E 0.001f)\r\n        {\r\n            return this * CreateRotation((IsFlipped ? 1 : -1) * rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public Matrix ResetRotation(SKSize size)\r\n    {\r\n        var rotation = Rotation;\r\n        if (Abs(rotation) \u003E 0.001f)\r\n        {\r\n            return this * CreateRotation((IsFlipped ? 1 : -1) * rotation, size.Width / 2, size.Height / 2);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix operator \u002B(in Matrix m1, in Matrix m2) =\u003E new(\r\n        m1.ScaleX \u002B m2.ScaleX, m1.SkewX \u002B m2.SkewX, m1.TransX \u002B m2.TransX,\r\n        m1.SkewY \u002B m2.SkewY, m1.ScaleY \u002B m2.ScaleY, m1.TransY \u002B m2.TransY);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    // ReSharper disable CompareOfFloatsByEqualityOperator\r\n    public static bool operator ==(in Matrix m1, in Matrix m2) =\u003E\r\n        m1.ScaleX == m2.ScaleX \u0026\u0026 m1.ScaleY == m2.ScaleY \u0026\u0026 m1.SkewX == m2.SkewX \u0026\u0026 \r\n        m1.SkewY == m2.SkewY \u0026\u0026 m1.TransX == m2.TransX \u0026\u0026 m1.TransY == m2.TransY;\r\n    // ReSharper restore CompareOfFloatsByEqualityOperator\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static bool operator !=(in Matrix m1, in Matrix m2) =\u003E !(m1 == m2);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    //                  | A B C |   | J K L |   | AJ\u002BBM AK\u002BBN AL\u002BBO\u002BC |\r\n    // Matrix * other = | D E F | * | M N O | = | DJ\u002BEM DK\u002BEN DL\u002BEO\u002BF |\r\n    public static Matrix operator *(in Matrix m1, in Matrix m2) =\u003E new(\r\n        m1.ScaleX * m2.ScaleX \u002B m1.SkewX * m2.SkewY,\r\n        m1.ScaleX * m2.SkewX \u002B m1.SkewX * m2.ScaleY,\r\n        m1.ScaleX * m2.TransX \u002B m1.SkewX * m2.TransY \u002B m1.TransX,\r\n        m1.SkewY * m2.ScaleX \u002B m1.ScaleY * m2.SkewY,\r\n        m1.SkewY * m2.SkewX \u002B m1.ScaleY * m2.ScaleY,\r\n        m1.SkewY * m2.TransX \u002B m1.ScaleY * m2.TransY \u002B m1.TransY);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix operator *(in Matrix m, float val) =\u003E new(\r\n        m.ScaleX * val, m.SkewX * val, m.TransX * val,\r\n        m.SkewY * val, m.ScaleY * val, m.TransY * val);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    // Matrix * pt = |A B C| |x| = |Ax\u002BBy\u002BC Dx\u002BEy\u002BF|                \r\n    //               |D E F| |y|\r\n    public static Vector2 operator *(in Matrix m, Vector2 p) =\u003E new(\r\n        m.ScaleX * p.X \u002B m.SkewX * p.Y \u002B m.TransX, \r\n        m.SkewY * p.X \u002B m.ScaleY * p.Y \u002B m.TransY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix operator !(in Matrix m) =\u003E m.Invert();\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix operator -(in Matrix m1, in Matrix m2) =\u003E new(\r\n        m1.ScaleX - m2.ScaleX, m1.SkewX - m2.SkewX, m1.TransX - m2.TransX,\r\n        m1.SkewY - m2.SkewY, m1.ScaleY - m2.ScaleY, m1.TransY - m2.TransY);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix operator -(in Matrix m) =\u003E new(\r\n        -m.ScaleX, -m.SkewX, -m.TransX,\r\n        -m.SkewY, -m.ScaleY, -m.TransY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static implicit operator Matrix(SKMatrix m) =\u003E new(m.ScaleX, m.SkewX, m.TransX, m.SkewY, m.ScaleY, m.TransY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static implicit operator SKMatrix(Matrix m) =\u003E new(\r\n        m.ScaleX, m.SkewX , m.TransX, \r\n        m.SkewY , m.ScaleY, m.TransY, \r\n        0       , 0       , 1      );\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateRotationDeg(float deg) =\u003E CreateRotation(deg.ToRadians());\r\n    \r\n    public static Matrix CreateRotation(float radians)\r\n    {\r\n        radians = IEEERemainder(radians, PI * 2);\r\n\r\n        float c, s;\r\n\r\n        if (radians is \u003E -RotationEpsilon and \u003C RotationEpsilon)\r\n        {\r\n            // Exact case for zero rotation.\r\n            c = 1;\r\n            s = 0;\r\n        }\r\n        else if (radians is \u003E PI / 2 - RotationEpsilon and \u003C PI / 2 \u002B RotationEpsilon)\r\n        {\r\n            // Exact case for 90 degree rotation.\r\n            c = 0;\r\n            s = 1;\r\n        }\r\n        else if (radians is \u003C -PI \u002B RotationEpsilon or \u003E PI - RotationEpsilon)\r\n        {\r\n            // Exact case for 180 degree rotation.\r\n            c = -1;\r\n            s = 0;\r\n        }\r\n        else if (radians is \u003E -PI / 2 - RotationEpsilon and \u003C -PI / 2 \u002B RotationEpsilon)\r\n        {\r\n            // Exact case for 270 degree rotation.\r\n            c = 0;\r\n            s = -1;\r\n        }\r\n        else\r\n        {\r\n            // Arbitrary rotation.\r\n            c = Cos(radians);\r\n            s = Sin(radians);\r\n        }\r\n\r\n        // [  c -s  0]\r\n        // [  s  c  0]\r\n        return new Matrix(c, -s, 0, s, c, 0);\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateRotationDeg(float deg, Vector2 centerPoint) =\u003E\r\n        CreateRotation(deg.ToRadians(), centerPoint.X, centerPoint.Y);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateRotationDeg(float deg, float centerX, float centerY) =\u003E\r\n        CreateRotation(deg.ToRadians(), centerX, centerY);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateRotation(float radians, Vector2 centerPoint) =\u003E\r\n        CreateRotation(radians, centerPoint.X, centerPoint.Y);\r\n    \r\n    public static Matrix CreateRotation(float radians, float centerX, float centerY)\r\n    {\r\n        radians = IEEERemainder(radians, PI * 2);\r\n\r\n        float c, s;\r\n\r\n        if (radians is \u003E -RotationEpsilon and \u003C RotationEpsilon)\r\n        {\r\n            // Exact case for zero rotation.\r\n            c = 1;\r\n            s = 0;\r\n        }\r\n        else if (radians is \u003E PI / 2 - RotationEpsilon and \u003C PI / 2 \u002B RotationEpsilon)\r\n        {\r\n            // Exact case for 90 degree rotation.\r\n            c = 0;\r\n            s = 1;\r\n        }\r\n        else if (radians is \u003C -PI \u002B RotationEpsilon or \u003E PI - RotationEpsilon)\r\n        {\r\n            // Exact case for 180 degree rotation.\r\n            c = -1;\r\n            s = 0;\r\n        }\r\n        else if (radians is \u003E -PI / 2 - RotationEpsilon and \u003C -PI / 2 \u002B RotationEpsilon)\r\n        {\r\n            // Exact case for 270 degree rotation.\r\n            c = 0;\r\n            s = -1;\r\n        }\r\n        else\r\n        {\r\n            // Arbitrary rotation.\r\n            c = Cos(radians);\r\n            s = Sin(radians);\r\n        }\r\n\r\n        var x = centerX * (1 - c) \u002B centerY * s;\r\n        var y = centerY * (1 - c) - centerX * s;\r\n\r\n        // [  c -s  x]\r\n        // [  s  c  y]\r\n        return new Matrix(c, -s, x, s, c, y);\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateScale(Vector2 scale) =\u003E new(scale.X,0,0,0,scale.Y,0);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateScale(float xScale, float yScale) =\u003E new(xScale,0,0,0,yScale,0);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateScale(float xScale, float yScale, Vector2 centerPoint) \r\n        =\u003E new(xScale, 0, centerPoint.X * (1 - xScale), 0, yScale, centerPoint.Y * (1 - yScale));\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateScale(float xScale, float yScale, float centerX, float centerY) \r\n        =\u003E new(xScale, 0, centerX * (1 - xScale), 0, yScale, centerY * (1 - yScale));\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateScale(float scale)=\u003E new(scale,0,0,0,scale,0);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateScale(float scale, Vector2 centerPoint)\r\n        =\u003E new(scale, 0, centerPoint.X * (1 - scale), 0, scale, centerPoint.Y * (1 - scale));\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateSkew(float radiansX, float radiansY) \r\n        =\u003E new(1,Tan(radiansX),0,Tan(radiansY),1,0);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateSkew(float radiansX, float radiansY, Vector2 centerPoint)\r\n    {\r\n        var xTan = Tan(radiansX);\r\n        var yTan = Tan(radiansY);\r\n        var tx = -centerPoint.Y * xTan;\r\n        var ty = -centerPoint.X * yTan;\r\n        return new Matrix(1, xTan, tx, 1, yTan, ty);\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateTranslation(Vector2 position) =\u003E new(1,0,position.X,0,1,position.Y);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public static Matrix CreateTranslation(float xPosition, float yPosition) =\u003E new(1, 0, xPosition, 0, 1, yPosition);\r\n\r\n    public Matrix Invert()\r\n    {\r\n        var det = ScaleX * ScaleY - SkewX * SkewY;\r\n        if (Abs(det) \u003C float.Epsilon)\r\n        {\r\n            return Identity;\r\n        }\r\n\r\n        var invDet = 1.0f / det;\r\n        return new Matrix(\r\n            ScaleY * invDet,\r\n            -SkewX * invDet,\r\n            (SkewX * TransY - TransX * ScaleY) * invDet,\r\n            -SkewY * invDet,\r\n            ScaleX * invDet,\r\n            (TransX * SkewY - ScaleX * TransY) * invDet);\r\n    }\r\n\r\n    public static Matrix Lerp(in Matrix m1, in Matrix m2, float amount) =\u003E new(\r\n        m1.ScaleX \u002B (m2.ScaleX - m1.ScaleX) * amount,\r\n        m1.SkewX \u002B (m2.SkewX - m1.SkewX) * amount,\r\n        m1.TransX \u002B (m2.TransX - m1.TransX) * amount,\r\n        m1.SkewY \u002B (m2.SkewY - m1.SkewY) * amount,\r\n        m1.ScaleY \u002B (m2.ScaleY - m1.ScaleY) * amount,\r\n        m1.TransY \u002B (m2.TransY - m1.TransY) * amount);\r\n\r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public override bool Equals(object? obj) =\u003E obj is Matrix other \u0026\u0026 Equals(other);\r\n    \r\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n    public bool Equals(Matrix other) =\u003E\r\n        ScaleX.Equals(other.ScaleX) \u0026\u0026 ScaleY.Equals(other.ScaleY) \u0026\u0026 SkewX.Equals(other.SkewX) \u0026\u0026 \r\n        SkewY.Equals(other.SkewY) \u0026\u0026 TransX.Equals(other.TransX) \u0026\u0026 TransY.Equals(other.TransY);\r\n\r\n    public override int GetHashCode() =\u003E HashCode.Combine(ScaleX, SkewX, SkewY, ScaleY, TransX, TransY);\r\n\r\n    public override string ToString()\r\n    {\r\n        if (this == Identity)\r\n        {\r\n            return \u0022Identity\u0022;\r\n        }\r\n\r\n        var rotation = RotationDeg;\r\n        if (rotation != 0)\r\n        {\r\n            return $\u0022x[{ScaleX},{ScaleY}] p[{TransX},{TransY}] {rotation}\u00B0\u0022;\r\n        }\r\n\r\n        if (Abs(ScaleX \u002B ScaleY - 2) \u003E 0.0001)\r\n        {\r\n            return $\u0022x[{ScaleX},{ScaleY}] p[{TransX},{TransY}]\u0022;\r\n        }\r\n        \r\n        return $\u0022[{TransX},{TransY}]\u0022;\r\n    }\r\n}\r\n\u0060\u0060\u0060 ",
        "createdAt": "2024-03-10T04:13:55",
        "reactions": [
          {
            "user": "DJGosnell",
            "content": "\u002B1",
            "createdAt": "2026-02-06T12:56:18.7515836Z"
          }
        ]
      },
      {
        "id": 1987192639,
        "author": "mattleibow",
        "body": "Oh thanks! I forgot that matrix 3x2 is probably all that is used... Not sure what the other 3 perspective fields in skia is used for...\n\nNeed to see if that is ever needed and maybe we can just create a new matrix type like you have. We can never have enough matrix types.\n\nFor SKMatrix44 I literally just Unsafe.As between skia and System.Numerics Matrix4x4. I still cast to skia types but now that I think about it, I can just add an overload that does not cast at all and passes memory directly to skia.\n\nI can do the same for a new SKMatrix32 where we have overloads and directly cast. However, the native SkMatrix has some other annoying fields. But, maybe we skip the whole 3x3 matrix and make the 4x4 matrix the way for skia 3. I think it is now in many apis so we may not even need the 3x3 anymore. The 4x4 one is probably simpler to use and a 3x2 is better anyways. ",
        "createdAt": "2024-03-10T11:26:33",
        "reactions": [
          {
            "user": "Mikolaytis",
            "content": "\u002B1",
            "createdAt": "2026-02-06T12:56:18.9372157Z"
          }
        ]
      }
    ]
  }
}