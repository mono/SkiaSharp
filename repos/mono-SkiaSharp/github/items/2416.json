{
  "number": 2416,
  "type": "issue",
  "state": "open",
  "title": "SKCanvasView.Draw(canvas) distorted image [BUG] ",
  "body": "**Description**\r\n\r\nI am taking a screenshot of my Android app in order to include it in a .pdf report.\r\n\r\nOn devices with API Level \u003E= 26 I am using [PixelCopy](https://developer.android.com/reference/android/view/PixelCopy) successfully, and I get a proper image.\r\n\r\nFor devices with API Level \u003C 26 I am forced to use Canvas like explained [here](https://stackoverflow.com/a/52905682). This works OK for most of the views I use it with, but there are a couple of them that do not render correctly. For example, the following screen should be captured:\r\n\r\n![image](https://user-images.githubusercontent.com/19507731/224710911-7182d44c-2a87-4467-a64d-0e87e3664e54.png)\r\n\r\nand I get:\r\n\r\n![image](https://user-images.githubusercontent.com/19507731/224710975-9b425ee3-b7aa-4746-ab8a-f092894a36b2.png)\r\n\r\nIn particular, the stuff that gets badly drawn are Views created with [Skia](https://skia.org/).\r\n\r\nIs there a way to modify my existing code in order to avoid this kind of inconsistencies?\r\n\r\n**Code**\r\n\r\n\u0060\u0060\u0060cs\r\nfun getBitmapFromView(view: View): Bitmap {\r\n    val bitmap = Bitmap.createBitmap(\r\n        view.width, view.height, Bitmap.Config.ARGB_8888\r\n    )\r\n    val canvas = Canvas(bitmap)\r\n    view.draw(canvas)\r\n    return bitmap\r\n}\r\n\u0060\u0060\u0060\r\n\r\n**Expected Behavior**\r\n\r\nNon distorted screenshot of SKCanvasView\r\n\u003C!-- a general description of what was the expected behavior or result --\u003E\r\n\r\n**Actual Behavior**\r\n\r\nDistorted screenshot of SKCanvasView\r\n\u003C!-- a general description of what really happened --\u003E\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  2.80.3\u003C!-- the version of SkiaSharp that has the issue --\u003E\r\n- Last known good version:  \u003C!-- the version of SkiaSharp that still working --\u003E\r\n- IDE:  Visual Studio\u003C!-- Visual Studio / Visual Studio for Mac / MonoDevelop / Visual Studio Code --\u003E\r\n- Platform Target Frameworks: Android\u003C!-- all that apply, remove the platforms that aren\u0027t broken or haven\u0027t had any testing --\u003E\r\n - Android: 31\u003C!-- the version of the Android SDK you are compiling against, e.g. 7.1 --\u003E \r\n  \r\n\u003Cdetails\u003E\r\n  \u003Csummary\u003EDetailed IDE/OS information (click to expand)\u003C/summary\u003E\r\n  \r\n\u0060\u0060\u0060\r\n\r\nPASTE ANY DETAILED VERSION INFO HERE\r\n\r\n\u0060\u0060\u0060\r\n\u003C/details\u003E\r\n",
  "author": {
    "login": "rubiomiguel06",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2023-03-13T13:40:27",
  "updatedAt": "2024-04-18T16:29:53",
  "commentCount": 3,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T13:37:47.4161136Z",
    "reactions": [],
    "comments": [
      {
        "id": 2018759897,
        "author": "DiabloDaniel",
        "body": "Que tal. Disculpa, pudiste arreglar el detalle con el screenshot y el skia, estoy teniendo el mismo detalle y no tengo idea de porque se produsca, me pudieras decir que fue de tu caso. gracias\r\n",
        "createdAt": "2024-03-25T19:32:33",
        "reactions": []
      },
      {
        "id": 2018804229,
        "author": "rubiomiguel06",
        "body": "Hola, no, no pude arreglarlo. Por el momento quien use mi aplicaci\u00F3n con un dispositivo con una API \u003C 26 se encuentra con este problema. Te invito a darle thumbs up al issue as\u00ED tiene m\u00E1s visibilidad.\r\n\r\n---------------------------------------------------------------------\r\n\r\nHi, no, I didn\u0027t find a fix/workaroung yet. At the moment, whoever is using my App with a device with API \u003C 26 is encountering this issue. I invite you to hit thumbs up to this issue so it increases its visibility.",
        "createdAt": "2024-03-25T19:58:51",
        "reactions": []
      },
      {
        "id": 2064448882,
        "author": "DiabloDaniel",
        "body": "Resolvi el problemas de la captura, estoy trabajando en Xamarin forms, te paso mi vista (.xaml) y el viewbag (.xaml.cs) de la misma. Te comento que todos tus componentes que quieras capturar en imagen deben estar en el mismo lienzo y no realizar la captura de pantalla con una libreria externa o de manera nativa, si no que debes de realizar la captura con la misma nuget o libreria canvas........Soluci\u00F3n: \r\n*Observe que la libreria tiene reacciones inesperadas, espero te sirva....\r\n\r\n-Vista-\r\n\r\n\u0060\r\n\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022 ?\u003E\r\n\u003CContentPage xmlns=\u0022http://xamarin.com/schemas/2014/forms\u0022\r\n        xmlns:x=\u0022http://schemas.microsoft.com/winfx/2009/xaml\u0022\r\n        xmlns:skia=\u0022clr-namespace:SkiaSharp.Views.Forms;assembly=SkiaSharp.Views.Forms\u0022 \r\n        xmlns:material=\u0022clr-namespace:XF.Material.Forms.UI;assembly=XF.Material\u0022\r\n        xmlns:xct=\u0022http://xamarin.com/schemas/2020/toolkit\u0022 \r\n        x:Class=\u0022ControlVehicular_App.Views.Menu.PlanosUnidad.PlanoIzquierdoPage\u0022\r\n        NavigationPage.HasNavigationBar=\u0022False\u0022\r\n        NavigationPage.HasBackButton=\u0022False\u0022\r\n        NavigationPage.IconColor=\u0022Black\u0022\r\n        BackgroundColor=\u0022White\u0022\u003E\r\n\r\n    \u003CAbsoluteLayout HorizontalOptions=\u0022FillAndExpand\u0022\r\n                  VerticalOptions=\u0022FillAndExpand\u0022\u003E\r\n\r\n        \u003Cskia:SKCanvasView x:Name=\u0022canvasView\u0022\r\n            AbsoluteLayout.LayoutFlags=\u0022All\u0022\r\n            AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022            \r\n            IsEnabled=\u0022{Binding IsEnableLine}\u0022  \r\n            BackgroundColor=\u0022Transparent\u0022\r\n            EnableTouchEvents=\u0022True\u0022\r\n            PaintSurface=\u0022canvasView_PaintSurface\u0022\r\n            Touch=\u0022canvasView_Touch\u0022/\u003E\r\n\r\n        \u003Cmaterial:MaterialButton\r\n            Margin=\u002210\u0022\r\n            HeightRequest=\u002255\u0022\r\n            Elevation=\u00225\u0022\r\n            Clicked=\u0022LimpiarLienzo_Clicked\u0022\r\n            ImageSource=\u0022Recargar.png\u0022\r\n            xct:IconTintColorEffect.TintColor=\u0022DarkSlateGray\u0022 \r\n            HorizontalOptions=\u0022EndAndExpand\u0022\r\n            VerticalOptions=\u0022StartAndExpand\u0022\r\n            BackgroundColor=\u0022LightGray\u0022\r\n            AbsoluteLayout.LayoutFlags=\u0022All\u0022\r\n            AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022/\u003E\r\n\r\n        \u003Cmaterial:MaterialButton\r\n            Margin=\u00220,10,100,0\u0022\r\n            HeightRequest=\u002255\u0022\r\n            Elevation=\u00225\u0022\r\n            Clicked=\u0022AtrasLienzo_Clicked\u0022\r\n            ImageSource=\u0022Atras.png\u0022\r\n            xct:IconTintColorEffect.TintColor=\u0022DarkSlateGray\u0022 \r\n            HorizontalOptions=\u0022EndAndExpand\u0022\r\n            VerticalOptions=\u0022StartAndExpand\u0022\r\n            BackgroundColor=\u0022LightGray\u0022\r\n            AbsoluteLayout.LayoutFlags=\u0022All\u0022\r\n            AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022/\u003E\r\n\r\n        \u003Cmaterial:MaterialButton\r\n            Margin=\u002210,0,0,10\u0022\r\n            HeightRequest=\u002255\u0022\r\n            Elevation=\u00225\u0022\r\n            Command=\u0022{Binding ActivarDrawLine}\u0022\r\n            Clicked=\u0022ActivarDrawLine_Button\u0022\r\n            ImageSource=\u0022Linea.png\u0022\r\n            xct:IconTintColorEffect.TintColor=\u0022White\u0022\r\n            HorizontalOptions=\u0022StartAndExpand\u0022\r\n            VerticalOptions=\u0022EndAndExpand\u0022\r\n            BackgroundColor=\u0022{Binding ColorButonLine}\u0022\r\n            AbsoluteLayout.LayoutFlags=\u0022All\u0022\r\n            AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022/\u003E\r\n\r\n        \u003Cmaterial:MaterialButton\r\n            Margin=\u0022100,0,0,10\u0022\r\n            HeightRequest=\u002255\u0022\r\n            Elevation=\u00225\u0022\r\n            Command=\u0022{Binding ActivarDrawCircle}\u0022\r\n            Clicked=\u0022ActivarDrawCircle_Button\u0022\r\n            ImageSource=\u0022Circulo.png\u0022\r\n            xct:IconTintColorEffect.TintColor=\u0022White\u0022\r\n            HorizontalOptions=\u0022StartAndExpand\u0022\r\n            VerticalOptions=\u0022EndAndExpand\u0022\r\n            BackgroundColor=\u0022{Binding ColorButonCircle}\u0022\r\n            AbsoluteLayout.LayoutFlags=\u0022All\u0022\r\n            AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022/\u003E\r\n\r\n        \u003Cmaterial:MaterialButton\r\n            TextColor=\u0022White\u0022\r\n            Padding=\u002220\u0022\r\n            Margin=\u002210\u0022      \r\n            HeightRequest=\u0022100\u0022\r\n            Clicked=\u0022CapturaPlano_Button\u0022\r\n            ImageSource=\u0022CaptureImagen.png\u0022\r\n            xct:IconTintColorEffect.TintColor=\u0022White\u0022\r\n            CornerRadius=\u002260\u0022              \r\n            Elevation=\u00225\u0022\r\n            HorizontalOptions=\u0022End\u0022\r\n            VerticalOptions=\u0022EndAndExpand\u0022\r\n            BackgroundColor=\u0022CadetBlue\u0022\r\n            AbsoluteLayout.LayoutFlags=\u0022All\u0022\r\n            AbsoluteLayout.LayoutBounds=\u00220,0,1,1\u0022/\u003E\r\n    \u003C/AbsoluteLayout\u003E\r\n    \r\n\u003C/ContentPage\u003E\u0060\r\n\r\n-ViewBag-\r\n\u0060using ControlVehicular_App.ViewModel.Menu.PlanosUnidad;\r\nusing Prism.Navigation;\r\nusing Prism.Services;\r\nusing SkiaSharp;\r\nusing SkiaSharp.Views.Forms;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing Xamarin.Forms;\r\nusing Xamarin.Forms.Xaml;\r\nusing ControlVehicular_App.Common;\r\nusing ControlVehicular_App.Dtos;\r\nusing Xamarin.Essentials;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing ControlVehicular_App.Model;\r\nusing ControlVehicular_App.ViewModel;\r\nusing Microsoft.IdentityModel.Tokens;\r\nusing ControlVehicular_App.Constantes;\r\n\r\nnamespace ControlVehicular_App.Views.Menu.PlanosUnidad\r\n{\r\n    [XamlCompilation(XamlCompilationOptions.Compile)]\r\n\tpublic partial class PlanoIzquierdoPage : ContentPage\r\n\t{\r\n        private INavigationService _navigationService;\r\n        private IPageDialogService _pageDialogService;\r\n        private INavigationService navigationService;\r\n        private IPageDialogService pageDialogService;\r\n\r\n        // Accede al contexto de Android\r\n        private Android.Content.Context context = Android.App.Application.Context;\r\n\r\n        private List\u003CSKPoint\u003E drawnPoints = new List\u003CSKPoint\u003E();\r\n        private SKSurface canvasMaster;\r\n\r\n        // Guardar el estado del \u00FAltimo evento de toque\r\n        private bool touchInsideCanvas;\r\n\r\n        private SKPoint startPoint; // Punto inicial del arrastre\r\n        private SKPoint endPoint; // Punto final del arrastre\r\n\r\n        private bool ValidCirculo;//Atributo que valida el dibujar el circulo temporal\r\n\r\n        private List\u003CCircle\u003E ListCircles;\r\n        private List\u003CLinea\u003E ListLinea;\r\n        private List\u003Cstring\u003E ListAccion;\r\n\r\n        private int idLinea;\r\n        private bool BackgroudCanvasCreated;\r\n        private bool ScreenShotCapture;\r\n        private bool IsValidDrawLine;\r\n        private bool IsValidDrawCircle;\r\n\r\n        private bool IsValidLine; //Valor que me indica quien fue el ultimo en pintar\r\n        private bool IsValidCircle; //Valor que me indica quien fue el ultimo en pintar \r\n        private bool IsValidRetroceder; //Valor que me indica que solo se retroceda 1 atras\r\n\r\n        private SKRectI destRect;\r\n\r\n        public PlanoIzquierdoPage ()\r\n\t\t{\r\n            //Iniciadores\r\n            ListCircles = new List\u003CCircle\u003E();\r\n            ListLinea = new List\u003CLinea\u003E();\r\n            App.Current.Properties[\u0022DrawValidPlanoIzquierdo\u0022] = null;\r\n            ValidCirculo = false;\r\n            BackgroudCanvasCreated = false;\r\n            ScreenShotCapture = false;\r\n            IsValidDrawLine = true;\r\n            IsValidDrawCircle = false;\r\n            IsValidLine = false;\r\n            IsValidCircle = false;\r\n            IsValidRetroceder = false;\r\n            idLinea = 0;\r\n            ListAccion = new List\u003Cstring\u003E();\r\n            var mainDisplayInfo = DeviceDisplay.MainDisplayInfo;\r\n            var MargenSupInf = (33.0 / 100) * (int)mainDisplayInfo.Height;\r\n            //Definir el rect\u00E1ngulo destino para el bitmap recortado\r\n            destRect = new SKRectI(0, (int)MargenSupInf - 100, (int)mainDisplayInfo.Width, (int)mainDisplayInfo.Height - ((int)MargenSupInf \u002B 80));\r\n\r\n            InitializeComponent();\r\n            BindingContext = new PlanoIzquierdoViewModel(_navigationService = navigationService, _pageDialogService = pageDialogService);          \r\n        }\r\n\r\n        private void LimpiarLienzo_Clicked(object sender, EventArgs e)\r\n        {\r\n            App.Current.Properties[\u0022DrawValidPlanoIzquierdo\u0022] = null;\r\n            touchInsideCanvas = true;\r\n            BackgroudCanvasCreated = false;\r\n            IsValidRetroceder = false;\r\n            if (ListLinea.IsNullOrEmpty() \u0026\u0026 ListCircles.IsNullOrEmpty())\r\n            {\r\n                ViewModelBase.MensajeToasError(\u0022No hay nada que deshacer\u0022);\r\n            }\r\n            ListCircles.Clear();\r\n            ListLinea.Clear();\r\n            ListAccion.Clear();\r\n            drawnPoints.Clear();   \r\n            canvasView.InvalidateSurface(); // Volver a dibujar el lienzo para que est\u00E9 vac\u00EDo\r\n        }\r\n\r\n        private void AtrasLienzo_Clicked(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                if (!ListLinea.IsNullOrEmpty() || !ListCircles.IsNullOrEmpty())\r\n                {\r\n\r\n                    if (!string.IsNullOrEmpty(ListAccion.Last()) \u0026\u0026 ListAccion.Last() == \u0022Linea\u0022)\r\n                    {\r\n                        var itemEnd = ListLinea.Last();\r\n                        ListLinea.RemoveAll(x =\u003E x.id == itemEnd.id);\r\n                        IsValidRetroceder = true;\r\n                    }\r\n\r\n                    if (!string.IsNullOrEmpty(ListAccion.Last()) \u0026\u0026 ListAccion.Last() == \u0022Circulo\u0022)\r\n                    {\r\n                        ListCircles.RemoveAt(ListCircles.Count - 1);\r\n                        IsValidRetroceder = true;\r\n                    }\r\n                    ListAccion.RemoveAt(ListAccion.Count - 1);\r\n\r\n                    canvasView.InvalidateSurface();\r\n                }\r\n                else\r\n                {\r\n                    ViewModelBase.MensajeToasError(\u0022No hay nada que deshacer\u0022);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n        }\r\n\r\n        private async void canvasView_PaintSurface(object sender, SKPaintSurfaceEventArgs args)\r\n        {\r\n            try\r\n            {\r\n                canvasMaster = args.Surface;\r\n                if (!BackgroudCanvasCreated)\r\n                {\r\n                    //Guardar el estado actual del lienzo\r\n                    var saveCount = canvasMaster.Canvas.SaveLayer();\r\n\r\n                    // Dibujar el bitmap recortado en el lienzo como fondo\r\n                    canvasMaster.Canvas.DrawPaint(new SKPaint() { Color = SKColors.White });\r\n\r\n                    using (Stream stream = context.Resources.OpenRawResource(AppConstantes.ParteIzquierda))\r\n                    {\r\n                        using (SKBitmap bitmap = SKBitmap.Decode(stream))\r\n                        {\r\n                            // Dibuja la imagen en el lienzo\r\n                            canvasMaster.Canvas.DrawBitmap(bitmap, destRect);\r\n                        }\r\n                    }\r\n\r\n                    // Restaurar el lienzo al estado guardado\r\n                    canvasMaster.Canvas.RestoreToCount(saveCount);\r\n                    BackgroudCanvasCreated = true;\r\n                }\r\n\r\n                if (IsValidRetroceder)\r\n                {\r\n                    // Dibujar el bitmap recortado en el lienzo como fondo\r\n                    canvasMaster.Canvas.DrawPaint(new SKPaint() { Color = SKColors.White });\r\n\r\n                    using (Stream stream = context.Resources.OpenRawResource(AppConstantes.ParteIzquierda))\r\n                    {\r\n                        using (SKBitmap bitmap = SKBitmap.Decode(stream))\r\n                        {\r\n                            // Dibuja la imagen en el lienzo\r\n                            canvasMaster.Canvas.DrawBitmap(bitmap, destRect);\r\n                        }\r\n                    }\r\n                    // Dibujar todos los puntos dibujados\r\n                    using (SKPaint paint = new SKPaint())\r\n                    {\r\n                        paint.Style = SKPaintStyle.Stroke;\r\n                        paint.Color = SKColors.Red;\r\n                        paint.StrokeWidth = 4;\r\n                        foreach (var circle in ListCircles)\r\n                        {\r\n                            // Dibujar cada c\u00EDrculo de la lista\r\n                            canvasMaster.Canvas.DrawCircle(circle.cx, circle.cy, circle.Radius, paint);\r\n                        }\r\n                        foreach (var item in ListLinea)\r\n                        {\r\n                            canvasMaster.Canvas.DrawLine(item.point0, item.point1, paint);\r\n                        }\r\n                    }\r\n                    IsValidRetroceder = false;\r\n                }\r\n\r\n                if (touchInsideCanvas)\r\n                {\r\n                    // Dibujar todos los puntos dibujados\r\n                    using (SKPaint paint = new SKPaint())\r\n                    {\r\n                        paint.Style = SKPaintStyle.Stroke;\r\n                        paint.Color = SKColors.Red;\r\n                        paint.StrokeWidth = 4;\r\n                        //Trazado de Lineas\r\n                        if (IsValidDrawLine)\r\n                        {\r\n                            for (int i = 1; i \u003C drawnPoints.Count; i\u002B\u002B)\r\n                            {\r\n                                canvasMaster.Canvas.DrawLine(drawnPoints[i - 1], drawnPoints[i], paint);\r\n                                var line = new Linea() { id = idLinea, point0 = drawnPoints[i - 1], point1 = drawnPoints[i], paint = paint };\r\n                                ListLinea.Add(line);\r\n                                IsValidLine = true;\r\n                                IsValidCircle = false;\r\n                            }\r\n                        }  \r\n                        //Trazado de Circulos\r\n                        if (IsValidDrawCircle)\r\n                        {\r\n                            // Dibujar el bitmap recortado en el lienzo como fondo\r\n                            canvasMaster.Canvas.DrawPaint(new SKPaint() { Color = SKColors.White });\r\n\r\n                            using (Stream stream = context.Resources.OpenRawResource(AppConstantes.ParteIzquierda))\r\n                            {\r\n                                using (SKBitmap bitmap = SKBitmap.Decode(stream))\r\n                                {\r\n                                    // Dibuja la imagen en el lienzo\r\n                                    canvasMaster.Canvas.DrawBitmap(bitmap, destRect);\r\n                                }\r\n                            }\r\n                            // Calcular el radio y el centro del c\u00EDrculo\r\n                            float radius = SKPoint.Distance(startPoint, endPoint) / 2;\r\n                            SKPoint center = new SKPoint((startPoint.X \u002B endPoint.X) / 2, (startPoint.Y \u002B endPoint.Y) / 2);\r\n\r\n                            // Dibujar el c\u00EDrculo temporal\r\n                            if (!ValidCirculo)\r\n                            {\r\n                                canvasMaster.Canvas.DrawCircle(center.X, center.Y, radius, paint);\r\n                            }\r\n                            foreach (var circle in ListCircles)\r\n                            {\r\n                                // Dibujar cada c\u00EDrculo de la lista\r\n                                canvasMaster.Canvas.DrawCircle(circle.cx, circle.cy, circle.Radius, paint);\r\n                            }\r\n                            foreach (var item in ListLinea)\r\n                            {\r\n                                canvasMaster.Canvas.DrawLine(item.point0, item.point1, paint);\r\n                            }                            \r\n                            IsValidLine = false;\r\n                            IsValidCircle = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (ScreenShotCapture)\r\n                {\r\n                    if (ListLinea.IsNullOrEmpty() \u0026\u0026 ListCircles.IsNullOrEmpty())\r\n                    {\r\n                        ViewModelBase.MensajeToasError(\u0022Debes indicar defectos para poder capturarlos\u0022);\r\n                    }\r\n                    else\r\n                    {\r\n                        byte[] bytes;\r\n\r\n                        // Capturar el dibujo como un bitmap con la configuraci\u00F3n personalizada\r\n                        using (var image = canvasMaster.Snapshot())\r\n                        {\r\n                            // Convertir el bitmap a bytes en formato PNG\r\n                            using (var data = image.Encode(SKEncodedImageFormat.Png, 100))\r\n                            {\r\n                                bytes = data.ToArray();\r\n                            }\r\n                        }\r\n                        // Aqu\u00ED puedes hacer lo que necesites con los bytes, como guardarlos en un archivo o enviarlos a otro m\u00E9todo\r\n                        var res = await Helper.SubirCapturaDetalle\u003CDtoSolicitud\u003E(\u0022_planoIzquierdo.PNG\u0022, bytes);\r\n                        if (res != null)\r\n                        {\r\n                            ViewModelBase.MensajeToasAviso(\u0022Imagen de parte izquierda guardada correctamente\u0022);\r\n                        }\r\n                        else\r\n                        {\r\n                            ViewModelBase.MensajeToasError(\u0022Imagen de parte izquierda no se puedo enviar\u0022);\r\n                        }\r\n                    }                  \r\n                    ScreenShotCapture = false;\r\n                }\r\n                touchInsideCanvas = false; //Siempre se cancela el touch luego de usarse\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex);\r\n            }           \r\n        }\r\n        private void canvasView_Touch(object sender, SKTouchEventArgs args)\r\n        {\r\n            try\r\n            {\r\n                switch (args.ActionType)\r\n                {\r\n                    case SKTouchAction.Pressed:\r\n                        startPoint = args.Location; // Almacenar el punto inicial\r\n                        endPoint = args.Location; // Inicializar el punto final\r\n                        drawnPoints.Clear(); // Limpiar puntos al iniciar el toque\r\n                        drawnPoints.Add(args.Location);\r\n                        // Guardar el estado del \u00FAltimo evento de toque\r\n                        touchInsideCanvas = true;\r\n                        args.Handled = true;\r\n                        break;\r\n                    case SKTouchAction.Moved:\r\n                        App.Current.Properties[\u0022DrawValidPlanoIzquierdo\u0022] = \u0022Marcado\u0022;\r\n                        endPoint = args.Location; // Actualizar el punto final mientras se mueve el dedo\r\n                        drawnPoints.Add(args.Location); // Agregar puntos mientras se mueve el dedo                                                            \r\n                        touchInsideCanvas = true;// Guardar el estado del \u00FAltimo evento de toque\r\n                        //Valores de circulo\r\n                        ValidCirculo = false;\r\n                        canvasView.InvalidateSurface(); // Volver a dibujar el lienzo                     \r\n                        args.Handled = true;\r\n                        break;\r\n                    case SKTouchAction.Released:\r\n                        touchInsideCanvas = false;\r\n                        //--Valores del Circulo--\r\n                        ValidCirculo = true;\r\n                        if (IsValidDrawLine)\r\n                        {\r\n                            idLinea\u002B\u002B;\r\n                            ListAccion.Add(\u0022Linea\u0022);\r\n                        }\r\n                        if (IsValidDrawCircle)\r\n                        {\r\n                            // Cuando se suelte el dedo, agregar el c\u00EDrculo a la lista de formas dibujadas\r\n                            float radius = SKPoint.Distance(startPoint, endPoint) / 2;\r\n                            SKPoint center = new SKPoint((startPoint.X \u002B endPoint.X) / 2, (startPoint.Y \u002B endPoint.Y) / 2);\r\n                            // Agregar el c\u00EDrculo a la lista de c\u00EDrculos dibujados\r\n                            ListCircles.Add(new Circle { cx = center.X, cy = center.Y, Radius = radius });\r\n                            ListAccion.Add(\u0022Circulo\u0022);\r\n                        }                                               \r\n                        //canvasView.InvalidateSurface(); // Volver a dibujar el lienzo\r\n                        args.Handled = true;\r\n                        break;\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void CapturaPlano_Button(object sender, EventArgs e)\r\n        {\r\n            ScreenShotCapture = true;\r\n            canvasView.InvalidateSurface(); // Volver a dibujar el lienzo\r\n        }\r\n\r\n        private void ActivarDrawLine_Button(object sender, EventArgs e)\r\n        {\r\n            IsValidDrawLine = true;\r\n            IsValidDrawCircle = false;\r\n        }\r\n\r\n        private void ActivarDrawCircle_Button(object sender, EventArgs e)\r\n        {\r\n            IsValidDrawLine = false;\r\n            IsValidDrawCircle = true;\r\n        }\r\n    }\r\n}\u0060",
        "createdAt": "2024-04-18T16:26:35",
        "reactions": []
      }
    ]
  }
}