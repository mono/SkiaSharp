{
  "number": 3178,
  "type": "issue",
  "state": "closed",
  "title": "[BUG] iOS: Crash when GC collects SKMetalView resources",
  "body": "### Description\n\nSkiaSharp v3.116.1\n.Net 9\nmaui                       9.0.0/9.0.100         SDK 9.0.100  \nmaui-ios                   9.0.0/9.0.100         SDK 9.0.100  \nIDE: JetBrains Rider\n\nIn our app we have several views, one of which contains an SKMetalView. Every time the GC runs to collect resources, the app crashes with the following stack:\n\n\u0060\u0060\u0060\nat \u003Cunknown\u003E \u003C0xffffffff\u003E\n\t  at SkiaSharp.SkiaApi:gr_direct_context_abandon_context \u003C0x00007\u003E\n\t  at SkiaSharp.GRContext:AbandonContext \u003C0x0010f\u003E\n\t  at SkiaSharp.GRContext:DisposeNative \u003C0x00083\u003E\n\t  at SkiaSharp.SKNativeObject:Dispose \u003C0x001c3\u003E\n\t  at SkiaSharp.SKObject:Dispose \u003C0x0007b\u003E\n\t  at SkiaSharp.GRContext:Dispose \u003C0x0007b\u003E\n\t  at SkiaSharp.SKNativeObject:Finalize \u003C0x000a7\u003E\n\t  at System.Object:runtime_invoke_virtual_void__this__ \u003C0x00087\u003E\n\u0060\u0060\u0060\n\n\n### Code\n\nTo reproduce the issue [SkiaSharpSample:](https://github.com/AlisiaNew/SkiaSharpSample)\n1. Click Open Skia Screen, then go back\n2. Click Open Text Screen, then go back\n3. Repeat steps 1 and 2 and the app will crash\n\n\n\n### Expected Behavior\n\n_No response_\n\n### Actual Behavior\n\n_No response_\n\n### Version of SkiaSharp\n\n3.116.0 (Current)\n\n### Last Known Good Version of SkiaSharp\n\n2.88.9 (Previous)\n\n### IDE / Editor\n\nOther (Please indicate in the description)\n\n### Platform / Operating System\n\niOS\n\n### Platform / Operating System Version\n\niOS 17.5\niOS 18.2\n\n### Devices\n\n_No response_\n\n### Relevant Screenshots\n\n_No response_\n\n### Relevant Log Output\n\n\u0060\u0060\u0060shell\nat \u003Cunknown\u003E \u003C0xffffffff\u003E\n\t  at SkiaSharp.SkiaApi:gr_direct_context_abandon_context \u003C0x00007\u003E\n\t  at SkiaSharp.GRContext:AbandonContext \u003C0x0010f\u003E\n\t  at SkiaSharp.GRContext:DisposeNative \u003C0x00083\u003E\n\t  at SkiaSharp.SKNativeObject:Dispose \u003C0x001c3\u003E\n\t  at SkiaSharp.SKObject:Dispose \u003C0x0007b\u003E\n\t  at SkiaSharp.GRContext:Dispose \u003C0x0007b\u003E\n\t  at SkiaSharp.SKNativeObject:Finalize \u003C0x000a7\u003E\n\t  at System.Object:runtime_invoke_virtual_void__this__ \u003C0x00087\u003E\n\u0060\u0060\u0060\n\n### Code of Conduct\n\n- [x] I agree to follow this project\u0027s Code of Conduct",
  "author": {
    "login": "AlisiaNew",
    "type": "User"
  },
  "labels": [
    {
      "name": "type/bug",
      "color": "fc2929"
    }
  ],
  "assignees": [],
  "createdAt": "2025-02-28T19:13:03",
  "updatedAt": "2025-08-22T20:40:53",
  "closedAt": "2025-08-22T20:40:53",
  "commentCount": 26,
  "reactionCount": 3,
  "engagement": {
    "syncedAt": "2026-02-06T13:25:10.0761327Z",
    "reactions": [
      {
        "user": "jeremy-visionaid",
        "content": "\u002B1",
        "createdAt": "2026-02-06T13:25:10.0761548Z"
      },
      {
        "user": "alex-bozhko",
        "content": "\u002B1",
        "createdAt": "2026-02-06T13:25:10.0761557Z"
      },
      {
        "user": "ghishadow",
        "content": "\u002B1",
        "createdAt": "2026-02-06T13:25:10.076156Z"
      }
    ],
    "comments": [
      {
        "id": 2837437885,
        "author": "jeremy-visionaid",
        "body": "Interesting, I\u0027ve also experienced an occasional crash using SKMetalView too - might be the same as this one. I notice that the backend context is created twice with the default constructor. So, related in a sense, but probably won\u0027t fix this issue:\n\nhttps://github.com/mono/SkiaSharp/pull/3256",
        "createdAt": "2025-04-29T04:45:58",
        "reactions": []
      },
      {
        "id": 2840443009,
        "author": "jeremy-visionaid",
        "body": "OK, what I\u0027m seeing is definitely the same problem as described here. It occurs on both iOS and MacCatalyst. As the original stack trace shows, there\u0027s a bug disposing/finalizing GRContext with the Metal backend. SKMetalView isn\u0027t even required to repro - just creating two \u0060GRContext\u0060s and disposing them is enough:\n\n\u0060\u0060\u0060C#\n        CreateAndDisposeMetalContext();\n        CreateAndDisposeMetalContext();\n\n        private static void CreateAndDisposeMetalContext()\n        {\n            var device = MTLDevice.SystemDefault!;\n            using (GRMtlBackendContext backendContext = new()\n            {\n                Device = device,\n                Queue = device.CreateCommandQueue(),\n            })\n            {\n                using GRContext context = GRContext.CreateMetal(backendContext);\n            }\n\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n        }\n\u0060\u0060\u0060\n\nI\u0027ll have a look into fixing it, or at least adding the above as a unit test.\n\n\n\n",
        "createdAt": "2025-04-29T23:18:37",
        "reactions": []
      },
      {
        "id": 2840741479,
        "author": "jeremy-visionaid",
        "body": "So, the above code was based on what SKMetalView was doing... The actual crash is coming from here\n\n\u0060\u0060\u0060\nThread 35 Crashed:: .NET Long Running Task\n0   libdispatch.dylib             \t       0x18f9c6c7c _dispatch_semaphore_dispose.cold.1 \u002B 40\n1   libdispatch.dylib             \t       0x18f993e0c _dispatch_semaphore_dispose \u002B 72\n2   libdispatch.dylib             \t       0x18f9924e4 _dispatch_dispose \u002B 208\n3   libdispatch.dylib             \t       0x18f99232c dispatch_release \u002B 152\n4   Metal                         \t       0x19ac8526c -[_MTLCommandQueue dealloc] \u002B 172\n5   IOGPU                         \t       0x1b145fa94 -[IOGPUMetalCommandQueue dealloc] \u002B 112\n6   AGXMetalG14X                  \t       0x11a34a230 -[AGXG14XFamilyCommandQueue dealloc] \u002B 84\n7   SkiaSharp.Tests.Devices       \t       0x102c85988 xamarin_dyn_objc_msgSend \u002B 160 (trampolines-arm64-objc_msgSend.inc.s:99)\n8   SkiaSharp.Tests.Devices       \t       0x1030278e4 do_icall \u002B 160 (interp.c:2268)\n9   SkiaSharp.Tests.Devices       \t       0x103025f20 do_icall_wrapper \u002B 356 (interp.c:2350)\n10  SkiaSharp.Tests.Devices       \t       0x10301b500 mono_interp_exec_method \u002B 2832\n11  SkiaSharp.Tests.Devices       \t       0x103019114 interp_runtime_invoke \u002B 244 (interp.c:2109)\n12  SkiaSharp.Tests.Devices       \t       0x102f67420 mono_jit_runtime_invoke \u002B 1320 (mini-runtime.c:3683)\n13  SkiaSharp.Tests.Devices       \t       0x102f07de8 do_runtime_invoke \u002B 60 (object.c:2576) [inlined]\n14  SkiaSharp.Tests.Devices       \t       0x102f07de8 mono_runtime_invoke_checked \u002B 148 (object.c:2792)\n15  SkiaSharp.Tests.Devices       \t       0x102f0f3ec mono_runtime_try_invoke_byrefs \u002B 548 (object.c:5176)\n16  SkiaSharp.Tests.Devices       \t       0x102ecc070 ves_icall_InternalInvoke \u002B 236 (icall.c:3615)\n17  SkiaSharp.Tests.Devices       \t       0x102ed5e88 ves_icall_InternalInvoke_raw \u002B 100 (icall-def.h:371)\n18  SkiaSharp.Tests.Devices       \t       0x10302794c do_icall \u002B 264 (interp.c:2298)\n19  SkiaSharp.Tests.Devices       \t       0x103025f58 do_icall_wrapper \u002B 412 (interp.c:2354)\n20  SkiaSharp.Tests.Devices       \t       0x10301b500 mono_interp_exec_method \u002B 2832\n21  SkiaSharp.Tests.Devices       \t       0x103019114 interp_runtime_invoke \u002B 244 (interp.c:2109)\n22  SkiaSharp.Tests.Devices       \t       0x102f67420 mono_jit_runtime_invoke \u002B 1320 (mini-runtime.c:3683)\n23  SkiaSharp.Tests.Devices       \t       0x102f07de8 do_runtime_invoke \u002B 60 (object.c:2576) [inlined]\n24  SkiaSharp.Tests.Devices       \t       0x102f07de8 mono_runtime_invoke_checked \u002B 148 (object.c:2792)\n25  SkiaSharp.Tests.Devices       \t       0x102f1c560 start_wrapper_internal \u002B 524 (threads.c:1213) [inlined]\n26  SkiaSharp.Tests.Devices       \t       0x102f1c560 start_wrapper \u002B 592 (threads.c:1271)\n27  libsystem_pthread.dylib       \t       0x18fb49c0c _pthread_start \u002B 136\n28  libsystem_pthread.dylib       \t       0x18fb44b80 thread_start \u002B 8\n\u0060\u0060\u0060\n\nI can\u0027t say I\u0027m familiar with Apple APIs or Objective C (and especially not Apple interop). But it looks/feels like a double free situation (i.e. abandonContext freeing the command queue followed by the finalizer). If I manually call retain on the command queue then it at least doesn\u0027t crash, but I\u0027m not sure if this is just masks the problem or causes a leak in its place:\n\n\u0060\u0060\u0060C#\nNSObject o = NSObject.FromObject(commandQueue);\no.DangerousRetain();\n\u0060\u0060\u0060\n\nI\u0027ve put in a draft pull request with a unit test and a proof of concept for the retain. Hopefully @mattleibow can take a look/take over!",
        "createdAt": "2025-04-30T04:01:15",
        "reactions": [
          {
            "user": "AlisiaNew",
            "content": "\u002B1",
            "createdAt": "2026-02-06T13:25:05.1312033Z"
          }
        ]
      },
      {
        "id": 2843658735,
        "author": "jeremy-visionaid",
        "body": "Some bits in Skia showing use of retain for the backend context. Looks like it calls through to CFRetain on the command buffer when creating a test context:\n\nhttps://skia.googlesource.com/skia/\u002B/7755e6ab0bc0/tools/gpu/mtl/MtlTestContext.mm\n\n",
        "createdAt": "2025-04-30T23:21:15",
        "reactions": []
      },
      {
        "id": 2954113600,
        "author": "taublast",
        "body": "Randomly (1 out of 3) getting this on iPhone when navigating away from a page:\n\n\u0060\u0060\u0060xml\n=================================================================\n  Managed Stacktrace:\n=================================================================\n    at \u003Cunknown\u003E \u003C0xffffffff\u003E\n    at SkiaSharp.SkiaApi:gr_direct_context_abandon_context \u003C0x00042\u003E\n    at SkiaSharp.GRContext:AbandonContext \u003C0x0006a\u003E\n    at SkiaSharp.GRContext:DisposeNative \u003C0x0001e\u003E\n    at SkiaSharp.SKNativeObject:Dispose \u003C0x000cc\u003E\n    at SkiaSharp.SKObject:Dispose \u003C0x00020\u003E\n    at SkiaSharp.GRContext:Dispose \u003C0x00020\u003E\n    at SkiaSharp.SKNativeObject:Finalize \u003C0x0003a\u003E\n    at System.Object:runtime_invoke_virtual_void__this__ \u003C0x00090\u003E\n    at \u003Cunknown\u003E \u003C0x00000\u003E\n=================================================================\n\nINFO:   Basic Fault Address Reporting\n=================================================================\nMemory around native instruction pointer (0x193a27aa4):0x193a27a94  00 00 00 ea 6d ff \nINFO: ff 54 10 7c 5f c8 02 82 7d 92  ....m..T.|_...}.\n0x193a27aa4  51 10 40 f9 f1 02 10 36 d0 03 00 36 11 fe 6c d3  Q.@....6...6\n\u0060\u0060\u0060\n\nSo i can easily reproduce.. Dunno how this could help though?\n\nA silly app-level workaround is to stop updating skglview when navigating away from page, so the grcontext is not in use after Dispose(false) is called maybe, something like that. \n\nThis is very similar to Windows double-buffered rendering, when you have queued renderings, you \u0022think\u0022 you stopped the rendering and you call dispose/anything destroying and a queued backbuffer is still using some resources = crash. \nGuess here its same, as metal rendering is async too. \nJust that not many people use skglview on windows so we do not hear much from this: https://github.com/mono/SkiaSharp/issues/1490",
        "createdAt": "2025-06-08T14:38:52",
        "reactions": []
      },
      {
        "id": 2954126277,
        "author": "taublast",
        "body": "To reproduce the crash: one can use an SKGLView with either \u0060HasRenderLoop\u0060 set to \u0060true\u0060 or other fast updating means, so it\u0027s updating non-stop when you navigate from a page with it inside. This way we can reproduce a collision between Dispose (calls AbandonContext) and a queued rendering that accesses released resources.   \n\nWorks for both iOS and Windows.\n\nEDIT: Just catched another randomly happening crash on iOS when navigating away from a page with a non-metal SKCanvas (not SKGLView) view, but it had a native metal view inside:\n\n\u0060\u0060\u0060xml\nThread 2 name:  Finalizer\nThread 2 Crashed:\n0   libobjc.A.dylib                        0x193a27aa4 objc_release \u002B 16\n1   libSkiaSharp                           0x10150841c 0x101208000 \u002B 3146780\n2   libSkiaSharp                           0x101508480 0x101208000 \u002B 3146880\n3   libSkiaSharp                           0x101405728 0x101208000 \u002B 2086696\n4   XXX.Mobile                       0x100810654 do_icall \u002B 124\n5   XXX.Mobile                       0x10080ece8 do_icall_wrapper \u002B 348\n6   XXX.Mobile                       0x100802260 mono_interp_exec_method \u002B 2580\n7   XXX.Mobile                       0x1007ff618 interp_entry_from_trampoline \u002B 656\n8   XXX.Mobile                       0x1005b5970 native_to_interp_trampoline \u002B 112\n9   XXX.Mobile                       0x1007ac380 mono_gc_run_finalize \u002B 588\n10  XXX.Mobile                       0x1006d9144 sgen_gc_invoke_finalizers \u002B 264\n11  XXX.Mobile                       0x1007ad594 finalizer_thread \u002B 768\n12  XXX.Mobile                       0x10078a9c8 start_wrapper \u002B 348\n13  libsystem_pthread.dylib                0x1e55040ec _pthread_start \u002B 115\n14  libsystem_pthread.dylib                0x1e550272c thread_start \u002B 7\n\u0060\u0060\u0060\n\n\u0060mono_gc_run_finalize\u0060.. ok maybe its mono runtime GC\u0027ing something not recognized as being still in use?",
        "createdAt": "2025-06-08T15:05:32",
        "reactions": []
      },
      {
        "id": 2956339788,
        "author": "taublast",
        "body": "Fixed what was happening for me inside a custom handler, sharing for what it\u0027s worth. Can\u0027t say in general.\nWhat was happening for me:\n\ninside \u0060public class SKMetalView\u0060 (SkiaSharp current code in main branch) we create \n\u0060\u0060\u0060\n            _backendContext = new GRMtlBackendContext\n            {\n                Device = _device,\n                Queue = _device.CreateCommandQueue() // this queue will get killed by GC collect, triggered either by runtime, or by MAUI code when disconnecting handler. No idea why, this makes me thing of .net runtime issue.\n            };\n\u0060\u0060\u0060\nthen we use it inside \u0060void IMTKViewDelegate.Draw(MTKView view)\u0060:\n\u0060\u0060\u0060\nusing var commandBuffer = _backendContext.Queue.CommandBuffer();\n\u0060\u0060\u0060\n\nAnd it looks like \u0060commandBuffer\u0060 is using native resources from \u0060Queue\u0060. So if the \u0060commandBuffer\u0060 finalizer is called after the \u0060Queue\u0060 was disposed we get a crash trying to dispose some already disposed resources.\n\n\u0060Queue\u0060 can be disposed *for some reason* after \u0060base\u0060 is called inside the handler \u0060protected override void DisconnectHandler(SKMetalView platformView)\u0060. Or later depending on the GC pressure, this creates random situations.\n\nIf \u0060commandBuffer\u0060 is disposed (notice \u0060using\u0060) after that (randomless\u002B\u002B) we suffer:\n\n\u0060\u0060\u0060xml\n at \u003Cunknown\u003E \u003C0xffffffff\u003E\n\t  at ObjCRuntime.Messaging:void_objc_msgSend \u003C0x00098\u003E\n\t  at ObjCRuntime.BaseWrapper:Release \u003C0x00096\u003E\n\t  at CoreFoundation.NativeObject:Dispose \u003C0x00062\u003E\n\t  at ObjCRuntime.DisposableObject:Finalize \u003C0x00028\u003E\n\t  at System.Object:runtime_invoke_virtual_void__this__ \u003C0x00090\u003E\n\t  at \u003Cunknown\u003E \u003C0x00000\u003E\n\u0060\u0060\u0060\n\nSo the fix for \u0060SKMetalView\u0060 was to pin the queue inside \u0060private void Initialize()\u0060:\n\n\u0060\u0060\u0060\n _queuePin = GCHandle.Alloc(_backendContext.Queue, GCHandleType.Pinned);\n\u0060\u0060\u0060\n\nand unpin inside \u0060Dispose\u0060:\n\n\u0060\u0060\u0060\n if (_queuePin.IsAllocated)\n {\n     _queuePin.Free();\n }\n\u0060\u0060\u0060\n\nI hope this could help.",
        "createdAt": "2025-06-09T16:47:11",
        "reactions": []
      },
      {
        "id": 2957113458,
        "author": "jeremy-visionaid",
        "body": "@taublast I don\u0027t think that\u0027s quite correct. The crash occurs on dispose - preventing the GC/finalization doesn\u0027t help with that, since it can be made to happen deterministically:\n\nhttps://github.com/mono/SkiaSharp/compare/main...jeremy-visionaid:SkiaSharp:grcontext-metal-finalizer",
        "createdAt": "2025-06-09T21:48:05",
        "reactions": []
      },
      {
        "id": 2957701581,
        "author": "taublast",
        "body": "@jeremy-visionaid sure, it\u0027s all possible, i\u0027m not an expert. Like i said, fixed the crash for myself and wanted to share.",
        "createdAt": "2025-06-10T05:12:39",
        "reactions": []
      },
      {
        "id": 3198676006,
        "author": "mattleibow",
        "body": "Looking at the apple docs: https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Cmd-Submiss/Cmd-Submiss.html#//apple_ref/doc/uid/TP40014221-CH3-SW14\n\n\n\n\u003E **Command Queue**\n\u003E A command queue accepts an ordered list of command buffers that the GPU will execute. All command buffers sent to a single queue are guaranteed to execute in the order in which the command buffers were enqueued. In general, command queues are thread-safe and allow multiple active command buffers to be encoded simultaneously.\n\u003E \n\u003E To create a command queue, call either the [newCommandQueue](https://developer.apple.com/documentation/metal/mtldevice/1433388-newcommandqueue) method or the [newCommandQueueWithMaxCommandBufferCount:](https://developer.apple.com/documentation/metal/mtldevice/1433433-makecommandqueue) method of a [MTLDevice](https://developer.apple.com/documentation/metal/mtldevice) object. In general, **command queues are expected to be long-lived, so they should not be repeatedly created and destroyed**.",
        "createdAt": "2025-08-18T23:04:22",
        "reactions": []
      },
      {
        "id": 3198685161,
        "author": "jeremy-visionaid",
        "body": "Yeah, the trouble here though appears to be that Skia itself is destroying the command queue, which I believe is the cause of the crash. In the upstream tests, they add a retain:\nhttps://skia.googlesource.com/skia/\u002B/7755e6ab0bc0/tools/gpu/mtl/MtlTestContext.mm#48\n\nMaybe we need to ask on the Skia forums about what\u0027s expected from the caller there...",
        "createdAt": "2025-08-18T23:10:47",
        "reactions": []
      },
      {
        "id": 3198729772,
        "author": "mattleibow",
        "body": "I am asking here, so we shall see: https://groups.google.com/g/skia-discuss/c/fYp8lLue4zU",
        "createdAt": "2025-08-18T23:41:01",
        "reactions": [
          {
            "user": "jeremy-visionaid",
            "content": "\u002B1",
            "createdAt": "2026-02-06T13:25:07.0444279Z"
          }
        ]
      },
      {
        "id": 3198746017,
        "author": "mattleibow",
        "body": "There is an incredible amount of \u0022no retain\u0022 words in this block:\n\nhttps://github.com/google/skia/blob/main/src/gpu/ganesh/mtl/GrMtlGpu.mm#L49-L75\n\nI am wondering if we are _supposed_ to retain?",
        "createdAt": "2025-08-18T23:52:28",
        "reactions": []
      },
      {
        "id": 3198777089,
        "author": "mattleibow",
        "body": "Lookin at instruments with an app, I see the ques being created and then they disappear as well - this is with the dangerous retain. Very interesting. I wonder what the latest skia does and if this is a currect skia bug or an always skia bug. Or a feature.",
        "createdAt": "2025-08-19T00:08:00",
        "reactions": []
      },
      {
        "id": 3198808575,
        "author": "jeremy-visionaid",
        "body": "Oh, is this a problem? Looks like it resets some smart pointers and then it immediately goes out of scope...\n\n\u0060\u0060\u0060C\u002B\u002B\nsk_sp\u003CGrDirectContext\u003E GrDirectContext::MakeMetal(void* device, void* queue,\n                                                  const GrContextOptions\u0026 options) {\n    sk_sp\u003CGrDirectContext\u003E direct(new GrDirectContext(GrBackendApi::kMetal, options));\n    GrMtlBackendContext backendContext = {};\n    backendContext.fDevice.reset(device);\n    backendContext.fQueue.reset(queue);\n\n    return GrDirectContext::MakeMetal(backendContext, options);\n}\n\u0060\u0060\u0060\n\nIt\u0027s a deprecated function, and doesn\u0027t look like the first GrDirectContext is even used...",
        "createdAt": "2025-08-19T00:27:04",
        "reactions": []
      },
      {
        "id": 3198841877,
        "author": "mattleibow",
        "body": "Ooh, that is what we are using and it looks so weird. \n\nThis is the one we are suppsoed to be using and it looks like somehting got lost in the migration:\n\n\u0060\u0060\u0060cpp\nsk_sp\u003CGrDirectContext\u003E GrDirectContext::MakeMetal(const GrMtlBackendContext\u0026 backendContext,\n                                                     const GrContextOptions\u0026 options) {\n    sk_sp\u003CGrDirectContext\u003E direct(new GrDirectContext(GrBackendApi::kMetal, options));\n\n    direct-\u003EfGpu = GrMtlTrampoline::MakeGpu(backendContext, options, direct.get());\n    if (!direct-\u003Einit()) {\n        return nullptr;\n    }\n\n    return direct;\n}\n\u0060\u0060\u0060\n\n**EDIT**\n\nI see the deprecated calls this one eventually. And options is null/the default object, so a duplicate is probably not a problem.\n\nThe \u0022reset\u0022 is just the way the pointers work to \u0022set\u0022 the value. It is effectively constructing a \u0060GrMtlBackendContext\u0060 object and then passing that to this function.",
        "createdAt": "2025-08-19T00:51:37",
        "reactions": []
      },
      {
        "id": 3198864300,
        "author": "jeremy-visionaid",
        "body": "Yeah, I can\u0027t say whether it matters or not without poking at it, but the deprecated named constructor looks sketchy to me. I haven\u0027t compiled the native bits on mac before, but otherwise looks simple enough to at least do a quick hack to try out calling the other one... I imagine you\u0027d beat me to it \uD83D\uDE06 ",
        "createdAt": "2025-08-19T01:06:29",
        "reactions": []
      },
      {
        "id": 3198891278,
        "author": "mattleibow",
        "body": "Other places do things like this:\n\n\nexternals/skia/tools/gpu/mtl/MtlTestContext.mm:\n\n\u0060\u0060\u0060mm\nbackendContext.fDevice.retain((GrMTLHandle)device.get());\nsk_cfp\u003Cid\u003CMTLCommandQueue\u003E\u003E queue([*device newCommandQueue]);\nbackendContext.fQueue.retain((GrMTLHandle)queue.get());\n\u0060\u0060\u0060\n\nexternals/skia/tools/window/MetalWindowContext.mm:\n\n\u0060\u0060\u0060mm\nGrMtlBackendContext backendContext = {};\nbackendContext.fDevice.retain((GrMTLHandle)fDevice.get());\nbackendContext.fQueue.retain((GrMTLHandle)fQueue.get());\n\u0060\u0060\u0060\n\nSo I think we are supposed to?",
        "createdAt": "2025-08-19T01:25:22",
        "reactions": []
      },
      {
        "id": 3198907608,
        "author": "mattleibow",
        "body": "I reviewed your PR and I tihnk for now, since the only place we own the queue is the SKMetalView, we should keep the retain there.\n\nAs soon as we have more data we can change.\n\nI don\u0027t want to inadvertantly retain and then behaviour happens as a result and we can\u0027t revert. Maybe Google will say something exciting and we will be \u0022oh yeah, that was smart! Good call Google\u0022 or something.",
        "createdAt": "2025-08-19T01:28:08",
        "reactions": []
      },
      {
        "id": 3198917451,
        "author": "mattleibow",
        "body": "We also need to test this on an actual iOS device. ",
        "createdAt": "2025-08-19T01:30:50",
        "reactions": []
      },
      {
        "id": 3198925943,
        "author": "jeremy-visionaid",
        "body": "I\u0027m wondering if the retains there are also to workaround the local scoping issues of GrMtlBackendContext \uD83E\uDD14  As an interrim thing, I don\u0027t think retaining in SKMetalView is too bad. It would at least fix the crashes that SkiaSharp users are currently getting, even if GRContext disposal were still broken without others needing to do an explicit retain. But if you\u0027ve got a few more days then we can wait to see what the Skia guys say and/or I could try another approach.",
        "createdAt": "2025-08-19T01:35:46",
        "reactions": []
      },
      {
        "id": 3198971224,
        "author": "jeremy-visionaid",
        "body": "@mattleibow Do you know which version of XCode the native deps are expected to build against so I can build the native deps locally (it doesn\u0027t look like XCode 16.4/macOS 15.5 SDK works)? I can only see the container is macos14...",
        "createdAt": "2025-08-19T02:05:34",
        "reactions": []
      },
      {
        "id": 3202325023,
        "author": "jeremy-visionaid",
        "body": "Ah, nvm, #3058 is sufficient to fix the local build",
        "createdAt": "2025-08-19T21:40:25",
        "reactions": []
      },
      {
        "id": 3202380162,
        "author": "jeremy-visionaid",
        "body": "Now that I have a local native build, here\u0027s a quick and dirty hack to show the sketchy constructor in Skia is the cause of the problem:\n\n\u0060\u0060\u0060C\u002B\u002B\nsk_sp\u003CGrDirectContext\u003E GrDirectContext::MakeMetal(void* device, void* queue,\n                                                  const GrContextOptions\u0026 options) {\n    GrMtlBackendContext *backendContext = new GrMtlBackendContext();\n    backendContext-\u003EfDevice.reset(device);\n    backendContext-\u003EfQueue.reset(queue);\n\n    return GrDirectContext::MakeMetal(*backendContext, options);\n}\n\u0060\u0060\u0060\n\nCherry-picking the unit test commit on top, the test passes. So, I\u0027d say that my proposed fix is near enough equivalent for the queue at least but without the leak (though it would still leave a potential issue for removable metal devices).\n\nAn alternative approach might be to tie GrMtlBackendContext to the GrDirectContext lifetime on the managed side. WDYT @mattleibow ?",
        "createdAt": "2025-08-19T22:02:40",
        "reactions": []
      },
      {
        "id": 3202839120,
        "author": "mattleibow",
        "body": "Are you saying removing the dodgy line is all it takes to fix it?",
        "createdAt": "2025-08-19T23:20:26",
        "reactions": []
      },
      {
        "id": 3203016619,
        "author": "jeremy-visionaid",
        "body": "I\u2019m saying that it might be either the scope of the context or that they called reset instead of retain: https://github.com/mono/SkiaSharp/pull/3258#discussion_r2286464628\n",
        "createdAt": "2025-08-19T23:40:10",
        "reactions": []
      }
    ]
  }
}