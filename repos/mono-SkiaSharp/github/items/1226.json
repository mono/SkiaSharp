{
  "number": 1226,
  "type": "issue",
  "state": "closed",
  "title": "[BUG] If SKCanvasView is inside CollectionView, PaintSurface is not called upon reusing CollectionView DataTemplate",
  "body": "**Description**\r\n\r\nHaving SKCanvasView in CollectionView in Xamarin.Forms causing not all items are displayed properly: when they are reused, InvalidateSurface() is not being called.\r\n\r\nIt happens only on iOS (tested on 13.4), on Android, it seems to work ok.\r\nTested on XF 4.5.0.617 and 4.5.0.530- both same\r\nSkiaSharp.Views.Forms 1.68.1.1\r\n\r\n**Code**\r\n\r\nOpen attached project, and run on iOS\r\n[CollectionViewBug.zip](https://github.com/mono/SkiaSharp/files/4462946/CollectionViewBug.zip)\r\n\r\nIf you see the debug output log, you could also see that on iOS, after you scroll out the first page, it does not call SKCanvasViewIconListItem_PaintSurface to paint the new items scrolled into the view.\r\nOn Android, you could see that SKCanvasViewIconListItem_PaintSurface is called for every item as you scroll.\r\n\r\n**Expected Behavior**\r\n\r\nTo display all items in CollectionView properly by calling SKCanvasViewIconListItem_PaintSurface  even on the reused items.\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  1.68.1.1\r\n- IDE:  Visual Studio 16.5.3\r\n- Platform Target Frameworks: \r\n  - iOS:  13.4\r\n\r\n**Screenshots**\r\n\r\nAndroid: OK, numbers are 1..150\r\n\r\n![android](https://user-images.githubusercontent.com/9251057/79015206-9f72b280-7b6c-11ea-9195-bb982d06f874.png)\r\n\r\n---------------------\r\n\r\niOS: NOT OK, after scrolling out first page and reaching number 40th, listitems are being reused, PaintSurface() is not called on them - so they display \u0022old\u0022 drawings.\r\n\r\n![ios](https://user-images.githubusercontent.com/9251057/79015264-baddbd80-7b6c-11ea-9ab4-d2e74497cdb1.png)\r\n\r\n\r\n",
  "author": {
    "login": "zoli13",
    "type": "User"
  },
  "labels": [
    {
      "name": "status/wontfix",
      "color": "B8EC4A"
    }
  ],
  "assignees": [],
  "createdAt": "2020-04-10T18:51:39",
  "updatedAt": "2022-08-19T06:02:03",
  "closedAt": "2020-04-11T17:44:23",
  "commentCount": 4,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T14:12:40.1395695Z",
    "reactions": [],
    "comments": [
      {
        "id": 612233727,
        "author": "mattleibow",
        "body": "Thanks for the detailed bug and the simple repro! Made it easy get testing.\r\n\r\nThis is technically \u0022by design\u0022 because there is no way of the items knowing that they need to redraw. The case with Android is that it just works because the Android OS always redraws when a view moves or changes parent - when it is moved from the top of the list to the bottom. iOS is far less verbose and if nothing changes, then there is no need to redraw.\r\n\r\nThe simple way to do this is to just trigger a redraw on the binding change:\r\n\r\n\u0060\u0060\u0060xaml\r\n\u003Cskia:SKCanvasView BindingContextChanged=\u0022SKCanvasViewIconListItem_BindingContextChanged\u0022 /\u003E\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060csharp\r\nprivate void SKCanvasViewIconListItem_BindingContextChanged(object sender, EventArgs e)\r\n{\r\n\t(sender as SKCanvasView)?.InvalidateSurface();\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2020-04-10T21:51:21",
        "reactions": [
          {
            "user": "felipecastagnarodecarvalho",
            "content": "\u002B1",
            "createdAt": "2026-02-06T14:12:39.4582171Z"
          }
        ]
      },
      {
        "id": 612421769,
        "author": "zoli13",
        "body": "Thanks the quick response, I had similar suspicion as well.\r\nI tried the workaround, and it solves the problem - it works fine. Maybe should be called only on iOS, to prevent multiple redraw on Android? Although, Android implementation can also change by time, so maybe better to remain on the safe side...\r\nAs this is by \u0022design\u0022, and there is a way to force the canvas to redraw, we should close?\r\n",
        "createdAt": "2020-04-11T13:30:28",
        "reactions": []
      },
      {
        "id": 612474181,
        "author": "mattleibow",
        "body": "To make things easier for you, you can just create a custom control and use that:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class AutoCanvasView : SKCanvasView\r\n{\r\n    protected override void OnBindingContextChanged()\r\n    {\r\n        base.OnBindingContextChanged();\r\n\r\n        InvalidateSurface();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nOr you can look into creating a behaviour so that you can convert an event into a \u0060Command\u0060 that you can use in the view model: https://dotnetdevaddict.co.za/2017/07/13/turning-events-into-commands/\r\n\r\n\u0060\u0060\u0060xaml\r\n\u003Cviews:SKCanvasView\u003E\r\n\u00A0\u00A0\u00A0\u00A0\u003Cviews:SKCanvasView.Behaviors\u003E\r\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u003Clocal:PaintSurfaceCommandBehavior Command=\u0022{Binding PaintCommand}\u0022 /\u003E\r\n\u00A0\u00A0\u00A0\u00A0\u003C/views:SKCanvasView.Behaviors\u003E\r\n\u003C/views:SKCanvasView\u003E\r\n\u0060\u0060\u0060\r\n\r\nYou can also combine the two to have a command and auto update:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class AutoCanvasView : SKCanvasView\r\n{\r\n    protected override void OnBindingContextChanged()\r\n    {\r\n        base.OnBindingContextChanged();\r\n\r\n        InvalidateSurface();\r\n    }\r\n\r\n    public static readonly BindableProperty PaintCommandProperty =\r\n        BindableProperty.Create(\r\n            nameof(PaintCommand),\r\n            typeof(ICommand),\r\n            typeof(AutoCanvasView),\r\n            null,\r\n            propertyChanged: (b, o, n) =\u003E ((AutoCanvasView)b).InvalidateSurface());\r\n\r\n    public ICommand PaintCommand\r\n    {\r\n        get =\u003E (ICommand)GetValue(PaintCommandProperty);\r\n        set =\u003E SetValue(PaintCommandProperty, value);\r\n    }\r\n\r\n    protected override void OnPaintSurface(SKPaintSurfaceEventArgs e)\r\n    {\r\n        base.OnPaintSurface(e);\r\n\r\n        if (PaintCommand?.CanExecute(e) == true)\r\n            PaintCommand.Execute(e);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2020-04-11T17:40:23",
        "reactions": [
          {
            "user": "eli191",
            "content": "\u002B1",
            "createdAt": "2026-02-06T14:12:39.8867419Z"
          }
        ]
      },
      {
        "id": 612474879,
        "author": "mattleibow",
        "body": "Closing this as it is by design to not trigger a redraw when the binding context changes.",
        "createdAt": "2020-04-11T17:43:58",
        "reactions": []
      }
    ]
  }
}