{
  "number": 427,
  "type": "issue",
  "state": "closed",
  "title": "Problems constructing a long image",
  "body": "I have a use case along these lines\r\n- I have to obtain a png representing a floor map where an asset is located by asking where the asset is\r\n- The above operation is required to work for multiple assets in one go but grouped, such that if two or more assets are in the same floor, the png will be obtained twice but rendered once\r\n- If there are multiple distinct floor maps obtained (not every asset is on the same floor), then the floor maps should be rendered one below the other and a single image consisting of all the floor maps should be returned\r\n\r\nNow, I tried the following approach... (warning, the code is in F# not C#, so apologies if you are not comfortable with F#, but hopefully you can make out the logic)\r\n\u0060\u0060\u0060fsharp\r\n// renderPositionGroups takes a sequence of byte arrays \r\nlet renderPositionGroups (maps: Byte array seq) =\r\n\r\n    // get the image infos ahead of time in order to set the boundaries of the surface\r\n    let mapBitmaps = maps |\u003E Seq.map (fun m -\u003E SKBitmap.Decode(m))\r\n\r\n    // get the max width in order to set the width of the surface\r\n    let mapMaxWidth = mapBitmaps |\u003E Seq.map (fun m -\u003E m.Width) |\u003E Seq.max\r\n\r\n    // get the total of all maps in order to set the height of the surface\r\n    let mapTotalHeight = mapBitmaps |\u003E Seq.sumBy (fun m -\u003E m.Height)\r\n    \r\n    // initialize the surface with the max width and total height\r\n    use surface = SKSurface.Create(mapMaxWidth, mapTotalHeight, SKColorType.RgbaF16, SKAlphaType.Unpremul)\r\n\r\n    // get the canvas to draw on\r\n    use canvas = surface.Canvas\r\n    \r\n    // fold over the maps, passing through the accumulated height of the past images in order to vertically offset the next image\r\n    mapBitmaps\r\n    |\u003E Seq.fold (fun offset mapBitmap -\u003E\r\n        // draw the map on the canvas horizontally flush but vertically offset by the accumulated height so far\r\n        canvas.DrawBitmap(mapBitmap, 0.0f, offset)\r\n\r\n        // will eventually render some stuff on the floor map itself\r\n        // ...\r\n\r\n        // return the offset plus the height of the current map\r\n        offset \u002B (float32 mapBitmap.Height)\r\n    ) 0.0f // starting offset is 0\r\n    |\u003E ignore\r\n\r\n    surface.Snapshot().Encode().ToArray()\r\n\u0060\u0060\u0060\r\n\r\nNow, the approach seems to work with small test images, but as soon as I pass in the floor maps which are larger (around the 5000x5000 pixel range) the surface initialization starts resulting in null once the heights (or even widths) go past the low 10,000s. In other words, after the following expression \u0060use surface = SKSurface.Create(mapMaxWidth, mapTotalHeight, SKColorType.RgbaF16, SKAlphaType.Unpremul)\u0060 is evaluated, the value of \u0060surface\u0060 is \u0060null\u0060.\r\n\r\nI assume there must be a size limit of some kind? If so, are there any alternative techniques to merging/combining/appending images? I did consider shrinking the images before combining them but I don\u0027t think that is a scalable technique as with many small images you might still hit the size limit. And I was not able to grok any way to resize the surface itself. And I could not pick out any other append like operation in the docs so any help would be appreciated.",
  "author": {
    "login": "lambdakris",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2018-01-16T20:34:28",
  "updatedAt": "2022-08-19T18:01:47",
  "closedAt": "2018-03-07T23:23:41",
  "commentCount": 5,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T14:00:58.5906138Z",
    "reactions": [],
    "comments": [
      {
        "id": 358439059,
        "author": "mattleibow",
        "body": "What platform is this? I don\u0027t think this is the case, but it may be: could the device have a low memory space for the app?\r\n\r\nAlso, is there a particular reason you are using \u0060RgbaF16\u0060? What happens if you use \u0060Rgba8888\u0060 or \u0060Bgra8888\u0060 (rather use \u0060SKImageInfo.PlatformColorType\u0060 as this will automatically pick the correct color)?\r\n",
        "createdAt": "2018-01-17T20:44:45",
        "reactions": []
      },
      {
        "id": 358688380,
        "author": "lambdakris",
        "body": "The platform I\u0027m working on is Windows 10 with VS 2017 and .NET Core 2.0.\r\n\r\nNow, I think I might be doing something completely incorrectly because trying to create a minimal reproduction, I can\u0027t get it to work at all (plus for some reason GH won\u0027t let me upload the zip so below are instructions to repro manually)\r\n\r\nTo create the project, execute the following from a command line...\r\n\u0060\u0060\u0060\r\ndotnet new console -o repro -lang f#\r\ncd repro\r\ndotnet add package SkiaSharp\r\n\u0060\u0060\u0060\r\n\r\nNow, replace the content in the Program.fs file with the following...\r\n\r\n\u0060\u0060\u0060\r\nopen System\r\nopen SkiaSharp\r\n\r\n[\u003CEntryPoint\u003E]\r\nlet main argv =\r\n    \r\n    let surface = SKSurface.Create(50,50, SKColorType.Unknown, SKAlphaType.Unknown)\r\n    \r\n    if surface = null then Console.WriteLine(\u0022Surface is null\u0022) else Console.WriteLine(\u0022Surface is not null\u0022)\r\n\r\n    Console.WriteLine(\u0022Press any key to exit...\u0022)\r\n    Console.ReadKey() |\u003E ignore\r\n\r\n    0 // exit code\r\n\u0060\u0060\u0060\r\n\r\nWhat I see is that \u0060surface\u0060 is null everytime. Just in case I tried reproducing in a C# project and got the same. I also tried targeting \u0060net471\u0060 instead of \u0060netcoreapp2.0\u0060 but that didn\u0027t make a difference. Also tried targeting x86 and x64 instead of AnyCPU, but that also did not make a difference. \r\n\r\nI am certain there must be something that I\u0027m doing wrong but for the life of me I can\u0027t see it...\r\n",
        "createdAt": "2018-01-18T15:49:56",
        "reactions": []
      },
      {
        "id": 364187004,
        "author": "mattleibow",
        "body": "@lambdakris The reason is the color type and alpha type. To use the platform defaults I would recommend the overload that takes the \u0060SKImageInfo\u0060:\r\n\r\n    var surface = SKSurface.Create(new SKImageInfo(50, 50));\r\n\r\nIf you don\u0027t want to use that, then the color type can\u0027t be unknown, so you MUST use a specific type or the platform type: \u0060SKImageInfo.PlatformColorType\u0060. The same goes for the alpha type, use \u0060SKAlphaType.Premul\u0060.\r\n\r\nAll four parameters are used to determine how much memory to allocate.",
        "createdAt": "2018-02-08T17:29:20",
        "reactions": []
      },
      {
        "id": 364586677,
        "author": "lambdakris",
        "body": "Yeah, it may be that this has nothing to do with image size and I just lost track of what technique was giving what results. Give me a chance to try using SKImageInfo to create the canvas and I\u0027ll close the issue if it works.",
        "createdAt": "2018-02-09T22:23:28",
        "reactions": []
      },
      {
        "id": 371321721,
        "author": "lambdakris",
        "body": "Using SKImageInfo to create an SKSurface did resolve the issue. Thank you for your patience.",
        "createdAt": "2018-03-07T23:23:41",
        "reactions": [
          {
            "user": "mattleibow",
            "content": "\u002B1",
            "createdAt": "2026-02-06T14:00:58.5403769Z"
          }
        ]
      }
    ]
  }
}