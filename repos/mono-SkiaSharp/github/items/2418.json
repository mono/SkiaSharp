{
  "number": 2418,
  "type": "issue",
  "state": "open",
  "title": "[BUG] SkiaSharp is 50-75% less performant than Processing when drawing lines",
  "body": "**Description**\r\n\r\nIn [Processing](https://processing.org/), you can find a performance example demonstrating the rendering of 50,000 lines in an 800x600 window in \u0060Examples -\u003E Demos -\u003E Performance -\u003E LineRendering\u0060. This runs at 60fps. And processing can maintain this 60fps performance up to 70,000 lines being drawn, only dropping off of 60fps after that.\r\n\r\nI am using [SkiaSharp](https://github.com/mono/SkiaSharp) with [GLFW](https://www.glfw.org/) for windowing to do cross-platform windowing and graphics in F#. I wanted to check the performance of my windowing library, so I tried to replicate this Processing example. I was surprised that I couldn\u0027t hit 60fps, so I decided to drop down to using a raw for loop with just GLFW and SkiaSharp. To my surprise (since I originally assumed the performance was due to my framework), the performance didn\u0027t improve at all, so the performance bottleneck is in SkiaSharp. I was able to replicate the poor performance with Silk.NET\u0027s GLFW bindings (code is below) in place of my custom bindings.\r\n\r\nThe SkiaSharp performance ranges between 30-50fps and can even dip down below 30fps and seems to bounce around a lot. It hovers around 35-45fps. It also only uses 20-30% of the GPU and seems to default to using integrated graphics. For example, on my laptop and others, the SkiaSharp code defaults to Intel graphics instead of NVIDIA unless I force NVIDIA via the NVIDIA control panel or by disabling the Intel GPU. However, using the NVIDIA GPU does not increase the performance. These tests were done on a laptop with a 12th Gen i7, integrated Intel Iris Xe graphics, and a discrete NVIDIA RTX 3050.\r\n\r\n**Code**\r\n\r\nProcessing code:\r\n\r\n\u0060\u0060\u0060processing\r\npublic void setup() {\r\n  size(800, 600, P2D);  \r\n}\r\n  \r\npublic void draw() {    \r\n  background(255);\r\n  stroke(0, 10);\r\n  for (int i = 0; i \u003C 50000; i\u002B\u002B) {\r\n    float x0 = random(width);\r\n    float y0 = random(height);\r\n    float z0 = random(-100, 100);\r\n    float x1 = random(width);\r\n    float y1 = random(height);\r\n    float z1 = random(-100, 100);    \r\n    \r\n    // purely 2D lines will trigger the GLU \r\n    // tessellator to add accurate line caps,\r\n    // but performance will be substantially\r\n    // lower.\r\n    line(x0, y0, x1, y1); // this line is modified from the example to use a 2D line\r\n  }\r\n  if (frameCount % 10 == 0) println(frameRate);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nF# code that uses only the \u0060SkiaSharp\u0060 and \u0060Silk.NET\u0060 NuGet packages:\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen FSharp.NativeInterop\r\nopen Silk.NET.GLFW\r\nopen SkiaSharp\r\n#nowarn \u00229\u0022\r\n\r\nlet width, height = 800, 600\r\n\r\nlet glfw = Glfw.GetApi()\r\nglfw.Init() |\u003E printfn \u0022Initialized?: %A\u0022\r\n\r\n// Uncomment these window hints if on macOS\r\n//glfw.WindowHint(WindowHintInt.ContextVersionMajor, 3)\r\n//glfw.WindowHint(WindowHintInt.ContextVersionMinor, 3)\r\n//glfw.WindowHint(WindowHintBool.OpenGLForwardCompat, true)\r\n//glfw.WindowHint(WindowHintOpenGlProfile.OpenGlProfile, OpenGlProfile.Core)\r\n\r\nlet window = glfw.CreateWindow(width, height, \u0022Test Window\u0022, NativePtr.ofNativeInt 0n, NativePtr.ofNativeInt 0n)\r\nprintfn \u0022Window: %A\u0022 window\r\nglfw.MakeContextCurrent(window)\r\nlet mutable error = nativeint\u003Cbyte\u003E 1uy |\u003E NativePtr.ofNativeInt\r\nglfw.GetError(\u0026error) |\u003E printfn \u0022Error: %A\u0022\r\n\r\nlet grGlInterface = GRGlInterface.Create(fun name -\u003E glfw.GetProcAddress name)\r\n\r\nif not(grGlInterface.Validate()) then\r\n    raise (System.Exception(\u0022Invalid GRGlInterface\u0022))\r\n\r\nlet grContext = GRContext.CreateGl(grGlInterface)\r\nlet grGlFramebufferInfo = new GRGlFramebufferInfo(0u, SKColorType.Rgba8888.ToGlSizedFormat()) // 0x8058\r\nlet grBackendRenderTarget = new GRBackendRenderTarget(width, height, 1, 0, grGlFramebufferInfo)\r\nlet surface = SKSurface.Create(grContext, grBackendRenderTarget, GRSurfaceOrigin.BottomLeft, SKColorType.Rgba8888)\r\nlet canvas = surface.Canvas\r\ngrContext.ResetContext()\r\n\r\nlet random = System.Random()\r\n\r\nlet randomFloat (maximumNumber: int) =\r\n    (float (maximumNumber \u002B 1)) * random.NextDouble()\r\n    |\u003E float32\r\n\r\n// Setup up mutable bindings and a function to calculate the framerate\r\nlet mutable lastRenderTime = System.DateTimeOffset.Now.ToUnixTimeMilliseconds()\r\nlet mutable currentRenderTime = System.DateTimeOffset.Now.ToUnixTimeMilliseconds()\r\nlet mutable numberOfFrameRatesToAverage = 30\r\nlet mutable frameRates = Array.zeroCreate\u003Cfloat\u003E(numberOfFrameRatesToAverage)\r\nlet mutable frameRateArrayIndex = 0\r\n\r\nlet calculateFrameRate () =\r\n    lastRenderTime \u003C- currentRenderTime\r\n    currentRenderTime \u003C- System.DateTimeOffset.Now.ToUnixTimeMilliseconds()\r\n    let currentFrameRate = 1.0 / (float(currentRenderTime - lastRenderTime) / 1000.0)\r\n    frameRates[frameRateArrayIndex] \u003C- currentFrameRate\r\n    frameRateArrayIndex \u003C- (frameRateArrayIndex \u002B 1) % numberOfFrameRatesToAverage\r\n    (Array.sum frameRates) / (float numberOfFrameRatesToAverage)\r\n\r\nlet linePaint = new SKPaint(Color = SKColor(0uy, 0uy, 0uy, 10uy))\r\n\r\nlet frameRatePaint = new SKPaint(Color = SKColor(byte 0, byte 0, byte 0, byte 255))\r\nframeRatePaint.TextSize \u003C- 50.0f\r\n\r\nwhile not (glfw.WindowShouldClose(window)) do\r\n    glfw.PollEvents()\r\n    \r\n    canvas.Clear(SKColors.WhiteSmoke)\r\n\r\n    for _ in 1..50_000 do\r\n        canvas.DrawLine(\r\n            SKPoint(randomFloat \u003C| int width, randomFloat \u003C| int height),\r\n            SKPoint(randomFloat \u003C| int width, randomFloat \u003C| int height),\r\n            linePaint)\r\n    let frameRate = calculateFrameRate()\r\n\r\n    canvas.DrawText(sprintf \u0022%.0f\u0022 frameRate, 10.0f, 50.0f, frameRatePaint)\r\n\r\n    canvas.Flush()\r\n    glfw.SwapBuffers(window)\r\n        \r\nglfw.DestroyWindow(window)\r\nglfw.Terminate()\r\n\u0060\u0060\u0060\r\n\r\n**Expected Behavior**\r\n\r\nI would have expected SkiaSharp to easily beat the performance of Processing or at least match it on this test.\r\n\r\n**Actual Behavior**\r\n\r\nSkiaSharp\u0027s drawing of 50,000 lines is at least 50-75% of that of Processing. I don\u0027t know how to get Processing to exceed 60fps, but it\u0027s likely it could. SkiaSharp can only draw the lines at around 30-50fps with a lot of bouncing around in the performance and some dips below 30fps. I would say the screenshot above was the most generous framerate I saw.\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  2.88.3\r\n- Last known good version:  unknown\r\n- Platform Target Frameworks: \u003C!-- all that apply, remove the platforms that aren\u0027t broken or haven\u0027t had any testing --\u003E\r\n  - Linux:  I can\u0027t get SkiaSharp to work on Linux, so no testing there.\r\n  - Windows Classic:  Windows 11, version 22H2, OS Build 22621.1265\r\n  \r\n\u003Cdetails\u003E\r\n  \u003Csummary\u003EDetailed IDE/OS information (click to expand)\u003C/summary\u003E\r\n  \r\n\u0060\u0060\u0060\r\n\r\n\r\n\r\n\u0060\u0060\u0060\r\n\u003C/details\u003E\r\n\r\n\r\n**Screenshots**\r\n\r\nRunning the Processing code and printing the framerate to Processing\u0027s console:\r\n\r\n![image](https://user-images.githubusercontent.com/65685447/225133431-7c88a2fa-6c77-44c4-8d91-0b7a9ee3fe91.png)\r\n\r\nRunning the SkiaSharp code and displaying the framerate in the window:\r\n\r\n![image](https://user-images.githubusercontent.com/65685447/225133587-6b6e6428-4e70-4893-a187-cafcd046bed2.png)\r\n\r\n**Reproduction Link**\r\n\r\n[PerformanceTest.zip](https://github.com/mono/SkiaSharp/files/10973702/PerformanceTest.zip)",
  "author": {
    "login": "bmitc",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2023-03-14T21:12:09",
  "updatedAt": "2025-05-31T20:54:43",
  "commentCount": 6,
  "reactionCount": 1,
  "engagement": {
    "syncedAt": "2026-02-04T19:52:30.3098953Z",
    "reactions": [
      {
        "user": "angelofb",
        "content": "\u002B1",
        "createdAt": "2026-02-04T19:52:30.3098989Z"
      }
    ],
    "comments": [
      {
        "id": 1496396635,
        "author": "TommiGustafsson-HMP",
        "createdAt": "2023-04-04T18:12:57",
        "reactions": []
      },
      {
        "id": 1496398918,
        "author": "bmitc",
        "createdAt": "2023-04-04T18:14:49",
        "reactions": []
      },
      {
        "id": 1496410687,
        "author": "TommiGustafsson-HMP",
        "createdAt": "2023-04-04T18:24:20",
        "reactions": []
      },
      {
        "id": 1496412832,
        "author": "bmitc",
        "createdAt": "2023-04-04T18:25:58",
        "reactions": []
      },
      {
        "id": 1546909355,
        "author": "cyraid",
        "createdAt": "2023-05-14T14:09:58",
        "reactions": []
      },
      {
        "id": 2925706835,
        "author": "ToolmakerSteve",
        "createdAt": "2025-05-31T20:38:57",
        "reactions": []
      }
    ]
  }
}