{
  "number": 2275,
  "type": "issue",
  "state": "closed",
  "title": "Why does the SKCanvasView show a different X,Y point after scaling?  ",
  "body": "First let me state, this is my first time messing with any type of drawing utility and I am way outside of my wheelhouse. First I will describe the issue I am having, then what I am trying to do and then my code.\r\n\r\nIssue:\r\nAfter scaling and transforming the canvas, when I TOUCH the canvas area on the phone, then look at the \u0027location\u0027 point in the touch event in Visual Studio, its not the same location that the canvas drew something. I need the exact location I drew something to show the user a popup.  If directly after drawing the image I reset the matrix then the rectangles are drawn in the right location but they do not scale.  I thought, well I will  ResetMatrix at the very end, but that doesn\u0027t seem to matter.  \r\n\r\nWhat I am trying to do:\r\nI have an image that I scale and draw to the canvas. Then I draw a large red rectangle on the image and smaller rectangles inside the larger rectangle. When the user presses the zoom button I scale by an increasing factor giving the allusion that we are zooming in on the center. So essentially the image grows in size, the large rectangle grows in size and the little rectangles grow in size. This seems to work flawlessly...but I feel I have done something wrong being that when I touch one of the little rectangles, the location is not the same (x,y) it was drawn at.\r\n\r\nBelow is most of the code I am using put all in one function for simplicity. Any help would be much appreciated. I would think the SKCanvas View would be the same coordinates as the SKCanvas but obviously I am wrong.  This code will not compile because you do not have certain classes that return objects...but they do not matter....the issue is Scaling and I am not sure why\r\n\r\n\u0060\u0060\u0060cs\r\npublic static void DrawLayout(SKImageInfo info, SKCanvas canvas, SKSvg svg, SetupViewModel vm)\r\n\r\nvar layout = vm.SelectedReticleLayout;\r\nfloat yRatio;\r\nfloat xRatio;\r\nfloat widgetHeight = 75;\r\nfloat widgetWidth = 170;\r\nfloat availableWidth = 720;\r\nfloat availableHeight = 1280;\r\n\r\nvar currentZoomScale = getScale();\r\ncanvas.Translate(info.Width / 2f, info.Height / 2f);\r\nSKRect bounds = svg.ViewBox;\r\n\r\nxRatio = (info.Width / bounds.Width) \u002B ((info.Width / bounds.Width) * currentZoomScale);\r\nyRatio = (info.Height / bounds.Height) \u002B ((info.Height / bounds.Height) * currentZoomScale);\r\nfloat ratio = Math.Min(xRatio, yRatio);\r\n\r\ncanvas.Scale(ratio);\r\ncanvas.Translate(-bounds.MidX, -bounds.MidY);\r\ncanvas.DrawPicture(svg.Picture, new SKPaint { Color = SKColors.White, Style = SKPaintStyle.Fill });\r\n\r\n// now set the X,Y and Width and Height of the large Red Rectangle\r\nfloat imageCenter = canvas.LocalClipBounds.Width / 2;\r\nlayout.RedBorderXOffSet = imageCenter - (imageCenter / 2.0f) \u002B canvas.LocalClipBounds.Left;\r\nfloat redBorderYOffSet = (float)(svg.Picture.CullRect.Top \u002B Math.Ceiling(.0654450261780105f * svg.Picture.CullRect.Bottom));\r\nlayout.RedBorderYOffSet = (float)(canvas.LocalClipBounds.Top \u002B Math.Ceiling(.0654450261780105f * canvas.LocalClipBounds.Bottom));\r\nlayout.RedBorderWidth = canvas.LocalClipBounds.Width / 2.0f;\r\nlayout.RedBorderWidthXOffSet = layout.RedBorderWidth \u002B layout.RedBorderXOffSet;\r\nlayout.RedBorderHeight = (float)(canvas.LocalClipBounds.Bottom - Math.Ceiling(.0654450261780105f * canvas.LocalClipBounds.Bottom * 2)) - canvas.LocalClipBounds.Top;\r\nlayout.RedBorderHeightYOffSet = layout.RedBorderYOffSet \u002B layout.RedBorderHeight;\r\n\r\n// draw the large red rectangle\r\ncanvas.DrawRect(layout.RedBorderXOffSet, layout.RedBorderYOffSet, layout.RedBorderWidth, layout.RedBorderHeight, RedBorderPaint);\r\n\r\n// clear the tracked widgets, tracked widgets are updated every time we draw the widgets\r\n// base widgets contain the default size and location relative to the scope. base line widgets\r\n// will need to be multiplied by the node scale height and width\r\n\r\nlayout.TrackedWidgets.Clear();\r\n\r\nvar widget = new widget\r\n{\r\nX = layout.RedBorderXOffSet \u002B 5;\r\nY = layout.RedBorderYOffSet \u002B layout.TrackedReticleWidgets[0].Height \u002B 15;\r\nHeight = layout.RedBorderHeight * (widgetHeight / availableHeight);\r\nWidth = layout.RedBorderWdith * (widgetWidth / availableWidth);\r\n}\r\n\r\n// define colors for text and border colors for small rectangles (widgets)\r\npublic static SKPaint SelectedWidgetColor =\u003E new SKPaint { Color = SKColors.LightPink, Style = SKPaintStyle.StrokeAndFill, StrokeWidth = 3 };\r\n\r\npublic static SKPaint EmptyWidgetBorder =\u003E new SKPaint { Color = SKColors.DarkGray, Style = SKPaintStyle.Stroke, StrokeWidth = 3 };\r\n\r\npublic static SKPaint EmptyWidgetText =\u003E new SKPaint { Color = SKColors.Black, TextSize = 10, FakeBoldText = false, Style = SKPaintStyle.Stroke, Typeface = SKTypeface.FromFamilyName(\u0022Arial\u0022) };\r\n\r\npublic static SKPaint DefinedWidgetText =\u003E new SKPaint { Color = SKColors.DarkRed, FakeBoldText = false, Style = SKPaintStyle.Stroke };\r\n\r\n// create small rectangle (widget) and draw the widget\r\nvar widgetRectangle = SKRect.Create(widget.X, widget.Y, widget.Width, widget.Height);\r\ncanvas.DrawRect(widgetRectangle, widget.IsSelected ? SelectedWidgetColor : EmptyWidgetBorder);\r\n\r\n// now lets create the text to draw in the widget\r\nstring text = EnumUtility.GetDescription(widget.WidgetDataType);\r\nfloat textWidth = EmptyWidgetText.MeasureText(text);\r\nEmptyWidgetText.TextSize = widget.Width * GetUnscaledWidgetWith(widget) * EmptyWidgetText.TextSize / textWidth;\r\n\r\nSKRect textBounds = new SKRect();\r\nEmptyWidgetText.MeasureText(text, ref textBounds);\r\n\r\nfloat xText = widgetRectangle.MidX - textBounds.MidX;\r\nfloat yText = widgetRectangle.MidY - textBounds.MidY;\r\n\r\ncanvas.DrawText(text, xText, yText, EmptyWidgetText);\r\n\u0060\u0060\u0060",
  "author": {
    "login": "sisaacks",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2022-10-05T14:41:46",
  "updatedAt": "2022-10-05T18:44:26",
  "closedAt": "2022-10-05T18:44:26",
  "commentCount": 1,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-04T20:29:48.4423785Z",
    "reactions": [],
    "comments": [
      {
        "id": 1268812771,
        "author": "mattleibow",
        "createdAt": "2022-10-05T18:44:16",
        "reactions": []
      }
    ]
  }
}