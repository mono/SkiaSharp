{
  "number": 2125,
  "type": "issue",
  "state": "closed",
  "title": "[BUG] \u0060System.AccessViolationException\u0060 thrown when flushing canvas or swapping buffers",
  "body": "**Description**\r\n\r\nI am using GLFW for creating a window and SkiaSharp to draw to that window\u0027s OpenGL context. SkiaSharp suddenly throws \u0060System.AccessViolationException\u0060 exceptions, often without an indication of where it occurred, but it seems to occur either at \u0060SKCanvas.flush()\u0060 or when instructing [GLFW to swap buffers](https://www.glfw.org/docs/latest/group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14).\r\n\r\nThe exception is thrown every run, but it is indeterminate how long it takes for the exception to be thrown.\r\n\r\nThe exception message in the Visual Studio \u0022Exception Unhandled\u0022 window that pops up:\r\n\r\n\u003E System.AccessViolationException: \u0027Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\u0027\r\n\r\nDetails after selecting \u0022Copy Details\u0022 in this window:\r\n\r\n\u0060\u0060\u0060\r\nSystem.AccessViolationException\r\n  HResult=0x80004003\r\n  Message=Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\r\n  Source=\u003CCannot evaluate the exception source\u003E\r\n  StackTrace:\r\n\u003CCannot evaluate the exception stack trace\u003E\r\n\u0060\u0060\u0060\r\n\r\nError message printed to console:\r\n\r\n\u0060\u0060\u0060\r\nFatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\r\nRepeat 2 times:\r\n--------------------------------\r\n   at SkiaSharp.SkiaApi.sk_refcnt_safe_unref(IntPtr)\r\n--------------------------------\r\n   at SkiaSharp.SKObjectExtensions.SafeUnRef(SkiaSharp.ISKReferenceCounted)\r\n   at SkiaSharp.SKNativeObject.Dispose(Boolean)\r\n   at SkiaSharp.SKNativeObject.Finalize()\r\n\u0060\u0060\u0060\r\n\r\n**Code**\r\n\r\nI have written my own GLFW bindings in F#, which are used below, but the wrappers below are almost one-to-one with the GLFW functions invoked.\r\n\r\n\u0060\u0060\u0060fsharp\r\nlet mutable width, height = 500, 500\r\nlet mutable framebufferWidth, framebufferHeight = width, height\r\n\r\nlet init = glfwInit()\r\n\r\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)\r\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)\r\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE)\r\nglfwWindowHint(GLFW_OPENGL_PROFILE, 0x00032001)\r\n\r\nlet window = glfwCreateWindow(width, height, \u0022Test Window\u0022, NULL_MONITOR, NULL_WINDOW)\r\n\r\nglfwMakeContextCurrent(window)\r\n\r\nlet grGlInterface = GRGlInterface.Create(getProcAddress)\r\n\r\nif not(grGlInterface.Validate())\r\nthen raise (System.Exception(\u0022Invalid GRGlInterface\u0022))\r\n\r\nlet grContext = GRContext.CreateGl(grGlInterface)\r\n\r\nlet draw(window, width, height) =\r\n    pollEvents()\r\n    grContext.ResetContext()\r\n    let grGlFramebufferInfo = new GRGlFramebufferInfo(0u, uint32(0x8058))\r\n    use grBackendRenderTarget = new GRBackendRenderTarget(width, height, 1, 0, grGlFramebufferInfo)\r\n    let surface = SKSurface.Create(grContext, grBackendRenderTarget, GRSurfaceOrigin.BottomLeft, SKColorType.Rgba8888)\r\n    let canvas = surface.Canvas\r\n    canvas.Clear(SKColors.Cyan)\r\n    use red = new SKPaint(Color = SKColor(byte(255), byte(0), byte(0), byte(255)))\r\n    canvas.DrawCircle(float32(width)/2.0f, float32(height)/2.0f, float32(100), red)\r\n    canvas.Flush()\r\n    glfwSwapBuffers(window)\r\n\r\nwhile not (glfwWindowShouldClose window = 1) do\r\n    glfwGetFramebufferSize(window, \u0026framebufferWidth, \u0026framebufferHeight)\r\n    draw(window, framebufferWidth, framebufferHeight)\r\n    \r\nglfwDestroyWindow(window)\r\nterminate()\r\n\u0060\u0060\u0060\r\n\r\n**Expected Behavior**\r\n\r\nNo exception.\r\n\r\n**Actual Behavior**\r\n\r\nA \u0060System.AccessViolationException\u0060 exception is thrown, often with no stack trace.\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  2.88.0\r\n- Last known good version:  unknown\r\n- IDE:  Visual Studio Community 2022, version 17.2.3\r\n- Platform Target Frameworks: \u003C!-- all that apply, remove the platforms that aren\u0027t broken or haven\u0027t had any testing --\u003E\r\n  - Linux:  I will eventually be targeting Linux, but I have not ran this code at all on Linux yet.\r\n  - macOS:  I will also eventually be targeting macOS, but I have not ran a recent version of my bindings and code on macOS.\r\n  - Windows Classic: Windows 11, OS Build 22000.739. This is where the exception is currently being thrown.\r\n- Target Devices:   \u003C!-- the devices that you noticed this on, e.g. iPhone X --\u003E\r\n  - PC\r\n  \r\n\u003C!--\u003Cdetails\u003E\r\n  \u003Csummary\u003EDetailed IDE/OS information (click to expand)\u003C/summary\u003E\r\n  \r\n\u0060\u0060\u0060\r\n\r\nPASTE ANY DETAILED VERSION INFO HERE\r\n\r\n\u0060\u0060\u0060\r\n\u003C/details\u003E--\u003E\r\n\r\n\r\n**Screenshots**\r\n\r\nThis is a screenshot of the window and image that\u0027s being drawn:\r\n\r\n![image](https://user-images.githubusercontent.com/65685447/175195589-b7039396-6065-4ec1-9480-00dc5f1afca1.png)\r\n\r\n**Reproduction Link**\r\n\r\n\u003C!-- please upload or provide a link to a reproduction case --\u003E\r\n\r\n~~Unavailable at the moment since the code is in a private repository.~~ [A reproduction is linked here.](https://github.com/mono/SkiaSharp/issues/2125#issuecomment-1170666517)",
  "author": {
    "login": "bmitc",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2022-06-23T02:44:11",
  "updatedAt": "2024-04-25T03:14:42",
  "closedAt": "2024-04-17T13:13:07",
  "commentCount": 13,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T13:37:34.700818Z",
    "reactions": [],
    "comments": [
      {
        "id": 1163882118,
        "author": "bmitc",
        "body": "Another error reported to the console is:\r\n\r\n\u0060\u0060\u0060\r\nFatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\r\nRepeat 2 times:\r\n--------------------------------\r\n   at SkiaSharp.SkiaApi.sk_canvas_flush(IntPtr)\r\n--------------------------------\r\n   at SkiaSharp.SKCanvas.Flush()\r\n   at Windowing.Window\u002BWindow.Draw()\r\n   at \u003CStartupCode$WindowTest\u003E.$Program.main@()\r\n\u0060\u0060\u0060\r\nThis is using some higher-level wrappers, but it is basically doing the same thing as the above code snippet. It shows that in this case, the error occurs at \u0060SKCanvas.Flush()\u0060.",
        "createdAt": "2022-06-23T03:24:04",
        "reactions": []
      },
      {
        "id": 1170666517,
        "author": "bmitc",
        "body": "I have tried debugging this a million ways, and I have not been able to solve this or workaround the issue. There are several seemingly related issues in this repository that mention the \u0060System.AccessViolationException\u0060, with some of them mentioning that the issue may be due to garbage collection of some of the SkiaSharp objects, such as the canvas. However, I\u0027ve tried everything from [\u0060GC.KeepAlive\u0060](https://docs.microsoft.com/en-us/dotnet/api/system.gc.keepalive?view=net-6.0) to keeping all SkiaSharp objects in class fields to even keeping a buffer of previous objects in class fields to try and workaround this. None of that has worked.\r\n\r\nIf I do not recreate the \u0060GRBackendRenderTarget\u0060 and \u0060SKSurface\u0060 every loop iteration, then this does not seem to occur. However, that prevents being able to resize the window, either manually or via a resize callback with GLFW.\r\n\r\nAttached is a very simple reproduction of this unexpected exception using only Silk.NET.GLFW, which is just using Silk.NET\u0027s GLFW binding and not their windowing abstraction, and SkiaSharp. The project was done in Visual Studio Community 2022 with the latest versions and only requires the NuGet dependencies.\r\n\r\nThe crash can take a few minutes, but it happens every time. It seems to happen much faster in other slightly more complicated scenarios, but the error is the same \u0060System.AccessViolationException\u0060 at \u0060SkiaSharp.SkiaApi.sk_refcnt_safe_unref(IntPtr)\u0060 as in the original description above.\r\n\r\n[GLFWTest.zip](https://github.com/mono/SkiaSharp/files/9015780/GLFWTest.zip)",
        "createdAt": "2022-06-30T02:01:30",
        "reactions": []
      },
      {
        "id": 1191245775,
        "author": "molesmoke",
        "body": "I\u0027m no F# expert, but should some of those \u0022let\u0022 statements be \u0022use\u0022?",
        "createdAt": "2022-07-21T09:15:27",
        "reactions": []
      },
      {
        "id": 1191577823,
        "author": "bmitc",
        "body": "\u0060use\u0060 is used in the attached reproduction using Silk.NET\u0027s GLFW bindings.\n\nI was playing around with \u0060let\u0060 to let things try and stay in memory as long as possible since it seemed like that was a possible issue here.\n\nAs far as my understanding goes, using \u0060let\u0060 over \u0060use\u0060 would only result in a memory leak for objects that implement \u0060IDisposable\u0060. That\u0027s my understanding though, not sure if that\u0027s right.",
        "createdAt": "2022-07-21T14:47:26",
        "reactions": []
      },
      {
        "id": 1197431563,
        "author": "molesmoke",
        "body": "Pretty sure this is just a bug in the example, though arguably it should be possible to notice some error and throw an exception earlier. The dispose pattern deals with resources - that may or may not be memory. It works for me if the unmanaged resources are properly disposed (i.e. GRBackendRenderTarget and SKSurface). ",
        "createdAt": "2022-07-27T22:19:21",
        "reactions": []
      },
      {
        "id": 1200332807,
        "author": "bmitc",
        "body": "Thanks for mentioning \u0060SKSurface\u0060. That seems to be the culprit. Although, like you say, I think maybe there might be some better checks internally, as there is often not even a stack trace when the exception is thrown.\r\n\r\nAt first I was confused, but the issue is because \u0060SKSurface\u0060 does not have any object constructors and relies on the static method \u0060SKSurface.Create\u0060 to create an \u0060SKSurface\u0060. In F#, you are notified via a warning when using a constructor for a class that implements \u0060IDisposable\u0060 if you do not use \u0060new\u0060 to create it, as you see for \u0060GRBackendRenderTarget\u0060 and \u0060SKPaint\u0060 in my GLFWTest project. That is the typical way, at least in F#, to know the object is an \u0060IDisposable\u0060 and that you should either call \u0060Dispose\u0060 on the created object or bind it with \u0060use\u0060, as I did for \u0060GRBackendRenderTarget\u0060 and \u0060SKPaint\u0060. For example:\r\n\r\n![image](https://user-images.githubusercontent.com/65685447/182006748-bfb39915-9a12-4edd-9c86-8216596c6383.png)\r\n\r\nUsing \u0060use\u0060 for \u0060SKSurface\u0060 or explicitly calling \u0060Dispose\u0060 on it after the canvas is flushed and buffers are swapped seems to be working so far. I would like to test this a bit longer to make sure there isn\u0027t a crash.\r\n\r\nI\u0027ll leave this issue open for now, as I think the \u0022bug\u0022 is now at least a documentation issue. Since \u0060SKSurface\u0060 uses a static method to create an \u0060SKSurface\u0060, I think the documentation should mention that it implements \u0060IDisposable\u0060. I may try my hand at a documentation PR.",
        "createdAt": "2022-07-31T02:16:32",
        "reactions": []
      },
      {
        "id": 1200366151,
        "author": "molesmoke",
        "body": "Again, I\u0027m no F# expert, but I read that warning as the \u0022new\u0022 operator should be used when directly invoking a constructor, not that the named constructor idiom should be avoided. It\u0027s fairly common to use that pattern any time additional context is needed to distinguish constructors that otherwise would have the same signatures. Probably here to distinguish between creating a new backend render target vs. wrapping an existing one.\r\n\r\nEdit: looks like most of the other named constructors are obsolete, so maybe regular constructors could be added. Trouble is, the existing ones would still be needed for compatibility.",
        "createdAt": "2022-07-31T07:21:45",
        "reactions": []
      },
      {
        "id": 1200465396,
        "author": "bmitc",
        "body": "Yes, I know. I didn\u0027t say named constructors should be avoided. In F#, the \u0060new\u0060 keyword is optional and is idiomatically not used when using object constructors. The warning I mentioned is to recommend (or force to get rid of the warning) using \u0060new\u0060 when using an object constructor for a class that implements \u0060IDisposable\u0060. The warning is there to basically force using the \u0060new\u0060 keyword and to remind you that you should use \u0060using\u0060, bind the object with \u0060use\u0060, or manually call \u0060Dispose\u0060.\r\n\r\nhttps://fsharpforfunandprofit.com/posts/classes/#constructing-and-using-a-class\r\n\r\nMy point was that \u0060SKSurface\u0060 does not have named constructors and rather uses a static method to create instances. Thus, I didn\u0027t know that \u0060SKSurface\u0060 needed to be disposed like \u0060GRBackendRenderTarget\u0060 (because in that case, I received the warning when constructing). That\u0027s why I think it should be mentioned in the documentation.",
        "createdAt": "2022-07-31T17:19:38",
        "reactions": []
      },
      {
        "id": 1200702102,
        "author": "molesmoke",
        "body": "A named constructor is a public static method used to instantiate an object... i.e. SKSurface.Create _is_ a named constructor. \r\n\r\nUpstream Skia surfaces themselves use named constructors too. I don\u0027t think it\u0027s wrong to use them where it\u0027s appropriate, and I don\u0027t necessarily think that F# rule implies that there\u0027s any issue here either. As an aside, you might not even always care about disposing types that implement IDisposable (e.g. Tasks). Though probably most of the time you will want to explicitly dispose, it\u0027s up to the caller to be aware and make an appropriate judgement.\r\n\r\nLooks like the error handling pattern here is that the named constructor returns null if the allocation failed (a regular constructor would only be able to throw an exception for errors), but it looks to me like the binding at least already does the right thing:\r\nhttps://github.com/mono/SkiaSharp/blob/main/binding/Binding/SKSurface.cs",
        "createdAt": "2022-08-01T04:49:37",
        "reactions": []
      },
      {
        "id": 1201868624,
        "author": "bmitc",
        "body": "Apologies for equating named constructors with object constructors. I wasn\u0027t aware that \u0022named constructors\u0022 were a specific thing. In my opinion, it\u0027s a poor name to mean something different than constructing an object by name. \uD83D\uDE43 I don\u0027t really know C#, only enough to use .NET libraries from F#, and defining constructors in F# is handled a bit differently.\r\n\r\n@mattleibow Can you please confirm the correct way to handle \u0060SKSurface\u0060? Should it be handled via \u0060using\u0060, binding with \u0060use\u0060, or manually disposed via \u0060Dispose\u0060, or is it supposed to just work? I think it might help if the documentation for \u0060SKSurface\u0060 was updated.",
        "createdAt": "2022-08-02T00:25:00",
        "reactions": []
      },
      {
        "id": 1221294039,
        "author": "mgood7123",
        "body": "\u003E Apologies for equating named constructors with object constructors. I wasn\u0027t aware that \u0022named constructors\u0022 were a specific thing. In my opinion, it\u0027s a poor name to mean something different than constructing an object by name. \uD83D\uDE43 I don\u0027t really know C#, only enough to use .NET libraries from F#, and defining constructors in F# is handled a bit differently.\r\n\u003E \r\n\u003E @mattleibow Can you please confirm the correct way to handle \u0060SKSurface\u0060? Should it be handled via \u0060using\u0060, binding with \u0060use\u0060, or manually disposed via \u0060Dispose\u0060, or is it supposed to just work? I think it might help if the documentation for \u0060SKSurface\u0060 was updated.\r\n\r\ngenerally a surface should be created, and then disposed when done using it\r\n\r\ni dont know F# so this is C#\r\n\r\n\u0060\u0060\u0060cs\r\nSKSurface surface;\r\n\r\nif (width == 0 || height == 0 || graphicsContext == null)\r\n{\r\n    return null;\r\n}\r\n\r\nSKSurface s = SKSurface.Create(graphicsContext, false, new SKImageInfo(width, height));\r\n\r\nif (s == null)\r\n{\r\n    return null;\r\n}\r\n\r\n// draw with s.Canvas\r\n\r\ns.Dispose(); // s.Canvas is disposed with surface\r\n\u0060\u0060\u0060",
        "createdAt": "2022-08-20T11:02:56",
        "reactions": []
      },
      {
        "id": 2061233261,
        "author": "bmitc",
        "body": "Conclusion: Surface must be disposed of.",
        "createdAt": "2024-04-17T13:13:07",
        "reactions": []
      },
      {
        "id": 2076273275,
        "author": "mgood7123",
        "body": "\u003E Conclusion: Surface must be disposed of.\r\n\r\nkeep in mind anything that automatically disposes the surface will also work, for example, a \u0060using\u0060 statement, another \u0060class\u0060 that manages the lifetime of its own \u0060SkSurface\u0060 and implements \u0060dispose\u0060 interface, and so on\r\n\r\nso long as the surface is disposed at the appropriate time",
        "createdAt": "2024-04-25T03:13:52",
        "reactions": []
      }
    ]
  }
}