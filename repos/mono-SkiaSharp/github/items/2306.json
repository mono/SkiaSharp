{
  "number": 2306,
  "type": "issue",
  "state": "open",
  "title": "[BUG] Segfault/Fatal CLR Error when copying from SKDataStream into FileStream",
  "body": "This is really difficult to reproduce, and is very inconsistent. I am really unskilled when it comes to issues occuring in unmanaged code, and I\u0027m assuming this is a problem with Skia and not SkiaSharp, but I best open the issue here initially.\r\n\r\nI am copying from an SKDataStream to a FileStream with CopyToAsync. Occasionally, for no apparent reason, this operation fails and hard crashes the entire .NET runtime with a segfault on Linux and a Fatal CLR Error on Windows.\r\n\r\n\u003C!-- a general description goes here --\u003E\r\n\r\n**Code**\r\n\r\n\u0060\u0060\u0060csharp\r\nSKImage sourceImage = SKImage.FromEncodedData(downloadedDataStream);\r\ndecimal widthRatio = (decimal)200 / sourceImage.Width;\r\ndecimal ratio = Math.Min(widthRatio, 1);\r\n            \r\nint newWidth = Convert.ToInt32(Math.Ceiling(sourceImage.Width * ratio));\r\nint newHeight = Convert.ToInt32(Math.Ceiling(sourceImage.Height * ratio));\r\n\r\nusing SKSurface? surface = SKSurface.Create(new SKImageInfo\r\n{\r\n    Width = newWidth,\r\n    Height = newHeight,\r\n    ColorType = SKImageInfo.PlatformColorType,\r\n    AlphaType = SKAlphaType.Premul\r\n});\r\n\r\nusing SKPaint paint = new();\r\n\r\npaint.IsAntialias = true;\r\npaint.FilterQuality = SKFilterQuality.High;\r\n\r\nsurface.Canvas.DrawImage(sourceImage, new SKRectI(0, 0, newWidth, newHeight), paint);\r\nsurface.Canvas.Flush();\r\n\r\nusing SKImage ss = surface.Snapshot();\r\nusing SKData? thumbnailPng = ss.Encode();\r\nStream? thumbnailPngData = thumbnailPng.AsStream();\r\n\r\nif (thumbnailPngData is not null)\r\n{\r\n    await using FileStream fileHandle = File.OpenWrite(filePath);\r\n    thumbnailPngData.Position = 0;\r\n    await thumbnailPngData.CopyToAsync(fileHandle);\r\n    fileHandle.Close();\r\n    \r\n    await thumbnailPngData.DisposeAsync();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI have of course taken this code out of context a bit, but everything is essentially the same. That OpenWrite takes a path which is generated way above this code in the real thing, and downloadedDataStream is a stream of PNG or JPG bytes which is also generated way above.\r\n\r\n**Expected Behavior**\r\n\r\nCopy works consistently every time\r\n\r\n**Actual Behavior**\r\n\r\nInconsistent behaviour where the copy just doesn\u0027t work. Doesn\u0027t appear to be invalid input image data at all, as it can crash and succeed on the same image.\r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  2.88.3\r\n- Last known good version:  N/A Just started using SkiaSharp\r\n- IDE:  Rider on Windows whilst debugging\r\n- Platform Target Frameworks:\r\n  - Linux:  Debian 11\u003C!-- The version and distro of linux that you are building for, e.g. Ubuntu 16.04 --\u003E\r\n  - Windows Classic:   Windows 10 Pro 10.0.19044\u003C!-- the version of Windows you are building for, e.g. Windows 7 --\u003E\r\n- Target Devices:\r\n  - Linux server\r\n  - Windows PC\r\n\r\n**Screenshots**\r\n\r\nAs you can see, my IDE breaks at the CopyToAsync:\r\n![image](https://user-images.githubusercontent.com/33007665/200140248-9e31e43f-0f70-40f5-811e-81b105b0a52f.png)\r\n\r\n**Crash Output**\r\nLinux Production Release, captured using GDB debug:\r\n\r\n\u0060\u0060\u0060\r\nThread 53 \u0022.NET ThreadPool\u0022 received signal SIGSEGV, Segmentation fault.\r\n[Switching to Thread 0x7ffa6a7fc700 (LWP 151468)]\r\n__longjmp () at ../sysdeps/x86_64/__longjmp.S:111\r\n111     ../sysdeps/x86_64/__longjmp.S: No such file or directory.\r\n\r\nThread 53 \u0022.NET ThreadPool\u0022 received signal SIGSEGV, Segmentation fault.\r\n0x00007ffff779a0af in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/6.0.10/libcoreclr.so\r\n\u0060\u0060\u0060\r\n\r\nWindows Debugging:\r\n\r\n\u0060\u0060\u0060\r\nFatal error. Internal CLR error. (0x80131506)\r\n   at System.Buffer._Memmove(Byte ByRef, Byte ByRef, UIntPtr)\r\n   at System.Buffer.Memmove(Byte ByRef, Byte ByRef, UIntPtr)\r\n   at System.IO.UnmanagedMemoryStream.ReadCore(System.Span\u00601\u003CByte\u003E)\r\n   at System.IO.UnmanagedMemoryStream.Read(Byte[], Int32, Int32)\r\n   at System.IO.UnmanagedMemoryStream.ReadAsync(System.Memory\u00601\u003CByte\u003E, System.Threading.CancellationToken)\r\n   at System.IO.Stream\u002B\u003C\u003CCopyToAsync\u003Eg__Core|29_0\u003Ed.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.Stream\u002B\u003C\u003CCopyToAsync\u003Eg__Core|29_0\u003Ed, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](\u003C\u003CCopyToAsync\u003Eg__Core|29_0\u003Ed ByRef)\r\n   at System.IO.Stream.\u003CCopyToAsync\u003Eg__Core|29_0(System.IO.Stream, System.IO.Stream, Int32, System.Threading.CancellationToken)\r\n   at System.IO.Stream.CopyToAsync(System.IO.Stream, Int32, System.Threading.CancellationToken)\r\n   at System.IO.Stream.CopyToAsync(System.IO.Stream)\r\n   at MyPrivateApplicationRedacted\u002B\u003CMyPrivateMethodRedacted\u003Ed__29.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon ByRef)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.Boolean, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKey\r\nToken=7cec85d7bea7798e]](System.__Canon ByRef)\r\n   at MyPrivateApplicationRedacted.MyPrivateMethodRedacted (System.IO.Stream, System.String, System.String, System.String)\r\n   at MyPrivateApplicationRedacted\u002B\u003CMyOtherPrivateMethodRedacted \u003Ed__22.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601\u002BAsyncStateMachineBox\u00601[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Vers\r\nion=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601\u002BAsyncStateMachineBox\u00601[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Vers\r\nion=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601\u002BAsyncStateMachineBox\u00601[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Vers\r\nion=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)\r\n   at System.Threading.Tasks.Task.RunContinuations(System.Object)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task\u00601[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TrySetResult(System.__Canon)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetExistingTaskResult(System.Threading.Tasks.Task\u00601\u003CSystem.__Canon\u003E, System.__Canon)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetResult(System.__Canon)\r\n   at MyPrivateApplicationRedacted\u002B\u003CMyYetAnotherPrivateMethodRedacted\u003Ed__28.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601\u002BAsyncStateMachineBox\u00601[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=ne\r\nutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601\u002BAsyncStateMachineBox\u00601[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=ne\r\nutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601\u002BAsyncStateMachineBox\u00601[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=ne\r\nutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)\r\n   at System.Threading.Tasks.Task.RunContinuations(System.Object)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.TrySetResult()\r\n   at System.Threading.Tasks.ValueTask\u002BValueTaskSourceAsTask\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__4_0(System.Object)\r\n   at System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore\u00601[[System.Int64, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SignalCompletion()\r\n   at Microsoft.Win32.SafeHandles.SafeFileHandle\u002BThreadPoolValueTaskSource.ExecuteInternal()\r\n   at Microsoft.Win32.SafeHandles.SafeFileHandle\u002BThreadPoolValueTaskSource\u002B\u003C\u003Ec.\u003CSystem.Threading.IThreadPoolWorkItem.Execute\u003Eb__18_0(ThreadPoolValueTaskSource)\r\n   at Microsoft.Win32.SafeHandles.SafeFileHandle\u002BThreadPoolValueTaskSource.System.Threading.IThreadPoolWorkItem.Execute()\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool\u002BWorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\u0060\u0060\u0060",
  "author": {
    "login": "alexhorner",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2022-11-05T20:49:10",
  "updatedAt": "2022-11-05T22:02:06",
  "commentCount": 2,
  "reactionCount": 2,
  "engagement": {
    "syncedAt": "2026-02-04T20:29:16.5350043Z",
    "reactions": [
      {
        "user": "DenisTDR",
        "content": "\u002B1",
        "createdAt": "2026-02-04T20:29:16.5350481Z"
      },
      {
        "user": "HaptelmanovArtem",
        "content": "\u002B1",
        "createdAt": "2026-02-04T20:29:16.535049Z"
      }
    ],
    "comments": [
      {
        "id": 1304645904,
        "author": "alexhorner",
        "createdAt": "2022-11-05T21:34:03",
        "reactions": []
      },
      {
        "id": 1304649774,
        "author": "alexhorner",
        "createdAt": "2022-11-05T22:02:06",
        "reactions": []
      }
    ]
  }
}