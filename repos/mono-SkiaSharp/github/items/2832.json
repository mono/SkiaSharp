{
  "number": 2832,
  "type": "issue",
  "state": "open",
  "title": "[BUG] Drawing is warped during window resize on NVIDIA graphics card",
  "body": "### Description\r\n\r\nI have a project where I am using SkiaSharp to draw to a window provided by GLFW. In the code below, I have reproduced the issue with just Silk.NET\u0027s GLFW bindings (whereas I am normally using my own bindings) and SkiaSharp. The code is not doing anything fancy. It simply draws a circle while the window is open, and during a resize, the entire surface is recreated and redrawn.\r\n\r\nThe issue is that when the window is resized, the drawing is stretched or compressed during the resize. It isn\u0027t clear what is causing this, as the entire surface is recreated during the resize callback and the drawing redrawn, and the callback is blocking. In this case, only a constant sized circle in a constant location is drawn, so it should be impossible for the drawing to contain anything other than a circle. However, the circle is often stretched into an ellipse in either or both directions during a window resize.\r\n\r\nWhat\u0027s curious is that this does *not* occur when integrated Intel graphics are used. It only seems to occur when NVIDIA graphics are used. Thus, it is unclear whether this is a SkiaSharp problem, a Skia problem, whatever backend graphics API is being chosen by Skia or SkiaSharp, or an NVIDIA driver problem. I have searched, and it seems pathological resize behavior has occurred in various forms in all three contexts.\r\n\r\nThis issue prevents any proper resize functionality in a window.\r\n\r\n### Code\r\n\r\nAttached is a .zip of the source file and project. Below is a copy of the source file. This issue occurs on any version of SkiaSharp I have tried, including the latest stable 2.88.8.\r\n\r\n[SilkNETGLFWWindowTest.zip](https://github.com/mono/SkiaSharp/files/14965352/SilkNETGLFWWindowTest.zip)\r\n\r\n\u0060\u0060\u0060fsharp\r\nopen FSharp.NativeInterop\r\nopen Silk.NET.GLFW\r\nopen SkiaSharp\r\n\r\n#nowarn \u00229\u0022\r\n\r\nlet initialWidth, initialHeight = 500, 500\r\nlet mutable framebufferWidth, framebufferHeight = initialWidth, initialHeight\r\n\r\nlet glfw = Glfw.GetApi()\r\nglfw.Init() |\u003E printfn \u0022Initialized?: %A\u0022\r\n\r\n// Uncomment these window hints if on macOS\r\n//glfw.WindowHint(WindowHintInt.ContextVersionMajor, 3)\r\n//glfw.WindowHint(WindowHintInt.ContextVersionMinor, 3)\r\n//glfw.WindowHint(WindowHintBool.OpenGLForwardCompat, true)\r\n//glfw.WindowHint(WindowHintOpenGlProfile.OpenGlProfile, OpenGlProfile.Core)\r\n\r\nglfw.WindowHint(WindowHintInt.Samples, 0)\r\nglfw.WindowHint(WindowHintInt.StencilBits, 1)\r\nglfw.WindowHint(WindowHintBool.DoubleBuffer, true)\r\nglfw.WindowHint(WindowHintBool.Focused, false)\r\nglfw.WindowHint(WindowHintBool.Maximized, false)\r\nglfw.WindowHint(WindowHintBool.Visible, true)\r\n\r\nlet window = glfw.CreateWindow(initialWidth, initialHeight, \u0022Test Window\u0022, NativePtr.ofNativeInt 0n, NativePtr.ofNativeInt 0n)\r\nprintfn \u0022Window: %A\u0022 window\r\nglfw.MakeContextCurrent(window)\r\nlet mutable error = nativeint\u003Cbyte\u003E 1uy |\u003E NativePtr.ofNativeInt\r\nglfw.GetError(\u0026error) |\u003E printfn \u0022Error: %A\u0022\r\n\r\nlet grGlInterface = GRGlInterface.Create(fun name -\u003E glfw.GetProcAddress name)\r\n\r\nif not (grGlInterface.Validate()) then\r\n    raise (System.Exception(\u0022Invalid GRGlInterface\u0022))\r\n\r\nlet grContext = GRContext.CreateGl(grGlInterface)\r\nlet grGlFramebufferInfo = new GRGlFramebufferInfo(0u, SKColorType.Rgba8888.ToGlSizedFormat()) // 0x8058\r\n\r\nlet draw(window, width, height) =\r\n    glfw.PollEvents()\r\n    grContext.ResetContext()\r\n\r\n    let grBackendRenderTarget = new GRBackendRenderTarget(width, height, 1, 0, grGlFramebufferInfo)\r\n    let surface = SKSurface.Create(grContext, grBackendRenderTarget, GRSurfaceOrigin.BottomLeft, SKColorType.Rgba8888)\r\n    let canvas = surface.Canvas\r\n\r\n    canvas.Clear(SKColors.LightBlue)\r\n    let red = new SKPaint(Color = SKColors.Black)\r\n    canvas.DrawCircle(float32(300)/2.0f, float32(300)/2.0f, 100.0f, red)\r\n    canvas.Flush()\r\n\r\n    glfw.SwapBuffers(window)\r\n\r\n    red.Dispose()\r\n    surface.Dispose()\r\n    grBackendRenderTarget.Dispose()\r\n    \r\nlet resizeCallbackFun window width height = draw(window, width, height)\r\nglfw.SetFramebufferSizeCallback(window, resizeCallbackFun) |\u003E ignore\r\n\r\nwhile glfw.WindowShouldClose window \u003C\u003E true do\r\n    glfw.GetFramebufferSize(window, \u0026framebufferWidth, \u0026framebufferHeight)\r\n    draw(window, framebufferWidth, framebufferHeight)\r\n\r\nglfw.DestroyWindow window\r\nglfw.Terminate()\r\n\u0060\u0060\u0060\r\n\r\n### Expected Behavior\r\n\r\nI expected that the resize happens as it does in the integrated Intel graphics situation, where the image drawn inside the main loop and resize callback is always as specified and not warped.\r\n\r\n### Actual Behavior\r\n\r\n## Resizing with integrated Intel graphics\r\n\r\nhttps://github.com/mono/SkiaSharp/assets/65685447/10333812-40fc-4aed-8910-f31afe935d0f\r\n\r\n## Resizing with NVIDIA graphics\r\n\r\nhttps://github.com/mono/SkiaSharp/assets/65685447/bf94c867-fba3-4669-a6f8-f59405e9e69f\r\n\r\n### Version of SkiaSharp\r\n\r\n3.x (Alpha)\r\n\r\n### Last Known Good Version of SkiaSharp\r\n\r\nOther (Please indicate in the description)\r\n\r\n### IDE / Editor\r\n\r\nVisual Studio (Windows)\r\n\r\n### Platform / Operating System\r\n\r\nWindows\r\n\r\n### Platform / Operating System Version\r\n\r\nI am running Windows 11. I currently can\u0027t run SkiaSharp on Linux, and I don\u0027t have a macOS machine to test on.\r\n\r\n\u0060winver\u0060 returns \u0060Version 23H2 (OS Build 22631.3447)\u0060.\r\n\r\n### Devices\r\n\r\n* Dell XPS Desktop\r\n* Dell XPS 15 laptop\r\n* Dell XPS 17 laptop\r\n\r\n### Relevant Screenshots\r\n\r\nYou can see in this screenshots how the circle is stretched. The issue seems to be related to a race condition *somewhere*. In the underlying stack, as the only time a circle is drawn in the top-level code is inside the \u0060draw\u0060 function, and it\u0027s a constant circle in the same location every time, so the stretching is being performed by something else.\r\n\r\n\u0060\u0060\u0060fsharp\r\ncanvas.DrawCircle(float32(300)/2.0f, float32(300)/2.0f, 100.0f, red)\r\n\u0060\u0060\u0060\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/65685447/03fbee3f-18e8-435b-92b0-8fb36ac2e3f0)\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/65685447/b21b75b7-6445-4714-95f4-d6ad5096b783)\r\n\r\n### Relevant Log Output\r\n\r\n_No response_\r\n\r\n### Code of Conduct\r\n\r\n- [X] I agree to follow this project\u0027s Code of Conduct",
  "author": {
    "login": "bmitc",
    "type": "User"
  },
  "labels": [
    {
      "name": "type/bug",
      "color": "fc2929"
    }
  ],
  "assignees": [],
  "createdAt": "2024-04-13T04:52:15",
  "updatedAt": "2025-11-19T10:05:30",
  "commentCount": 1,
  "reactionCount": 0
}