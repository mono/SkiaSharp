{
  "number": 3168,
  "type": "issue",
  "state": "closed",
  "title": "[BUG / WinUI] SKXamlCanvas throws an exception on devices without a GPU or with outdated GPU drivers",
  "body": "### Description\n\nWhen running a **WinUI application** that uses \u0060SKXamlCanvas\u0060, an exception occurs on devices that:  \n- Do **not** have a GPU (e.g., virtual machines, low-end devices)  \n- Have **outdated GPU drivers**, specifically **AMD Radeon drivers from before 2021**  \n\nThe issue originates from **SkiaSharp.Views.WinUI.Native**, where \u0060IBuffer\u0060 is cast to \u0060IBufferByteAccess\u0060.  \nIf the system lacks GPU hardware or uses an outdated driver, **COM fails to locate the required GPU resources**, causing the application to crash.  \n\nThis appears to be the same issue discussed in **[SkiaSharp Issue #3136](https://github.com/mono/SkiaSharp/issues/3136)**.  \n\n**Possible Fix \u0026 PR Proposal** \nI have implemented a workaround that **catches the COMException** and falls back to **software rendering** using \u0060SoftwareBitmap\u0060 and \u0060SoftwareBitmapSource\u0060.  \n\nIf needed, I can **submit a PR** with this fix. Please let me know if this would be helpful.\n\n### Code\n\nThis issue can be reproduced **100% of the time in Windows Sandbox**, as it runs in a virtualized environment with no GPU access.  \n\n1. Create a **WinUI 3** application.  \n2. Install \u0060LiveChartsCore.SkiaSharpView.WinUI\u0060.  \n3. Add the following code to your XAML file:  \n   \u0060\u0060\u0060xml\n   \u003Clvc:CartesianChart /\u003E\n   \u0060\u0060\u0060\n4. Run the application in **Windows Sandbox** or on a **device without a GPU**.  \n5. The application **crashes when rendering the \u0060CartesianChart\u0060**. \n\n### Expected Behavior\n\n- The application should gracefully handle the exception.  \n- If \u0060IBufferByteAccess\u0060 casting fails, the system should **fallback to software rendering** instead of crashing.  \n\n### Actual Behavior\n\n- The application **crashes immediately** when rendering the \u0060CartesianChart\u0060.  \n\n### Version of SkiaSharp\n\n3.116.0 (Current)\n\n### Last Known Good Version of SkiaSharp\n\nOther (Please indicate in the description)\n\n### IDE / Editor\n\nVisual Studio (Windows)\n\n### Platform / Operating System\n\nWindows\n\n### Platform / Operating System Version\n\n- **OS:** Windows 10 / Windows 11  \n- **WinUI Version:** 1.6\n- **SkiaSharp Version:** [2.88.9](https://www.nuget.org/packages/LiveChartsCore.SkiaSharpView.WinUI), [3.116.0](https://github.com/mono/SkiaSharp/issues/3136)\n\n### Devices\n\nWindows devices that \n- Do **not** have a GPU (e.g., virtual machines, low-end devices)  \n- Have **outdated GPU drivers**, specifically **AMD Radeon drivers from before 2021**  \n\n### Relevant Screenshots\n\n_No response_\n\n### Relevant Log Output\n\n- A full memory dump of the crash can be found here:  \n  [\uD83D\uDD17 Download Dump File](https://nas.kagamine-rin.com/public/8ff1003e1d09)  \n- Related SkiaSharp Issue: **[#3136](https://github.com/mono/SkiaSharp/issues/3136)**\n\n### Code of Conduct\n\n- [x] I agree to follow this project\u0027s Code of Conduct",
  "author": {
    "login": "airtaxi",
    "type": "User"
  },
  "labels": [
    {
      "name": "type/bug",
      "color": "fc2929"
    }
  ],
  "assignees": [],
  "createdAt": "2025-02-18T08:27:15",
  "updatedAt": "2025-08-28T12:23:57",
  "closedAt": "2025-08-22T23:58:17",
  "commentCount": 8,
  "reactionCount": 1,
  "engagement": {
    "syncedAt": "2026-02-06T13:24:50.7666487Z",
    "reactions": [
      {
        "user": "naratteu",
        "content": "rocket",
        "createdAt": "2026-02-06T13:24:50.7666564Z"
      }
    ],
    "comments": [
      {
        "id": 2664929465,
        "author": "airtaxi",
        "body": "### **Note**  \n\nThis issue is **not limited to LiveCharts2**\u2014it was only used as a simple example to demonstrate the problem quickly.  \n\nIn reality, this **affects all cases where \u0060SKXamlCanvas\u0060 is used**, regardless of whether it is in LiveCharts2 or another implementation.  \n\nThe root cause of the issue is in **SkiaSharp.Views.WinUI.Native**, where \u0060IBuffer\u0060 is cast to \u0060IBufferByteAccess\u0060. This happens specifically when \u0060SKXamlCanvas\u0060 internally interacts with a **WriteableBitmap**. The failure occurs when trying to retrieve the pixel buffer (\u0060IBuffer\u0060), and **COM cannot allocate the required GPU resources**.  \n\nLet me know if you need more details!  ",
        "createdAt": "2025-02-18T08:30:39",
        "reactions": []
      },
      {
        "id": 2726913675,
        "author": "TommiGustafsson-HMP",
        "body": "This behavior is expected but unfortunate, since SKXamlCanvas, which is based on Canvas, is GPU accelerated.",
        "createdAt": "2025-03-15T18:26:13",
        "reactions": [
          {
            "user": "karalabecode",
            "content": "-1",
            "createdAt": "2026-02-06T13:24:49.4979414Z"
          }
        ]
      },
      {
        "id": 2728195147,
        "author": "airtaxi",
        "body": "\u003E This behavior is expected but unfortunate, since SKXamlCanvas, which is based on Canvas, is GPU accelerated.\n\n@TommiGustafsson-HMP \nThe issue was the WriteableBitmap. I was successfully got it working on problematic environment by using SoftwareBitmap.\n\nOn original post:\n\u003E I have implemented a workaround that catches the COMException and falls back to software rendering using SoftwareBitmap and SoftwareBitmapSource.  \nIf needed, I can submit a PR with this fix. Please let me know if this would be helpful.",
        "createdAt": "2025-03-17T05:14:50",
        "reactions": []
      },
      {
        "id": 2751978959,
        "author": "mattleibow",
        "body": "@airtaxi do you have some code that you are able to share? I wonder if there is a way to detect a lack of support and fallback - or even just use the \u0060SoftwareBitmap\u0060 directly for all cases.\n\nIf WriteableBitmap is on the GPU, then is each frame copying data to the GPU? Maybe the SoftwareBitmap is better? We probably should do some benchmarks and see.",
        "createdAt": "2025-03-25T17:12:13",
        "reactions": []
      },
      {
        "id": 2753247496,
        "author": "airtaxi",
        "body": "@mattleibow \n\nBelow is an example implementation where \u0060WriteableBitmap\u0060 falls back to \u0060SoftwareBitmap\u0060 in a problematic system. Please refer to the following points:\n\n- This was not originally created with a Pull Request in mind, so I have stripped out implementations related to support for other platforms. If I were to submit this as a Pull Request, I would analyze the changes and rewrite it as a completely new source.\n- As far as I know, WinUI\u2019s \u0060SoftwareBitmapSource\u0060 does not provide a way to invalidate when the \u0060SoftwareBitmap\u0060 is updated. As a result, the brush must be refreshed on every frame update. Otherwise, frame synchronization issues may cause flickering in many frames.\n- Due to the aforementioned issue, \u0060SoftwareBitmap\u0060 should only be used as a fallback to prevent crashes and ensure minimal functionality, as \u0060WriteableBitmap\u0060 relies on the GPU. Note that we have confirmed that rendering two to three charts works smoothly without performance issues even on our customers\u0027 low-end PCs with \u0060SoftwareBitmap\u0060.\n\n\u0060\u0060\u0060csharp\n#if WINDOWS\nusing System;\nusing System.Runtime.InteropServices;\nusing Windows.ApplicationModel;\nusing Windows.Graphics.Imaging;\nusing Microsoft.UI.Dispatching;\nusing Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Controls;\nusing Microsoft.UI.Xaml.Data;\nusing Microsoft.UI.Xaml.Media;\nusing Microsoft.UI.Xaml.Media.Imaging;\nusing System.Runtime.InteropServices.WindowsRuntime;\nusing System.Threading.Tasks;\nusing System.Threading;\nusing Windows.Storage.Streams;\nusing SkiaSharp.Views.WinUI.Native;\nusing WinRT;\n\nnamespace SkiaSharp.Views.Windows\n{\n\tpublic partial class SKXamlCanvas : Canvas\n\t{\n\t\tprivate const float DpiBase = 96.0f;\n\n\t\tprivate static readonly DependencyProperty ProxyVisibilityProperty =\n\t\t\tDependencyProperty.Register(\n\t\t\t\t\u0022ProxyVisibility\u0022,\n\t\t\t\ttypeof(Visibility),\n\t\t\t\ttypeof(SKXamlCanvas),\n\t\t\t\tnew PropertyMetadata(Visibility.Visible, OnVisibilityChanged));\n\n\t\tprivate static bool designMode = DesignMode.DesignModeEnabled;\n\n\t\t// original fields\n\t\tprivate IntPtr pixels;\n\t\tprivate WriteableBitmap bitmap;\n\t\tprivate ImageBrush brush;\n\t\tprivate bool ignorePixelScaling;\n\t\tprivate bool isVisible = true;\n\n\t\t// Fallback fields for SoftwareBitmap/SoftwareBitmapSource\n\t\tprivate int fallbackSoftwareBitmapWidth;\n\t\tprivate int fallbackSoftwareBitmapHeight;\n\t\tprivate SoftwareBitmap fallbackSoftwareBitmap;\n\t\tprivate SoftwareBitmapSource fallbackSoftwareBitmapSource;\n\t\tprivate SemaphoreSlim fallbackSoftwareBitmapSourceUpdateSemaphore = new SemaphoreSlim(1, 1);\n\t\tprivate bool isFallbackMode = false;\n\n\t\t// workaround for https://github.com/mono/SkiaSharp/issues/1118\n\t\tprivate int loadUnloadCounter = 0;\n\n\t\tpublic SKXamlCanvas()\n\t\t{\n\t\t\tif (designMode)\n\t\t\t\treturn;\n\n\t\t\tLoaded \u002B= OnLoaded;\n\t\t\tUnloaded \u002B= OnUnloaded;\n\t\t\tSizeChanged \u002B= OnSizeChanged;\n\n\t\t\tvar binding = new Binding\n\t\t\t{\n\t\t\t\tPath = new PropertyPath(nameof(Visibility)),\n\t\t\t\tSource = this\n\t\t\t};\n\t\t\tSetBinding(ProxyVisibilityProperty, binding);\n\t\t}\n\n\t\tpublic SKSize CanvasSize { get; private set; }\n\n\t\tpublic bool IgnorePixelScaling\n\t\t{\n\t\t\tget =\u003E ignorePixelScaling;\n\t\t\tset\n\t\t\t{\n\t\t\t\tignorePixelScaling = value;\n\t\t\t\tInvalidate();\n\t\t\t}\n\t\t}\n\n\t\tpublic double Dpi { get; private set; } = 1;\n\n\t\tpublic event EventHandler\u003CSKPaintSurfaceEventArgs\u003E PaintSurface;\n\n\t\tprotected virtual void OnPaintSurface(SKPaintSurfaceEventArgs e)\n\t\t{\n\t\t\tPaintSurface?.Invoke(this, e);\n\t\t}\n\n\t\tprivate static void OnVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\n\t\t{\n\t\t\tif (d is SKXamlCanvas canvas \u0026\u0026 e.NewValue is Visibility visibility)\n\t\t\t{\n\t\t\t\tcanvas.isVisible = visibility == Visibility.Visible;\n\t\t\t\tcanvas.Invalidate();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnXamlRootChanged(XamlRoot xamlRoot = null, XamlRootChangedEventArgs e = null)\n\t\t{\n\t\t\tvar root = xamlRoot ?? XamlRoot;\n\t\t\tvar newDpi = root?.RasterizationScale ?? 1.0;\n\t\t\tif (newDpi != Dpi)\n\t\t\t{\n\t\t\t\tDpi = newDpi;\n\t\t\t\tUpdateBrushScale();\n\t\t\t\tInvalidate();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnSizeChanged(object sender, SizeChangedEventArgs e)\n\t\t{\n\t\t\tInvalidate();\n\t\t}\n\n\t\tprivate void OnLoaded(object sender, RoutedEventArgs e)\n\t\t{\n\t\t\tloadUnloadCounter\u002B\u002B;\n\t\t\tif (loadUnloadCounter != 1)\n\t\t\t\treturn;\n\n\t\t\tXamlRoot.Changed \u002B= OnXamlRootChanged;\n\t\t\tOnXamlRootChanged();\n\t\t}\n\n\t\tprivate void OnUnloaded(object sender, RoutedEventArgs e)\n\t\t{\n\t\t\tloadUnloadCounter--;\n\t\t\tif (loadUnloadCounter != 0)\n\t\t\t\treturn;\n\n\t\t\tif (XamlRoot != null)\n\t\t\t{\n\t\t\t\tXamlRoot.Changed -= OnXamlRootChanged;\n\t\t\t}\n\n\t\t\tFreeBitmap();\n\t\t}\n\n\t\tpublic void Invalidate()\n\t\t{\n\t\t\tDispatcherQueue.TryEnqueue(DispatcherQueuePriority.Normal, DoInvalidate);\n\t\t}\n\n\n\t\tprivate (SKImageInfo Info, SKSizeI PixelSize, float Dpi) CreateBitmap()\n\t\t{\n\t\t\tvar (viewSize, pixelSize, dpi) = CreateSize();\n\t\t\tvar info = new SKImageInfo(pixelSize.Width, pixelSize.Height, SKImageInfo.PlatformColorType, SKAlphaType.Premul);\n\n\t\t\tif (!isFallbackMode \u0026\u0026 (bitmap?.PixelWidth != info.Width || bitmap?.PixelHeight != info.Height))\n\t\t\t\tFreeBitmap();\n\t\t\telse if (isFallbackMode  \u0026\u0026 (fallbackSoftwareBitmapWidth != info.Width || fallbackSoftwareBitmapHeight != info.Height))\n\t\t\t\tFreeBitmap();\n\n\t\t\tif ((!isFallbackMode ? bitmap == null : pixels == IntPtr.Zero) \u0026\u0026 info.Width \u003E 0 \u0026\u0026 info.Height \u003E 0)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// try to use WriteableBitmap as before\n\t\t\t\t\tbitmap = new WriteableBitmap(info.Width, info.Height);\n\t\t\t\t\tpixels = bitmap.GetPixels();\n\t\t\t\t\tvar brush = new ImageBrush\n\t\t\t\t\t{\n\t\t\t\t\t\tImageSource = bitmap,\n\t\t\t\t\t\tAlignmentX = AlignmentX.Left,\n\t\t\t\t\t\tAlignmentY = AlignmentY.Top,\n\t\t\t\t\t\tStretch = Stretch.Fill\n\t\t\t\t\t};\n\n\t\t\t\t\tUpdateBrushScale();\n\t\t\t\t\tBackground = brush;\n\t\t\t\t\tisFallbackMode = false;\n\t\t\t\t}\n\t\t\t\t// Devices with old Radeon GPU or devices with no GPU (like some VMs) throw a COMException from WriteableBitmap.GetPixels()\n\t\t\t\t// Workaround: use SoftwareBitmap/SoftwareBitmapSource instead\n\t\t\t\tcatch (COMException)\n\t\t\t\t{\n\t\t\t\t\tbitmap = null;\n\t\t\t\t\tisFallbackMode = true;\n\t\t\t\t\tfallbackSoftwareBitmapWidth = info.Width;\n\t\t\t\t\tfallbackSoftwareBitmapHeight = info.Height;\n\n\t\t\t\t\tvar totalBytes = info.Height * info.RowBytes;\n\t\t\t\t\tpixels = Marshal.AllocHGlobal(totalBytes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (info, viewSize, dpi);\n\t\t}\n\n\t\tprivate (SKSizeI ViewSize, SKSizeI PixelSize, float Dpi) CreateSize()\n\t\t{\n\t\t\tvar w = ActualWidth;\n\t\t\tvar h = ActualHeight;\n\n\t\t\tif (!IsPositive(w) || !IsPositive(h))\n\t\t\t\treturn (SKSizeI.Empty, SKSizeI.Empty, 1);\n\n\t\t\tvar dpi = (float)Dpi;\n\t\t\tvar viewSize = new SKSizeI((int)w, (int)h);\n\t\t\tvar pixelSize = new SKSizeI((int)(w * dpi), (int)(h * dpi));\n\n\t\t\treturn (viewSize, pixelSize, dpi);\n\n\t\t\tstatic bool IsPositive(double value)\n\t\t\t{\n\t\t\t\treturn !double.IsNaN(value) \u0026\u0026 !double.IsInfinity(value) \u0026\u0026 value \u003E 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate void UpdateBrushScale()\n\t\t{\n\t\t\tif (brush == null)\n\t\t\t\treturn;\n\n\t\t\tvar scale = 1.0 / Dpi;\n\n\t\t\tbrush.Transform = new ScaleTransform\n\t\t\t{\n\t\t\t\tScaleX = scale,\n\t\t\t\tScaleY = scale\n\t\t\t};\n\t\t}\n\n\t\tprivate DateTime _lastSoftwareUpdate;\n\t\tprivate void DoInvalidate()\n\t\t{\n\t\t\tif (designMode)\n\t\t\t\treturn;\n\n\t\t\tif (!isVisible)\n\t\t\t\treturn;\n\n\t\t\tvar (info, viewSize, dpi) = CreateBitmap();\n\n\t\t\tif (info.Width \u003C= 0 || info.Height \u003C= 0)\n\t\t\t{\n\t\t\t\tCanvasSize = SKSize.Empty;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar matchUI = IgnorePixelScaling;\n\n\t\t\tvar userVisibleSize = matchUI ? viewSize : info.Size;\n\t\t\tCanvasSize = userVisibleSize;\n\n\t\t\tif (!isFallbackMode)\n\t\t\t{\n\t\t\t\t// Create an SKSurface using the obtained pixels pointer\n\t\t\t\tusing var surface = SKSurface.Create(info, pixels, info.RowBytes);\n\n\t\t\t\tif (matchUI)\n\t\t\t\t{\n\t\t\t\t\tvar canvas = surface.Canvas;\n\t\t\t\t\tcanvas.Scale(dpi);\n\t\t\t\t\tcanvas.Save();\n\t\t\t\t}\n\n\t\t\t\tOnPaintSurface(new SKPaintSurfaceEventArgs(surface, info.WithSize(userVisibleSize), info));\n\t\t\t\tbitmap.Invalidate();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tusing var surface = SKSurface.Create(info, pixels, info.RowBytes);\n\t\t\t\tif (IgnorePixelScaling)\n\t\t\t\t{\n\t\t\t\t\tvar canvas = surface.Canvas;\n\t\t\t\t\tcanvas.Scale(dpi);\n\t\t\t\t\tcanvas.Save();\n\t\t\t\t}\n\n\t\t\t\tOnPaintSurface(new SKPaintSurfaceEventArgs(surface, info.WithSize(userVisibleSize), info));\n\n\t\t\t\tvar totalBytes = info.Height * info.RowBytes;\n\t\t\t\tvar managedBuffer = new byte[totalBytes];\n\t\t\t\tMarshal.Copy(pixels, managedBuffer, 0, totalBytes);\n\n\t\t\t\tvar buffer = managedBuffer.AsBuffer();\n\n\t\t\t\tvar newSoftwareBitmap = SoftwareBitmap.CreateCopyFromBuffer(buffer, BitmapPixelFormat.Bgra8, info.Width, info.Height, BitmapAlphaMode.Premultiplied);\n\t\t\t\tfallbackSoftwareBitmap = newSoftwareBitmap;\n\n\t\t\t\tDispatcherQueue.TryEnqueue(async () =\u003E\n\t\t\t\t{\n\t\t\t\t\tif (DateTime.UtcNow \u003E _lastSoftwareUpdate.AddSeconds(1 / 60d))\n\t\t\t\t\t\t_lastSoftwareUpdate = DateTime.UtcNow;\n\t\t\t\t\telse \n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tawait fallbackSoftwareBitmapSourceUpdateSemaphore.WaitAsync();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tfallbackSoftwareBitmapSource = new SoftwareBitmapSource();\n\t\t\t\t\t\tawait fallbackSoftwareBitmapSource.SetBitmapAsync(newSoftwareBitmap);\n\t\t\t\t\t\tnewSoftwareBitmap.Dispose();\n\n\t\t\t\t\t\tif(Background is not ImageBrush brush)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbrush = new ImageBrush\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAlignmentX = AlignmentX.Left,\n\t\t\t\t\t\t\t\tAlignmentY = AlignmentY.Top,\n\t\t\t\t\t\t\t\tStretch = Stretch.Fill\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tBackground = brush;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbrush.ImageSource = fallbackSoftwareBitmapSource;\n\n\t\t\t\t\t\tvar savedSource = fallbackSoftwareBitmapSource;\n\t\t\t\t\t\tDispatcherQueue.TryEnqueue(async () =\u003E\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\t\t\tsavedSource?.Dispose();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tfallbackSoftwareBitmapSourceUpdateSemaphore.Release();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tprivate void FreeBitmap()\n\t\t{\n\t\t\tBackground = null;\n\t\t\tbrush = null;\n\t\t\tbitmap = null;\n\t\t\tpixels = IntPtr.Zero;\n\t\t}\n\t}\n}\n\n#endif\n\u0060\u0060\u0060",
        "createdAt": "2025-03-26T04:59:58",
        "reactions": []
      },
      {
        "id": 3192570932,
        "author": "mattleibow",
        "body": "I created this test app that I think should either repro the issue, or the crash is somewhere else: https://github.com/mattleibow/ComCrashTestApp\n\nIf you can, please test and let me know.\n\nIt is an unpckaged app, so you can just run the exe, or if you don\u0027t trust me, open in VS and run.",
        "createdAt": "2025-08-15T19:54:07",
        "reactions": []
      },
      {
        "id": 3215616053,
        "author": "mattleibow",
        "body": "While we wait for the fix to go out, there is a workaround - install the VC runtime redistributable.",
        "createdAt": "2025-08-22T20:48:05",
        "reactions": []
      },
      {
        "id": 3233290185,
        "author": "danies8",
        "body": "When this bug will be fixed and how i got the fix?",
        "createdAt": "2025-08-28T12:23:57",
        "reactions": []
      }
    ]
  }
}