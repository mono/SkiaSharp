{
  "number": 2794,
  "type": "issue",
  "state": "open",
  "title": "[BUG] Porting from 2.88.6 to 3.0.0-preview2.1 - \u0022Access Violation on Finalizer/Dispose\u0022- SKPaint object",
  "body": "### Description\r\n\r\nThank you for SkiaSharp!  We love love love it.\r\n\r\nTonight I started our efforts to port our application from using SkiaSharp 2.88.6 (which is working like a champ, making full use of custom shaders on GLSurfaces), to the latest 3.0.0-preview2.1.\r\n\r\nWe had to change over about a dozen API\u0027s to the new API\u0027s -- very smooth, no issue.\r\n\r\nBut now when we run our previously very-stable application (in production), it now (with SkiaSharp v3.0) instantly crashes with an \u0022Access Violation\u0022 error where the stack trace shows a Native SKObject Dispose() method being called by it\u0027s finalizer.\r\n\r\nHere\u0027s what I see in Visual Studio 2022:\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/10914515/3b71f545-0541-4693-842d-7e4671105b2f)\r\n\r\n**The object type Disposed is of type \u0022SKPaint\u0022.**\r\n\r\n\r\n### Code\r\n\r\nBecause I don\u0027t know which SKObject is being Finalized, I don\u0027t know which code triggers it.   But somewhere, I\u0027ve got an SKPaint object that is being disposed via the Finalizer, which is supposed to be fine (right?).\r\n\r\n### Expected Behavior\r\n\r\nI\u0027m expecting SkiaSharp Object Finalizers to NOT cause Access Violation exceptions, but instead to operated normally.\r\n\r\n### Actual Behavior\r\n\r\nFinalizer calls Dispose() which throws a fatal \u0022Access Violoation\u0022 exception, and our app crashes.\r\n\r\n### Version of SkiaSharp\r\n\r\n3.x (Alpha)\r\n\r\n### Last Known Good Version of SkiaSharp\r\n\r\n2.88.2 (Previous)\r\n\r\n### IDE / Editor\r\n\r\nVisual Studio (Windows)\r\n\r\n### Platform / Operating System\r\n\r\nWindows\r\n\r\n### Platform / Operating System Version\r\n\r\nWindows 11 Home\r\n\r\n### Devices\r\n\r\nCyberPowerPC with intel i9-14900K, running Windows 11 Home\r\n\r\n### Relevant Screenshots\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/10914515/dc523b12-fe50-4ee3-923d-9ba3b05ef41e)\r\n\r\n\r\n### Relevant Log Output\r\n\r\n_No response_\r\n\r\n### Code of Conduct\r\n\r\n- [X] I agree to follow this project\u0027s Code of Conduct",
  "author": {
    "login": "najak3d",
    "type": "User"
  },
  "labels": [
    {
      "name": "type/bug",
      "color": "fc2929"
    }
  ],
  "assignees": [],
  "createdAt": "2024-03-12T10:17:05",
  "updatedAt": "2025-03-12T23:52:13",
  "commentCount": 39,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-06T12:46:17.6902059Z",
    "reactions": [],
    "comments": [
      {
        "id": 1991291752,
        "author": "najak3d",
        "body": "NOTE: ONCE, as I re-ran this many times, it crashed on the GLControl Paint event thread, while running this line of code:\r\n\r\n\tint charsMeasured = (int)Paint.BreakText(textSpan.Span, maxWidth, out float measuredWidth);\r\n\r\nSame error, \u0022Access Violation Exception\u0022.  \r\n\r\n",
        "createdAt": "2024-03-12T10:21:21",
        "reactions": []
      },
      {
        "id": 1991335052,
        "author": "najak3d",
        "body": "And so, I wrote specialized Property Getter/Setter for my \u0022Font\u0022 class which ensures that no SKPaint objects ever get Finalized (which is something I\u0027m hoping to avoid worrying about).\r\n\r\nAnd so now the \u0022Access Violation\u0022 now only happens on my call to \u0022Paint.BreakText(...)\u0022:\r\n\r\n\tint charsMeasured = (int)Paint.BreakText(textSpan.Span, maxWidth, out float measuredWidth);\r\n\r\nSo I set a watch on \u0027Paint\u0027 property, and the watch gets 3 \u0022AccessVioloationExceptions\u0022 inside of it, as shown here:\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/10914515/af5b1c7e-0a71-447f-9821-f45efec1990d)\r\n\r\n\r\n",
        "createdAt": "2024-03-12T10:40:39",
        "reactions": []
      },
      {
        "id": 1991351806,
        "author": "najak3d",
        "body": "NOTE - if I set a BreakPoint, to change the \u0022timing\u0022 - the line of code that throws this Access Violation exception can be changed, such as this last time it crashed on this line of code:\r\n\r\n\t\tcanvas.DrawText(txtLine, lineX, drawY \u002B 0.4f, OutlinePaint);\r\n\r\n(where OutlinePaint itself is throwing AccessViolations on some properties).\r\n\r\nNOTE - that it successfully uses these Paint objects many many times just fine (and rapidly) - and then it randomly breaks (as though something were disposed by a finalizer, is what it could be).",
        "createdAt": "2024-03-12T10:49:57",
        "reactions": []
      },
      {
        "id": 2019537529,
        "author": "AmitParmar2005",
        "body": "Hi,\r\n\r\nCould you please tell me how did you make code working? Did you just install SkiaSharp 3.0.0-preview2.1 nuget package? I have installed it but I get Access Violation exception. Did you also build and install latest Angle library?\r\n\r\nIf possible, could you please list down the steps you followed for code migration?\r\n\r\nThanks in advance,\r\nAmit",
        "createdAt": "2024-03-26T07:10:27",
        "reactions": []
      },
      {
        "id": 2019843954,
        "author": "najak3d",
        "body": "I just changed my NUGET references to the various SkiaSharp libraries over to the preview 3.0, for 3 packages as shown here:\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/10914515/b2dee8af-b10c-470a-837b-070735836380)\r\n\r\nAnd then it compiled great (after a few code fixes)... but crashes on the \u0027Finalizers\u0027 it seems.\r\n\r\nI do NOT have (nor ever had) Angle nuget referenced by my project.   But I do have OpenTK 3.3.3 packages as follows:\r\n\r\n![image](https://github.com/mono/SkiaSharp/assets/10914515/79bfb71d-7bdb-4bdb-b001-c554cd6fba0a)\r\n\r\nOther than those, I have System.XXXX libraries, and Xamarain.Essentials 1.8, and NetonSoft.Json 13.0.3 and EntityFramework 6.4.4.\r\n\r\nThat\u0027s it..   So the ONLY change I made in migration to NUGET was those THREE SkiaSharp packages shown above.\r\n\r\n",
        "createdAt": "2024-03-26T08:47:14",
        "reactions": []
      },
      {
        "id": 2020203285,
        "author": "AmitParmar2005",
        "body": "Thanks for quick reply.\r\n\r\nI think, I misunderstood. Is your application developed in WPF? \r\n\r\nMy application is in WinUI 3. ",
        "createdAt": "2024-03-26T11:44:05",
        "reactions": []
      },
      {
        "id": 2021530840,
        "author": "najak3d",
        "body": "It runs on WPF for Windows, but Xamarin Forms for Android/iOS.   Windows/WPF is the easiest place to get things working, so am starting here.   Then will move on to Android/iOS w/Xamarin.Forms.",
        "createdAt": "2024-03-26T21:48:14",
        "reactions": []
      },
      {
        "id": 2283983732,
        "author": "FoggyFinder",
        "body": "any updates? workarounds? or at least MCVE? so far crashes look randomly.\r\n",
        "createdAt": "2024-08-12T13:23:12",
        "reactions": []
      },
      {
        "id": 2708919381,
        "author": "najak3d",
        "body": "I just confirmed this bug, although BETTER, still happens within 5 minutes of operation, where I\u0027m loading up new Map Tile bitmaps, and rendering them to a GL-based SKSurface.Canvas.DrawBitmap(skBitmap) -- which gets converted to an SKImage, and auto-disposed...   But then within a few minutes, finalizers kick in -- and crash.\n\nHere are the images of the new 3.116.1 crash on finalizing SKImage:\n![Crash-Shot#1](https://drive.google.com/uc?export=view\u0026id=1Dna_ITYcoQwIdtYc_aH_RnuQ2Bwjoab7)\n\n![Crash-Shot#2](https://drive.google.com/uc?export=view\u0026id=1QH76_egvSNMcBqfOLwYB52EQlnh91_2m)\n\n\nI\u0027m available new 24/7 to iterate with you to getting this fixed. \n",
        "createdAt": "2025-03-09T15:35:31",
        "reactions": []
      },
      {
        "id": 2709049479,
        "author": "najak3d",
        "body": "Here is our screenshot of iFlyEFB avaiation map, where for the last 18 months we\u0027ve been using SkiaSharp to render a 30 FPS animated map, with many thousands of draws per second.\n\n![Image](https://github.com/user-attachments/assets/2b61c0c2-fb10-48af-95b6-5a4b66112970)",
        "createdAt": "2025-03-09T20:18:36",
        "reactions": []
      },
      {
        "id": 2709447863,
        "author": "mattleibow",
        "body": "Are you able to reproduce this in a sample app? I am not sure what your code looks like and it may have disposed the typeface manually somewhere.\n\nSame with the image. There may have been a case of you passing it to an object that takes over the life of the image and I was unaware.\n\nOne example that I know offhand of this is when you create a pdf document, the stream it is writing to is now owned by the document and can me disposed in native code at any time. There may be some api somewhere that is doing this for image and typeface.\n\nI know this is me saying compress your entire app into a single line and send it over, but maybe you can try disabling chunks of the drawing code and see which part of the render is triggering a crash. ",
        "createdAt": "2025-03-10T05:10:36",
        "reactions": []
      },
      {
        "id": 2709471397,
        "author": "mattleibow",
        "body": "Also, I may have missed it, is this full or dotnet \u0022core\u0022? ",
        "createdAt": "2025-03-10T05:30:29",
        "reactions": []
      },
      {
        "id": 2709548470,
        "author": "mattleibow",
        "body": "I just had an idea while taking a nap. The paint object is a lie! Sort of. In the new versions of skia, the paint object does not have any of the font members. They were moved to skfont.\n\nYou probably have many, but what happens if you switch to use skfont and none of the font members, like typeface and breaktext, on the paint and instead use a font object.\n\nI wonder if I have a life cycle bug in where the secret font instance of paint is being disposed.\n\nInstead of using paint.breaktext and canvas.drawtext with paint, use font.breaktext and canvas.drawtext that uses paint and font. \n\nWhen I get back to my machine I will check some things. ",
        "createdAt": "2025-03-10T06:21:01",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:12.4884405Z"
          }
        ]
      },
      {
        "id": 2709556681,
        "author": "najak3d",
        "body": "\u003E Also, I may have missed it, is this full or dotnet \u0022core\u0022?\n\nOur windows project is .NET Framework 4.8, but on the verge of being ported to .NET 8.\n\nOn Android/iOS - we are full .NET 8. \n\nThis crash is happening on Windows, I haven\u0027t tried it yet on Android or iOS.   I\u0027ll do that next, to provide you with some added information.\n\nThe SKImage that is having issues is one that we NEVER have a reference to... it\u0027s created via \u0022Canvas.DrawBitmap\u0022 which creates an SKImage via \u0022using\u0022 statement, and so is auto-disposed.\n\nThe specific 258x258 pixel size of this SKImage lets me know who created it, which is only one place in our code (indirectly by calling SKCanvas.DrawBitmap())\u0022.\n\nSo the issue here, for these, is \u0027Dispose()\u0027 is called implicitly/immediately via the \u0022using\u0022 context.   But when GC kicks in later, calling the SKImage Finalizer, it\u0027s trying to access invalid memory via the Skia wrapper.\n\nIn my mind, it seems that SKObject shouldn\u0027t be trying to access the raw SKIA object once Dispose() is called.  Shouldn\u0027t Dispose() be deleting the native SKIA SKImage already?   If so, then this crash seems expected to me... as we\u0027re trying to access it again, later, during the Finalize phase.",
        "createdAt": "2025-03-10T06:26:42",
        "reactions": []
      },
      {
        "id": 2709582896,
        "author": "najak3d",
        "body": "\u003E I just had an idea while taking a nap. The paint object is a lie! Sort of. In the new versions of skia, the paint object does not have any of the font members. They were moved to skfont.\n\u003E \n\u003E You probably have many, but what happens if you switch to use skfont and none of the font members, like typeface and breaktext, on the paint and instead use a font object.\n\u003E \n\u003E I wonder if I have a life cycle bug in where the secret font instance of paint is being disposed.\n\u003E \n\u003E Instead of using paint.breaktext and canvas.drawtext with paint, use font.breaktext and canvas.drawtext that uses paint and font.\n\u003E \n\u003E When I get back to my machine I will check some things.\n\nOur use of SKPaint for Fonts is tightly wrapped in our own \u0022iFont\u0022 class (iFlyEFB-Font) - and for these, we strictly make them all Static references, via our \u0022iFonts\u0022 static classes (i.e. iFonts.Tahoma18Bold)... so each SKPaint used for Fonts is created at startup, with readonly static references.     We apply these Fonts to BOTH contexts that we have in our system. \n\nDue to 2.88.x limitation of only having ONE GL Context, we employ GL Context for our Main Map (the place where we render at 30 FPS), while for all UI Popup forms employ the non-GL context. \n\n(Not sure yet, if this limitation to a singular GL context remains for 3.116.x)\n\nSo just letting you know that we reuse these static iFont.SKPaint instances for both contexts - and it seems to be working well.\n\nFor the SKImages being disposed, there is no use of iFont on them.   We are Loading a PNG image from stream, \n\n===\nOur code related to the SKImage that is crashing us is this:\n\n\u003E bci.Data.SKBitmap.InstallPixels(new SKImageInfo(width, height, Bitmap.SKColorFormat, alphaType), pBits);\n\u003E _imageSurface.Canvas.DrawBitmap(bci.Data.SKBitmap, 0, 0);\n\u003E \n\nSo we\u0027ve preloaded our Tile Bitmaps to BMP-style PixelBuffers in RAM.   And use \u0022InstallPixels()\u0022 to make your SKBitmap use these pixels, and it works great.   Then draw this Bitmap to an SKSurface.\n\nThe SKImage culprit is created by your DrawBitmap wrapper method.\n\nWe don\u0027t do much creation of SKImages in our app, and no where else do we employ 258x258 size images, that are specifically sized for our Tile rendering.\n\nIf I go to a different map mode (vector mode vs. this tile mode), no such crash occurs for SKImage.\n\n",
        "createdAt": "2025-03-10T06:43:52",
        "reactions": []
      },
      {
        "id": 2710245605,
        "author": "najak3d",
        "body": "It crashes on Android as well.   In this context we are only using GL for one task - SKIA.\n\nHere is our Crash Log, associated with GL thread following a GC.\n\n[skiacrash.txt](https://github.com/user-attachments/files/19161436/skiacrash.txt)",
        "createdAt": "2025-03-10T11:18:34",
        "reactions": []
      },
      {
        "id": 2710451429,
        "author": "najak3d",
        "body": "Overall, Android runs more stable with this than Windows (at least on my main Android OS 12 Galaxy S10 test device).   I can make it crash on windows within a few minutes, but on Android, it\u0027s 10\u0027s of minutes of stressing it.\n\nSo this Disposal/Finalizer-related crash appears to be a rare occurrence, which of course makes it harder to debug/fix, yet still renders this bug critical for us.   Our users are flying airplanes, and cannot tolerate an app crash, requiring restart.",
        "createdAt": "2025-03-10T12:39:50",
        "reactions": []
      },
      {
        "id": 2711232167,
        "author": "najak3d",
        "body": "Using Skia 2.88.6, I was able to produce the same exact SKImage crash on the same SKImage Finalizer calling Dispose(), producing an unauthorized access violation.   \n\nSo this crash isn\u0027t new to version 3.116.1. \n\nEDIT - and it happened just now for 2.88.9. \n\nWe\u0027ve had this crashing bug for 1.5 years now, and this week, just figured out it\u0027s source.   It\u0027s a bug that typically happens about 30-60 minutes into usage, so has been elusive to us, and we just figured out the use cases that accelerate it, so that we can now cause it to happen in \u003C 3 minutes usually now.\n\nWe\u0027ve slowed it down in the past by holding a reference to the SKImage (up to 120 of them!) - so that they won\u0027t dispose, and have chance to cause this app crash.  ",
        "createdAt": "2025-03-10T16:52:45",
        "reactions": []
      },
      {
        "id": 2711403960,
        "author": "najak3d",
        "body": "Since your \u0022Dispose(disposing)\u0022 method \u0022does it all\u0022 - I\u0027m going to test the method calling \u0022Dispose()\u0022 manually, then GC.SuppressFinalizer(skImg)....  but this fails even worse.  \n\n===\nWe need a way to simply Blit a PixelBuffer from CPU RAM to the GPU buffer used by the SKSurface.   Once it\u0027s on the surface, it draws quickly/readily to the main map.\n\nOur SKIA method for doing this is:\n1. Load the Pixels to CPU ram pixel buffer (BMP format, raw pixels)\n2. InstallPixels to a SKBitmap\n3. Call SKSurface.DrawBitmap(bitmap)\n4. done.\n\nWe only need this problematic SKImage to pump our pixels verbatim to the SKSurface.  It\u0027s a 1:1 mapping, no change in the pixels.\n\n====\nI see the regular SKIA a SKSurface method called \u0022WritePixels()\u0022, which sidesteps the requirement of having an SKImage.\n\nThis may resolve the issue for us.   Plus is more efficient, as we can skip this \u0022meaningless middleman - SKImage\u0022 since we are just wanting to do a direct PixMap dump to the surface.",
        "createdAt": "2025-03-10T17:59:10",
        "reactions": []
      },
      {
        "id": 2711622520,
        "author": "mattleibow",
        "body": "I wonder if the crash is related to the case where an image is copied to the GPU and then the GPU context changes/resets.\n\nBut also, I wonder if it is the case that there is no one holding onto the bitmap... Looking at the API in C\u002B\u002B for the image-from-bitmap:\n\n\u0060\u0060\u0060cpp\nSK_API sk_sp\u003CSkImage\u003E RasterFromBitmap(const SkBitmap\u0026 bitmap);\n\u0060\u0060\u0060\n\nThe bitmap is a reference - not a smart/counted pointer. So I wonder when you draw the bitmap, the image is created but does not actually retain the managed bitmap, which is collected by the GC but the GPU still tries to draw it... I am not 100% sure, I will try and reproduce it here and see if I can track the life of the actual pixel data, but I wonder if loading the pixels directly into an SKImage will help.\n\nCan you try loading the pixels into the SKImage directly? There is a \u0060SKImage.FromPixelCopy\u0060, \u0060SKImage.FromPixels\u0060 and \u0060SKImage.Create\u0060 which should remove the need for installing the pixels into a bitmap. \n\n* \u0060SKImage.FromPixelCopy\u0060 - This can load from a file/memory stream as well as an array or raw memory location. This should make sure the image gets its how copy of the pixel data. It will be a copy, but using this for testing will make sure there is no middle man at all\n* \u0060SKImage.FromPixels\u0060 - This can effectively \u0022install\u0022 the pixel data. If you have the data as a \u0060SKData\u0060 or as a native pointer, this may work. The Image does not actually have ownership of the pixel data like a copy would, but will not require a copy. The GC should not collect the data instance since it will be reference counted.\n* \u0060SKImage.Create\u0060 - This will create an empty image, which you can then use \u0060PeekPixels\u0060 method to get a \u0060SKPixmap\u0060 which is basically an info type to the pixel information. But, if you need to provide a destination to another type - like some image loader - this can be used to pass the value from \u0060GetPixels()\u0060 or \u0060GetPixelSpan()\u0060. This will be a buffer of \u0060BytesSize\u0060 that you can load the image directly into. \n\nSo, the best mechanism is all depending on how your data exists. If you have control of the loading, maybe load as a \u0060SKData\u0060 (using \u0060SKData.Create\u0060) which will load the pixels directly into native code, and then create an image around it letting the image dispose of the data for you when it is done.\n\nIf you have a stream, then \u0060SKImage.FromPixelCopy\u0060 is probably best to copy out of the stream and into native code.\n\nIf you have a byte array, there is the easy copy way using \u0060SKImage.FromPixelCopy\u0060 or there is the move exciting way to pin the array in C# and pass that to native code which will avoid a copy:\n\n\u0060\u0060\u0060cs\nvar bytes = ...; // from somewhere\n\nvar gch = GCHandle.Alloc(bytes, GCHandleType.Pinned); // pin memory so the GC doesn\u0027t move it\n\nvar info = new SKImageInfo(width, height);\nvar pixmap = new SKPixmap(info, gch.AddrOfPinnedObject());\n\nvar image = SKImage.FromPixels(pixmap, (addr, _) =\u003E GCHandle.FromIntPtr(addr).Free());\n\u0060\u0060\u0060\n\nBut, before doing anything fancy, try swapping to use \u0060SKImage\u0060 directly.\n\n",
        "createdAt": "2025-03-10T19:31:06",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:13.8560755Z"
          },
          {
            "user": "najak3d",
            "content": "heart",
            "createdAt": "2026-02-06T12:46:13.8560762Z"
          }
        ]
      },
      {
        "id": 2711692967,
        "author": "najak3d",
        "body": "OK - I tried the simple fix, and it fails just-the-same.  \n\u0060\u0060\u0060\n//old_line: bci.Data.SKImage = SKImage.FromBitmap(bci.Data.SKBitmap);\nbci.Data.SKImage = SKImage.FromPixelCopy(sKImageInfo, bci.Data.Image.pBits);\n\u0060\u0060\u0060\n\nMy data is pinned inside of a large data block on the large object heap (we do our own allocations, given we have a pre-defined pool of 120 blocks of 258x258x4 for each Tile image pixels.  Each tile is assigned an unmoving IntPtr to the start of it\u0027s pixel buffer.  This is what is sent in above as \u0022...Image.pBits\u0022.\n\nIt works the exact same as using the SkBitmap, regarding how well it works for a couple minutes, then crashes on the Finalizer, exactly the same way, in about the same amount of time.\n\n===\nEach Tile also holds an SKSurface reference, which is our target object for these pixels on the GPU, to be used in as a child sampler to a custom shader.\n\nOur pipeline is this:\n===\n1. Load Pixels from PNG format on disk-file to RAM, as Pixel Buffer, that is stationary in RAM.\n2. Install those Pixels to SKBitmap (this is optional, and helpful for Debug Mode, as we sometimes \u0022mark it up\u0022 with SKIA draw calls to label it, etc.\n3. Then we want to simply BLIT/Dump these Pixels verbatim to the Tile\u0027s SKSurface.  (The SKImage is just a middleman that adds no value.)\n\n4. THEN from the surface, we draw to the Screen surface, in the correct location/rotation/scale.\n\n===\nI see SKIA C\u002B\u002B version\u0027s Surface has \u0022WritePixels()\u0022 API - this would work perfectly for us, if you are willing and able to add support for this method.\n\nOur code to draw to the Screen surface is like this:\n\u0060\u0060\u0060\n\t_imageSamplingShader = _imageSurface.Snapshot().ToShader(SKShaderTileMode.Clamp, SKShaderTileMode.Clamp);\n\u0060\u0060\u0060\n\nFrom there this sampler becomes a Child shader of a custom shader, which combines the TileMap with an Elevation Map, so that we can color code the map as \u0022Yellow/Red\u0022 to show Higher elevations that pose a collision risk to lower flying aircraft.\n\nThis attached video, shows how we colorize the tiles with Red/Yellow, and enrich the tilemap color to make sure details are not washed out.   It\u0027s all working GREAT, except for this stability issue, which has been a real sore spot:\n\nhttps://github.com/user-attachments/assets/07c7f4b7-07e6-4bb6-843c-8ded33a8622b",
        "createdAt": "2025-03-10T20:03:26",
        "reactions": []
      },
      {
        "id": 2712888947,
        "author": "mattleibow",
        "body": "I am wondering how the image is getting collected if you have a reference to it.\n\nIf you can see the value of the handle in the finalizer, is it the same as the ones that you know you created?\n\nMaybe it is the snapshot one. That creates an image as well. Can you try doing skcanvas.drawsurface and see if it still happens? I wonder if the shader needs to take ownership/strong ref the snapshot... I suppose you can try adding it to a static list so it also never gets collected. ",
        "createdAt": "2025-03-11T07:02:09",
        "reactions": []
      },
      {
        "id": 2714537535,
        "author": "najak3d",
        "body": "\u003E I am wondering how the image is getting collected if you have a reference to it.\n\nNOTE: In no circumstance was I holding onto a SKImage reference, for longer than a few extra seconds (the longest I was delaying it was the time when the tile itself became recycled -- so only holding onto 120 SKImg references at a time, max).\n\n In my experiment above, I was calling \u0022img.Dispose()\u0022 then \u0022GC.SuppressFinalizer(img)\u0022, then set \u0022img = null\u0022 to make it fall out of scope quickly, Disposed() but never to be finalized.  This crashed even faster, as you might predict.\n\nCode for this failed experiment:\n\u0060\u0060\u0060\nvar img = SKImage.FromPixelsCopy(...)\nsurface.Canvas.DrawImage(img);\nimg.Dispose()\nGC.SuppressFinalize(img);\nimg = null;\n\u0060\u0060\u0060\n\n=====\n\u003E If you can see the value of the handle in the finalizer, is it the same as the ones that you know you created?\n\n**They DIFFER every time!...  So a copy is being made.**     \n\n**To Validate this result**: Every time one is created, I put it into a SortedList\u003CHandle, string\u003E, so that I can review results at the time of the crashing exception.     I\u0027m typically able to load 15K to 45K tiles before it crashes (about 100 to 300 pinch operations equivalent, but also triggered by panning) -- this is why it crashes randomly between 20-60 minutes into usage.\n\n\n\u003E Maybe it is the snapshot one. That creates an image as well. Can you try doing skcanvas.drawsurface and see if it still happens? I wonder if the shader needs to take ownership/strong ref the snapshot... \n\n**I\u0027m not sure what you want for me to do here.  I\u0027ve got a Bitmap to draw to an existing surface.   Do you want me to create a new Temp surface each time I load a tile?  And how do you want me to insert this into my pipeline for sake of doing this test?**\n\n\u003EI suppose you can try adding it to a static list so it also never gets collected.\n\nIf I never let it get collected - we\u0027ll get an OOM fast.   A single pinch operation can load 150 tiles, as we animate each level of detail as you zoom in/out.   Each tile is 258x258x4 bytes = 0.25 MB.   So collecting 40 MB of never-to-be-used-again pointers is not an option.   I can do this for sake of showing that it doesn\u0027t crash until the OOM, if you like.\n\nFINAL NOTE:  \nAs I\u0027m creating my own SKImage references, and putting them into a SortedList with key as the IntPtr...  I\u0027m finding a lot of RE-USE here,  for example, 25K tiles total, but only created 2200 unique IntPtr references, so something here is resulting in a lot of re-use of the same memory locations.   Not sure if this is meaningful -- I assume this is to be expected.\n\n\n",
        "createdAt": "2025-03-11T14:30:45",
        "reactions": []
      },
      {
        "id": 2714839073,
        "author": "najak3d",
        "body": "MORE INFO.  I have found a way to make the crash less likely to occur. \n\n1. skImg = SKImage.FromPixelsCopy(...)\n2. surface.Canvas.DrawImage(skImg...)\n3. skImg.Dispose()\n4. THEN - hold onto this reference for a Minimum \u0027X\u0027 msec before releasing it.\n\nI accomplish #4 by having two static List\u003CSkImage\u003E to hold the references.  The every \u0022X\u0022 msec, I swap the lists, and clear the other list.    The \u0022other list\u0022 has references that were created between \u0022X\u0022 and \u00222X\u0022 msec ago.\n\nThis influences the crashing rate results significantly.\n\nNew Crash when I do this:\nSo far, it crashed 3x, on \u0022surface.Canvas.DrawImage(skImg)\u0022 - \u0022AccessViolationException\u0022.  So holding on to the references to delay Finalization, causes this new issue.\n\nIf I precede my \u0022Surface.Canvas.DrawImage()\u0022 with a \u0022...Clear(transparent)\u0022 -- the crash still happens on the \u0022Clear()\u0022 -- so the issue is associated with the Surface, not the SKImg here.\n\nFor each Tile, we are creating just one Surface, and reusing it.  120 Surfaces in all - as our Tile Pool size is 120.\n\nMy rapid testing is loading/drawing about 15,000 tiles per minute.\n\n====\nIf I delay \u0022Dispose()\u0022 until the time I delay release the reference (\u0027X\u0027 msec min) - it crashed much faster.\n\n===\nThe Best result I\u0027ve been able to achieve is for \u0027X\u0027 = 300 msec.   I Dispose() immediately after use, and then release my reference 250-500 msec later.\n\nIf I set \u0027X\u0027 longer, it crashes much soon, and as \u0027X\u0027 gets even longer, it begins to crash on my Surface.Draw/Clear() calls.\n\nToo short - and it doesn\u0027t help much.\n\n250-500 msec for my context seems to be the sweet-spot where it runs about 2x as long as before, without crash - average.\n\n===\nI hope this new information helps you \u0022guess the issue\u0022 better.\n\n",
        "createdAt": "2025-03-11T15:47:29",
        "reactions": []
      },
      {
        "id": 2715349614,
        "author": "mattleibow",
        "body": "I wonder if the surface is holding onto the image internally, and then you dispose it making the surface invalid. Is it possible to have a test where you never dispose the image and keep it around forever?\n\nBut, I wonder if this is a GPU surface, you will need to flush the surface to actually push the image to the surface and not queue it up? GPU commands are not immediate, so the delay may actually be you allowing the commands to be flushed.\n\nI also wonder if there is anything on \u0060SKGraphics\u0060 that you can use to influence caches and things.\n\nBut, maybe I am not understanding something as well.\n\nYou have your main screen surface, and then smaller surfaces for each tile, and then an image that you are drawing on that smaller surface? I also see shaders and snapshots. I feel like my brain is saying you are loading an image, drawing it to a surface, then creating a snapshot and then making a shader? Can you not draw directly to the main surface?\n\nOr even use the \u0060SKImage.ToTextureImage\u0060? Also, are you using a single, shared GRContext? Does that ever get recreated? I wonder if that happens you need to discard all surfaces.",
        "createdAt": "2025-03-11T18:31:31",
        "reactions": []
      },
      {
        "id": 2715385488,
        "author": "mattleibow",
        "body": "The crash in the finalizer is so weird because if you are disposing it, then the handle should be set to zero, which would then make the finalizer skip of the the logic. In fact we set a flag at the top to prevent anything from running twice.\n\nThis means it has to be another image somewhere that is being collected - probably the snapshot. Are you able to keep that around - or dispose immediately after making the shader to force afaster crash?\n\nThis is the implementation of the snapshot:\n\n\u003Cimg width=\u0022354\u0022 alt=\u0022Image\u0022 src=\u0022https://github.com/user-attachments/assets/bf9d5849-0ba0-437b-b321-67f80f2f515b\u0022 /\u003E\n\nIt should be reference counted ,but is actually the surface under the hood. So if you are disposing the surface, then it may also be disposing the snapshot.\n\nI wonder if making a snapshot with bounds that is just slightly different to the surface bounds will cause a copy to be made and then you can let the GC collect.",
        "createdAt": "2025-03-11T18:44:43",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:15.0584628Z"
          }
        ]
      },
      {
        "id": 2715392107,
        "author": "mattleibow",
        "body": "Are you able to see the handle of the crash in the finalizer vs the handle in the ones you make? If there is an image that you create and then dispose that is then later being collected - something is really wrong. Dispose also calls \u0060GC.SuppressFinalize (this);\u0060 so it should _never_ happen.\n\nIt has to be the surface snapshot that may still be in use.",
        "createdAt": "2025-03-11T18:47:41",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:15.236441Z"
          }
        ]
      },
      {
        "id": 2715393578,
        "author": "mattleibow",
        "body": "Please! Help me keep my sanity! \uD83D\uDE06 ",
        "createdAt": "2025-03-11T18:48:26",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:15.4457643Z"
          }
        ]
      },
      {
        "id": 2715403972,
        "author": "najak3d",
        "body": "YES, this sounds very promising!   I\u0027m just feeding, as I wasn\u0027t tracking that Snapshot at all.  My call looks like this:\n\u0060\u0060\u0060\n_imageSamplingShader = _imageSurface.Snapshot().ToShader(SKShaderTileMode.Clamp, SKShaderTileMode.Clamp);\n\u0060\u0060\u0060\n\nNow changing it to this:\n\u0060\u0060\u0060\n_imageSamplingShader?.Dispose();\nusing (SKImage snapshot = _imageSurface.Snapshot())\n{\n\t_imageSamplingShader = snapshot.ToShader(SKShaderTileMode.Clamp, SKShaderTileMode.Clamp);\n}\n\u0060\u0060\u0060\n\nIf I drive you insane, we\u0027ll pay for your in-patient asylum medical costs.  We need to take care of you, just as you have taken such great care of us.\n\nThis latest guess makes a ton of sense... I didn\u0027t realize this Snapshot() was creating the SKImage too.  Doh.    Running tests now and will send you the results, within 30 minutes.",
        "createdAt": "2025-03-11T18:53:18",
        "reactions": []
      },
      {
        "id": 2715455474,
        "author": "najak3d",
        "body": "EVERYTHING LOOKING SUPER DUPER NOW!   THANK YOU!  (as I write, we\u0027re at 400K tiles loaded/drawn/Snapshotted, and counting..)\n\nWe have about a dozen places in our code where we do this \u0022Snapshot().ToShader()\u0022 without calling Dispose() on the Snapshot SKImage.   \n\nSo we\u0027re going to create an SKUtil static method called \u0022CreateShaderFromSurface(surface)\u0022 to return the SKShader, and will be sure to dispose of the Snapshot Image via \u0022using\u0022 context.\n\n====\nI had started down the path of calling forced \u0022GC.Collect\u0022 which improved the situation, but didn\u0027t fix it, while also causing our frame rate to drop by 15%.   So I\u0027m glad to avoid that kludge.\n\nNow at 440K tiles and counting.... (Previous record achieved via GC.Collect kludge was 167K, and without GC.Collect, record was 85K tiles, and typical was 40K-60K).\n\nSo I think we have a clear winner here!  Thanks!   Where do we send the money?",
        "createdAt": "2025-03-11T19:17:48",
        "reactions": []
      },
      {
        "id": 2715483807,
        "author": "mattleibow",
        "body": "I wonder why you need an explicit Dispose on the image tho... Maybe to release it in C# first before the shader does its thing.\n\nI feel like the image should be OK with the shader being collected. If the shader is making a copy of the image, then why should it matter if the Dispose or the GC is collecting things...\n\nDoes any of this happen with cpu rendering?",
        "createdAt": "2025-03-11T19:30:02",
        "reactions": []
      },
      {
        "id": 2715591571,
        "author": "mattleibow",
        "body": "For future me when I get to my windows machine... Trying to repro the code paths here, but not sure of the steps.\n\n\u0060\u0060\u0060cs\n\n[SkippableFact]\npublic unsafe void ImageSnaps()\n{\n\tvar (weak, shader) = DoWork();\n\n\tCollectGarbage();\n\n\tAssert.False(weak.IsAlive);\n\n\tshader.Dispose();\n\n\tstatic (WeakReference Weak, SKShader Shader) DoWork()\n\t{\n\t\tvar image = SKImage.FromEncodedData(Path.Combine(PathToImages, \u0022baboon.jpg\u0022));\n\t\tvar surface = SKSurface.Create(new SKImageInfo(image.Width, image.Height));\n\t\tsurface.Canvas.DrawImage(image, 0, 0);\n\t\timage.Dispose();\n\n\t\tvar snapshot = surface.Snapshot();\n\n\t\tsurface.Dispose();\n\n\t\tvar shader = snapshot.ToShader();\n\n\t\treturn (new WeakReference(snapshot), shader);\n\t}\n}\n\u0060\u0060\u0060",
        "createdAt": "2025-03-11T20:08:13",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:16.2213133Z"
          }
        ]
      },
      {
        "id": 2715707790,
        "author": "najak3d",
        "body": "\u003E I wonder why you need an explicit Dispose on the image tho... Maybe to release it in C# first before the shader does its thing.\n\u003E \n\u003E I feel like the image should be OK with the shader being collected. If the shader is making a copy of the image, then why should it matter if the Dispose or the GC is collecting things...\n\nI\u0027m not sure.   But I bet you are going to find out.\n\n\u003E Does any of this happen with cpu rendering?\n\nNot that we\u0027re seeing.  Our CPU rendering is much lighter weight.",
        "createdAt": "2025-03-11T21:06:03",
        "reactions": []
      },
      {
        "id": 2715727597,
        "author": "najak3d",
        "body": "I\u0027m going to create a new issue called \u0022please expose SkCanvas.WritePixels()\u0022 - to avoid the SKImage middleman.  My impression of that API is that it saves the middleman copy of our pixelBuffer, and skips the use of a Shader -- just does a Blit.\n\nWe do a TON of this, including this Raster Map tile example that we just resolved.\n\nAnother feature of our is Animating Weather (images) -- we have the images in RAM in \u0022code-runLength\u0022 quick compression mode, which we then send to the GPU to render the resulting Image. \n\nSo as we animated, currently, these images are decompressed JIT, into a fixed Pixel Buffer (the same one for all frames), and then we are creating SKImage from it, each frame, and then DrawImage to our render surface. (which is a full 1:1 copy of the image)...    Then our render pipeline Draws this full Image (enscribed onto the Surface) onto the final Screen Render Surface (using Matrix manipulations to scale/rotate/translate it)...\n\nIt would be nice to just go from \u0022PixBuffer\u0022 to \u0022Surface\u0022 each frame without creating this SKImage chaff as middleman.\n\nEDIT:  Added it here:\n#3195 ",
        "createdAt": "2025-03-11T21:17:04",
        "reactions": []
      },
      {
        "id": 2716274160,
        "author": "mattleibow",
        "body": "Why would you need a shader and not use the image directly? You can copy to the GPU using \u0060ToTextureImage\u0060, and skip the whole drawing, snapshot, shader process. Also, using a shader with clap is the same as just drawing the texture image directly I think?\n\nAlso, you don\u0027t need to copy the pixel data, just use the \u0060SKImage.FromPixels(SKImageInfo info, IntPtr pixels)\u0060 overload and pass the address of the first byte. This will reference the pixels directly.\n\nI saw these discussions:\n* https://groups.google.com/g/skia-discuss/c/M6G_bQd8Vf8/m/fW80OwXtEwAJ\n* https://groups.google.com/g/skia-discuss/c/EqvExXnEUbI/m/vpfpb3uHAwAJ\n\nBasically, the images are cached on the GPU, so you can try to increase the cache limits and let skia handle some caching. But, for more control, you could convert the image into a texture image and then just draw that directly.",
        "createdAt": "2025-03-12T02:56:59",
        "reactions": []
      },
      {
        "id": 2717808374,
        "author": "najak3d",
        "body": "\u003E Also, you don\u0027t need to copy the pixel data, just use the \u0060SKImage.FromPixels(SKImageInfo info, IntPtr pixels)\u0060 overload and pass the address of the first byte. This will reference the pixels directly.\n\nThis is what we\u0027re doing now to create the SKImage, that is then blitted to our surface.\n\n\u003E Why would you need a shader and not use the image directly? You can copy to the GPU using \u0060ToTextureImage\u0060, and skip the whole drawing, snapshot, shader process. Also, using a shader with clap is the same as just drawing the texture image directly I think?\n\nOur Tile Renderer is a shader, because we\u0027ve encoded the \u0022heightmap\u0022 into the tile image\u0027s alpha channel.  And our shader makes use of a \u0022cOwnshipAltitudeFt\u0022 uniform value, so that we can Colorize it as Yellow or Red for terrain that is a Collision hazard.  We need a custom shader to produce this colorization/enhancement effect in real-time (as the \u0022cOwnshipAltitudeFt\u0022 can vary frame to frame - the colorization logic is \u0027relative\u0027 to this).\n\n===\nI see now that we can avoid using the SKSurface middleman.  I just changed our code to skip this step and to create our SampleShader direct from the SKImage.\n\nEach time a tile image is changed, we have to do the following now:\n\u0060\u0060\u0060\nusing (var img = SKImage.FromPixelCopy(td.SKBitmap.Info, td.Image.pBits))\n{\n\t_imageSamplingShader?.Dispose();\n\t_imageSamplingShader = img.ToShader(SKShaderTileMode.Clamp, SKShaderTileMode.Clamp);\n}\n_children[\u0022img_map\u0022] = _imageSamplingShader;\n\n_shaderUniforms[\u0022cOwnshipAltitudeFt\u0022] = AlertViewAltFt;\n_shaderUniforms[\u0022cAltMin\u0022] = bci.MinElev; \n_shaderUniforms[\u0022cAltSpan\u0022] = bci.ElevSpan;\n\n_terrainShader?.Dispose();\n_terrainShader = SKUtil.ToShader(s_TerrainEffect, true, _shaderUniforms, _children);\n_terrainPaint.Shader = _terrainShader;\n\u0060\u0060\u0060\nwhere \u0027s_TerrainEffect\u0027 is our master custom shader.\n\n===\nIdeally, our work flow would simply be:\n1. Blit new pixel data directly to the existing \u0027_imageSamplingShader\u0027 pixel buffer.\n2. Update the _shaderUniforms[].\n\nAnd avoid doing these steps:\n1. Create/Dispose new SKImage middleman.\n2. Create/Dispose _imageSamplingShader \n3. Create/Dispose _terrainShader\n\n**In short, ideally, there we just keep using the CURRENT _terrainShader and _imageSamplingShader, with updated Pixel Data, and updated _shaderUniforms[].**\n\n\n",
        "createdAt": "2025-03-12T12:59:42",
        "reactions": []
      },
      {
        "id": 2717968143,
        "author": "mattleibow",
        "body": "You are using \u0060FromPixelCopy\u0060 which copies the pixels, if you use \u0060FromPixels\u0060 then it will just be a skia wrapper for your pixel data. Should have no allocations other than the infrastructure for drawing.",
        "createdAt": "2025-03-12T13:55:38",
        "reactions": [
          {
            "user": "najak3d",
            "content": "rocket",
            "createdAt": "2026-02-06T12:46:17.2176547Z"
          }
        ]
      },
      {
        "id": 2718835170,
        "author": "najak3d",
        "body": "\u003E You are using \u0060FromPixelCopy\u0060 which copies the pixels, if you use \u0060FromPixels\u0060 then it will just be a skia wrapper for your pixel data. Should have no allocations other than the infrastructure for drawing.\n\nThanks!   My revised code would look like this:\n\u0060\u0060\u0060\nusing (var img = SKImage.FromPixel(td.SKBitmap.Info, td.Image.pBits))\n{\n\t_imageSamplingShader?.Dispose();\n\t_imageSamplingShader = img.ToShader(SKShaderTileMode.Clamp, SKShaderTileMode.Clamp);\n}\n\u0060\u0060\u0060\nAnd you are saying that my \u0027pBits\u0027 Pixel buffer in RAM, goes straight to the GPU one-time, for use in the \u0022img.ToShader()\u0022??  Or are there intermediate copies of the pixel buffers?\n\nMy assumption is that the above logic would do this:\n1. Copies pBits pixels into private immutable SKIMage pixel buffer.\n2. \u0022ToShader()\u0022 then copies these pixels from SKImage buffer to it\u0027s own private buffer. \n(so here two new allocations are made?  I\u0027d prefer to just copy my pixels to a static GPU pixel buffer)\n\nPreference:\nI\u0027d much prefer that the existing Shader simply have a way to \u0022WritePixels()\u0022 direct to where it\u0027s private pixel buffer exists... and skip the intermediaries here.   With WritePixels(), there would be no confusion/ambiguity...    I\u0027d create the SamplerShader once, with a correctly sized pixel buffer; from then on, would just WritePixels() to update it\u0027s content.\n\n(This is how I was used to doing it with OpenGL.)\n",
        "createdAt": "2025-03-12T18:59:19",
        "reactions": []
      },
      {
        "id": 2719372767,
        "author": "najak3d",
        "body": "Is the \u0022preference\u0022 I\u0027m specifying here something that is even feasible with SKIA?  (Where the SamplerShader is kept intact, and we just update the PixelBuffer directly - and next time it renders, it uses this new data?)\n\nIf not, that\u0027s OK - -SkiaSharp kicks major butt.  We are very very pleased with the performance.   And my love and appreciation for you remains undying and unwavering. :)\n\nThank you, thank you, thank you!   For getting this resolved for us.  We\u0027ll be moving to Skia version 3, soon.  And will be happy to let you use our application as a Showcase/showpiece for Skia Sharp, if this interests you.",
        "createdAt": "2025-03-12T23:52:12",
        "reactions": []
      }
    ]
  }
}