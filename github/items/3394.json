{
  "number": 3394,
  "type": "pr",
  "state": "open",
  "title": "[BUG] Add GC.KeepAlive calls to protect P/Invoke parameters from premature collection",
  "body": "## Overview\n\nThis PR addresses a critical GC safety issue where managed objects can be prematurely collected while native code is still operating on their handles, potentially causing crashes or data corruption.\n\n## Problem\n\nAs described in [Chris Brumme\u0027s blog post on Lifetime, GC.KeepAlive, handle recycling](https://learn.microsoft.com/en-us/archive/blogs/cbrumme/lifetime-gc-keepalive-handle-recycling):\n\n\u003E Once we\u0027ve extracted \u0060_handle\u0060 from \u0060this\u0060, there are no further uses of this object. In other words, \u0060this\u0060 can be collected even while you are executing an instance method on that object. But what if class \u0060C\u0060 has a \u0060Finalize()\u0060 method which closes \u0060_handle\u0060? When we call \u0060C.OperateOnHandle()\u0060, we now have a race between the application and the GC / Finalizer.\n\nThe .NET runtime cannot see into native code. Once a handle is extracted from a managed object and passed to a P/Invoke method, the GC may:\n1. Determine the managed object is no longer referenced\n2. Collect and finalize the object (disposing its native handle)\n3. Cause the native code to operate on an invalid/freed handle\n\nThis race condition is particularly problematic under GC pressure (mobile devices, memory-constrained environments) and can manifest as intermittent crashes that are difficult to diagnose.\n\n### Real-World Example\n\nFrom the issue description and unoplatform/uno#21660:\n\n\u0060\u0060\u0060csharp\nvar canvas = ...\nvar picture = ...\ncanvas.DrawPicture(picture);\n// \u0060picture\u0060 is not referenced after this point, so GC can collect it\n// But native code may still be using picture.Handle!\n\u0060\u0060\u0060\n\n## Solution\n\nAdd \u0060GC.KeepAlive()\u0060 calls after P/Invoke methods to ensure reference type parameters remain alive until the native call completes:\n\n\u0060\u0060\u0060csharp\n// Before\npublic void DrawPicture(SKPicture picture, SKPaint paint = null)\n{\n    if (picture == null)\n        throw new ArgumentNullException(nameof(picture));\n    SkiaApi.sk_canvas_draw_picture(Handle, picture.Handle, null, paint?.Handle ?? IntPtr.Zero);\n}\n\n// After\npublic void DrawPicture(SKPicture picture, SKPaint paint = null)\n{\n    if (picture == null)\n        throw new ArgumentNullException(nameof(picture));\n    SkiaApi.sk_canvas_draw_picture(Handle, picture.Handle, null, paint?.Handle ?? IntPtr.Zero);\n    GC.KeepAlive(picture);\n    GC.KeepAlive(paint);\n}\n\u0060\u0060\u0060\n\n## Changes in This PR\n\n### Fixed Classes (40\u002B methods)\n- **SKCanvas.cs** - All drawing methods: \u0060DrawPicture\u0060, \u0060DrawImage\u0060, \u0060DrawPath\u0060, \u0060DrawPaint\u0060, \u0060DrawRegion\u0060, \u0060DrawRect\u0060, \u0060DrawRoundRect\u0060, \u0060DrawOval\u0060, \u0060DrawCircle\u0060, \u0060DrawPoint\u0060, \u0060DrawPoints\u0060, \u0060DrawText\u0060, \u0060DrawDrawable\u0060, \u0060DrawVertices\u0060, \u0060DrawArc\u0060, \u0060DrawRoundRectDifference\u0060, \u0060DrawAtlas\u0060, \u0060DrawPatch\u0060, \u0060DrawImageNinePatch\u0060, \u0060DrawImageLattice\u0060, and all \u0060Clip*\u0060 and annotation methods\n- **SKPaint.cs** - Constructor with \u0060SKFont\u0060, property setters (\u0060Shader\u0060, \u0060MaskFilter\u0060, \u0060ColorFilter\u0060, \u0060ImageFilter\u0060, \u0060Blender\u0060, \u0060PathEffect\u0060), \u0060SetColor\u0060, \u0060GetFillPath\u0060\n- **SKImage.cs** (partial) - \u0060FromPixelCopy\u0060, \u0060FromPixels\u0060, \u0060FromEncodedData\u0060, \u0060PeekPixels\u0060\n- **SKBitmap.cs** (partial) - \u0060ExtractSubset\u0060\n- **SKPath.cs** (partial) - Constructor, \u0060AddRoundRect\u0060, \u0060AddPath\u0060 (all overloads), \u0060AddPathReverse\u0060\n\n### Documentation\n- **GC_KEEPALIVE_IMPLEMENTATION_GUIDE.md** - Comprehensive implementation guide with patterns, examples, complete file checklist, and testing strategy\n- **analyze_gc_keepalive.sh** - Analysis script to identify remaining methods needing fixes\n\n## Scope\n\nThis issue affects approximately **200\u002B methods across 56 files** in \u0060binding/SkiaSharp\u0060. This PR implements the fix for the most critical and commonly-used APIs (~20% of total methods), providing:\n- Protection for all core drawing operations\n- A clear pattern for completing the remaining work\n- Tools and documentation to track and implement remaining fixes\n\n## Testing\n\nChanges follow the established pattern and are minimally invasive. Each fix:\n- Adds only \u0060GC.KeepAlive()\u0060 calls after existing P/Invoke calls\n- Does not change method signatures or behavior\n- Maintains backward compatibility\n\nTesting should include:\n1. Existing unit test suite (no regressions expected)\n2. GC stress testing under memory pressure\n3. Platform-specific validation (Android, iOS where GC behavior varies)\n\n## Related Issues\n\n- Related to unoplatform/uno#21660\n- Related to dotnet/java-interop#719\n- Follows guidance from [Chris Brumme\u0027s blog post](https://learn.microsoft.com/en-us/archive/blogs/cbrumme/lifetime-gc-keepalive-handle-recycling)\n\n## Remaining Work\n\nThe implementation guide (\u0060GC_KEEPALIVE_IMPLEMENTATION_GUIDE.md\u0060) documents all remaining files and provides a checklist for completing this work. High-priority files still needing fixes include:\n- SKPath.cs (12 more methods)\n- SKImageFilter.cs (28 methods)\n- SKTextBlob.cs (18 methods)\n- SKFont.cs (8 methods)\n- SKShader.cs (13 methods)\n- And 30\u002B additional files\n\nThe pattern is consistent and well-documented, making it straightforward to complete the remaining implementations.\n\n\u003E [!WARNING]\n\u003E\n\u003E \u003Cdetails\u003E\n\u003E \u003Csummary\u003EFirewall rules blocked me from connecting to one or more addresses (expand for details)\u003C/summary\u003E\n\u003E\n\u003E #### I tried to connect to the following addresses, but was blocked by firewall rules:\n\u003E\n\u003E - \u00600t3vsblobprodcus362.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u00602kmvsblobprodcus39.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u00602zrvsblobprodcus388.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u00607devsblobprodcus323.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u00607tjvsblobprodcus341.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060bcnvsblobprodcus378.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060c78vsblobprodcus322.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060frdvsblobprodcus327.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060ibzvsblobprodcus369.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060imzvsblobprodcus368.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060josvsblobprodcus372.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060kgfvsblobprodcus314.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060kh4vsblobprodcus325.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060kijvsblobprodcus387.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060l49vsblobprodcus358.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060s4uvsblobprodcus326.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060u3hvsblobprodcus371.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E - \u0060u6ovsblobprodcus377.vsblob.vsassets.io\u0060\n\u003E   - Triggering command: \u0060dotnet build -c Release\u0060 (dns block)\n\u003E\n\u003E If you need me to access, download, or install something from one of these locations, you can either:\n\u003E\n\u003E - Configure [Actions setup steps](https://gh.io/copilot/actions-setup-steps) to set up my environment, which run before the firewall is enabled\n\u003E - Add the appropriate URLs or hosts to the custom allowlist in this repository\u0027s [Copilot coding agent settings](https://github.com/mono/SkiaSharp/settings/copilot/coding_agent) (admins only)\n\u003E\n\u003E \u003C/details\u003E\n\n\u003C!-- START COPILOT CODING AGENT SUFFIX --\u003E\n\n\n\n\u003Cdetails\u003E\n\n\u003Csummary\u003EOriginal prompt\u003C/summary\u003E\n\n\u003E \n\u003E ----\n\u003E \n\u003E *This section details on the original issue you should resolve*\n\u003E \n\u003E \u003Cissue_title\u003E[BUG] P/Invokes should protect parameters across invocations\u003C/issue_title\u003E\n\u003E \u003Cissue_description\u003E### Description\n\u003E \n\u003E Context: https://learn.microsoft.com/en-us/archive/blogs/cbrumme/lifetime-gc-keepalive-handle-recycling\n\u003E Context: https://github.com/unoplatform/uno/pull/21660\n\u003E Context: https://github.com/dotnet/java-interop/issues/719\n\u003E \n\u003E *Background*: The most important background is Chris Bruce\u0027s blog post [Lifetime, GC.KeepAlive, handle recycling](https://learn.microsoft.com/en-us/archive/blogs/cbrumme/lifetime-gc-keepalive-handle-recycling). Excerpts:\n\u003E \n\u003E \u003E \u0060\u0060\u0060csharp\n\u003E \u003E class C {\n\u003E \u003E    IntPtr _handle;\n\u003E \u003E    Static void OperateOnHandle(IntPtr h) { ... }\n\u003E \u003E    void m() {\n\u003E \u003E       OperateOnHandle(_handle);\n\u003E \u003E       ...\n\u003E \u003E    }\n\u003E \u003E    ...\n\u003E \u003E }\n\u003E \u003E  \n\u003E \u003E class Other {\n\u003E \u003E    void work() {\n\u003E \u003E       if (something) {\n\u003E \u003E          C aC = new C();\n\u003E \u003E          aC.m();\n\u003E \u003E          ...  // most guess here\n\u003E \u003E       } else {\n\u003E \u003E          ...\n\u003E \u003E       }\n\u003E \u003E    }\n\u003E \u003E }\n\u003E \u003E \u0060\u0060\u0060\n\u003E \u003E \n\u003E \u003E It\u2019s more interesting to worry about the earliest point that \u0060aC\u0060 could be collected. \u2026\n\u003E \u003E \n\u003E \u003E \u2026 Actually, \u0060aC\u0060 could become eligible for collection before \u0060C.m()\u0060 even calls \u0060C.OperateOnHandle()\u0060. Once we\u2019ve extracted \u0060_handle\u0060 from \u0060this\u0060, there are no further uses of this object. In other words, \u0060this\u0060 can be collected even while you are executing an instance method on that object.\n\u003E \u003E \n\u003E \u003E But what if class \u0060C\u0060 has a \u0060Finalize()\u0060 method which closes \u0060_handle\u0060? When we call \u0060C.OperateOnHandle()\u0060, we now have a race between the application and the GC / Finalizer. Eventually, that\u2019s a race we\u2019re going to lose.\n\u003E \n\u003E Rephrased:\n\u003E \n\u003E  1. .NET is a multi-threaded environment, and the GC is one of many threads that can mutate your data.\n\u003E  2. The .NET runtime cannot \u0022see\u0022 into native code\n\u003E  3. Therefore, care must be taken to ensure that we don\u0027t allow the GC to collect instances *while native code is operating on them*.\n\u003E \n\u003E dotnet/java-interop#719 was one non-Skia example of this.\n\u003E \n\u003E unoplatform/uno#21660 is a Skia-related example of this.  Paraphrasing greatly, we have:\n\u003E \n\u003E \u0060\u0060\u0060csharp\n\u003E var canvas = \u2026\n\u003E var picture = \u2026\n\u003E canvas.DrawPicture(picture);\n\u003E // \u0060picture\u0060 is not referenced after this point.\n\u003E \u0060\u0060\u0060\n\u003E \n\u003E While we may *wish* that the \u0060canvas.DrawPicture()\u0060 call will keep \u0060picture\u0060 alive, *it does **not***.  Eventually you hit:\n\u003E \n\u003E https://github.com/mono/SkiaSharp/blob/34c5ed8272b9e0a138089d2e0a18f34f5592653f/binding/SkiaSharp/SKCanvas.cs#L533-L538\n\u003E \n\u003E meaning once exeecution hits \u0060SkiaApi.sk_canvas_draw_picture()\u0060, *nothing* ensures that \u0060picture\u0060 is kept alive.  (Or \u0060canvas\u0060, for that matter!)\n\u003E \n\u003E The fix: audit the code (is there a generator?) such that *all reference type parameters* are explicitly kept alive across P/Invoke boundaries.  For example, \u0060SKCanvas.DrawPicture()\u0060 should be updated to be:\n\u003E \n\u003E \u0060\u0060\u0060csharp\n\u003E partial class SKCanvas {\n\u003E \tpublic void DrawPicture (SKPicture picture, SKPaint paint = null)\n\u003E \t{\n\u003E \t\tif (picture == null)\n\u003E \t\t\tthrow new ArgumentNullException (nameof (picture));\n\u003E \t\tSkiaApi.sk_canvas_draw_picture (Handle, picture.Handle, null, paint == null ? IntPtr.Zero : paint.Handle);\n\u003E \t\tGC.KeepAlive (picture);\n\u003E \t\tGC.KeepAlive (paint);\n\u003E \t\t// *arguably* GC.KeepAlive(this), but maybe just require that the caller keep it around?\n\u003E \t}\n\u003E }\n\u003E \u0060\u0060\u0060\n\u003E \n\u003E This should be done for *all* public methods that invoke P/Invoke methods.\n\u003E \n\u003E ### Code\n\u003E \n\u003E -\n\u003E \n\u003E ### Expected Behavior\n\u003E \n\u003E _No response_\n\u003E \n\u003E ### Actual Behavior\n\u003E \n\u003E _No response_\n\u003E \n\u003E ### Version of SkiaSharp\n\u003E \n\u003E 3.116.0 (Current)\n\u003E \n\u003E ### Last Known Good Version of SkiaSharp\n\u003E \n\u003E Other (Please indicate in the description)\n\u003E \n\u003E ### IDE / Editor\n\u003E \n\u003E Visual Studio Code (macOS)\n\u003E \n\u003E ### Platform / Operating System\n\u003E \n\u003E Android, All\n\u003E \n\u003E ### Platform / Operating System Version\n\u003E \n\u003E _No response_\n\u003E \n\u003E ### Devices\n\u003E \n\u003E _No response_\n\u003E \n\u003E ### Relevant Screenshots\n\u003E \n\u003E _No response_\n\u003E \n\u003E ### Relevant Log Output\n\u003E \n\u003E \u0060\u0060\u0060shell\n\u003E \n\u003E \u0060\u0060\u0060\n\u003E \n\u003E ### Code of Conduct\n\u003E \n\u003E - [x] I agree to follow this project\u0027s Code of Conduct\u003C/issue_description\u003E\n\u003E \n\u003E ## Comments on the Issue (you are @copilot in this section)\n\u003E \n\u003E \u003Ccomments\u003E\n\u003E \u003C/comments\u003E\n\u003E \n\n\n\u003C/details\u003E\n\nFixes mono/SkiaSharp#3393\n\n\u003C!-- START COPILOT CODING AGENT TIPS --\u003E\n---\n\n\u2728 Let Copilot coding agent [set things up for you](https://github.com/mono/SkiaSharp/issues/new?title=\u2728\u002BSet\u002Bup\u002BCopilot\u002Binstructions\u0026body=Configure%20instructions%20for%20this%20repository%20as%20documented%20in%20%5BBest%20practices%20for%20Copilot%20coding%20agent%20in%20your%20repository%5D%28https://gh.io/copilot-coding-agent-tips%29%2E%0A%0A%3COnboard%20this%20repo%3E\u0026assignees=copilot) \u2014 coding agent works faster and does higher quality work when set up for your repo.\n",
  "author": {
    "login": "Copilot",
    "type": "Bot"
  },
  "labels": [],
  "assignees": [
    {
      "login": "mattleibow",
      "type": "User"
    },
    {
      "login": "Copilot",
      "type": "Bot"
    }
  ],
  "createdAt": "2025-10-22T01:51:35",
  "updatedAt": "2025-10-22T11:53:38",
  "commentCount": 0,
  "reactionCount": 0,
  "draft": true,
  "mergeable": true,
  "mergeableState": "behind",
  "baseBranch": "main",
  "headBranch": "copilot/fix-pinvoke-parameter-protection",
  "additions": 438,
  "deletions": 17,
  "changedFiles": 7,
  "commits": 6,
  "reviews": [
    {
      "author": "jonpryor",
      "state": "COMMENTED",
      "submittedAt": "2025-10-22T11:53:38"
    }
  ]
}