{
  "number": 2795,
  "type": "issue",
  "state": "open",
  "title": "[BUG] Custom SKSL Shaders - no longer compile",
  "body": "### Description\n\nAs we upgrade from 2.88.6 to 3.0.0-preview, our custom shaders now don\u0027t compile, and have many errors.  \r\n\r\nWhat I am requesting here is documentation on the changes made to SKGL, to guide us in porting our custom shaders to 3.0.0.\r\n\r\n\n\n### Code\n\nHere is our rather long Terrain Shader that works wonderfully inside SkiaSharp 2.88.6 (other than the inefficiencies, as seen in our doing a Quadruple Sampling and Lerping to simulate \u0022LINEAR\u0022 sampling mode):\r\n\r\n\u0060\u0060\u0060cs\r\n\tin fragmentProcessor elev_map;\r\n\tin fragmentProcessor vfr_map;\r\n\r\n\tuniform float cDarken; // Used to uniformly darked the entire result (for Night Time, etc).\r\n\tuniform float cShadingOn; // 0.0 = OFF,  \u003E 0 is ON\r\n    uniform float cAlpha; // Overall Transparency for Relief and Alert Highlights (can be throbbed)\r\n\r\n\t// Values used for showing Elevation Highlights (Red/Yellow)\r\n    uniform float cShowAlerts;\r\n\tuniform float cOwnshipAltitudeFt;\r\n    uniform float cAltThreshWarn;\r\n    uniform float cAltThreshDanger;\r\n\r\n\t// Values for Elevation Highlights with DISTANCE Radius\r\n\tuniform float cCtrX;\r\n\tuniform float cCtrY;\r\n\tuniform float cScaleX;\r\n\tuniform float cScaleY;\r\n\tuniform float4 cRad; // x=rad, y=radEnd, z=ctrX, w=ctrY\r\n\tuniform float2 cRot; // x=sinRot, y=cosRot\r\n\r\n\t// Values to interpret the Elevations\r\n\tuniform float cAltMin;\r\n\tuniform float cAltSpan;\r\n\r\n\t// Values to Draw Contour Lines\r\n\tuniform float cContourWidth;\r\n\tuniform float cInvContourSpacing;\r\n\tuniform float cContourAlpha;\r\n\r\nfloat smoothstep(float a, float b, float x) {\r\n        float t = clamp((x - a) / (b - a), 0.0, 1.0);\r\n        return t * t * (3.0 - 2.0 * t);\r\n    }\r\nfloat smoothstepFAST(float min, float max, float val) {\r\n\treturn (val \u003C= min) ? 0.0 : (val \u003E= max) ? 1.0 : ((val - min) / (max - min));\r\n}\r\n\r\nfloat3 getElev(float2 fc)\r\n{\r\n\treturn sample(elev_map, fc).xyz;\r\n}\r\n\r\nfloat4 main(float2 cf) \r\n{\r\n\tbool UseRadius = (cScaleX \u003E 0.0);\r\n\tbool ShowAlerts = (cShowAlerts \u003E 0.0);\r\n    bool IsColored = (cShadingOn \u003E 0.0); // true; // Toggle Colored Mode below\r\n    bool IsReliefMode = IsColored; // true; // RRRRRRRRRRRRRRRR true;\r\n\tbool ShowContours = IsColored; // true;\r\n\tbool OnlyShowAlerts = !IsColored \u0026\u0026 !IsReliefMode;\r\n\r\n\tif (OnlyShowAlerts \u0026\u0026 !ShowAlerts)\r\n\t\tdiscard; // This shader is entirely off!\r\n\r\n\tfloat2 fc;\r\n\tfloat3 elevNorm;\r\n\tfloat fwidthN = 0.0;\r\n\tconst float MinUV = 2.0; // 2 pixel margin around the tile Elevation image.  Rendered Terrain Tiles are only 124 pixels dim.\r\n\r\n\tif (IsReliefMode || ShowAlerts)\r\n\t{\r\n\t\tconst float UVIncr = 1.0; // / 128.0;\r\n\t\tconst float InvUVIncr = 1.0; //128.0;\r\n\r\n\t\tfloat fcxi = (cf.x * InvUVIncr);\r\n\t\tfloat fcyi = (cf.y * InvUVIncr);\r\n\t\tfloat fcxi0 = floor(fcxi);\r\n\t\tfloat fcyi0 = floor(fcyi);\r\n\r\n\t\t// These are \u0027lerps\u0027.\r\n\t\tfloat lpX = fcxi - fcxi0;\r\n\t\tfloat lpY = fcyi - fcyi0;\r\n\t\tfloat iLpX = 1.0 - lpX;\r\n\t\tfloat iLpY = 1.0 - lpY;\r\n\r\n\t\tfloat fcx0 = fcxi0 * UVIncr;\r\n\t\tfloat fcy0 = fcyi0 * UVIncr;\r\n\t\tfc = (float2(MinUV \u002B fcx0, MinUV \u002B fcy0));\r\n\t\tfloat3 el00 = getElev(fc);\r\n\t\tfc.x \u002B= UVIncr;\r\n\t\tfloat3 el10 = getElev(fc);\r\n\t\tfc.y \u002B= UVIncr;\r\n\t\tfloat3 el11 = getElev(fc);\r\n\t\tfc.x -= UVIncr;\r\n\t\tfloat3 el01 = getElev(fc);\r\n\r\n\t\televNorm = (el00 * iLpX * iLpY) \u002B (el10 * lpX * iLpY) \u002B (el01 * iLpX * lpY) \u002B (el11 * lpX * lpY);\r\n\r\n\t\tif (ShowContours)\r\n\t\t{\r\n\t\t\tfloat v00 = (el00.z \u002B el00.y);\r\n\t\t\tfloat v01 = (el01.z \u002B el01.y);\r\n\t\t\tfloat v10 = (el10.z \u002B el10.y);\r\n\t\t\tfloat v11 = (el11.z \u002B el11.y);\r\n\r\n\t\t\tconst float dlerp = 1.0;\r\n\t\t\tconst float iDlerp = 1.0 - dlerp;\r\n\t\t\tfloat dd = iDlerp * abs(v00 - v11);\r\n\t\t\tfloat adx = (dlerp * abs(v00 - v10)) \u002B dd;\r\n\t\t\tfloat ady = (dlerp * abs(v00 - v01)) \u002B dd;\r\n\t\r\n\t\t\tfwidthN = adx \u002B ady; //((el00.z \u002B el00.y) - (el11.z \u002B el11.y));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfwidthN = 9999;\r\n\t\tfc = (float2(MinUV, MinUV) \u002B cf);\r\n\t\televNorm = sample(elev_map, fc).xyz; \r\n\t}\r\n\r\n\tfloat elevChans = elevNorm.z \u002B elevNorm.y; // Range 0..2\r\n\tfloat elevFt = (cAltMin \u002B (elevChans * cAltSpan));\r\n\tfloat elevFtp2000 = elevFt \u002B 2000.0;\r\n    float alertElev = (ShowAlerts) ? (elevFt - cOwnshipAltitudeFt) : -99999.0;\r\n\r\n\tif (OnlyShowAlerts)\r\n\t{\r\n        if (alertElev \u003C cAltThreshWarn)\r\n            discard;\r\n\t}\r\n\r\n    const float BaseBright = 0.83;\r\n\tconst float InvBaseBright = 1.0 / BaseBright; // 1.20482; // inverse 0.83.   1.42857; // inverse of 0.7, which is the brightness for level (non-sloped) areas.\r\n\r\n    float4 color;\r\n\tfloat bVal = (IsReliefMode) ? elevNorm.x : BaseBright; // NOTE: .a for Droid\r\n\tfloat radFactor = 1.0;\r\n\tfloat alertFactor = 0.0;\r\n\r\n\tif (UseRadius) // RADIUS ===================================================================================================\r\n\t{\r\n\t\tbool HasRotation = (cRot.x != 0.0);\r\n\t\tfloat cfx = cf.x * cScaleX; // Scaled X offset\r\n\t\tfloat cfy = cf.y * cScaleY; // Scaled Y offset\r\n\t\tfloat radOfsX;\r\n\t\tfloat radOfsY;\r\n\r\n\t\tif (HasRotation)\r\n\t\t{\t// Calc Rotation impact - more math\r\n\t\t\tfloat cfRotX = (cfx * cRot.y) - (cfy * cRot.x); // (cfx * cos) - (cfy * sin)\r\n\t\t\tfloat cfRotY = (cfx * cRot.x) \u002B (cfy * cRot.y); // (cfx * sin) \u002B (cfy * cos)\r\n\t\t\tradOfsX = cCtrX \u002B cfRotX - cRad.z;\r\n\t\t\tradOfsY = cCtrY \u002B cfRotY - cRad.w;\r\n\t\t}\r\n\t\telse\r\n\t\t{\t// No Rotation logic - cheaper\r\n\t\t\tradOfsX = cCtrX \u002B cfx - cRad.z;\r\n\t\t\tradOfsY = cCtrY \u002B cfy - cRad.w;\r\n\t\t}\r\n\t\r\n\t\t// Now Determine if it\u0027s inside the Radius\r\n\t\tfloat distOffset2 = (radOfsX * radOfsX) \u002B (radOfsY * radOfsY);\r\n\t\tif (distOffset2 \u003E cRad.x)\r\n\t\t{\r\n\t\t\tradFactor = 1.0 - smoothstep(distOffset2, cRad.x, cRad.y);\r\n\t\t}\r\n\t}\r\n\r\n\tif (OnlyShowAlerts)\r\n\t{\t// Outside of Alert Radius, nothing to render\r\n        if (radFactor \u003C= 0.2)\r\n            discard;\r\n\t}\r\n\r\n\r\n\tif (IsColored)\r\n\t{\r\n\t\tconst float invPaletteSize = 0.015625; // 1 / 64\r\n\t\tconst float PaletteOffset = 0.0078125; // 1 / 128\r\n\r\n\t\tfloat palettePixel = 64.0 * floor(elevFtp2000 * 0.001); // rounds down to nearest 1000.\r\n\t\tfloat paletteU = PaletteOffset \u002B (palettePixel * invPaletteSize);\r\n\t\tvec2 paletteUV = vec2(paletteU, 0.0);\r\n\r\n\t\tcolor = sample(vfr_map, paletteUV).rgba; // abgr; // argb; // rgba;  // texture2D(sEnvMap, paletteUV).rgba;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcolor = float4(bVal, bVal, bVal, 1.0);\r\n\t}\r\n\r\n\tfloat boost = 0.0;\r\n\tfloat brightness = InvBaseBright * bVal;\r\n\r\n\tif (IsReliefMode)\r\n\t{\r\n\t\tcolor.rgb *= (0.9 * brightness);\r\n\t\tboost = 0.2 * (brightness - BaseBright);\r\n\t\tcolor.rgb \u002B= float3(boost, boost, boost);\r\n\t}\r\n\r\n\t// Now allow Alerts to override\r\n\tif (ShowAlerts \u0026\u0026 alertElev \u003E cAltThreshWarn \u0026\u0026 radFactor \u003E 0.1)\r\n\t{\r\n\t\tboost *= 3.0;\r\n\t\tfloat warnThresh2 = cAltThreshWarn \u002B 50.0;  // RRRRRE: should be const\r\n\t\tbool isYellow = (alertElev \u003C cAltThreshDanger);\r\n\t\tfloat green = (isYellow) ? (0.777 * brightness) : boost;\r\n\t\tfloat blue = (isYellow) ? (1.7 * boost) : boost;\r\n\r\n\t\tfloat alphaFactor = (alertElev \u003C warnThresh2) ? 0.5 \u002B (0.5 * smoothstep(cAltThreshWarn, warnThresh2, alertElev)) : 1.0;\r\n\t\tfloat alpha = (cAlpha * alphaFactor * radFactor);\r\n\t\tfloat invAlpha = 1.0 - alpha;\r\n\t\tcolor.rgb = (color.rgb * invAlpha) \u002B (alpha * float3(brightness, green, blue));  // BLEND\r\n\t}\r\n\r\n\tif (ShowContours)\r\n\t{\r\n\t\tfloat cl = elevFt * cInvContourSpacing;\r\n\t\tfloat cl0 = floor(cl);\r\n\t\tfloat cr = cl - cl0; // same as \u0027fract\u0027\r\n\t\tfloat df = 0.0003 * cAltSpan * cContourWidth * abs(fwidthN);\r\n\t\t//df = pow(df, 0.7);\r\n\r\n\t\tfloat c = 1.0 - smoothstep(df * 1.0, df * 2.0, cr);\r\n\t\tfloat showC = (elevFt \u003E 400.0) ? 1.0 : 0.0;\r\n\t\tcolor.rgb \u002B= (showC * c * cContourAlpha);\r\n\t\t\t\r\n\t\t//if (cr \u003C (0.05 * pow(1 - bVal, 0.1))) // \u0026\u0026 bVal \u003C 0.9)\r\n\t\t//\tcolor = float4(0.0, 0.0, 0.0, 1.0);\r\n\t}\r\n\r\n\tcolor.rgb *= cDarken; // Darken the entire result\r\n\tcolor.a = 1.0;\r\n\treturn color;\r\n}\r\n\u0060\u0060\u0060\r\n\n\n### Expected Behavior\n\nExpecting this to compile the same as it does for 2.88.6 -- or if not, then would like to have docs that guide me on the changes I need to make.\n\n### Actual Behavior\n\nInstead I now get 23 compiler errors, as follows:\r\nerror: 2: no type named \u0027fragmentProcessor\u0027\r\n    in fragmentProcessor elev_map;\r\n       ^^^^^^^^^^^^^^^^^\r\nerror: 2: no type named \u0027elev_map\u0027\r\n    in fragmentProcessor elev_map;\r\n                         ^^^^^^^^\r\nerror: 2: expected a declaration, but found \u0027;\u0027\r\n    in fragmentProcessor elev_map;\r\n                                 ^\r\nerror: 3: no type named \u0027fragmentProcessor\u0027\r\n    in fragmentProcessor vfr_map;\r\n       ^^^^^^^^^^^^^^^^^\r\nerror: 3: no type named \u0027vfr_map\u0027\r\n    in fragmentProcessor vfr_map;\r\n                         ^^^^^^^\r\nerror: 3: expected a declaration, but found \u0027;\u0027\r\n    in fragmentProcessor vfr_map;\r\n                                ^\r\nerror: 32: duplicate definition of \u0027float smoothstep(float a, float b, float x)\u0027\r\nfloat smoothstep(float a, float b, float x) {\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nerror: 33: unknown identifier \u0027x\u0027\r\n        float t = clamp((x - a) / (b - a), 0.0, 1.0);\r\n                         ^\r\nerror: 33: unknown identifier \u0027a\u0027\r\n        float t = clamp((x - a) / (b - a), 0.0, 1.0);\r\n                             ^\r\nerror: 33: unknown identifier \u0027b\u0027\r\n        float t = clamp((x - a) / (b - a), 0.0, 1.0);\r\n                                   ^\r\nerror: 33: unknown identifier \u0027a\u0027\r\n        float t = clamp((x - a) / (b - a), 0.0, 1.0);\r\n                                       ^\r\nerror: 34: unknown identifier \u0027t\u0027\r\n        return t * t * (3.0 - 2.0 * t);\r\n               ^\r\nerror: 34: unknown identifier \u0027t\u0027\r\n        return t * t * (3.0 - 2.0 * t);\r\n                   ^\r\nerror: 34: unknown identifier \u0027t\u0027\r\n        return t * t * (3.0 - 2.0 * t);\r\n                                    ^\r\nerror: 42: unknown identifier \u0027sample\u0027\r\n    return sample(elev_map, fc).xyz;\r\n           ^^^^^^\r\nerror: 42: unknown identifier \u0027elev_map\u0027\r\n    return sample(elev_map, fc).xyz;\r\n                  ^^^^^^^^\r\nerror: 55: discard statement is only permitted in fragment shaders\r\n        discard; // This shader is entirely off!\r\n        ^^^^^^^\r\nerror: 111: unknown identifier \u0027sample\u0027\r\n        elevNorm = sample(elev_map, fc).xyz; \r\n                   ^^^^^^\r\nerror: 111: unknown identifier \u0027elev_map\u0027\r\n        elevNorm = sample(elev_map, fc).xyz; \r\n                          ^^^^^^^^\r\nerror: 122: discard statement is only permitted in fragment shaders\r\n            discard;\r\n            ^^^^^^^\r\nerror: 165: discard statement is only permitted in fragment shaders\r\n            discard;\r\n            ^^^^^^^\r\nerror: 178: unknown identifier \u0027sample\u0027\r\n        color = sample(vfr_map, paletteUV).rgba; // abgr; // argb; // rgba;  // texture2D(sEnvMap, paletteUV).rgba;\r\n                ^^^^^^\r\nerror: 178: unknown identifier \u0027vfr_map\u0027\r\n        color = sample(vfr_map, paletteUV).rgba; // abgr; // argb; // rgba;  // texture2D(sEnvMap, paletteUV).rgba;\r\n                       ^^^^^^^\r\n23 errors\r\n\n\n### Version of SkiaSharp\n\n3.x (Alpha)\n\n### Last Known Good Version of SkiaSharp\n\n2.88.2 (Previous)\n\n### IDE / Editor\n\nVisual Studio (Windows)\n\n### Platform / Operating System\n\nWindows\n\n### Platform / Operating System Version\n\nWindows 11 Home\n\n### Devices\n\nWindows 11, CyberPowerPC, Intel i9 14900K\r\n\n\n### Relevant Screenshots\n\n_No response_\n\n### Relevant Log Output\n\n_No response_\n\n### Code of Conduct\n\n- [X] I agree to follow this project\u0027s Code of Conduct",
  "author": {
    "login": "najak3d",
    "type": "User"
  },
  "labels": [
    {
      "name": "type/bug",
      "color": "fc2929"
    }
  ],
  "assignees": [],
  "createdAt": "2024-03-12T11:33:53",
  "updatedAt": "2024-03-12T11:33:53",
  "commentCount": 0,
  "reactionCount": 1
}