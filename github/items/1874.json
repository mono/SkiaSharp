{
  "number": 1874,
  "type": "issue",
  "state": "closed",
  "title": "[QUESTION] Apparent poor performance in SKGLControl when overlaying bitmaps",
  "body": "Hello,\r\n  I\u0027m new to SkiaSharp, am trying to use it with its OpenGL backend to pan, zoom and overlay large bitmaps, and I\u0027m seeing poor performance I don\u0027t understand.   When I draw a single bitmap, drawing is very quick.  But when I overlay a second bitmap, performance drops precipitously.  I don\u0027t doubt that I\u0027m using SkiaSharp incorrectly, but I don\u0027t see where.\r\n\r\nI\u0027m on windows 10 build 19043.1348, using the SkiaSharp, SkiaSharp.Views.Desktop.Common and SkiaSharp.Views.WindowsForms nuget packages, all v2.80.3.\r\n\r\nHere is code that demonstrates the behavior.  This code creates an SKGLControl and a form containing it.  (My understanding is that the SKGLControl handles OpenGL, and I don\u0027t need to do anything further to get GPU acceleration.  Is this right?)\r\n\r\nThe code then loads three bitmaps, two from the same file.  It then proceeds to draw the bitmaps on the SKGLControl repeatedly, measuring the time between each iteration.  There\u0027s a configuration variable (run_case) that says what to draw, and the timings for each case are shown below.\r\n\r\n    [STAThread]\r\n    static void Main()\r\n    {\r\n        var form = new Form { Size = new System.Drawing.Size(1400, 800) };\r\n        var control = new SKGLControl { Dock = DockStyle.Fill }; form.Controls.Add(control);\r\n\r\n        // All images Width=4992 Height=4096 AlpaType=Opaque ColorType=Bgra8888 isTextureBacked=false\r\n        var image1 = SKImage.FromEncodedData(@\u0022bitmap1.png\u0022);\r\n        var image2 = SKImage.FromEncodedData(@\u0022bitmap2.png\u0022);\r\n        var image3 = SKImage.FromEncodedData(@\u0022bitmap1.png\u0022);  // note, this is the same bitmap loaded as image1\r\n\r\n        var draw_count = 0;\r\n        var timer = System.Diagnostics.Stopwatch.StartNew();\r\n\r\n        var run_case = 6;\r\n\r\n        control.PaintSurface \u002B= (object sender, SKPaintGLSurfaceEventArgs e) =\u003E\r\n        {\r\n            var opacity = 1f;\r\n            var src_rect = new SKRect(0, 0, image1.Width, image1.Height);\r\n            var dest_rect1 = SKRect.Create(0, 0, control.Width, control.Height);\r\n            var dest_rect2 = SKRect.Create(0, 0, 0.8f * control.Width, 0.8f * control.Height);\r\n            var paint = new SKPaint { FilterQuality = SKFilterQuality.None, Color = SKColors.White.WithAlpha((byte)(255f * opacity)) };\r\n            var canvas = e.Surface.Canvas;\r\n\r\n            switch(run_case)\r\n            {\r\n                case 1:\r\n                    canvas.DrawImage(image1, src_rect, dest_rect1, paint);\r\n                    break;\r\n                case 2:\r\n                    canvas.DrawImage(image2, src_rect, dest_rect2, paint);\r\n                    break;\r\n                case 3:\r\n                    canvas.DrawImage(image1, src_rect, dest_rect1, paint);\r\n                    canvas.DrawImage(image1, src_rect, dest_rect2, paint);\r\n                    break;\r\n                case 4:\r\n                    canvas.DrawImage(image2, src_rect, dest_rect1, paint);\r\n                    canvas.DrawImage(image2, src_rect, dest_rect2, paint);\r\n                    break;\r\n                case 5:\r\n                    canvas.DrawImage(image1, src_rect, dest_rect1, paint);\r\n                    canvas.DrawImage(image2, src_rect, dest_rect2, paint);\r\n                    break;\r\n                case 6:\r\n                    canvas.DrawImage(image1, src_rect, dest_rect1, paint);\r\n                    canvas.DrawImage(image3, src_rect, dest_rect2, paint);\r\n                    break;\r\n            }\r\n\r\n            draw_count\u002B\u002B;\r\n            var msec_per_draw = timer.ElapsedMilliseconds / (double)draw_count;\r\n\r\n            canvas.DrawText($\u0022msec/draw = {msec_per_draw:F0}\u0022, new SKPoint(100, 100), new SKPaint { TextSize = 32, Color = SKColors.Blue });\r\n            control.Invalidate();\r\n        };\r\n\r\n        Application.Run(form);\r\n    }\r\n\r\nHere are the times printed by the DrawText call.  Because the Stopwatch is created on the main thread, then the form and SKGLControl are created and initialized before the draw loop starts on the graphics thread, I\u0027ve let the program run a while to let this time settle down.\r\n\r\ncase 1: 18 msec \u003C- draws bitmap1 once\r\ncase 2: 18 msec \u003C- draws bitmap2 once\r\ncase 3: 18 msec \u003C- draws bitmap1 twice\r\ncase 4: 18 msec \u003C- draws bitmap2 twice\r\ncase 5: 510 msec \u003C- draws bitmap1 then bitmap2\r\ncase 6: 403 msec \u003C- draws bitmap1 then bitmap1 again as different image instance\r\n\r\nAlso, when running these cases in visual studio community 2019 with the debugger, it looks like one core is saturated in cases 5 and 6.\r\n\r\nIf I load the png files as SKBitmaps rather than SKImages, the case 5 \u0026 6 times are somewhat less but still much greater than the other cases.  If I remove the assignment to the Color property of the SKPaint and let that default, the times don\u0027t change.\r\n\r\nWhat is going on with these times, and what mental model should I have about what Skia is doing that explains them?  Do I need to initialize the SKGLControl differently?  I had thought that Skia would transfer the images as bitmaps to the GPU and render them onto the openGL context there, with very little work done by the CPU.  That doesn\u0027t seem to be the case when overlaying the second image.\r\n\r\nMy goal is to render multiple bitmaps overlayed with transparency and to pan and zoom them smoothly.  My machine\u0027s GPU should be capable of doing that, and I think Skia should be able to use the GPU do it.  These bitmaps are fairly large (4992x4096), and GDI\u002B is too slow.\r\n Thank you,\r\n     Mark Shirley\r\n\r\np.s., If I switch from using SKImage to using SKBitmap explicitly and then create the bitmaps via new SKBitmap(4992, 4096, true) rather than reading them from files, the behavior is similar.  The speed of case 3 (draw image1 twice) is still 18 msec and the speed of drawing two different bitmaps (created the same way) is 241 msec. This is faster than the example with images with varying data in them but still much slower than drawing a single image either once or twice.\r\n\r\nI\u0027ve also calling SetImmutable() on each of the SKBitmap\u0027s, with no change to the behavior.",
  "author": {
    "login": "Costigan",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2021-11-26T21:23:40",
  "updatedAt": "2022-08-19T00:02:07",
  "closedAt": "2021-12-01T21:34:16",
  "commentCount": 1,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-04T20:56:05.447344Z",
    "reactions": [],
    "comments": [
      {
        "id": 984074636,
        "author": "Costigan",
        "createdAt": "2021-12-01T21:34:16",
        "reactions": []
      }
    ]
  }
}