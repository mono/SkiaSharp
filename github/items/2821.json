{
  "number": 2821,
  "type": "issue",
  "state": "open",
  "title": "[BUG] \u0060SKNativeObject\u0060 instances are not kept alive during native API calls",
  "body": "### Description\r\n\r\nHi there, I\u0027m currently integrating SkiaSharp in a project, and it seems to work well so far. However, when looking through the source code, unless I\u0027m missing something, I think there\u0027s an issue/bug in how the native handle of \u0060SKNativeObject\u0060 (e.g. \u0060SKPaint\u0060) is freed by the finalizer (i.e. when you don\u0027t explicitly call \u0060Dispose()\u0060).\r\n\r\nGenerally, when a managed object wraps a native handle/pointer, you want to ensure that the handle is not released \u0022prematurely\u0022, i.e. when it is still in use. See the [following comment in \u0060GC.KeepAlive()\u0060](https://github.com/dotnet/runtime/blob/b8964d8bc2d94bab9deb29791fb8eee7cb9ddc90/src/coreclr/System.Private.CoreLib/src/System/GC.CoreCLR.cs#L245-L261):\r\n\r\n\u003E // The JIT is very aggressive about keeping an\r\n\u003E // object\u0027s lifetime to as small a window as possible, to the point\r\n\u003E // where a \u0027this\u0027 pointer isn\u0027t considered live in an instance method\r\n\u003E // unless you read a value from the instance.  So for finalizable\r\n\u003E // objects that store a handle or pointer and provide a finalizer that\r\n\u003E // cleans them up, this can cause subtle race conditions with the finalizer\r\n\u003E // thread.  This isn\u0027t just about handles - it can happen with just\r\n\u003E // about any finalizable resource.\r\n\u003E //\r\n\u003E // Users should insert a call to this method right after the last line\r\n\u003E // of their code where their code still needs the object to be kept alive.\r\n\u003E // The object which reference is passed into this method will not\r\n\u003E // be eligible for collection until the call to this method happens.\r\n\u003E // Once the call to this method has happened the object may immediately\r\n\u003E // become eligible for collection.\r\n\r\nFor example, consider the following user code, where a \u0060SKPaint\u0060 is created without a \u0060using\u0060 statement (so it isn\u0027t disposed explicitly):\r\n\r\n\u0060\u0060\u0060cs\r\nvoid DrawSomething(SKCanvas canvas)\r\n{\r\n    var paint = new SKPaint\r\n    {\r\n        Style = SKPaintStyle.Stroke,\r\n        StrokeWidth = 2f\r\n    };\r\n\r\n    canvas.DrawLine(0, 0, 50, 50, paint);\r\n}\r\n\u0060\u0060\u0060\r\n\u0060canvas.DrawLine(...)\u0060 will retrieve the \u0060Handle\u0060 of the \u0060SKPaint\u0060 and \u0060SKCanvas\u0060, and pass it to the native \u0060sk_canvas_draw_line\u0060 function:\r\n\r\nhttps://github.com/mono/SkiaSharp/blob/a290ccffc74bc95a45569e8b74e77be851d4a688/binding/SkiaSharp/SKCanvas.cs#L89-L94\r\n\r\nHowever, because the \u0060SKPaint\u0060 object in the example above isn\u0027t used after the \u0060canvas.DrawLine()\u0060 call, it may become eligible for garbage collection right after retrieving its \u0060Handle\u0060 property in \u0060SKCanvas.DrawLine()\u0060.\r\n\r\nThis could mean that the GC finalizer already calls \u0060SkiaApi.sk_compatpaint_delete\u0060 (from the finalizer thread) while \u0060SkiaApi.sk_canvas_draw_line()\u0060 is still executing, or even before \u0060SkiaApi.sk_canvas_draw_line\u0060 is called, which would cause undefned behavior, like invalid memory access (e.g. it could cause Access Violations such as in #2794, though I don\u0027t know whether that issue would be caused by this one).\r\n\r\nFor example, this might be an issue when using \u0060RichString\u0060 from \u0060Topten.RichTextKit\u0060, which doesn\u0027t seem to explicitly dispose SK objects like \u0060SKFont\u0060 etc., and relies on the finalizer freeing the handle.\r\n\r\nA solution is to add \u0060GC.KeepAlive()\u0060 calls after a native API call (as described in that method\u0027s comment), to keep the objects alive from which the handles are retrieved. For example, with \u0060SKCanvas.DrawLine()\u0060, the code could be changed to this:\r\n\r\n\u0060\u0060\u0060cs\r\npublic void DrawLine (float x0, float y0, float x1, float y1, SKPaint paint)\r\n{\r\n    if (paint == null)\r\n        throw new ArgumentNullException (nameof (paint));\r\n    SkiaApi.sk_canvas_draw_line (Handle, x0, y0, x1, y1, paint.Handle);\r\n\r\n    // Keep the objects with handles alive until after the native API call returns.\r\n    GC.KeepAlive (this);\r\n    GC.KeepAlive (paint);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe \u0060GC.KeepAlive()\u0060 calls here ensure that the objects (\u0060SKPaint\u0060 and \u0060SKCanvas\u0060) don\u0027t become eligible for GC (and thus their finalizer which would delete the native handles won\u0027t be called) until after the \u0060SkiaApi.sk_canvas_draw_line\u0060 call returns.\r\n\r\nThis is also e.g. how \u0060dotnet/winforms\u0060 handles it: https://github.com/dotnet/winforms/blob/897c9d87e973be3724375f8b272e82a5c6692070/src/System.Drawing.Common/src/System/Drawing/Bitmap.cs#L179-L180\r\n\r\nWhat do you think?\r\nThanks!\r\n\r\n### Code\r\n\r\n(see above)\r\n\r\n### Expected Behavior\r\n\r\n\u0060SKNativeObject\u0060 instances should be kept alive during native API calls where their \u0060Handle\u0060 is passed, until after the native API call returns.\r\n\r\n### Actual Behavior\r\n\r\n\u0060SKNativeObject\u0060 instances are not kept alive, which could cause the GC calling the finalizer which would delete the handle via functions such as \u0060SkiaApi.sk_compatpaint_delete\u0060 while or before another thread still uses these handles in a native API call like \u0060SkiaApi.sk_canvas_draw_line\u0060, causing undefined behavior.\r\n\r\n### Version of SkiaSharp\r\n\r\n3.x (Alpha)\r\n\r\n### Last Known Good Version of SkiaSharp\r\n\r\nOther (Please indicate in the description)\r\n\r\n### IDE / Editor\r\n\r\nVisual Studio (Windows)\r\n\r\n### Platform / Operating System\r\n\r\nWindows\r\n\r\n### Platform / Operating System Version\r\n\r\nWindows 10 Pro Version 22H2 (x64)\r\n\r\n### Devices\r\n\r\n_No response_\r\n\r\n### Relevant Screenshots\r\n\r\n_No response_\r\n\r\n### Relevant Log Output\r\n\r\n_No response_\r\n\r\n### Code of Conduct\r\n\r\n- [X] I agree to follow this project\u0027s Code of Conduct",
  "author": {
    "login": "kpreisser",
    "type": "User"
  },
  "labels": [
    {
      "name": "type/bug",
      "color": "fc2929"
    }
  ],
  "assignees": [],
  "createdAt": "2024-04-06T09:46:39",
  "updatedAt": "2024-04-07T21:15:46",
  "commentCount": 0,
  "reactionCount": 0
}