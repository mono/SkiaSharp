{
  "number": 2358,
  "type": "issue",
  "state": "open",
  "title": "[QUESTION] Trying to use span\u003CSKColor\u003E and get moire pattern",
  "body": "Hello I have a pice of code that creates a circle with points of color in the following way(see code) i have three ways of doing it the first one produces the result I want but is slow the other two are faster but the output is wrong see the following code and outcome (screenshots).\r\nThe first and slow method write to the canvas with a DrawCircle and x /y pos this\r\n  see nr 1\r\nTo speed things up i use a span of SKColor in two different versions to write directly to bitmap but if I use any other color then SKColors.Black I get moire patterns.\r\nthe first span method use an SKBitmap of 1024 * 1 bytes and Translate and RotateDegrees this produces moire pattern. See 2\r\nThe second span method (fastest) i use the whole 1024*1024 BitMap in other words an array of a 1048576 SKColor and use x and y i also get moire pattern see 3.\r\nVersion 2.88.3 same problem on Android and iOS.\t\r\nAny idea of what i do wrong?\r\n\r\nDrawCircle gray display is as i expect\r\n\r\n\u0060\u0060\u0060\r\npublic static void Write1SpokeToCanvas(SKSurface inSurface,ConcurrentQueue\u003CdrawingDataNew\u003E queuDrawings, ref float range, SKColor radarBackgroundColor)\r\n        {\r\n   bool retValue;\r\n                drawingDataNew drawdata;\r\n                int midx, midy;\r\n                midx = 1024 / 2 \u002B xOffset;\r\n                midy = 1024 / 2 \u002B yOffset;\r\n                byte[] spoke = new byte[512];\r\n            lock (LockingPaintThread)\r\n            {\r\n                while (queuDrawings.Count \u003E 0)\r\n                {\r\n                    retValue = queuDrawings.TryDequeue(out drawdata);\r\n                    var angle = drawdata.degree;\r\n                    double rad = ToRadian(angle);\r\n                    double radcos = Math.Cos(rad);\r\n                    double radsin = Math.Sin(rad);\r\n                    if (retValue)\r\n                    {\r\n                        range = drawdata.range;\r\n                        spoke = drawdata.data;\r\n                        for (int k = 0; k \u003C 512; k\u002B\u002B)\r\n                        {\r\n                            float r = k;//*scale;\r\n                            int valpunkt = spoke[k]; ;\r\n                            var paint = theColorWeak;\r\n                             paint.Color = SKColors.Transparent;\r\n                            if (valpunkt == 0)\r\n                                paint.Color = radarBackgroundColor;                 \r\n                            else if (valpunkt \u003E ThresholdRed)\r\n                                paint = theColorStrong;\r\n                            else if (valpunkt \u003E ThresholdGreen)\r\n                                paint = theColorIntermediate;\r\n                            else if (valpunkt \u003E ThresholdBlue)\r\n                                paint = theColorWeak;\r\n                            float x = (float)(midx \u002B radcos * r);\r\n                            float y = (float)(midy \u002B radsin * r);\r\n                            inSurface.Canvas.DrawCircle((int)x, (int)y, 1f, paint);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n2. Transformtransparent display has a moire pattern \r\nThe inBitMap is created as follows\r\n\u0060\u0060\u0060\r\nSKBitmap(new SKImageInfo((int)radarRect.Width, 1, SKColorType.Bgra8888, SKAlphaType.Premul));\r\npublic static void Write1SpokeToBitMemory(SKCanvas inCanvas,SKBitmap inBitMap, ConcurrentQueue\u003CdrawingDataNew\u003E queuDrawings, ref float range, SKColor radarBackgroundColor)\r\n        {\r\n            lock (LockingPaintThread)\r\n            {\r\n              var   lokBmp = new SKBitmap(new SKImageInfo(1024, 1, SKColorType.Bgra8888, SKAlphaType.Premul));\r\n\r\n                var span = lokBmp.PeekPixels().GetPixelSpan\u003CSKColor\u003E();\r\n                bool retValue;\r\n                drawingDataNew drawdata;\r\n                byte[] spoke;\r\n                int x, y;\r\n                while (queuDrawings.Count \u003E 0)\r\n                {\r\n                    retValue = queuDrawings.TryDequeue(out drawdata);\r\n                    if (retValue)\r\n                    {\r\n                        range = drawdata.range;\r\n                        spoke = drawdata.data;\r\n                        for (int k = 0; k \u003C 512; k\u002B\u002B)\r\n                        {\r\n                            float r = k;//*scale;\r\n                            int valpunkt = spoke[k]; ;\r\n                            var paint = theColorWeak;\r\n                            paint.Color = SKColors.Empty;\r\n                            if (valpunkt == 0)\r\n\r\n                     //       paint.Color = SKColors.Transparent;\r\n                            paint.Color = SKColors.Black;\r\n     \r\n\r\n                            else if (valpunkt \u003E ThresholdRed)\r\n                                paint = theColorStrong;\r\n                            else if (valpunkt \u003E ThresholdGreen)\r\n                                paint = theColorIntermediate;\r\n                            else if (valpunkt \u003E ThresholdBlue)\r\n                                paint = theColorWeak;\r\n                            span[k] = paint.Color;\r\n                        }\r\n\r\n                        inCanvas.Save();\r\n                        inCanvas.Translate(new SKPoint(512, 512));\r\n                        inCanvas.RotateDegrees(drawdata.degree);\r\n                        inCanvas.DrawBitmap(lokBmp, 0, 0);\r\n                        inCanvas.Restore();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n\r\n3.  Direct span without transform display has a moire pattern\r\nThe span is created as follows \r\n\u0060\u0060\u0060\r\n   var radarsurfspokeBmp = new SKBitmap(new SKImageInfo(1024,1024, SKColorType.Bgra8888, SKAlphaType.Premul));\r\n Span\u003CSKColor\u003E radarBitmapSpan = radarsurfspokeBmp.PeekPixels().GetPixelSpan\u003CSKColor\u003E();\r\n\r\n   public static void Write1SpokeToBitmapSpanMemory(Span\u003CSKColor\u003E span,  ConcurrentQueue\u003CdrawingDataNew\u003E queuDrawings, ref float range, SKColor radarBackgroundColor)\r\n        {\r\n      // 1024*1024 = 1048576\r\n                bool retValue;\r\n                drawingDataNew drawdata;\r\n                byte[] spoke;      \r\n            int midx = 1024 / 2 \u002B xOffset;\r\n            int midy = 1024 / 2 \u002B yOffset;\r\n            lock (LockingPaintThread)\r\n                {\r\n                    while (queuDrawings.Count \u003E 0)\r\n                    {\r\n                        retValue = queuDrawings.TryDequeue(out drawdata);\r\n                        var angle = drawdata.degree;\r\n                        double rad = ToRadian(angle);\r\n                        double radcos = Math.Cos(rad);\r\n                        double radsin = Math.Sin(rad);\r\n                        if (retValue)\r\n                        {\r\n                            range = drawdata.range;\r\n                            spoke = drawdata.data;\r\n                            for (int k = 0; k \u003C 512; k\u002B\u002B)\r\n                            {\r\n                                float r = k;//*scale;\r\n                                int valpunkt = spoke[k]; \r\n                                var paint = theColorWeak;\r\n                                paint.Color = SKColors.Transparent;\r\n                                if (valpunkt == 0)\r\n                                  paint.Color = SKColors.Transparent;\r\n                                else if (valpunkt \u003E ThresholdRed)\r\n                                    paint = theColorStrong;\r\n                                else if (valpunkt \u003E ThresholdGreen)\r\n                                    paint = theColorIntermediate;\r\n                                else if (valpunkt \u003E ThresholdBlue)\r\n                                    paint = theColorWeak;\r\n                                int x = (int)(radcos * r);\r\n                                int y = (int)(radsin * r);\r\n                            var s\r\n![Screenshot_directDrawCirclegrey](https://user-images.githubusercontent.com/4975613/211543543-de282c1c-00af-4631-acd7-2903278a22a2.png)\r\npanplac = GetPlaceInBitmapSpan((int)x,(int) y);\r\n                            if (spanplac \u003E 1048576)\r\n                          \r\n                                Debug.WriteLine(\u0022X:\u0022 \u002B x \u002B \u0022 Y:\u0022 \u002B y);\r\n                            else\r\n                            span[spanplac] = paint.Color;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\u0060\u0060\u0060\r\n![Screenshot_transform\r\n![Screenshot_directspangrey](https://user-images.githubusercontent.com/4975613/211543656-53f92292-ac8f-4e80-bad3-27cc0b8197e4.png)\r\nspangrey](https://user-images.githubusercontent.com/4975613/211543606-222f3c3f-b5a4-4eea-9bd6-2b59373452b2.png)\r\n",
  "author": {
    "login": "pilotshamn",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "createdAt": "2023-01-10T11:48:42",
  "updatedAt": "2023-01-10T11:50:02",
  "commentCount": 1,
  "reactionCount": 0
}