{
  "number": 1343,
  "type": "issue",
  "state": "closed",
  "title": "[BUG] SKCanvas owned by SKSurface gets disposed",
  "body": "**Description**\r\n\r\nThe SKCanvas object that is originally owned by the SKSurface ends up being disposed at some point in a highly multi-threaded environment. We have seen this happen with both surfaces provided by a SKElement as well as surfaces created off screen. The issue may appear immediately or after a couple mins of running the demo.  The more threads the more likely it is to happen. The debugger shows that the SKSurface still holds a canvas object but looking through source I suspect this is a newly created canvas different from the original one.\r\n\r\n**Code**\r\n\u0060\u0060\u0060xaml\r\n\u003CWindow x:Class=\u0022WpfApp1.MainWindow\u0022\r\n        xmlns=\u0022http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0022\r\n        xmlns:x=\u0022http://schemas.microsoft.com/winfx/2006/xaml\u0022\r\n        xmlns:d=\u0022http://schemas.microsoft.com/expression/blend/2008\u0022\r\n        xmlns:mc=\u0022http://schemas.openxmlformats.org/markup-compatibility/2006\u0022\r\n        xmlns:local=\u0022clr-namespace:WpfApp1\u0022\r\n        xmlns:skia =\u0022clr-namespace:SkiaSharp.Views.WPF;assembly=SkiaSharp.Views.WPF\u0022\r\n        mc:Ignorable=\u0022d\u0022\r\n        Title=\u0022MainWindow\u0022 Height=\u0022450\u0022 Width=\u0022800\u0022\u003E\r\n    \u003CGrid\u003E\r\n        \u003Cskia:SKElement\r\n            Name=\u0022Canvas\u0022\r\n            PaintSurface=\u0022SKElement_PaintSurface\u0022 /\u003E\r\n    \u003C/Grid\u003E\r\n\u003C/Window\u003E\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060cs\r\nusing SkiaSharp;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Windows;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Data;\r\nusing System.Windows.Documents;\r\nusing System.Windows.Input;\r\nusing System.Windows.Media;\r\nusing System.Windows.Media.Imaging;\r\nusing System.Windows.Navigation;\r\nusing System.Windows.Shapes;\r\n\r\nnamespace WpfApp1\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Interaction logic for MainWindow.xaml\r\n    /// \u003C/summary\u003E\r\n    public partial class MainWindow : Window\r\n    {\r\n        const int NUM_THREADS = 16;\r\n        SKImage _image = null;\r\n        object _imageLock = new object();\r\n        Random random = new Random();\r\n\r\n\r\n\r\n        public MainWindow()\r\n        {\r\n            InitializeComponent();\r\n            \r\n            for (int i = 0; i \u003C NUM_THREADS; i\u002B\u002B)\r\n                Task.Run(() =\u003E\r\n                {\r\n                    for (; ; )\r\n                        UpdateImage();\r\n                });\r\n        }\r\n\r\n        private void UpdateImage()\r\n        {\r\n            using (var surface = SKSurface.Create(new SKImageInfo((int)ActualWidth, (int)ActualHeight, SKImageInfo.PlatformColorType, SKAlphaType.Premul)))\r\n            {\r\n                if (surface != null)\r\n                {\r\n                    var canvas = surface.Canvas;\r\n\r\n                    canvas.Clear(SKColors.Orange);\r\n                    using (var paint = new SKPaint() { TextSize = 136, TextAlign = SKTextAlign.Center })\r\n                        canvas.DrawText($\u0022{random.Next()}\u0022, new SKPoint((float)ActualWidth / 2, (float)ActualHeight / 2), paint);\r\n                    canvas.RestoreToCount(-1);\r\n\r\n                    var image = surface.Snapshot();\r\n\r\n                    lock (_imageLock)\r\n                        _image = image;\r\n                }\r\n            }\r\n            Application.Current?.Dispatcher?.Invoke(() =\u003E Canvas?.InvalidateVisual());\r\n        }\r\n\r\n        private void SKElement_PaintSurface(object sender, SkiaSharp.Views.Desktop.SKPaintSurfaceEventArgs e)\r\n        {\r\n            lock (_imageLock)\r\n            {\r\n                if (_image != null)\r\n                    e.Surface.Canvas.DrawImage(_image, new SKRect(0, 0, _image.Width, _image.Height), new SKRect(0, 0, e.Info.Width, e.Info.Height));\r\n            }\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n**Expected Behavior**\r\n\r\nThe canvas should live until the surface is disposed.\r\n\r\n**Actual Behavior**\r\n\r\nThe canvas is being disposed mid render sequence. \r\n\r\n**Basic Information**\r\n\r\n- Version with issue:  1.68.3 , 2.80.0 preview 14\r\n- Last known good version:  N/A\r\n- IDE:  VS 2019 Pro\r\n- Platform Target Frameworks: .Net Standard 2.0 , .Net Framework 4.7.2, WPF, Windows 10 update 1809\r\n\r\n**Screenshots**\r\n\r\n![image](https://user-images.githubusercontent.com/41022806/85171925-fae0b100-b23d-11ea-952e-4b7bdc656194.png)\r\n\r\n![image](https://user-images.githubusercontent.com/41022806/85171957-0cc25400-b23e-11ea-9b9b-89dc3f8b2177.png)\r\n\r\n\r\n**Reproduction Link** \r\nSee source code above. That encompasses the entire program to force this to happen. The more threads the more it becomes visible. May take a few seconds to a few mins of the code running to recreate. \r\n",
  "author": {
    "login": "mclose90",
    "type": "User"
  },
  "labels": [],
  "assignees": [],
  "milestone": "v2.80.0",
  "createdAt": "2020-06-19T19:06:48",
  "updatedAt": "2022-08-19T06:01:16",
  "closedAt": "2020-06-21T19:18:58",
  "commentCount": 3,
  "reactionCount": 0,
  "engagement": {
    "syncedAt": "2026-02-04T20:52:28.728091Z",
    "reactions": [],
    "comments": [
      {
        "id": 646888144,
        "author": "mattleibow",
        "createdAt": "2020-06-19T22:53:55",
        "reactions": []
      },
      {
        "id": 647651357,
        "author": "mclose90",
        "createdAt": "2020-06-22T17:07:36",
        "reactions": []
      },
      {
        "id": 647675089,
        "author": "mattleibow",
        "createdAt": "2020-06-22T17:39:03",
        "reactions": []
      }
    ]
  }
}